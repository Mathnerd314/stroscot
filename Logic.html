

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Logic &mdash; Stroscot  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="_static/hexagon_favicon.png"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Reduction" href="Reduction.html" />
    <link rel="prev" title="Verification" href="Verification.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html">
          

          
            
            <img src="_static/hexagon_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="About.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fexprs.html">Metaprogramming</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arguments.html">Argument passing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="Overloading.html">Overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="Delimited-Continuations.html">Delimited continuations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="Verification.html">Verification</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Logic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#jumbo-connectives">Jumbo connectives</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#common-connectives">Common connectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#programming-types">Programming types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#polarized-logic">Polarized logic</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#exponentials">Exponentials</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#equivalences">Equivalences</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#structural-rules">Structural rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#quantifiers">Quantifiers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#logic-translations">Logic translations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#set-theory">Set theory</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#paradoxes">Paradoxes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#comprehension">Comprehension</a></li>
<li class="toctree-l3"><a class="reference internal" href="#equality">Equality</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#infinite-structures">Infinite structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hashing">Hashing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reduction.html#random-old-junk">Random old junk</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l1"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l1"><a class="reference internal" href="Memory.html">Memory management</a></li>
<li class="toctree-l1"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="zzreferences.html">References</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Stroscot</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Logic</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Logic.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="logic">
<h1>Logic<a class="headerlink" href="#logic" title="Permalink to this headline">¶</a></h1>
<p>The logic for Stroscot is based on a two-sided linear logic sequent calculus.</p>
<div class="section" id="jumbo-connectives">
<h2>Jumbo connectives<a class="headerlink" href="#jumbo-connectives" title="Permalink to this headline">¶</a></h2>
<p>Based on <span id="id1">[<a class="reference internal" href="zzreferences.html#id41" title="Paul Blain Levy. Jumbo λ-calculus. In Michele Bugliesi, Bart Preneel, Vladimiro Sassone, and Ingo Wegener, editors, Automata, Languages and Programming, Lecture Notes in Computer Science, 444–455. Berlin, Heidelberg, 2006. Springer. URL: https://www.cs.bham.ac.uk/~pbl/papers/jumboicalp.pdf, doi:10.1007/11787006_38.">Lev06</a>]</span>, we aim for the largest allowable set of operators. In particular we generalize into two jumbo operators, <span class="math notranslate nohighlight">\(\Sigma\)</span> (sigma) and <span class="math notranslate nohighlight">\(\Pi\)</span> (pi).</p>
<p>We start with the generalized <span class="math notranslate nohighlight">\(\Pi\)</span> rule. This is similar to Levy’s rule except it allows multiple conclusion propositions. We have indexed variables <span class="math notranslate nohighlight">\(A_{ij}\)</span> and <span class="math notranslate nohighlight">\(B_{ik}\)</span> where <span class="math notranslate nohighlight">\(0 \leq i &lt; N, 0 \leq j &lt; m_i, 0 \leq k &lt; n_i\)</span>. We call <span class="math notranslate nohighlight">\(N\)</span> the length of the jumbo type and the list <span class="math notranslate nohighlight">\([(m_i,n_i)]\)</span> the jumbo-arity.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
\newcommand{\rule}[3]{ \dfrac{\displaystyle ~~#1~~ }{\displaystyle ~~#2~~ } \  (#3)}
\newcommand{\defeq}{\overset{\text{def}}{=}}
\newcommand{\with}{\mathbin{\mathrm{\&amp;}}}
\newcommand{\par}{\mathbin{\mathrm{⅋}}}
\newcommand{\multimapboth}{\mathbin{\mathrm{⧟}}}
\newcommand{\bang}{{\mathrm{!}}}
\newcommand{\whim}{{\mathrm{?}}}
\newcommand{\ocin}{\mathrel{\raise{-1pt}{\mathrm{!}}\mathord{\in}}}
\definecolor{mygray}{RGB}{156,156,156}
\newcommand{\sk}[1]{{\color{mygray} #1}}
\rule{\overrightarrow{ \Gamma, \overrightarrow{A_{i j}} \vdash \overrightarrow{B_{i k}}, \Delta }}
  {\Gamma \vdash \prod \limits_{i} \left(\overrightarrow{A_i} \multimap \overrightarrow{B_i}\right), \Delta }
  {\Pi_R}
&amp;
\rule{\overrightarrow{ \sk{\Gamma_j} \vdash A_{i j}, \sk{\Delta_j} } \quad \overrightarrow{ \sk{\Theta_k}, B_{i k} \vdash \sk{\Lambda_k} }}
  {\sk{\overrightarrow{\Gamma}}, \sk{\vec \Theta}, \prod \limits_{i} \left(\overrightarrow{A_i} \multimap \overrightarrow{B_i}\right) \vdash \sk{\overrightarrow{\Delta}}, \sk{\vec\Lambda}}
  {\Pi_{i} {}_{L}}
\end{array}</div><p>Next we have the generalized <span class="math notranslate nohighlight">\(\Sigma\)</span> rule. This is the dual of <span class="math notranslate nohighlight">\(\Pi\)</span>. Following <span id="id2">[<a class="reference internal" href="zzreferences.html#id56" title="Philip Wadler. Call-by-value is dual to call-by-name. In Proceedings of the Eighth ACM SIGPLAN International Conference on Functional Programming, ICFP '03, 189–201. Uppsala, Sweden, August 2003. Association for Computing Machinery. URL: http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf (visited on 2020-06-17), doi:10.1145/944705.944723.">Wad03</a>]</span> <span id="id3">[<a class="reference internal" href="zzreferences.html#id17" title="Tristan Crolard. A formulae-as-types interpretation of subtractive logic. Journal of Logic and Computation, 14(4):529–570, August 2004. URL: https://academic.oup.com/logcom/article/14/4/529/933555 (visited on 2020-06-18), doi:10.1093/logcom/14.4.529.">Cro04</a>]</span> the dual of implication is called “subtraction” or “difference” and is denoted <span class="math notranslate nohighlight">\(-\)</span>. For normal ADTs, the RHS of the difference is empty, i.e. it looks like <span class="math notranslate nohighlight">\(\Sigma (a. A - \cdot \mid b. B_1,B_2 - \cdot \mid c. \cdot - \cdot)\)</span>. The syntax <span class="math notranslate nohighlight">\(\Sigma [(a, [A], []),(b, [B_1, B_2], []), (c,[],[])]\)</span> might be clearer.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
\rule{\overrightarrow{ \sk{\Gamma_k}, B_{i k} \vdash \sk{\Delta_k} } \quad \overrightarrow{ \sk{\Theta_j} \vdash A_{i j}, \sk{\Lambda_j} } }
  {\sk{\overrightarrow{\Gamma}}, \sk{\overrightarrow{\Theta}} \vdash \sum \limits_{i} \left( \overrightarrow{A_i} - \overrightarrow{B_i} \right), \sk{\overrightarrow{\Delta}}, \sk{\overrightarrow{\Lambda}}}
  {\Sigma_{i} {}_{R}}
&amp;
\rule{\overrightarrow{ \Gamma, \overrightarrow{A_{i j}} \vdash \overrightarrow{B_{i k}}, \Delta } }
  {\Gamma, \sum \limits_{i} \left ( \overrightarrow{A_i} - \overrightarrow{B_i} \right ) \vdash \Delta }
  {\Sigma_L}
\end{array}</div><p>When the RHS is nonempty we get terms with holes, that can be pattern-matched by filling the holes, e.g. <a class="reference external" href="https://en.wikipedia.org/wiki/Difference_list">difference lists</a>. (TODO: check that this actually gives efficient concatenation)</p>
<div class="section" id="common-connectives">
<span id="connectives"></span><h3>Common connectives<a class="headerlink" href="#common-connectives" title="Permalink to this headline">¶</a></h3>
<p>All of the standard operators 01⊕⊗⊤⊥&amp;⅋⊸⧟ in linear logic can be expressed using <span class="math notranslate nohighlight">\(\Sigma\)</span> and <span class="math notranslate nohighlight">\(\Pi\)</span>. We use our notation for them.</p>
<table class="colwidths-given docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operator</p></th>
<th class="head"><p>Girard Notation</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(F\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(0\)</span></p></td>
<td><p>Zero (False)</p></td>
<td><p><span class="math notranslate nohighlight">\(\Sigma []\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(1\)</span></p></td>
<td><p>One</p></td>
<td><p><span class="math notranslate nohighlight">\(\Sigma [(\#s,[] - [])]\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(A \lor B\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(A \oplus B\)</span></p></td>
<td><p>Plus (coproduct, or)</p></td>
<td><p><span class="math notranslate nohighlight">\(\Sigma [(\#l,[A] - []),(\#r,[B] - [])]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(A \otimes B\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(A \otimes B\)</span></p></td>
<td><p>Times (tensor product)</p></td>
<td><p><span class="math notranslate nohighlight">\(\Sigma [(\#s,[A,B] - [])]\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(A^{\otimes n}\)</span></p></td>
<td></td>
<td><p><a class="reference external" href="https://en.wikipedia.org/wiki/Tensor_product#Tensor_powers_and_braiding">Tensor power</a></p></td>
<td><p><span class="math notranslate nohighlight">\(\Sigma [(\#s,\overbrace{[A,\ldots,A]}^n - [])]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\smash{\stackrel{+}{\neg}} A\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(A^{\bot}\)</span></p></td>
<td><p>Positive Negation</p></td>
<td><p><span class="math notranslate nohighlight">\(\Sigma [(\#s,[] - [A])]\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\({↑}A\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(A\)</span></p></td>
<td><p>Up shift</p></td>
<td><p><span class="math notranslate nohighlight">\(\Sigma [(\#s,[A] - [])]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(T\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\top\)</span></p></td>
<td><p>Top (True)</p></td>
<td><p><span class="math notranslate nohighlight">\(\Pi []\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\bot\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\bot\)</span></p></td>
<td><p>Bottom (contradiction)</p></td>
<td><p><span class="math notranslate nohighlight">\(\Pi [(\#s,[] \multimap [])]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(A \land B\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(A \with B\)</span></p></td>
<td><p>With (product, and)</p></td>
<td><p><span class="math notranslate nohighlight">\(\Pi [(\#l,[] \multimap [A]),(\#r,[] \multimap [B])]\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(A \par B\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(A \par B\)</span></p></td>
<td><p>Par (“unless”, classical or, parallel product, dual of tensor)</p></td>
<td><p><span class="math notranslate nohighlight">\(\Pi [(\#s,[] \multimap [A,B])]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(A^{\par n}\)</span></p></td>
<td></td>
<td><p>Par power</p></td>
<td><p><span class="math notranslate nohighlight">\(\Pi [(\#s,[] \multimap \overbrace{[A,\ldots,A]}^n)]\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(A \to B\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(A \multimap B\)</span></p></td>
<td><p>Lollipop (implication, internal hom)</p></td>
<td><p><span class="math notranslate nohighlight">\(\Pi [(\#f,[A] \multimap [B])]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(A \leftrightarrow B\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(A \multimapboth B\)</span></p></td>
<td><p>Equivalence</p></td>
<td><p><span class="math notranslate nohighlight">\(\Pi [(\#l,[A] \multimap [B]),(\#r,[B] \multimap [A])]\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\smash{\stackrel{-}{\neg}} A\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(A^{\bot}\)</span></p></td>
<td><p>Negative Negation</p></td>
<td><p><span class="math notranslate nohighlight">\(\Pi [(\#s,[A] \multimap [])]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\({↓}A\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(A\)</span></p></td>
<td><p>Down shift</p></td>
<td><p><span class="math notranslate nohighlight">\(\Pi [(\#s,[] \multimap [A])]\)</span></p></td>
</tr>
</tbody>
</table>
<p>The idea behind <span class="math notranslate nohighlight">\(\bot\)</span> as contradiction is as follows: if we have a sequent <span class="math notranslate nohighlight">\(\Gamma \vdash A\otimes \neg A\)</span>, we can decompose this into sequents <span class="math notranslate nohighlight">\(\Gamma_1 \vdash A\)</span> and <span class="math notranslate nohighlight">\(\Gamma_2, A \vdash\)</span> where <span class="math notranslate nohighlight">\(\Gamma = \Gamma_1, \Gamma_2\)</span>. Then we can cut to derive the sequent <span class="math notranslate nohighlight">\(\Gamma \vdash\)</span>, and hence derive <span class="math notranslate nohighlight">\(\Gamma \vdash \bot\)</span>.</p>
<p>The notation <span class="math notranslate nohighlight">\(\land,\lor\)</span> is chosen because the structure-preserving translation from intuitionistic logic preserves the logical operators <span id="id4">[<a class="reference internal" href="zzreferences.html#id19" title="Roberto Di Cosmo. Introduction to Linear Logic. MPRI course notes, 2015. URL: https://www.dicosmo.org/CourseNotes/LinLog/IntroductionLinearLogic.pdf (visited on 2020-05-13).">DC15</a>]</span>, hence some intuition arises from using it. The notation for times and par is trickier; times and par are both <a class="reference external" href="https://en.wikipedia.org/wiki/Monoidal_category">tensor/monoidal products</a> (identities <span class="math notranslate nohighlight">\(1,\bot\)</span>), and do not appear in classical logic. The fact that tuples are typically positive data leads us to privilege <span class="math notranslate nohighlight">\(\otimes\)</span> as the default product, agreeing with Girard.</p>
<p><span class="math notranslate nohighlight">\(\par\)</span> is the dual of <span class="math notranslate nohighlight">\(\otimes\)</span> in the sense that <span class="math notranslate nohighlight">\(A \par B \equiv \neg (\neg A \otimes \neg B)\)</span>; unfortunately for deciding a notation, this seems to be its only useful property. <span class="math notranslate nohighlight">\(\oplus, \odot ,\Box,\sharp, \bullet\)</span> and <span class="math notranslate nohighlight">\(*\)</span> have meanings (direct sum/coproduct, Hadamard product/XNOR gate/symmetric product, modal operator, music, multiplication/logical and, convolution) dissimilar from the function of <span class="math notranslate nohighlight">\(\par\)</span>. <span class="math notranslate nohighlight">\(\mathbin{{\scriptstyle+}\mkern-0.522em\raise{-0.077em}{\diamond}},\mathbin{{\vee}\mkern-0.815em\raise{0.09em}{\bigcirc}}\)</span> don’t have Unicode symbols so are hard to use. In the end none of the operators seems particularly evocative. <span class="math notranslate nohighlight">\(\par\)</span> on the other hand redirects to linear logic on Wikipedia. It can be said to be Girard’s contribution.</p>
</div>
<div class="section" id="programming-types">
<h3>Programming types<a class="headerlink" href="#programming-types" title="Permalink to this headline">¶</a></h3>
<p>We can also write some types common from programming:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Operator</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\text{Bool}\)</span></p></td>
<td><p>Booleans</p></td>
<td><p><span class="math notranslate nohighlight">\(\Sigma [(\#F,[]-[]),(\#T,[]-[])]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\text{Int}\)</span></p></td>
<td><p>Integers</p></td>
<td><p><span class="math notranslate nohighlight">\(\Sigma [(\#{-2}^{31},[]-[]),\ldots,(\#0,[]-[]),\ldots,(\#2^{31}-1,[]-[])]\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(L_A\)</span></p></td>
<td><p>Linked list of A</p></td>
<td><p><span class="math notranslate nohighlight">\(\Sigma\{(\text{#nil},[]-[]),(\text{#cons},[A,L_A]-[])\)</span></p></td>
</tr>
</tbody>
</table>
<p>With these we see the justification for the jumbo types: they can represent abstract data types (ADTs). Although we can encode <span class="math notranslate nohighlight">\(\Pi,\Sigma\)</span> using the common connectives:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\Pi [(\#t_1,[A_{1,1},A_{1,2},\ldots] \multimap [B_{1,1},B_{1,2},\ldots]),\ldots] \equiv (\smash{\stackrel{-}{\neg}} A_{1,1} \par \smash{\stackrel{-}{\neg}} A_{1,2} \par \ldots \par B_{1,1} \par \ldots) \land \ldots\\\Sigma [(\#t_1,[A_{1,1},A_{1,2},\ldots] \multimap [B_{1,1},B_{1,2},\ldots]),\ldots] \equiv (A_{1,1} \otimes A_{1,2} \otimes \ldots \otimes \smash{\stackrel{+}{\neg}} B_{1,1} \otimes \ldots) \lor \ldots\end{aligned}\end{align} \]</div>
<p>With the encoding, we lose the free-form tags and have to use strings like “RRRRRL”. This leads to unbalanced proof trees and a general lack of expressiveness of the proof language.</p>
</div>
<div class="section" id="polarized-logic">
<h3>Polarized logic<a class="headerlink" href="#polarized-logic" title="Permalink to this headline">¶</a></h3>
<p>The polarized negations and shifts show up in polarized linear logic. <span id="id5">[<a class="reference internal" href="zzreferences.html#id60" title="Noam Zeilberger. The Logical Basis of Evaluation Order and Pattern-Matching. PhD thesis, Carnegie Mellon University, Pittsburgh, PA, April 2009. URL: https://software.imdea.org/~noam.zeilberger/thesis.pdf.">Zei09</a>]</span> In particular <span class="math notranslate nohighlight">\(\Sigma\)</span> is positive while <span class="math notranslate nohighlight">\(\Pi\)</span> is negative. We use the opposite direction for shifts from <span id="id6">[<a class="reference internal" href="zzreferences.html#id60" title="Noam Zeilberger. The Logical Basis of Evaluation Order and Pattern-Matching. PhD thesis, Carnegie Mellon University, Pittsburgh, PA, April 2009. URL: https://software.imdea.org/~noam.zeilberger/thesis.pdf.">Zei09</a>]</span> with the mnemonic that an up shift converts from negative to positive, hence increases the value. For most purposes the polarity does not matter (they have identical derivation rules) so we write <span class="math notranslate nohighlight">\(\neg A\)</span> and <span class="math notranslate nohighlight">\(\smash{\updownarrow}A\)</span>. <span id="id7">[<a class="reference internal" href="zzreferences.html#id47" title="Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Proceedings of the 11th ACM SIGPLAN Conference on Principles and Practice of Declarative Programming - PPDP '09, 129. Coimbra, Portugal, 2009. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1599410.1599427 (visited on 2021-03-26), doi:10.1145/1599410.1599427.">NM09</a>]</span> uses delay operators <span class="math notranslate nohighlight">\(\delta^\pm(\cdot)\)</span> instead of shifts.</p>
<p>The jumbo connectives have the nice property that any purely-positive or purely-negative combination connectives  can be written as a single jumbo connective.</p>
</div>
</div>
<div class="section" id="exponentials">
<h2>Exponentials<a class="headerlink" href="#exponentials" title="Permalink to this headline">¶</a></h2>
<p>Normally there are two S4 modalities !/bang/”of course” (positive) and the dual ?/whim/whimper/”why not” (negative). But if we introduce two modalities <span class="math notranslate nohighlight">\(\bang_1, \bang_2\)</span> with separate rules we cannot prove <span class="math notranslate nohighlight">\(\bang_1 A \equiv \bang_2 A\)</span>. So in keeping with the maximalist approach we use subexponentials <span class="math notranslate nohighlight">\(\bang^x_m,\whim^x_m\)</span> where <span class="math notranslate nohighlight">\(m\)</span> is in an index set <span class="math notranslate nohighlight">\(M \supseteq \{\cdot\}\)</span> and <span class="math notranslate nohighlight">\(x \in X, X = \{\cdot, c, w, \emptyset\}\)</span>. <span class="math notranslate nohighlight">\(m=\cdot\)</span> is written <span class="math notranslate nohighlight">\(\bang^x,\whim^x\)</span>, and similarly <span class="math notranslate nohighlight">\(x=\cdot\)</span> is written as <span class="math notranslate nohighlight">\(\bang_m,\whim_m\)</span>, so that we recover the usual notation <span class="math notranslate nohighlight">\(\bang,\whim\)</span> for <span class="math notranslate nohighlight">\(m=x=\cdot\)</span>. We can also write <span class="math notranslate nohighlight">\(\bang_{(m,x)},\whim_{(m,x)}\)</span> or more simply <span class="math notranslate nohighlight">\(\bang_{m}\)</span> if the context is clear.</p>
<p>To use these we must define a relation <span class="math notranslate nohighlight">\(\leq\)</span> on <span class="math notranslate nohighlight">\((M,X)\)</span> such that <span class="math notranslate nohighlight">\(((M,X),\leq)\)</span> is a poset and <span class="math notranslate nohighlight">\((m,x) \leq (n,y)\)</span> implies <span class="math notranslate nohighlight">\(x\leq y\)</span>, where the relation on <span class="math notranslate nohighlight">\(X\)</span> is <span class="math notranslate nohighlight">\(\emptyset \leq \{c, w\} \leq \cdot\)</span>. Reflexivity ensures the identity theorem. Transitivity and the compatibility with the poset <span class="math notranslate nohighlight">\(X\)</span> ensure cut elimination. Antisymmetry ensures that if <span class="math notranslate nohighlight">\(\bang^x_m A \equiv \bang^y_n A\)</span> then <span class="math notranslate nohighlight">\(m=n\)</span> and <span class="math notranslate nohighlight">\(x=y\)</span>, so that we do not have duplicate notation for a particular modality. For the standard modality <span class="math notranslate nohighlight">\(m=\cdot\)</span> we require <span class="math notranslate nohighlight">\((\cdot,\emptyset) \leq \{(\cdot,c),(\cdot,w)\} \leq (\cdot,\cdot)\)</span>, but for other values of <span class="math notranslate nohighlight">\(m\)</span> these relations may not hold.</p>
<p>The rule for promotion requires that <span class="math notranslate nohighlight">\((z,o)\leq (x_i,m_i)\)</span> and <span class="math notranslate nohighlight">\((z,o)\leq (y_i,n_i)\)</span> for the elements of the context.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
  \rule{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i } \vdash A, \overrightarrow{\whim^{y_i}_{n_i}\Delta_i} }{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i } \vdash \bang^z_o A, \overrightarrow{\whim^{y_i}_{n_i}\Delta_i}}{\bang}
  &amp;
  \rule{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i } , A\vdash \overrightarrow{\whim^{y_i}_{n_i}\Delta_i} }{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i }, \whim^z_o A \vdash \overrightarrow{\whim^{y_i}_{n_i}\Delta_i}}{\whim}

\end{array}</div><p>For dereliction there are no restrictions.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
  \rule{\sk{\Gamma}, A \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^x_m A \vdash \sk{\Delta}}{\bang d}
&amp; \rule{\sk{\Gamma} \vdash A, \sk{\Delta} }{\sk{\Gamma} \vdash \whim^x_m A, \sk{\Delta}}{\whim d}
\end{array}</div><p>Weakening requires <span class="math notranslate nohighlight">\(x \geq w\)</span>.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
    \rule{\sk{\Gamma} \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^x_m A \vdash \sk{\Delta}}{\bang w}
  &amp; \rule{\sk{\Gamma} \vdash \sk{\Delta} }{\sk{\Gamma} \vdash \whim^x_m A, \sk{\Delta}}{\whim w}
  \end{array}</div><p>Contraction requires <span class="math notranslate nohighlight">\(x \geq c\)</span>. Instead of binary contraction we allow <span class="math notranslate nohighlight">\(n\)</span>-ary contraction for <span class="math notranslate nohighlight">\(n\geq 2\)</span>. This is equivalent to binary contraction but makes the proof trees a little more compact.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
    \rule{\sk{\Gamma}, \overrightarrow{\bang^x_m A, \bang^x_m A, \cdots} \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^x_m A \vdash \sk{\Delta}}{\bang c_n}
  &amp; \rule{\sk{\Gamma} \vdash \overrightarrow{\whim^x_m A, \whim^x_m A, \cdots}, \sk{\Delta} }{\sk{\Gamma} \vdash \whim^x_m A, \sk{\Delta}}{\whim c_n}
\end{array}</div><p>We define call-by-name lambdas as <span class="math notranslate nohighlight">\(\Omega = \bang \Omega \multimap \Omega\)</span> and call-by-value or optimal lambdas <span class="math notranslate nohighlight">\(\Omega = \bang (\Omega \multimap \Omega)\)</span>. <span id="id8">[<a class="reference internal" href="zzreferences.html#id42" title="John Maraist, Martin Odersky, David N. Turner, and Philip Wadler. Call-by-name, call-by-value, call-by-need, and the linear lambda calculus. Electronic Notes in Theoretical Computer Science, 1:370–392, January 1995. URL: http://www.sciencedirect.com/science/article/pii/S1571066104000222 (visited on 2020-08-23), doi:10.1016/S1571-0661(04)00022-2.">MOTW95</a>]</span></p>
<div class="section" id="equivalences">
<h3>Equivalences<a class="headerlink" href="#equivalences" title="Permalink to this headline">¶</a></h3>
<p>For <span class="math notranslate nohighlight">\((x,m)\geq(y,n)\)</span>, <span class="math notranslate nohighlight">\(\bang^x_m \bang^y_n A \equiv \bang^x_m A \equiv \bang^y_n \bang^x_m A\)</span>, and similarly for <span class="math notranslate nohighlight">\(\whim\)</span>.</p>
<p>For <span class="math notranslate nohighlight">\((x,n)\leq(z,p)\)</span> and <span class="math notranslate nohighlight">\((y,o)\leq(w,m)\)</span> we can prove <span class="math notranslate nohighlight">\(\bang^w_m \whim^x_n \bang^y_o \whim^z_p A \equiv \bang^w_m \whim^z_p A\)</span>.</p>
<p>So for a single modality there are 7 derived modalities, with the relationships <span class="math notranslate nohighlight">\(\bang A \to A \to \whim A\)</span>, <span class="math notranslate nohighlight">\(\bang A \to \bang \whim \bang A \to \{\bang \whim A, \whim \bang A\} \to \whim \bang \whim A \ to \whim A\)</span>.:cite:<cite>coniglioEqualityLinearLogic2002</cite> But with multiple modalities the possibilities become infinite. On the other hand, from an operational perspective, we can always erase the subexponential information and use the normal !/?.</p>
</div>
</div>
<div class="section" id="structural-rules">
<h2>Structural rules<a class="headerlink" href="#structural-rules" title="Permalink to this headline">¶</a></h2>
<p>Finally we have the structural rules. As is usual for linear logic there are no structural rules for weakening or contraction (they are restricted to the exponentials above).</p>
<p>First is the exchange rule, given for permutations <span class="math notranslate nohighlight">\(\sigma_L, \sigma_R\)</span>. In practice we use a graph or multiset representation that internalizes the exchange rule.</p>
<div class="math notranslate nohighlight">
\begin{array}{c}
  \rule{\sk{\Gamma} \vdash \sk{\Delta}}{\sk{\sigma_L(\Gamma)} \vdash \sk{\sigma_R(\Delta)}}{\text{x}}
\end{array}</div><p>The cut rule is technically a theorem; we can prove that any proof using cut can be reformulated to be cut-free. But the expansion may result in exponentially more rule applications.</p>
<div class="math notranslate nohighlight">
  \rule{\sk{\Gamma} \vdash A, \sk{\Delta} \quad \sk{\Theta}, A \vdash \sk{\Lambda} }{\sk{\Gamma}, \sk{\Theta} \vdash \sk{\Delta}, \sk{\Lambda} }{\text{cut}}</div><p>Similarly the identity rule is a theorem for the logic we have formulated so far (propositional logic): we can produce a proof tree for <span class="math notranslate nohighlight">\(A \vdash A\)</span> for any finite proposition <span class="math notranslate nohighlight">\(A\)</span> via expansion of all the cases. Using the identity rule speeds up reduction because it skips iterating through the structure, and it also allows manipulating (prefixes of) <a class="reference internal" href="#infinite"><span class="std std-ref">infinite</span></a> trees.</p>
<div class="math notranslate nohighlight">
\begin{array}{ccc}
  \rule{}{A \vdash A}{\text{id}}
\end{array}</div></div>
<div class="section" id="quantifiers">
<h2>Quantifiers<a class="headerlink" href="#quantifiers" title="Permalink to this headline">¶</a></h2>
<p>To move from propositional to first-order logic we must introduce identity axioms for terms. The set of terms consists of variables, name constants, and uninterpreted predicates <span class="math notranslate nohighlight">\(f(t_1,\ldots,t_n)\)</span> where <span class="math notranslate nohighlight">\(f\)</span> is a function symbol and <span class="math notranslate nohighlight">\(t_i\)</span> are terms.</p>
<div class="math notranslate nohighlight">
\begin{array}{ccc}
  \rule{}{x \vdash x}{\text{id}}
  &amp;
  \rule{}{P(x_1,\ldots,x_n) \vdash P(x_1,\ldots,x_n)}{\text{id}}
\end{array}</div><p><a class="reference external" href="https://ncatlab.org/nlab/show/sequent+calculus">nLab</a> defines a substitution rule/theorem. <span class="math notranslate nohighlight">\(A[\overrightarrow{x \mapsto t}]\)</span> stands for the proposition <span class="math notranslate nohighlight">\(A\)</span> where all free occurrences of the variables <span class="math notranslate nohighlight">\(\overrightarrow{x}\)</span> have been replaced by the propositions/terms <span class="math notranslate nohighlight">\(\overrightarrow{t}\)</span> (and bound variables have been renamed to fresh ones when necessary). There is a theorem that substitution rules can be eliminated from the proof tree, proven by taking the proof tree for <span class="math notranslate nohighlight">\(\Gamma \vdash \Delta\)</span> and replacing all its identities <span class="math notranslate nohighlight">\(x \vdash x\)</span> with identities <span class="math notranslate nohighlight">\(t\ vdash t\)</span>.</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\begin{array}{c}
  \rule{\Gamma \vdash \Delta}{\Gamma[\overrightarrow{x \mapsto t}] \vdash \Delta[\overrightarrow{x \mapsto t}]}{\text{sub}}
\end{array}</div></div></blockquote>
<p>Then we add quantifiers. For these <span class="math notranslate nohighlight">\(x\)</span> must have no free occurrence in <span class="math notranslate nohighlight">\(\Gamma\)</span> or <span class="math notranslate nohighlight">\(\Delta\)</span>. Unlike with sets, there is no problem with identity expansion because the substitution is always for a variable and hence the number of quantifiers decreases.</p>
<div class="math notranslate nohighlight">
 \begin{array}{cccc}
    \rule{\Gamma \vdash A, \Delta}{\Gamma \vdash \forall x. A, \Delta}{\forall_R}
    &amp;
    \rule{t\vdash t\quad\Gamma, A[x\mapsto t] \vdash \Delta}{\Gamma, \forall x. A \vdash \Delta}{\forall_L}
    &amp;
    \rule{t\vdash t\quad\Gamma \vdash A[x\mapsto t], \Delta}{\Gamma \vdash \exists x. A, \Delta}{\exists_R}
    &amp;
    \rule{\Gamma, A \vdash \Delta}{\Gamma, \exists x. A \vdash \Delta}{\exists_L}
  \end{array}</div><p>We also allow quantification over modalities, as in <span id="id9">[<a class="reference internal" href="zzreferences.html#id47" title="Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Proceedings of the 11th ACM SIGPLAN Conference on Principles and Practice of Declarative Programming - PPDP '09, 129. Coimbra, Portugal, 2009. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1599410.1599427 (visited on 2021-03-26), doi:10.1145/1599410.1599427.">NM09</a>]</span>.</p>
</div>
<div class="section" id="logic-translations">
<h2>Logic translations<a class="headerlink" href="#logic-translations" title="Permalink to this headline">¶</a></h2>
<p>First we must define classical and intuitionistic logic. To define classical logic we simply add standard structural weakening and contraction rules to our linear logic. Then <span class="math notranslate nohighlight">\(A\otimes B \equiv A \land B\)</span>, <span class="math notranslate nohighlight">\(A\par B \equiv A \lor B\)</span>, and we obtain the usual classical logic with modalities;:cite:<cite>lafontLinearLogicPages</cite> all the connectives decompose into or are equivalent to the standard ones. To define intuitionistic logic we take classical logic and restrict the right hand side of all sequents to have at most one consequent; various pi/sigma connectives cannot be used as they would create multiple consequents, and similarly right contraction cannot be used. We allow disallow right weakening to make the translation easier.</p>
<p>The translation from intuitionistic logic to linear logic decorates every proposition and subproposition with !. <span id="id10">[<a class="reference internal" href="zzreferences.html#id19" title="Roberto Di Cosmo. Introduction to Linear Logic. MPRI course notes, 2015. URL: https://www.dicosmo.org/CourseNotes/LinLog/IntroductionLinearLogic.pdf (visited on 2020-05-13).">DC15</a>]</span></p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\left[\prod \limits_{i} \left(\overrightarrow{A_i} \multimap \overrightarrow{B_i}\right)\right]_I &amp;= \prod \limits_{i} \left(\overrightarrow{\bang\left[A_i\right]_I} \multimap \overrightarrow{\bang\left[B_i\right]_I}\right)\\\left[\sum \limits_{i} \left(\overrightarrow{A_i} - \overrightarrow{B_i}\right)\right]_I &amp;= \sum \limits_{i} \left(\overrightarrow{\bang\left[A_i\right]_I} - \overrightarrow{\bang\left[B_i\right]_I}\right)\end{aligned}\end{align} \]</div>
<p>We can translate classical logic into intuitionistic logic by decorating every proposition and subproposition with <span class="math notranslate nohighlight">\(\neg\neg\)</span> and moving the right to the left with another negation, i.e. <span class="math notranslate nohighlight">\(\Gamma \vdash \Delta \Rightarrow \Gamma', \neg \Delta' \vdash\)</span>. Thus the translation of classical logic into linear logic decorates like <span class="math notranslate nohighlight">\(\neg \bang (\neg \bang A) \equiv \whim \bang A\)</span>.</p>
<p>These two decoration translations preserve proof structure, in the sense that every intuitionistic/classical proof tree can be converted to a linear logic proof tree, and the reverse as well if the linear logic proof tree’s sequent is the result of the proposition translation.</p>
</div>
<div class="section" id="definitions">
<h2>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<p>We call sequents of the form <span class="math notranslate nohighlight">\(\vdash A\)</span> proofs of <span class="math notranslate nohighlight">\(A\)</span>. Similarly sequents <span class="math notranslate nohighlight">\(A \vdash\)</span> are refutations of <span class="math notranslate nohighlight">\(A\)</span>. <span class="math notranslate nohighlight">\(\Sigma_R\)</span> constructs a proof from a collection of proofs and refutations, while <span class="math notranslate nohighlight">\(\Pi_L\)</span> constructs a refutation from a collection of proofs and refutations. We can similarly consider proof patterns <span class="math notranslate nohighlight">\(x, \ldots, z \vdash A\)</span> / refutation patterns <span class="math notranslate nohighlight">\(x,\ldots,z, A \vdash\)</span> where <span class="math notranslate nohighlight">\(x,\ldots,z\)</span> are free variables.</p>
<p>If we have a proof of <span class="math notranslate nohighlight">\(A\)</span> then <span class="math notranslate nohighlight">\(A\)</span> is a theorem (also called a tautology). If we prove a sequent <span class="math notranslate nohighlight">\(\Gamma \vdash\)</span> then <span class="math notranslate nohighlight">\(\Gamma\)</span> is a contradiction. We define equivalence <span class="math notranslate nohighlight">\(A\equiv B\)</span> as the theorem <span class="math notranslate nohighlight">\(\vdash A \leftrightarrow B\)</span>.</p>
<p>We define the notation <span class="math notranslate nohighlight">\(A\defeq B\)</span> as a pair of rules:</p>
<div class="math notranslate nohighlight">
  \begin{array}{cc}
    \rule{\Gamma \vdash B, \Delta}{\Gamma \vdash A, \Delta}{\text{def}_R}
    &amp;
    \rule{\Gamma, B \vdash \Delta}{\Gamma, A \vdash \Delta}{\text{def}_L}
  \end{array}</div><p>The cut elimination theorem poses no problem, but the identity theorem fails to complete if there is an infinite chain of definitions <span class="math notranslate nohighlight">\(A_1 \defeq \ldots A_2 \ldots, A_2 \defeq \ldots A_3 \ldots, \ldots\)</span>. So we categorize the definitions where such an infinite chain exists as undefined (circular) and exclude them from the syntax. Once we have our restriction, we can derive the identity theorem on it, via deriving the identity theorem on the definition instances and using the normal identity theorem on the sequent with all definition instances replaced with fresh variables. For the substitution theorem we must limit our substitution to propositions that are defined. For the parts of the proof tree not using the identity or substitution theorems the notation is always defined.</p>
<p>In general it is undecidable if a particular definition instance is defined (see <a class="reference internal" href="#paradoxes"><span class="std std-ref">discussion of set paradoxes</span></a>). But most definitions don’t have a definition on the RHS hence are easy to check for circularity.</p>
</div>
<div class="section" id="set-theory">
<h2>Set theory<a class="headerlink" href="#set-theory" title="Permalink to this headline">¶</a></h2>
<p>We define <span class="math notranslate nohighlight">\(t\in \{x\mid A\} \defeq A[x\mapsto t]\)</span>. Here the elements <span class="math notranslate nohighlight">\(t\)</span> of the sets are propositions; e.g. we can prove <span class="math notranslate nohighlight">\(\bot \in \{x\mid x \leftrightarrow \bot \}\)</span>. Usually the variables in set theory range over sets. Hence we introduce new variables <span class="math notranslate nohighlight">\(x^S\)</span> which range over sets. Since all sets are of the form <span class="math notranslate nohighlight">\(\{x\mid X\}\)</span> these can be translated as follows:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(x^S \defeq \{x\mid X\}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\{x^S\mid X\} \defeq \{X\mid X\}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\{x\mid X\} \in Y \defeq X \in Y\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\forall x^S. X \defeq \forall X. X\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\{x^S\mid X\} \subseteq \{x^S\mid Y\} \defeq X \to Y\)</span></p></li>
</ul>
<p>So for example <span class="math notranslate nohighlight">\(t^S\in \{x^S\mid x^S \in x^S \}\)</span> expands to <span class="math notranslate nohighlight">\(T \in \{X \mid X \in \{x\mid X\} \}\)</span></p>
<p>We can also define set-builder notation <span class="math notranslate nohighlight">\(\{a_1,\ldots,a_n\} = \{x\mid x = a_1 \lor \ldots \lor x=a_n\}\)</span>.</p>
<p>We define <span class="math notranslate nohighlight">\(a \ocin B = \bang(a \in B)\)</span>, <span class="math notranslate nohighlight">\(\left[ P(x) \vdash_{x\in A} Q(x) \right] = \left[ \bang(x\in A), P(x) \vdash Q(x) \right]\)</span>, <span class="math notranslate nohighlight">\(\exists x\in A. P(x) = \exists x. \bang(x \in A) \otimes P(x)\)</span>, <span class="math notranslate nohighlight">\(\forall x\in A. P(x) = \forall x. (\bang(x\in A) \multimap P(x)\)</span>. This is similar to <span id="id11">[<a class="reference internal" href="zzreferences.html#id54" title="Michael Shulman. Linear logic for constructive mathematics. arXiv:1805.07518 [math], May 2018. URL: http://arxiv.org/abs/1805.07518 (visited on 2021-03-04), arXiv:1805.07518.">Shu18</a>]</span> except <span class="math notranslate nohighlight">\(\in\)</span> is not affirmative.</p>
<div class="section" id="paradoxes">
<span id="id12"></span><h3>Paradoxes<a class="headerlink" href="#paradoxes" title="Permalink to this headline">¶</a></h3>
<p>With regards to definedness, some statements may be defined but not others. For example <span class="math notranslate nohighlight">\(\{x\mid T \} \in \{x\mid x \in x \}\)</span> is defined (and provable) but <span class="math notranslate nohighlight">\(\{x\mid x \in x \} \in \{x\mid x \in x \}\)</span> is circular hence not defined.</p>
<p>It seems from playing with some examples that forbidding circular definitions is sufficient to prevent Russell’s paradox and Curry’s paradox. <span class="math notranslate nohighlight">\(t\in R \land t= R, R = \{x\mid \neg(\bang x \in x)\}\)</span> is not circular, but it is not sufficient to derive a paradox, as in order to apply contraction we have to use substitution to obtain the forbidden proposition <span class="math notranslate nohighlight">\(R \in R\)</span>. Since cut elimination holds, only the identity or substitution rules could produce paradoxes, hence closing the loopholes in these solves the issue.</p>
<p>The question of whether a given set comprehension is defined is undecidable, as we can encode the lambda calculus and hence the halting problem - the beta rule <span class="math notranslate nohighlight">\((\lambda x. A) t\)</span> does the same substitution as <span class="math notranslate nohighlight">\(t\in\{x\mid A\}\)</span>. We can approximate definedness with a termination checking algorithm or syntactic check:</p>
<ul class="simple">
<li><p>Strict comprehension, i.e. the bound variable can only appear once in the formula <span id="id13">[<a class="reference internal" href="zzreferences.html#id53" title="Masaru Shirahata. Linear set theory with strict comprehension. In Proceedings of the Sixth Asian Logic Conference, 223–245. Beijing, China, April 1998. WORLD SCIENTIFIC / S'PORE UNIV PRESS (PTE) LTD. URL: http://www.worldscientific.com/doi/abs/10.1142/9789812812940_0013 (visited on 2021-03-06), doi:10.1142/9789812812940_0013.">Shi98</a>]</span></p></li>
<li><p>New Foundations’s stratified formulas <span id="id14">[<a class="reference internal" href="zzreferences.html#id30" title="Thomas Forster. Quine’s New Foundations. In Edward N. Zalta, editor, The Stanford Encyclopedia of Philosophy. Metaphysics Research Lab, Stanford University, summer 2019 edition, 2019. URL: https://plato.stanford.edu/archives/sum2019/entries/quine-nf/ (visited on 2021-03-04).">For19</a>]</span> <span id="id15">[<a class="reference internal" href="zzreferences.html#id34" title="M. Randall Holmes. Elementary Set Theory with a Universal Set. Bruylant-Academia, 1998. ISBN 978-2-87209-488-2. URL: https://randall-holmes.github.io/head.pdf.">Hol98</a>]</span></p></li>
<li><p>Hindley-Milner type inference (since the simply typed lambda calculus terminates)</p></li>
<li><p>A size-checking algorithm like in <span id="id16">[<a class="reference internal" href="zzreferences.html#id36" title="Neil D. Jones and Nina Bohr. Call-by-value termination in the untyped lambda-calculus. Logical Methods in Computer Science, 4(1):3, March 2008. URL: http://arxiv.org/abs/0801.0882 (visited on 2021-03-06), arXiv:0801.0882, doi:10.2168/LMCS-4(1:3)2008.">JB08</a>]</span></p></li>
<li><p>Brute-force expansion</p></li>
</ul>
<p>There is also <span id="id17">[<a class="reference internal" href="zzreferences.html#id52" title="Masaru Shirahata. A linear conservative extension of Zermelo-Fraenkel set theory. Studia Logica, 56(3):361–392, May 1996. URL: http://link.springer.com/10.1007/BF00372772 (visited on 2021-03-06), doi:10.1007/BF00372772.">Shi96</a>]</span> which allows sets built from ZF’s axioms.</p>
</div>
<div class="section" id="comprehension">
<h3>Comprehension<a class="headerlink" href="#comprehension" title="Permalink to this headline">¶</a></h3>
<p>We can prove the axiom schema of comprehension for (defined) formulas <span class="math notranslate nohighlight">\(\phi\)</span>:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\vdash \phi \leftrightarrow \phi)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\vdash x\in \{x\mid\phi\} \leftrightarrow \phi)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\vdash \forall x. x\in \{x\mid\phi\} \leftrightarrow \phi)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\vdash \exists y. \forall x. x\in y \leftrightarrow \phi)\)</span></p></li>
</ol>
</div>
<div class="section" id="equality">
<h3>Equality<a class="headerlink" href="#equality" title="Permalink to this headline">¶</a></h3>
<p>The axioms of reflexivity, substitution, etc. can take a variety of modalities as in <span id="id18">[<a class="reference internal" href="zzreferences.html#id14" title="Marcelo Coniglio and Francisco Miraglia. Equality in linear logic. Logique et Analyse, 39(153/154):113–151, January 2002. URL: https://www.researchgate.net/profile/Marcelo-Coniglio/publication/2387274_Equality_In_Linear_Logic/links/0deec5165a6babbd8a000000/Equality-In-Linear-Logic.pdf.">CM02</a>]</span>, some of them corresponding with intuitionistic and classical notions of equality. For sets we use linear weak extensional equality <span class="math notranslate nohighlight">\(A=B \defeq \forall x. (x \in A \leftrightarrow x \in B)\)</span>.
We can easily prove</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\vdash A=A\\A=B\vdash B=A\\A=B,B=C\vdash A=C\end{aligned}\end{align} \]</div>
<p>For substitution, we can prove <span class="math notranslate nohighlight">\(!(A=B), \phi \vdash \phi[A/B]\)</span> for any specific proposition <span class="math notranslate nohighlight">\(\phi\)</span>. Proof: For <span class="math notranslate nohighlight">\(\Pi\)</span> we use the right rule to split into cases for each tag, then we use contraction/weakening on <span class="math notranslate nohighlight">\(\bang(A=B)\)</span> to match the number of A’s/B’s in the case, then the left rule to split into each A and B, giving each branch a copy of the hypothesis. <span class="math notranslate nohighlight">\(\Sigma\)</span> is similar but with the left first. For exponentials, quantifiers, and set comprehension we simply do left/right in the correct order. Then at the end we use the hypothesis to change <span class="math notranslate nohighlight">\(A[x/a]\)</span> on the left or right to <span class="math notranslate nohighlight">\(B[x/b]\)</span>, or else weakening to remove the hypothesis followed by the identity.</p>
<p>Alternatively we could use intuitionistic equality <span class="math notranslate nohighlight">\(A\overset{!}{=}B \defeq !(A=B)\)</span>, then substitution is <span class="math notranslate nohighlight">\(A\overset{!}{=}B, \phi \vdash \phi[A/B]\)</span>. But the linear equality seems more useful.</p>
</div>
</div>
<div class="section" id="infinite-structures">
<span id="infinite"></span><h2>Infinite structures<a class="headerlink" href="#infinite-structures" title="Permalink to this headline">¶</a></h2>
<p>We want to support infinite types like the lambda calculus or lists, and similarly infinite expressions like <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">x</span></code>. We construct “infinite” as a terminal coalgebra - our proof trees turn into fixed points of systems of formal equations. <span id="id19">[<a class="reference internal" href="zzreferences.html#id38" title="Panagis Karazeris, Apostolos Matzaris, and Jiří Velebil. Final coalgebras in accessible categories. Mathematical Structures in Computer Science, 21(5):1067–1108, October 2011. URL: https://www.cambridge.org/core/product/identifier/S0960129511000351/type/journal_article (visited on 2021-03-11), doi:10.1017/S0960129511000351.">KMV11</a>]</span> We represent these using variable and assignment rules. The semantics is that the variable usage is a “hole” that plugs in a copy of the derivation tree from the variable assignment. The type of the use rule can performs a substitution on the free variables of the type of the assignment.</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cc}
  \rule{X }{ \Gamma[\vec x/\vec t] \vdash \Delta[\vec x/\vec t] }{\text{Use}}
  &amp;
  \rule{\Gamma \vdash \Delta}{ X = }{\text{Assign}}
\end{array}\]</div>
<p>Infinite structures can be paradoxical, e.g. we can prove <span class="math notranslate nohighlight">\(\vdash\bot\)</span> using cut on the proposition <span class="math notranslate nohighlight">\(A=\neg A\)</span>. Cut elimination will often fail to complete, but there is a progress property in the sense that the cut can always be pushed down and eliminate an identity rule or two matching logical rules.</p>
</div>
<div class="section" id="hashing">
<h2>Hashing<a class="headerlink" href="#hashing" title="Permalink to this headline">¶</a></h2>
<p>To hash the graphs we can use the tree structure of the sequent derivations. Each upward slot in a node is hashed with a fixed value and each downward slot is hashed with a value corresponding to the path through the derivation tree followed by the label of the upward slot. It is written as a single DFS traversal from the leaves upwards that stores the hashed subtree and a map from edge name to partial path.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Reduction.html" class="btn btn-neutral float-right" title="Reduction" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="Verification.html" class="btn btn-neutral float-left" title="Verification" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019-2020 Mathnerd314.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>