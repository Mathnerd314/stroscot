

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Verification &mdash; Stroscot  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="_static/hexagon_favicon.png"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Logic" href="Logic.html" />
    <link rel="prev" title="Types" href="Types.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html">
          

          
            
            <img src="_static/hexagon_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="About.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fexprs.html">Metaprogramming</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arguments.html">Argument passing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="Overloading.html">Overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="Delimited-Continuations.html">Delimited continuations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Verification</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#configurable-program-analysis">Configurable Program Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cpachecker-algorithm">CPAChecker algorithm</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#properties">Properties</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#reachability">Reachability</a></li>
<li class="toctree-l3"><a class="reference internal" href="#termination">Termination</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logic">Logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#equivalence">Equivalence</a></li>
<li class="toctree-l3"><a class="reference internal" href="#supercompilation">Supercompilation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#incremental-program-analysis">Incremental program analysis</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#optimizations">Optimizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sat-solving">SAT solving</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reduction.html#random-old-junk">Random old junk</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l1"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l1"><a class="reference internal" href="Memory.html">Memory management</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="zzreferences.html">References</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Stroscot</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Verification</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Verification.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="verification">
<h1>Verification<a class="headerlink" href="#verification" title="Permalink to this headline">¶</a></h1>
<p>Stroscot aims to be a practical programming language, but it also aims to provide strong guarantees about program behavior. Verification is the process of verifying that a system satisfies a property. Verification suffers from <em>extreme</em> scalability limitations. The combinations of program states increase exponentially, “state space explosion”. To get around this there are various tricks:</p>
<ul class="simple">
<li><p>combine “equivalent” program states into abstract program states, where equivalence is defined relative to the properties we are checking</p></li>
<li><p>optimize checking individual states, so larger state spaces can be checked in a given amount of time (brute force proof)</p></li>
<li><p>change the order states are explored, so that the failure mode is found earlier, before we run out of time or memory. But here we are not exploring the full state space (smart fuzzing)</p></li>
</ul>
<p>These techniques combine to form a much more powerful toolkit than conventional unit testing. Furthermore since they are built into the language there is a standardized API and UX for understanding tracebacks.</p>
<p>In practice, we can’t check deep properties on 200KLOC, but we can affordably verify them on 2KLOC. And then properties can be “shallow” and not result in a state space explosion.</p>
<p>model checkers:
[CBMC](<a class="reference external" href="https://www.cprover.org/cbmc/">https://www.cprover.org/cbmc/</a>)</p>
<p>The state-of-the-art seems to be the ULTIMATE framework that does abstract interpretation of the program via Buchi automata. CPAChecker has also done well in SV-COMP using an extension of dataflow analysis.</p>
<p>Verdi, Ironfleet, JSCert, Cosette, FSCQ, Chapar, CertiKOS, Linksem, miTLS and HACL*, Versat and IsaSAT
CakeML</p>
<p>Concolic (Concrete-Symbolic) testing or dynamic symbolic execution: DART, CUTE, KLEE, [NASA’s Java Pathfinder](<a class="reference external" href="https://github.com/javapathfinder">https://github.com/javapathfinder</a>), jCUTE, SAGE</p>
<div class="section" id="configurable-program-analysis">
<h2>Configurable Program Analysis<a class="headerlink" href="#configurable-program-analysis" title="Permalink to this headline">¶</a></h2>
<div style="display: none">
\[
\newcommand{\true}{\mathit{true}}
\newcommand{\false}{\mathit{false}}
\newcommand{\seq}[1]{{\langle #1 \rangle}}
\newcommand{\sem}[1]{[\![ #1 ]\!]}
\newcommand{\setsem}[1]{\bigcup_{e \in #1} \sem{e}}
\newcommand{\locs}{\mathit{L}}
\newcommand{\op}{\mathit{op}}
\newcommand{\pc}{\mathit{pc}}
\newcommand{\pcvar}{\mathit{pc}}
\newcommand{\pco}{\mathit{pc_0}}
\newcommand{\pce}{\mathit{pc_{err}}}
\newcommand{\meet}{\sqcap}
\newcommand{\cpa}{\mathbb{D}}
\newcommand{\Nats}{\mathbb{N}}
\newcommand{\Bools}{\mathbb{B}}
\newcommand{\Ints}{\mathbb{Z}}
\newcommand{\strengthen}{\mathord{\downarrow}}
\newcommand{\transconc}[1]{\smash{\stackrel{#1}{\rightarrow}}}
\newcommand{\transabs}[2]{\smash{\stackrel[#2]{#1}{\rightsquigarrow}}}
\newcommand{\merge}{\mathsf{merge}}
\newcommand{\stopop}{\mathsf{stop}}
\newcommand{\wait}{\mathsf{waitlist}}
\newcommand{\reached}{\mathsf{reached}}
\newcommand{\result}{\mathsf{result}}
\newcommand{\compare}{\preceq}
\renewcommand{\implies}{\Rightarrow}
\newcommand{\BUG}{{\sc fa}}
\newcommand{\flag}{\mathit{flag}}
\newcommand{\Itp}[3]{\smash{\mbox{\sc Itp}{(#2,#3)(#1)}}}
\]
</div><p>A <em>configurable program analysis</em> (CPA) specifies — independently of the analysis algorithm —
the abstract domain and a set of operations that control the program analysis.
Such a CPA can be plugged in as a component into the software-verification framework
without the need to work on program parsers, exploration algorithms, and
their general data structures.</p>
<p>A <em>program</em> is represented by a <em>control-flow automaton</em> (CFA) / Kripke structure <span class="math notranslate nohighlight">\((C, Ops, \transconc{})\)</span>,
which consists of</p>
<ul class="simple">
<li><p>A set <span class="math notranslate nohighlight">\(C\)</span> of concrete states. Many papers use a simple state model consisting of a program counter/location and a data store mapping variable names to integers.</p></li>
<li><p>A set <span class="math notranslate nohighlight">\(Ops\)</span> of program operations (alphabet). Typical operations include:
* Computation, where the state evolves with no input
* Unmodeled parts of the system; e.g. IO operations <code class="docutils literal notranslate"><span class="pre">Read</span> <span class="pre">1</span></code> for a read that returned 1 or <code class="docutils literal notranslate"><span class="pre">Write</span></code> for a write.
* Havoc operations, similar to unmodeled operations</p></li>
<li><p>A concrete transition function <span class="math notranslate nohighlight">\(\mathord{\transconc{}} \subseteq C \times Ops \times C\)</span> defining a (labeled) transition relation of how concrete states evolve into other concrete states. There is at most one concrete state succeeding a given concrete state and program operation, but we allow halting states with no available operations and a state to evolve differently with different operations. We define the notation <span class="math notranslate nohighlight">\(\mathord{\transconc{o}} = \{ (c,o,c') \in \mathord{\transconc{}} \}\)</span>. We write <span class="math notranslate nohighlight">\(c \transconc{o} c'\)</span> if <span class="math notranslate nohighlight">\((c, o, c') \in \mathord{\transconc{}}\)</span> and <span class="math notranslate nohighlight">\(c \transconc{} c'\)</span> if there exists an <span class="math notranslate nohighlight">\(o\)</span> with <span class="math notranslate nohighlight">\(c \transconc{o} c'\)</span>.</p></li>
</ul>
<p>A concrete path <span class="math notranslate nohighlight">\(\sigma = \langle (c_1, o_1 , c_2 ), (c_2 , o_2 , c_3 ), \ldots , (c_{n-1} , o_{n-1} , c_n ) \rangle\)</span> is a sequence of consecutive concrete states. A concrete path is called a program path if it starts with the initial state <span class="math notranslate nohighlight">\(c_I\)</span>. A path is called feasible if the transitions are concrete transitions, <span class="math notranslate nohighlight">\(c_i \transconc{o_i} c_{i+1}\)</span>; paths are assumed to be feasible unless declared infeasible. A state <span class="math notranslate nohighlight">\(c\)</span> is called reachable if there exists a feasible program path from <span class="math notranslate nohighlight">\(c_I\)</span> to <span class="math notranslate nohighlight">\(c\)</span>.</p>
<p>Dealing with concrete states will immediately lead to state explosion. So we introduce abstract states, that are sets of concrete states, and abstract operations, that are sets of concrete operations. An abstract domain <span class="math notranslate nohighlight">\(D = ({\cal E}, G, \leadsto)\)</span> consists of</p>
<ul class="simple">
<li><p>a set <span class="math notranslate nohighlight">\({\cal E} \subseteq 2^C\)</span> of abstract states</p></li>
<li><p>a set <span class="math notranslate nohighlight">\(G \subseteq 2^{Ops}\)</span> of abstract operations.</p></li>
<li><p>a transfer relation <span class="math notranslate nohighlight">\(\leadsto \subseteq E × G × E\)</span>  of (labeled) abstract state transitions. We define <span class="math notranslate nohighlight">\(\overset{g}{\leadsto}\)</span>, <span class="math notranslate nohighlight">\(s \leadsto s'\)</span>, and abstract paths and reachability, in a manner similar to concrete states.</p></li>
</ul>
<p>We have to tie this to our program. The domain <em>covers</em> the program if each reachable concrete state is contained in some abstract state in <span class="math notranslate nohighlight">\({\cal E}\)</span> and each operation encountered during a feasible path is contained in some abstract operation in <span class="math notranslate nohighlight">\(G\)</span>. The domain is <em>compatible</em> with the program if <span class="math notranslate nohighlight">\((e,g,e')\in\leadsto \iff \exists c\ in e, c' \in e', o \in g. c,o,c' \in \mathord{\transconc{}}\)</span>.</p>
<p>To support loop acceleration we could extend our notion of compatibility to allow mapping multiple concrete state transitions to one abstract transition. But which abstract state would the intermediate concrete states map to? It seems better to model loop acceleration as a transformation on the concrete state transition graph that is reflected into a transformation on the abstract state graph.</p>
<p>The simplest covering domain is <span class="math notranslate nohighlight">\(({C},{Ops})\)</span>. Slightly more complicated is the domain containing an abstract state for each program location. But the real meat lies in creating an abstract domain with complicated predicates on concrete states.</p>
<div class="section" id="cpachecker-algorithm">
<h3>CPAChecker algorithm<a class="headerlink" href="#cpachecker-algorithm" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>A transfer operator that identifies successor abstract states to a given abstract state as well as their abstract operations, <span class="math notranslate nohighlight">\(t : E → 2^{(E,G)}\)</span>.</p></li>
<li><p>a merge operator <span class="math notranslate nohighlight">\(\merge :  E × E → E\)</span> specifies if and how to merge abstract states when control flow meets. The operator weakens/widens the abstract state that is given as second parameter depending on the first parameter. Note that the operator <span class="math notranslate nohighlight">\(\merge\)</span> is not commutative, and is not necessarily the same as the join operator of the lattice. <span class="math notranslate nohighlight">\(e' \subseteq \merge(e, e') \subseteq \top\)</span>. Two simple ones are <span class="math notranslate nohighlight">\(\merge_{sep}(e,e')=e'\)</span> and <span class="math notranslate nohighlight">\(\merge_{join}(e,e')=e \cup e'\)</span>.</p></li>
<li><p>The termination check <span class="math notranslate nohighlight">\(\stopop : E × 2^E \to \{Stop,Continue\}\)</span> checks whether the abstract state <span class="math notranslate nohighlight">\(e\)</span> that is given as first parameter is covered by the set <span class="math notranslate nohighlight">\(R\)</span> of abstract states given as second parameter. Usually this is <span class="math notranslate nohighlight">\(\stopop_{join}(e, R) = e \subseteq \bigcup R\)</span> but we can also use <span class="math notranslate nohighlight">\(\stopop_{sep}(e, R) = \exists e' \in R . e \subseteq e'\)</span>.</p></li>
</ul>
</div>
</div>
<div class="section" id="properties">
<h2>Properties<a class="headerlink" href="#properties" title="Permalink to this headline">¶</a></h2>
<div class="section" id="reachability">
<h3>Reachability<a class="headerlink" href="#reachability" title="Permalink to this headline">¶</a></h3>
<p>A reachability (safety) task consists of a program and a set of error states, with the goal to show that the error states are unreachable, or otherwise to find a feasible program path to an error state. This can be used to verify assertions and check for type errors.</p>
<p>To prove unreachability we exhibit a covering domain with no concrete error states in any of the abstract states. To prove reachability we produce a concrete feasible path ending in an error state.</p>
</div>
<div class="section" id="termination">
<h3>Termination<a class="headerlink" href="#termination" title="Permalink to this headline">¶</a></h3>
<p>Termination checking verifies properties like “A function call must eventually return” or “A program execution that calls malloc() must eventually call free()”. A counterexample can be an infinite state transition sequence that doesn’t call free, so it is a liveness property. Note that it’s different from a safety property “A call to free must be preceded by a call to malloc”. It’s also different from “If the program ends gracefully then all memory has been freed”. A lot of programs look like <code class="docutils literal notranslate"><span class="pre">repeat</span> <span class="pre">{</span> <span class="pre">handleCommand{}</span> <span class="pre">}</span></code> and for those we can prove termination of <code class="docutils literal notranslate"><span class="pre">handleCommand</span></code> but not the loop. But we can prove graceful exit.</p>
<p>Proving termination is of undecidable complexity, but in practice we can prove termination and nontermination in many cases. We can reduce liveness to fair termination constraints <code class="docutils literal notranslate"><span class="pre">&lt;A,</span> <span class="pre">B&gt;</span></code>, in each trace either <code class="docutils literal notranslate"><span class="pre">A</span></code> is true for only finitely many states or <code class="docutils literal notranslate"><span class="pre">B</span></code> is true for infinitely many states.</p>
<p>To prove termination we construct an abstract state graph of reachable states and a ranking function mapping states to some well-ordered set such that every cycle in the state graph has a transition that decreases the rank.</p>
<p>To prove nontermination we need an infinite path of concrete states. This can be simplified to an initial path of concrete states leading to a strongly connected component of abstract states with no exits.</p>
<p>There’s also some interesting <a class="reference external" href="http://mmjb.github.io/T2/">work</a> on termination checking by Microsoft. There’s a representation of terms as sets, which ends up mapping out all the paths through the program, and then identifying termination is fairly easy.</p>
</div>
<div class="section" id="logic">
<h3>Logic<a class="headerlink" href="#logic" title="Permalink to this headline">¶</a></h3>
<p>Both reachability and termination can be expressed in CTL*. There is an even more expressive language, the modal μ-calculus.</p>
</div>
<div class="section" id="equivalence">
<h3>Equivalence<a class="headerlink" href="#equivalence" title="Permalink to this headline">¶</a></h3>
<p>Equivalence of pure programs is based on comparing results over all possible inputs.</p>
<p>Equivalence of I/O programs is based on comparing events: we represent all I/O actions in a datatype and then compare as for pure programs.</p>
<p>In the literature there is a notion of bisimulation. But here our state transition graph includes computation transitions, while the amount of computation is not relevant for equivalence. But of course bisimulation implies equivalence.</p>
</div>
<div class="section" id="supercompilation">
<h3>Supercompilation<a class="headerlink" href="#supercompilation" title="Permalink to this headline">¶</a></h3>
<p>Supercompilation produces an output program with observable behavior equivalent to an input program but faster.  Essentially we are transforming abstract states into pieces of code, creating a term in the output for every intermediate state.</p>
<p>The algorithm in <span id="id1">[<a class="reference internal" href="zzreferences.html#id11" title="Maximilian Bolingbroke and Simon Peyton Jones. Supercompilation by evaluation. In Proceedings of the Third ACM Haskell Symposium on Haskell, Haskell '10, 135–146. New York, NY, USA, September 2010. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/supercompilation-by-evaluation/ (visited on 2021-03-24), doi:10.1145/1863523.1863540.">BPJ10</a>]</span> is similar to that of CPAChecker. There is a termination check that takes a list of states and a state and either stops or continues - in particular it stops if any previously examined states are less than the current state by a well-quasi-order. Reduction produces successor states as with the transfer operator; as an optimization they skip merging/termination checking “intermediate” states. Another difference is that they are compiling pure programs so there is a “splitting” operation that transforms a state into a composition of substates. They are evaluating to full normal form rather than WHNF, so there is some nondeterminism in the evaluation order.</p>
</div>
<div class="section" id="incremental-program-analysis">
<h3>Incremental program analysis<a class="headerlink" href="#incremental-program-analysis" title="Permalink to this headline">¶</a></h3>
<p>Another issue is incremental analysis. Checking is slow so we would like to re-use most of the analysis when recompiling a file. Looking at a 2019 presentation <span id="id2">[<a class="reference internal" href="zzreferences.html#id35" title="Marie-Christine Jakobs. Differential modular software verification. URL: https://www.sosy-lab.org/research/prs/2019-10-01-CPA19-Differntial-Verification.pdf (visited on 2020-07-25).">Jak</a>]</span> there doesn’t seem to be any major breakthrough. Marking the analyzer’s computation steps in the general incremental build framework is probably sufficient.</p>
<p>since you can check all these conditions it’s a very powerful analysis that can also check buffer overflows and array bounds and resource use <span id="id3">[<a class="reference internal" href="zzreferences.html#id4" title="Elvira Albert, Miquel Bofill, Cristina Borralleras, Enrique Martin-Martin, and Albert Rubio. Resource Analysis driven by (Conditional) Termination Proofs. Theory and Practice of Logic Programming, 19(5-6):722–739, September 2019. URL: http://arxiv.org/abs/1907.10096 (visited on 2020-06-22), arXiv:1907.10096, doi:10.1017/S1471068419000152.">ABB+19</a>]</span> and things of that nature.</p>
</div>
</div>
<div class="section" id="optimizations">
<h2>Optimizations<a class="headerlink" href="#optimizations" title="Permalink to this headline">¶</a></h2>
<p>A <a class="reference external" href="http://venge.net/graydon/talks/CompilerTalk-2019.pdf">talk</a> by Graydon Hoare on compilers mentions the paper <span id="id4">[<a class="reference internal" href="zzreferences.html#id5" title="Frances E Allen and John Cocke. A catalogue of optimizing transformations. IBM Research Center, pages 30, 1971. URL: https://www.clear.rice.edu/comp512/Lectures/Papers/1971-allen-catalog.pdf.">AC71</a>]</span>. He says we need 8 optimization passes to get 80% of the performance:</p>
<ul class="simple">
<li><p>Common subexpression elimination - This starts from atomic expressions / closed connected components and then works up to identify opportunities for sharing. Because of unsharing fans it can share parents regardless of their other children; this doesn’t increase the graph size and may decrease code size/computation. Since the graph may be cyclic we need a partitioning algorithm like in <span id="id5">[<a class="reference internal" href="zzreferences.html#id44" title="Laurent Mauborgne. Representation of Sets of Trees for Abstract Interpretation. PhD thesis, Ecole Polytechnique, November 1999. URL: http://software.imdea.org/~mauborgn/publi/t.pdf.">Mau99</a>]</span>.</p></li>
<li><p>Inlining - Going through <span id="id6">[<a class="reference internal" href="zzreferences.html#id48" title="Simon Peyton Jones and Simon Marlow. Secrets of the Glasgow Haskell Compiler inliner. Journal of Functional Programming, 12(4):393–434, July 2002. URL: https://www.microsoft.com/en-us/research/wp-content/uploads/2002/07/inline.pdf (visited on 2020-07-01), doi:10.1017/S0956796802004331.">PJM02</a>]</span>, a lot of the cases are handled by partial evaluation / optimal reduction that moves cuts down and exposes/eliminates case statements. But we also want to do it inside recursive functions etc., which means we need a strictness/termination analysis.</p></li>
<li><p>Constant Folding - partial evaluation of the code includes this</p></li>
<li><p>Loop unrolling, code motion - These are optimizations on mutable variables, so will have to wait until a mutability story is worked out. But unrolling recursive functions could prove useful, as part of inlining.</p></li>
<li><p>Dead code elimination - Unused expressions aren’t connected to the main graph and so are trivially eliminated. But we also want to eliminate conditional branches that will never be taken; this requires a reachability analysis.</p></li>
<li><p>Peephole - this is instruction selection for the backend. LLVM might help, or find a JIT library.</p></li>
</ul>
</div>
<div class="section" id="sat-solving">
<h2>SAT solving<a class="headerlink" href="#sat-solving" title="Permalink to this headline">¶</a></h2>
<p>For SAT, conflict driven clause learning (CDCL) seems to be the most powerful algorithm for solving systems of complex clauses. It is based on assuming specific states for each variable based on each requirement and then, when a conflict is encountered, creating a new requirement from the clause and backtracking. There are extensions of it to nonlinear real systems <span id="id7">[<a class="reference internal" href="zzreferences.html#id12" title="Franz Brauße, Konstantin Korovin, Margarita Korovina, and Norbert Th Müller. A CDCL-style calculus for solving non-linear constraints. arXiv:1905.09227 [cs], July 2019. URL: http://arxiv.org/abs/1905.09227 (visited on 2020-07-25), arXiv:1905.09227.">BKKM19</a>]</span>, and one paper/PhD on using CDCL for termination checking <span id="id8">[<a class="reference internal" href="zzreferences.html#id24" title="Vijay D’Silva and Caterina Urban. Conflict-driven conditional termination. In Daniel Kroening and Corina S. Păsăreanu, editors, Computer Aided Verification, Lecture Notes in Computer Science, 271–286. Cham, 2015. Springer International Publishing. URL: http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf, doi:10.1007/978-3-319-21668-3_16.">DSilvaU15</a>]</span>.</p>
<p>SAT solving can be recast as proving a sequent <span class="math notranslate nohighlight">\(C_1, \ldots, C_n \vdash \bot\)</span> with clauses <span class="math notranslate nohighlight">\(C_i = (a_1 \land \ldots \land a_n \to b_1 \lor \ldots \lor b_m)\)</span>. Resolution is just the cut rule (although resolution-based solving are different from CDCL).</p>
<p>The conversion to CNF uses properties of classical reasoning. In the intuitionistic case, every formula can be transformed into an equiprovable sequent <span class="math notranslate nohighlight">\(\Gamma_i, \Gamma_f \vdash d\)</span> with <span class="math notranslate nohighlight">\(d\)</span> an atom, <span class="math notranslate nohighlight">\(\Gamma_f\)</span> made of flat clauses as in the <span class="math notranslate nohighlight">\(C_i\)</span> above, and implication clauses <span class="math notranslate nohighlight">\((a \to b) \to c\)</span>.</p>
<p>There are definitions of resolution for fragments of linear logic, and linear logic theorem provers.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Logic.html" class="btn btn-neutral float-right" title="Logic" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="Types.html" class="btn btn-neutral float-left" title="Types" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019-2020 Mathnerd314.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>