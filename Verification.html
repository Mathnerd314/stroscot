

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Verification &mdash; Stroscot  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Argument passing" href="Arguments.html" />
    <link rel="prev" title="Overloading" href="Overloading.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Stroscot
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="Overloading.html">Overloading</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Verification</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#sat-solving">SAT solving</a></li>
<li class="toctree-l2"><a class="reference internal" href="#configurable-program-analysis">Configurable Program Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#incremental-program-analysis">Incremental program analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#condition-checking">Condition checking</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Arguments.html">Argument passing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Delimited-Continuations.html">Delimited continuations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fexprs.html">Metaprogramming</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reduction.html#random-old-junk">Random old junk</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l1"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="Memory.html">Memory management</a></li>
<li class="toctree-l1"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="zzreferences.html">References</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Stroscot</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Verification</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Verification.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="verification">
<h1>Verification<a class="headerlink" href="#verification" title="Permalink to this headline">¶</a></h1>
<p>SMT solvers have become very powerful. but termination checking is still in its infancy. It is a difficult (undecidable) task. The state-of-the-art seems to be the ULTIMATE framework that does abstract interpretation of the program via Buchi automata. CPAChecker has also done well in SV-COMP using an extension of dataflow analysis.</p>
<div class="section" id="sat-solving">
<h2>SAT solving<a class="headerlink" href="#sat-solving" title="Permalink to this headline">¶</a></h2>
<p>For SAT, conflict driven clause learning (CDCL) seems to be the most powerful algorithm for solving systems of complex clauses. It is based on assuming specific states for each variable based on each requirement and then, when a conflict is encountered, creating a new requirement from the clause and backtracking. There are extensions of it to nonlinear real systems <a class="bibtex reference internal" href="zzreferences.html#braussecdclstylecalculussolving2019" id="id1">[BKKM19]</a>, and one paper/PhD on using CDCL for termination checking <a class="bibtex reference internal" href="zzreferences.html#dsilvaconflictdrivenconditionaltermination2015" id="id2">[DSilvaU15]</a>.</p>
<p>TT-Open-WBO-Inc</p>
<p>Open-WBO-Inc-complete
Loandra
Open-WBO-Inc-satlike</p>
<p>UWrMaxSat       436     148.97
MaxHS   434     184.69
RC2-B   417     205.88
RC2-A   411     185.92
maxino  393     203.21</p>
<p>Pacose  385     197.83
QMaxSAT 377     281.47</p>
<p>maxino-pref     375     162.1
smax_minisat    339     182.94
smax_mergesat   282     293.93</p>
</div>
<div class="section" id="configurable-program-analysis">
<h2>Configurable Program Analysis<a class="headerlink" href="#configurable-program-analysis" title="Permalink to this headline">¶</a></h2>
<div style="display: none">
\[
\newcommand{\true}{\mathit{true}}
\newcommand{\false}{\mathit{false}}
\newcommand{\seq}[1]{{\langle #1 \rangle}}
\newcommand{\sem}[1]{[\![ #1 ]\!]}
\newcommand{\setsem}[1]{\bigcup_{e \in #1} \sem{e}}
\newcommand{\locs}{\mathit{L}}
\newcommand{\op}{\mathit{op}}
\newcommand{\pc}{\mathit{pc}}
\newcommand{\pcvar}{\mathit{pc}}
\newcommand{\pco}{\mathit{pc_0}}
\newcommand{\pce}{\mathit{pc_{err}}}
\newcommand{\meet}{\sqcap}
\newcommand{\cpa}{\mathbb{D}}
\newcommand{\Nats}{\mathbb{N}}
\newcommand{\Bools}{\mathbb{B}}
\newcommand{\Ints}{\mathbb{Z}}
\newcommand{\strengthen}{\mathord{\downarrow}}
\newcommand{\transconc}[1]{\smash{\stackrel{#1}{\rightarrow}}}
\newcommand{\transabs}[2]{\smash{\stackrel[#2]{#1}{\rightsquigarrow}}}
\newcommand{\merge}{\mathsf{merge}}
\newcommand{\stopop}{\mathsf{stop}}
\newcommand{\wait}{\mathsf{waitlist}}
\newcommand{\reached}{\mathsf{reached}}
\newcommand{\result}{\mathsf{result}}
\newcommand{\compare}{\preceq}
\renewcommand{\implies}{\Rightarrow}
\newcommand{\BUG}{{\sc fa}}
\newcommand{\flag}{\mathit{flag}}
\newcommand{\Itp}[3]{\smash{\mbox{\sc Itp}{(#2,#3)(#1)}}}
\]
</div><p>A <em>configurable program analysis</em> (CPA) specifies — independently of the analysis algorithm —
the abstract domain and a set of operations that control the program analysis.
Such a CPA can be plugged in as a component into the software-verification framework
without the need to work on program parsers, exploration algorithms, and
their general data structures.</p>
<p>A <em>program</em> is represented by a <em>control-flow automaton</em> or CFA <span class="math notranslate nohighlight">\((\locs, l_o, G)\)</span>,
which consists of</p>
<ul class="simple">
<li><p>a set <span class="math notranslate nohighlight">\(\locs\)</span> of program locations/states (models the program counter <span class="math notranslate nohighlight">\(\pc\)</span>)</p></li>
<li><p>an initial program location/state <span class="math notranslate nohighlight">\(l_0\)</span> (models the program entry)</p></li>
<li><p>a set <span class="math notranslate nohighlight">\(Ops\)</span> of program operations. In a simple model, <span class="math notranslate nohighlight">\(Ops\)</span> are either assignment operations or assume operations. The set of program variables that occur in operations from <span class="math notranslate nohighlight">\(Ops\)</span> is denoted by <span class="math notranslate nohighlight">\(X\)</span>.</p></li>
<li><p>a set <span class="math notranslate nohighlight">\(G \subseteq \locs \times Ops \times \locs\)</span> of control-flow edges (models the operation that is executed when control flows from one program location to another).</p></li>
</ul>
<p>A <em>concrete state</em> of a program is
a variable assignment <span class="math notranslate nohighlight">\(c: X \cup \{\pc\} \to V\)</span>
that assigns to each variable a value <span class="math notranslate nohighlight">\(V\)</span>; a simple model takes <span class="math notranslate nohighlight">\(V = \Ints\)</span>.
The set of all concrete states of a program is denoted by <span class="math notranslate nohighlight">\(C\)</span>.
A set <span class="math notranslate nohighlight">\(r \subseteq C\)</span> of concrete states is called a <em>region</em>.
Each edge <span class="math notranslate nohighlight">\(g \in G\)</span> defines a (labeled) transition relation
<span class="math notranslate nohighlight">\(\mathord{\transconc{g}} \subseteq C \times \{g\} \times C\)</span>, which defines how concrete states of one program location (source) are transformed into concrete states of another program location (target).
The complete transition relation <span class="math notranslate nohighlight">\(\transconc{}\)</span> is the union over
all control-flow edges:
<span class="math notranslate nohighlight">\(\mathord{\transconc{}} = \bigcup_{g \in G} \transconc{g}\)</span>.
We write <span class="math notranslate nohighlight">\(c \transconc{g} c'\)</span> if <span class="math notranslate nohighlight">\((c, g, c') \in \mathord{\transconc{}}\)</span>,
and <span class="math notranslate nohighlight">\(c \transconc{} c'\)</span> if there exists a <span class="math notranslate nohighlight">\(g\)</span> with <span class="math notranslate nohighlight">\(c \transconc{g} c'\)</span>.
A concrete state <span class="math notranslate nohighlight">\(c_n\)</span> is <em>reachable</em> from a region <span class="math notranslate nohighlight">\(r\)</span>, denoted by <span class="math notranslate nohighlight">\(c_n \in Reach(r)\)</span>, if
there exists a sequence of concrete states <span class="math notranslate nohighlight">\(\seq{c_0, c_1, \ldots, c_n}\)</span>
such that <span class="math notranslate nohighlight">\(c_0 \in r\)</span> and for all <span class="math notranslate nohighlight">\(1 \leq i \leq n\)</span>,
we have <span class="math notranslate nohighlight">\(c_{i-1} \transconc{} c_{i}\)</span>.</p>
<p>A CPA <span class="math notranslate nohighlight">\(\mathbb{C} = (D, \leadsto, \merge, \stopop)\)</span> consists of 4 elements:</p>
<ul class="simple">
<li><p>an abstract domain <span class="math notranslate nohighlight">\(D = (C, {\cal E}, \sem{\cdot})\)</span>, consisting of</p>
<ul>
<li><p>a set <span class="math notranslate nohighlight">\(C\)</span> of concrete states,</p></li>
<li><p>a bounded join <a class="reference external" href="https://en.wikipedia.org/wiki/Semilattice">semi-lattice</a> <span class="math notranslate nohighlight">\(({\cal E}, \sqsubseteq, \sqcup, \top)\)</span> over abstract-domain elements, and</p></li>
<li><p>a concretization function <span class="math notranslate nohighlight">\(\sem{\cdot} : E \to 2^C\)</span> that maps each abstract-domain element to its represented set of concrete states.</p></li>
</ul>
</li>
<li><p>a transfer relation <span class="math notranslate nohighlight">\(T \subseteq E × G × E\)</span> computes abstract successor states. It assigns to each abstract state <span class="math notranslate nohighlight">\(e\)</span> possible new abstract states <span class="math notranslate nohighlight">\(e'\)</span> that are abstract successors of <span class="math notranslate nohighlight">\(e\)</span>. Similarly to the CFA each transfer is labeled with a control-flow edge <span class="math notranslate nohighlight">\(g\)</span>, so we have <span class="math notranslate nohighlight">\(\overset{g}{\leadsto}\)</span> as well as <span class="math notranslate nohighlight">\(\leadsto\)</span> derived from <span class="math notranslate nohighlight">\(T\)</span>.</p></li>
<li><p>a merge operator <span class="math notranslate nohighlight">\(\merge :  E × E → E\)</span> specifies if and how to merge abstract states when control flow meets. The operator weakens the abstract state (also called widening) that is given as second parameter depending on the first parameter. Note that the operator <span class="math notranslate nohighlight">\(\merge\)</span> is not commutative, and is not necessarily the same as the join operator of the lattice. The result of <span class="math notranslate nohighlight">\(\merge(e, e')\)</span> can be anything between <span class="math notranslate nohighlight">\(e'\)</span> and <span class="math notranslate nohighlight">\(\top\)</span>. Two simple ones are <span class="math notranslate nohighlight">\(\merge_{sep}(e,e')=e'\)</span> and <span class="math notranslate nohighlight">\(\merge_{join}(e,e')=e \sqcup e'\)</span></p></li>
<li><p>a termination check <span class="math notranslate nohighlight">\(\stopop : E × 2^E \to B\)</span> checks whether the abstract state <span class="math notranslate nohighlight">\(e\)</span> that is given as first parameter is covered by the set <span class="math notranslate nohighlight">\(R\)</span> of abstract states given as second parameter, i.e., every concrete state that <span class="math notranslate nohighlight">\(e\)</span> represents is represented by some abstract state from <span class="math notranslate nohighlight">\(R\)</span>. Two simple termination checks are <span class="math notranslate nohighlight">\(\stopop_{sep}(e, R) = \exists e' ∈ R : e \sqsubseteq e'\)</span> and <span class="math notranslate nohighlight">\(\stopop_{join}(e, R) = e \sqsubseteq \bigsqcup R\)</span>. The second requires <span class="math notranslate nohighlight">\(D\)</span> to be a power-set domain, i.e. .</p></li>
</ul>
<p>We run a CPA analysis with the following algorithm::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>CPA(reached, wait)
INPUT
   a CPA cpa = (D, T, merge, stopop)
   a set reached of abstract states in E (usually a single state e0)
   a set wait of frontier abstract states, a subset of reached (also e0)
OUTPUT
   a set reached of reachable abstract states
   a set wait of frontier abstract states (empty if the algorithm terminated correctly)

WHILE not wait.empty
  choose e from wait; remove e from wait;
  FOR each e&#39; with T(e, e&#39;)
    FOR each e&#39;&#39; in reached
      // Combine with existing abstract state.
      e_new := merge(e&#39;, e&#39;&#39;);
      IF e_new != e&#39;&#39;
        wait    := (wait    union {e_new}) setminus e&#39;&#39;;
        reached := (reached union {e_new}) setminus e&#39;&#39;;
      ENDIF
    ENDFOR
    // Add new abstract state?
    IF not stop(e&#39;, reached)
      wait := wait union e&#39;;
      reached := reached union e&#39;;
    ENDIF
  ENDFOR
ENDWHILE
// wait is empty
return reached
</pre></div>
</div>
<div class="section" id="incremental-program-analysis">
<h3>Incremental program analysis<a class="headerlink" href="#incremental-program-analysis" title="Permalink to this headline">¶</a></h3>
<p>Another issue is incremental analysis. Solving the halting problem is slow so we would like to re-use most of the analysis when recompiling a file. Looking at a 2019 presentation <a class="bibtex reference internal" href="zzreferences.html#jakobsdifferentialmodularsoftware" id="id3">[Jak]</a> there doesn’t seem to be any major breakthrough. Marking the analyzer’s computation steps in the general incremental build framework is probably sufficient.</p>
</div>
<div class="section" id="condition-checking">
<h3>Condition checking<a class="headerlink" href="#condition-checking" title="Permalink to this headline">¶</a></h3>
<p>There’s some interesting <a class="reference external" href="http://mmjb.github.io/T2/">work</a> on termination checking by Microsoft, called <a class="reference external" href="https://web.archive.org/web/20131005142732/http://research.microsoft.com:80/en-us/um/cambridge/projects/terminator/papers.htm">TERMINATOR</a>. There’s a representation of terms as sets, which ends up mapping out all the paths through the program, and then identifying termination is fairly easy. But since you can check all these conditions it’s a very powerful analysis that can also check buffer overflows and array bounds and resource use <a class="bibtex reference internal" href="zzreferences.html#albertresourceanalysisdriven2019" id="id4">[ABB+19]</a> and things of that nature.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Arguments.html" class="btn btn-neutral float-right" title="Argument passing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="Overloading.html" class="btn btn-neutral float-left" title="Overloading" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019-2020 Mathnerd314.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>