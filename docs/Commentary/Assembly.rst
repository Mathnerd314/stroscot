Assembly
########

A lot of languages aim for "no runtime overhead". But this is unattainable, even C structs and arrays have to use memcpy occasionally. Stroscot merely aims to be as fast as C, which means compiling to good C is sufficient. But C is somewhat ill-defined and assembly can be faster in some cases, so it would be nice to do assembly directly as well.

Architectures
=============

The first step in dealing with assembly is to decide which instruction set architectures to support. I couldn't find a list of processor architectures by popularity, but from `this quora answer <https://www.quora.com/What-kind-of-instruction-set-architecture-do-modern-processors-use>`__ and checking it by googling numbers of units sold for other random ISAs, the two primary architectures are x86-64 AMD64 (desktops) and ARMv8-A A64 (mobile devices).

Others to consider as well:

* ARMv9-A A64: It's released, devices expected in 2022. Very similar to v8 so should be able to share the code as a microarchitecture. Verdict: on the roadmap
* C: compilation to a self-contained C program makes porting much easier, and obviates the need for many of these architectures. Verdict: on the roadmap. Note though that this is only compiling to a subset of C - not every C program can be produced. And some things like tail calls are really hard to encode in C, or add significant compilation overhead, so it can't be the only option.
* WASM: it still doesn't support `tail calls <https://github.com/WebAssembly/proposals/issues/17>`__. Given the lack of progress it seems like a low priority. Verdict: Contributor.
* LLVM: The bitcode format may be worth targeting at some point. Per blog posts the API is much more unstable than the IR, and generating the IR in memory and parsing it is about as fast as using the API. Verdict: Contributor.
* RISC-V: There are $100-ish dev boards listed at https://riscv.org/exchange/boards/. No non-dev systems yet. It's a relatively simple ISA, similar to ARM. Verdict: Contributor
* 32-bit ARM: Old phones, the Raspberry Pi Zero. The XML database is similar. Verdict: Contributor.
* 32-bit x86: Old desktop PCs. From a time/effort perspective it seems cheaper to buy a new computer instead of writing support for these. Verdict: C backend or contributor.
* POWER: `Raptor <https://secure.raptorcs.com/content/base/products.html>`__ sells expensive systems. Much more niche than RISC-V. Verdict: C backend.
* MIPS: the company that develops it went bankrupt and is now doing RISC-V. There are consumer systems available in China (Loongson), but the rumor is that they too are moving to RISC-V or else to their own architecture LoongArch. Verdict: C backend.
* z/Architecture: really expensive, weird OS. Verdict: C backend.
* SPARC: It's end-of-life but I guess you can still buy servers second-hand. Verdict: C backend.

From a design perspective supporting 2 architectures is not much different from supporting 10, it's just a larger set of cases, but 10 is 5x the work of 2. ARM support will be tested through QEMU, x86 natively. There are also CI services that could work (Drone). Code bloat is an issue but keeping each ISA in its own folder should avoid drift.

In addition to the basic ISAs, there are also extensions and `microarchitectures <https://en.wikipedia.org/wiki/Microarchitecture>`__ to consider. `PassMark <https://www.cpubenchmark.net/share30.html>`__ has a list of CPU shares, it's probably wildly skewed to gaming but it's better than nothing. The data on CPU cycles, ports, etc. is rather detailed and has to be generated by running benchmarking programs, so it will probably depend on user submissions; for now I'll use my own CPU (AMD A6-3650 APU).

Operating systems
=================

In planned order:

1. Linux for AMD64, because it's what I'm typing on now
2. Android for ARM, because it's my phone and it's easy to hook up
3. Windows for AMD64, which I can emulate with WINE and get access to fairly easily

We'll exclude Apple for now because their OS documentation sucks, they charge $100/year for a "developer license", and their anti-competitive practices mean that they would probably find some way to shut Stroscot down once Stroscot starts being a serious competitor with Swift. Of course there is nothing stopping someone else from jumping through all the hoops needed to placate Apple and making a port.

Instruction database
====================

Data sources
------------

The basic goal is to have official data sources where possible and otherwise generate it automatically via measurement, that way new processors / ISAs can be added quickly. In terms of data sources for ISAs, for x86 the official sources are `Intel's SDM <https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html>`__ / `AMD's Architecture Programmer's Manual <https://developer.amd.com/resources/developer-guides-manuals/>`__, which use English and pseudocode and have numerous typos (if the experiences of others hold true). Also they are only distributed as PDFs. Parsing the PDFs is a lot of work. `EXEgesis <https://github.com/google/EXEgesis>`__ uses a hacky Xpdf parser but has some amount of effort invested by Google. `x86doc <https://github.com/HJLebbink/x86doc/tree/master/Python>`__ uses pdfminer to generate HTML which seems like a more friendly starting point.

More structured but less official are x86 instruction databases:

* `Intel XED <https://intelxed.github.io/>`__ (`file <https://github.com/intelxed/xed/blob/main/datafiles/xed-isa.txt>`__). This might as well be official, although it is technically its own open-source project I think Intel uses it internally.
* LLVM `x86 tables <https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/X86.td>`__
* NASM `instruction table <https://github.com/netwide-assembler/nasm/blob/master/x86/insns.dat>`__
* `GNU Assembler (gas) <https://sourceware.org/git/?p=binutils-gdb.git;a=blob;f=opcodes/i386-opc.tbl;h=b0530e5fb82f4f4cd85d67f7ebf6ce6ebf9b45b5;hb=HEAD>`__
* `iced <https://github.com/icedland/iced/blob/65d1f49584247a09dcc2559727936a53014268f5/src/csharp/Intel/Generator/Tables/InstructionDefs.txt>`__
* `OSACA <https://github.com/RRZE-HPC/OSACA/tree/master/osaca/data/isa>`__ is AGPL licensed and very incomplete
* `Ghidra <https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/languages/ia.sinc#L1594>`__, seems to have semantics
* emulators: https://github.com/colejohnson66/rbx86, https://bochs.sourceforge.io/
* https://github.com/asmjit/asmjit, https://github.com/bitdefender/bddisasm, https://github.com/dyninst/dyninst, https://github.com/herumi/xbyak, qemu/capstone, https://github.com/diegocarba99/bagheera, https://github.com/mongodb-labs/disasm, zydis, https://github.com/MahdiSafsafi/AMED, https://github.com/nidud/asmc
* Go assembler https://cs.opensource.google/go/go/+/master:src/cmd/internal/obj/x86/avx_optabs.go;l=1791?q=vfixupimmss&ss=go
* https://github.com/Barebit/x86reference/blob/master/x86reference.xml

Semantics:

* For ARM, we have official XML `Machine Readable Architecture instruction tables <https://developer.arm.com/architectures/cpu-architecture/a-profile/exploration-tools>`__, which is nice-ish XML, and the code has been validated against ARM's conformance suite. There is a toy disassembler `hs-arm <https://github.com/nspin/hs-arm>`__ using the tables. EXEgesis also parses the XML. `asl-interpreter <https://github.com/alastairreid/asl-interpreter>`__ runs the descriptions which are written in a special language.

* For x86-64 some academics have created a `formal X86-64 semantics <https://github.com/kframework/X86-64-semantics>`__ containing most of the userspace Haswell instructions. It was mostly manually written and has been checked with fuzzing. It is written in the K Framework syntax. It is missing concurrency, crypto (AES), supervisor/privileged, x87 floating-point, MMX, and also has a bug where it rounds too much with fused multiply-add floating point precision.


Timing:

* https://github.com/e12005490/valgrind_timing/tree/117292a3a94f843c173bdb53e4933c6b79570240/variable_time_instructions
* I think EXEgesis or llvm-exegesis generates timings on the current x86 CPU
* ARM: ?

Definition of an instruction
----------------------------

An instruction is a finite sequence of binary data (generally some number of bytes). The general idea is that instructions are a syntactic unit above bits, like words in a character string. Except unlike words, there's no instruction separator character; instructions are all run together like ``afewinstructions``. Segmenting ARM instructions is simple because they are all 32 or 64 bits. For x86, the length varies from 1 to 15 bytes and is affected by almost all parts of the instruction. `sandsifter <https://github.com/xoreaxeaxeax/sandsifter>`__ can determine the length of the first instruction in some bytes by finding an index for which ``seq|uence`` does not trigger a page fault, but ``se|quence`` does (where ``|`` is a page boundary). `haruspex <https://blog.can.ac/2021/03/22/speculating-x86-64-isa-with-one-weird-trick/>`__ is even more tricky and examines the microcode speculation buffer performance counters to see how many nops after the byte sequence were speculated. With these tools we can segment arbitrary data into x86 instructions, assuming access to the processor.

We cannot build a 100% complete and verified list of instructions. As far as verification, there are simply too many; sandsifter/haruspex take days to run and do not even explore the full instruction space, making assumptions about the format of instructions. As far as completeness, these tools have been run on various processors and confirmed that there are many undocumented instructions, and there are likely more instructions that will be found in the future. But building a database that is 99% complete and probabilistically verified is not too hard; we take the officially documented instruction patterns, manually add whatever undocumented instructions we can find, and fuzz it a bit with sandsifter to check decoding.

Still though, we should design for our instruction database being incomplete, and allow a syntax for writing raw instructions, ``instr('f0 0f')`` or similar. It's similar to a ``.db`` statement that allows include file headers or data in the ``.data`` section, but is meant specifically for executable data. Unfortunately with these raw instructions, if they are not in the database, many compiler optimizations are useless: pipelining, register allocation, etc. So for an optimizing compiler we need instruction metadata, like clobbered registers, cycles, possible traps, etc. There are generally sensible defaults in the absence of information (all registers clobbered, no reordering, all traps possible, etc.), but specifying this information allows optimizing raw instructions just as well as database instructions.

Templates
---------

Listing instructions out exhaustively one-per-line would be too much data due to combinatorial explosion, so instead we have a list of templates, each of which can turned into an instruction by filling in the holes. Following Xed we can call the data that is filled in "explicit operands". The explicit operands are distinguished bitstrings and can refer to registers, addresses, and immediate values. We choose each template so that it has similar behavior regardless of what is chosen for its explicit operands.

The templates should have names. For automatically generating them it could be a hash of the template string, or else the smallest unique opcode prefix or something. But really we want to use the mnemonics from the docs.

Intel has variable-length instructions and from the docs seems to use byte-based templates, for example 64-bit ADCX is ``66 <REX.w> 0F 38 F6 <MODRM>``. The REX has 3 bits of operand data; the modrm is an operand and can be 1-6 bytes (register or memory with optional SIB/displacement). We could parse the Intel docs for this (EXEgesis + handling all the weird encoding stuff), but I think extracting Xed's `iform list <https://intelxed.github.io/ref-manual/xed-iform-enum_8h.html>`__ and using Xed for encoding is the way to go. It doesn't match the docs 1-1 but it saves on sanity - e.g. the separate memory / register templates abstract over the complications of MODRM.

ARM has fixed length instructions and uses a bit-based format, for example A64 ADDS is ``sf 0101011 shift* 0 Rm**** imm6***** Rn**** Rd****``. Here each name is an operand and the stars represent extra bits of the operand - the operand is a fixed-length bitstring. hs-arm `seems <https://github.com/nspin/hs-arm/blob/8f10870a4afbbba010e78bd98e452ba67adc34e0/nix-results/harm.harm-tables-src/gen/Harm/Tables/Gen/Insn.hs>`__ to pull out this information just fine, although its operand names are a little weird.

So the information for each template is:

* form name (string)
* explicit operands (list)

  * name (dest, src1, xmm1, etc.)
  * type:

    * immediate (range/size b, z, etc.)
    * register class (class GPR8, GPRv, XMM, etc.)
    * memory (size b, v, etc.)

* encoding function ``[Operands] -> Bits``
* Xed's isa_set field
* the condition on CPUID for this instruction to work
* the valid modes (32-bit, 64-bit, real, protected, etc.)

The isa_set field and fields after are because there are lots of overlapping sets of instructions and maintaining one master set is easier than duplicating the data.

Affected state
--------------

Another important piece of data is the affected state, i.e. the list of read/written flags/registers/etc. This is used in instruction reordering/scheduling and register allocation to minimize `data hazards <https://en.wikipedia.org/wiki/Hazard_(computer_architecture)#Data_hazards>`__.

The affected things depend on the instruction (and the operands). Where can we get this info?

It seems possible to automatically determine by fuzzing (weighted towards special cases like 0 and 1). But it's probably really slow and the result is somewhat suspect - it can't determine that a flag/register becomes undefined, and it may miss reads/writes that happen in rare circumstances.

In the Intel docs there is a little ``(r,w)`` or ``(r)`` after the operands. But this doesn't include everything. The rest can be found by scanning the English text, but unless we use NLP this will only give a list of affected things and not read/write info. Xed has info on read/written standard flags. But it abbreviates other flag registers - for example (per the Intel documentation) VFIXUPIMMSS reads MXCSR.DAZ and conditionally updates MXCSR.IE and MXCSR.ZE, but Xed just records a MXCSR attribute. LLVM similarly just has ``USES = [MXCSR]``. NASM and gas don't seem to have flag information at all. iced does have flag info but no MXCSR. The K semantics don't have MXCSR. So I guess Xed is the best data source but we will have to use EXEgesis somehow to scrape the affected flags, and then manually mark them as read/write/conditional or just leave it at coarse reordering information.

For ARM modifying asl-interpreter should give info on flags etc.

So the affected state database schema:

* form name
* affected things (list)

  * type:

    * explicit operand (+ index)
    * fixed register
    * pseudo resource
    * flag bit

  * read: read / not read / conditionally read / unknown
  * written:

    * value: constant,  copied from input, input + constant, undefined/reserved, complex computation
    * written with value, not written, conditionally written with value, unknown

* possible exceptions

Instructions with no data have all possible affected things present, with read/write unknown.

Pseudo-resource includes things like load-link/store-conditional. LDXR sets monitors (write) and STXR checks monitors (read). A second LL clears the monitor so LL is actually read/write. Anyway the monitor is a pseudo resource, because it's not a register.

"undefined" in the context of Intel means "arbitrary bit-pattern may be returned". This is distinct from C's UB but matches LLVM's "undef".

Classification
--------------

We can classify instructions:

* Data usage: does it read or write flags/general-purpose registers/stack pointer/memory/FP regs/SIMD regs/program counter?
* Category: nop, movement, arithmetic, logic, floating point, string, cryptography, SSE, AVX, control flow, I/O, system call/privilege rings/virtualization, concurrency, (atomics, fences), cache control (prefetch/barrier), performance monitoring/debugging, virtual memory, interrupts/exceptions/traps,

Performance
-----------

the data present in LLVM for instruction scheduling (such as uops, execution ports/units, and latencies),

If PSTATE.DIT is 1 the execution time is independent of the values.

Memory model
------------

A memory model is needed to determine if reordering data writes will change the behavior of a concurrent program.
