

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Build system &mdash; Stroscot  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="FAQ" href="FAQ.html" />
    <link rel="prev" title="Compiler design" href="Compiler.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Stroscot
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arguments.html">Argument passing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fexprs.html">Metaprogramming</a></li>
<li class="toctree-l1"><a class="reference internal" href="Delimited-Continuations.html">Delimited continuations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Optimal-Reduction.html">Optimal reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="Overloading.html">Overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="Memory.html">Memory management</a></li>
<li class="toctree-l1"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Build system</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#notes">Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#package-manager">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="#linux-distribution">Linux distribution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ci-cd">CI/CD</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="zzreferences.html">References</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Stroscot</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Build system</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/BuildSystem.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="build-system">
<h1>Build system<a class="headerlink" href="#build-system" title="Permalink to this headline">¶</a></h1>
<p>Although build systems are often an afterthought in programming language design, they interface with the compiler in several areas, so it is better to integrate the build system into the compiler as a library. That way intermediate results such as typechecked/optimized functions can be stored efficiently and rebuilt only when needed. Also, it allows the compiler’s include-following mechanism to tightly integrate with the build system, so that generated files can be generated before they are used.</p>
<div class="graphviz"><img src="_images/graphviz-1a509ab03a6c9026e34ddceebc0e71426e17cdab.png" alt="digraph foo {
    rankdir=LR;
    subgraph cluster_0 {
        style=filled;
        color=lightgrey;
        node [style=filled,color=white];
        a0 -&gt; a1 -&gt; a2;
        a0, a1, a2 [shape=&quot;circle&quot;];
        a0 [label=&quot;require&quot;];
        a1 [label=&quot;cmd&quot;];
        a2 [label=&quot;provide&quot;];
        label = &quot;BuildModule C.java&quot;;
    }
    &quot;Javac config&quot; -&gt; a0
    &quot;C.java&quot; -&gt; a0
    a2 -&gt; &quot;C.class&quot;
    a2 -&gt; &quot;C$1.class&quot;
    a2 -&gt; &quot;C$Foo.class&quot;
}" class="graphviz" /></div>
<p>The pipeline of a build system is fairly straightforward:</p>
<ul>
<li><p>We start with a changelist of “dirty” keys; this is usually a list of local files, but can also include volatile information such as version numbers or FTP server listings or finer keys such as individual AST nodes.</p></li>
<li><p>Next we propagate dirtiness up the pre-built task/key graph; this allows us to identify tasks as being in one of these states:</p>
<blockquote>
<div><ul class="simple">
<li><p>Present: built, not dirty</p></li>
<li><p>Recheck: a subtask / subkey is dirty, might have to rebuild again</p></li>
<li><p>Missing: never built, needs to be built</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Next we go down from the top-level task. We want a suspending build system <a class="bibtex reference internal" href="zzreferences.html#mokhovbuildsystemscarte2020" id="id1">[MMPJ20]</a>. So there must be some way to suspend the current task when it calls a sub-task, probably just continuations like how Shake does it.</p></li>
<li><p>When a task is called, we first check its state to determine whether it needs to be re-run. Missing tasks are run immediately. Present tasks can be skipped immediately. Otherwise we run through the serialized dependency list and re-check the keys / subtasks in order (and in parallel if the subtasks are parallel).</p></li>
<li><p>Before re-running a task, we delete all its generated keys (outputs). After running a task we store its (keyed) outputs with either verifying or constructive traces.</p></li>
<li><p>To prune the store, we can do as above and also load all the subtasks of present tasks. Then anything not loaded is not needed and can be pruned, although if there are multiple configurations etc. then this is a bad idea.</p></li>
</ul>
<div class="section" id="notes">
<h2>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h2>
<p>Unlike Shake, tasks are not keys; it is a two-level graph like Pluto. Task identifiers are serializable as well, but they are in a different namespace. The store maintains dependency lists of key and task identifiers for each task, but tasks do not store versions the way keys do.</p>
<p>For the task graph, we have some nontrivial requirements for soundness, similar to <a class="bibtex reference internal" href="zzreferences.html#erdwegsoundoptimalincremental2015" id="id2">[ELW15]</a>:</p>
<ul class="simple">
<li><p>The graph is a DAG.</p></li>
<li><p>There can be at most one task providing a given key.</p></li>
<li><p>If a task depends on a generated key, the task providing the key must have been run first.</p></li>
</ul>
<p>An easy way to ensure these last two is to construct a function mapping from generated files (keys) to tasks, and then have a library function for requiring keys which uses the map to require the task and then the key. Unfortunately in a dynamic build such a direct map is not always available and so the requirement is relaxed to allow indirect dependencies. For example, we may have a generated file that is picked up in a search path directory listing. To deal with this directly we would need to introduce build logic into the search mechanism, but a phase separation handles it too with minimal changes. And since dependencies can be required after execution, we can speculatively generate files and require only the ones that are actually used.</p>
<p>Giving tasks versions is a good idea; this amounts to adding a version key as a dependency.</p>
<p>Without an initial list of changed keys, we will have to walk the whole graph. This can still be done efficiently by batching filesystem reads. A bigger question is whether up-propagation of dirtyiness can be avoided. My intuition is that most dependency graphs are tree-like and so going up is roughly <span class="math notranslate nohighlight">\(\log(n)\)</span>. There are some dependencies (e.g. small common functions) which have a huge reverse dependency list, but changing those requires a full rebuild anyway so the overhead is dwarfed.</p>
</div>
<div class="section" id="package-manager">
<h2>Package manager<a class="headerlink" href="#package-manager" title="Permalink to this headline">¶</a></h2>
<p>A language also needs a package manager. Compared to a build system alone, the main feature is downloading files over the network and verifying cryptographic hashes. In the build graph a new state “Substituted” is added which behaves similarly to “Present”; when a task is requested, and package management is enabled, the task is checked against a list of prebuilt tasks and if so the relevant keys are downloaded instead of the task being built. Relevant here means the runtime dependencies needed by other tasks. From a build perspective this is a shortcut, as running the task should recreate everything the task builds to avoid potentially leaving out necessary files, but most people who use a package manager do not rebuild their intermediate steps and want the smallest possible package sizes.</p>
<p>In the implementation details are some filesystem issues, in particular different layouts on different systems and allowing per-user installs, but Conda has worked out a reasonable layout.</p>
</div>
<div class="section" id="linux-distribution">
<h2>Linux distribution<a class="headerlink" href="#linux-distribution" title="Permalink to this headline">¶</a></h2>
<p>Once we have a package manager we can build a Linux distribution. Compared to a user-level package manager, a system-level package manager must be built a bit more robustly to handle crashes/rollbacks. It also needs various build system hooks for dealing with tricky/non-standardized installation procedures, e.g. putting kernel/initrd images into the boot manager, building in a container with overlayfs to guard against untrustworthy packages, and using auditd to identify file dependencies in a bulletproof manner. As a basis for the distribution we can use small distros like LFS and Buildroot. It would also be good to figure out some way to import data from bigger distributions like Arch, Gentoo, or NixOS. Cross-compilation is a goal, but it isn’t strictly necessary and it’s easily broken anyways.</p>
<p>The goal of the Linux distribution, compared to others, is automation: all package updates are automatic, and packaging new software is as simple as giving a package identifier / URL (and dependency information or build instructions, for C/C++ projects or custom build systems). Language-specific package repositories have grown to be bigger than most distros, so providing easy one-line installation of them is paramount.</p>
</div>
<div class="section" id="ci-cd">
<h2>CI/CD<a class="headerlink" href="#ci-cd" title="Permalink to this headline">¶</a></h2>
<p>Along with a Linux distribution (or any large software collection) comes the need to continuously test and update packages. Besides providing a prebuilt collection of packages, the main purpose is to identify breakages, i.e. when a test or build fails due to an update. Once a breakage is identified, it can be ameliorated by pinning the package to the old version. If the update is in a library and only a few packages are broken by the dependency update, the package can be split into multiple versions and the pin can be restricted to those specific dependencies.</p>
<p>Unfortunately, detecting breakages is an imperfect science; there are exponentially many combinations of different versions, and tests can be flaky. So we can only identify updates that have a high probability of causing a breakage. But, given a breakage, we can use the dependency graph traces to narrow a failure down to a specific build task, so most of the graph can be ruled out immediately and skipped during a rebuild.</p>
<p>We can model the test process as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>broken = false
for change in observed_changes:
  change_type &lt;- choice([broken ? FIXING : BREAKING, NONE], broken, change)
  if change_type = BREAKING:
    broken = true
  else if change_type = FIXING:
    broken = false

  for run in observed_runs:
    flaky &lt;- choice([YES, NO], broken, change)
    if flaky = YES:
      report(!broken)
    else:
      report(broken)
</pre></div>
</div>
<p>The choice function can be an arbitrarily complicated function of <code class="docutils literal notranslate"><span class="pre">commit</span></code>, but since the outcome is a random binary we can distill it down to two probabilities for each commit <span class="math notranslate nohighlight">\(k\)</span>: fixing <span class="math notranslate nohighlight">\(P(f_k)\)</span> and breaking <span class="math notranslate nohighlight">\(P(b_k)\)</span>. We’ll want complex models to predict these, like the logistic models from <a class="bibtex reference internal" href="zzreferences.html#najafibisectingcommitsmodeling2019" id="id3">[NRS19]</a> that use the list of files changed / modified components, presence of keywords in commit message, etc. Regardless, our model boils down to a hidden Markov process with two states, broken and working. Since the state space is so small we probably want to work with the second-order process, so we can easily identify breaking and fixing commits. The initial state is known to be working.</p>
<p>For observations, if we assume that the probability of false positive / false success <span class="math notranslate nohighlight">\(P(p_k)\)</span> and false negative / false failure <span class="math notranslate nohighlight">\(P(n_k)\)</span> are fixed per commit, then the probability of observing <span class="math notranslate nohighlight">\(i\)</span> test failures and <span class="math notranslate nohighlight">\(j\)</span> test successes (in a given/fixed order) given that the build is broken / not broken is</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}P(o_k = f^i s^j \mid r_k) = (1-P(p_k))^i P(p_k)^j\\P(o_k = f^i s^j \mid \neg r_k) = P(n_k)^i (1-P(n_k))^j\end{aligned}\end{align} \]</div>
<p>We will want to use the logit function <a class="bibtex reference internal" href="zzreferences.html#wikipedialogit2020" id="id4">[Wikipedia20b]</a> instead of computing products of small floating point numbers. We can also use a per-run model of flakiness, e.g. based on analyzing the test logs; then each success/failure probability is calculated individually. Whatever the case, we can then use the forward-backward algorithm <a class="bibtex reference internal" href="zzreferences.html#wikipediaforwardbackwardalgorithm2020" id="id5">[Wikipedia20a]</a> to smooth all the observations and compute the individual probabilities that each commit is broken / breaking / fixing. This can then be propagated back to compute the probability that each run is flaky. When all is said and done we end up with a table:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Change #</p></th>
<th class="head"><p>P(Broken)</p></th>
<th class="head"><p>P(Type)</p></th>
<th class="head"><p>Run #</p></th>
<th class="head"><p>P(Flaky)</p></th>
<th class="head"><p>Result</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>101</p></td>
<td><p>0.02</p></td>
<td><p>Breaking 0.1, Fixing 0.2</p></td>
<td><p>1</p></td>
<td><p>0.01</p></td>
<td><p>Success</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td><p>2</p></td>
<td><p>0.01</p></td>
<td><p>Success</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td><p>3</p></td>
<td><p>0.03</p></td>
<td><p>Failure</p></td>
</tr>
<tr class="row-odd"><td><p>102</p></td>
<td><p>0.01</p></td>
<td><p>Breaking 0.1, Fixing 0.5</p></td>
<td><p>1</p></td>
<td><p>0.02</p></td>
<td><p>Success</p></td>
</tr>
</tbody>
</table>
<p>The table only has one probability, treating the build as a unit; we could also make one table for each test and a UI to aggregate them somehow. From this table, we can make simple decisions, reporting breakages, hiding flaky runs, blacklisting broken builds, etc. once a certainty threshold is reached. But a more important question is determining which build to do next. There are several goals:</p>
<ul class="simple">
<li><p>Identifying breakages etc. sufficiently to generate reports</p></li>
<li><p>Minimizing redundant builds/tests that generate no new information</p></li>
<li><p>Redoing runs that are affected by flaky tests</p></li>
<li><p>Doing cheap tests and sensitive tests before others</p></li>
</ul>
<p>The general problem falls under “stochastic scheduling”. For the optimal (intractable) solution, as well as the success/failure probability we must also know the cost associated with running the tests (in time/resource usage) and (for parallelisation) the available resources; it is almost a multi-armed bandit problem where getting enough information to generate a report results in a payoff. However, a failing build for one commit changes the calculated probabilities of the other commits failing, so it is not independent.</p>
<p>A simple heuristic is to find the build with <code class="docutils literal notranslate"><span class="pre">P(Broken)</span></code> closest to 50%; this ignores flakiness. What we want is to maximize the information entropy gained from a run <span class="math notranslate nohighlight">\(X\)</span>, i.e.</p>
<div class="math notranslate nohighlight">
\[H(X) = - P(x_s) \log(P(x_s)) - P(x_f) \log(P(x_f))\]</div>
<p>where <cite>x_s = 1 - x_f</cite> is the probability that the run will succeed.</p>
<p>There is also the issue of spacing out parallel builds to do trisection / general <span class="math notranslate nohighlight">\(n\)</span>-section. Speculative building will end up doing bisection of bisection (i.e. quadrisection and general <span class="math notranslate nohighlight">\(2^n\)</span>-section) in the case of little information, which is probably good enough.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="FAQ.html" class="btn btn-neutral float-right" title="FAQ" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Compiler.html" class="btn btn-neutral float-left" title="Compiler design" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019-2020 Mathnerd314

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>