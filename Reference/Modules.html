<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modules &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Dispatch" href="Dispatch.html" />
    <link rel="prev" title="Metaprogramming" href="Fexprs.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Values.html">Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fexprs.html">Metaprogramming</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#access">Access</a></li>
<li class="toctree-l3"><a class="reference internal" href="#with-statement">With statement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exports-and-internal-symbols">Exports and internal symbols</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parameters">Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linking">Linking</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#imports">Imports</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#overrides">Overrides</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory.html">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Commentary/index.html">Commentary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Language Reference</a> &raquo;</li>
      <li>Modules</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Reference/Modules.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="modules">
<h1>Modules<a class="headerlink" href="#modules" title="Permalink to this heading"></a></h1>
<p>Modules from the programming perspective are records; they contain a list of bindings. But they have a top-level scope and take advantage of declaration syntax. They also define namespaces for symbols.</p>
<p>A module starts with a module identifier followed by import declarations followed by other declarations.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>module

a = 1
b = 2

# C = { a = 1; b = 2 }
</pre></div>
</div>
<section id="access">
<h2>Access<a class="headerlink" href="#access" title="Permalink to this heading"></a></h2>
<p>By default bare symbols are interpreted as belonging to the current module. So <code class="docutils literal notranslate"><span class="pre">a</span></code> in module <code class="docutils literal notranslate"><span class="pre">A</span></code> refers to <code class="docutils literal notranslate"><span class="pre">A.a</span></code>.</p>
<p>To access a member of a module we use dot notation <code class="docutils literal notranslate"><span class="pre">C.a</span></code>. Modules can be nested arbitrarily deep, <code class="docutils literal notranslate"><span class="pre">A.B.C.a</span></code>. The uniform notation with records seems cleaner than notation like <code class="docutils literal notranslate"><span class="pre">A::B::C::a.b</span></code>. The first component of the dotted name is still qualified to the current module, so <code class="docutils literal notranslate"><span class="pre">C.a</span></code> in module <code class="docutils literal notranslate"><span class="pre">A</span></code> refers to <code class="docutils literal notranslate"><span class="pre">A.C.a</span></code>. The recursive knot in the linker defines <code class="docutils literal notranslate"><span class="pre">A.C.a</span> <span class="pre">=</span> <span class="pre">&lt;global&gt;.C.a</span></code> after it sees that <code class="docutils literal notranslate"><span class="pre">A</span></code> imports <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p>
</section>
<section id="with-statement">
<h2>With statement<a class="headerlink" href="#with-statement" title="Permalink to this heading"></a></h2>
<p>To save on typing there is the <code class="docutils literal notranslate"><span class="pre">with</span></code> statement.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">#</span><span class="w"> </span><span class="n">equivalent</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="n">most</span><span class="w"> </span><span class="n">purposes</span><span class="w"></span>
<span class="kt">C</span><span class="o">.</span><span class="n">a</span><span class="w"></span>
<span class="nf">with</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>If multiple modules are in scope through <code class="docutils literal notranslate"><span class="pre">with</span></code>, then an identifier may refer to any of the modules as well. These are handled through the normal overloading mechanism, as if <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">C.a</span></code> were written for every identifier <code class="docutils literal notranslate"><span class="pre">a</span></code> and module <code class="docutils literal notranslate"><span class="pre">C</span></code>. A warning/error will be generated if the overloading cannot be resolved statically or if it is ambiguous.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>C = complex computation returning a module
D = complex computation returning a module

with D { with C { a } }
-- refers to C.a or D.a
</pre></div>
</div>
<p>To avoid ambiguity, <code class="docutils literal notranslate"><span class="pre">with</span></code> statements can be restricted by hiding identifiers or limiting the introduced identifiers to a list.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">with</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="n">hiding</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="nf">with</span><span class="w"> </span><span class="kt">D</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>You can use <code class="docutils literal notranslate"><span class="pre">with</span></code> on an argument with the dot syntax: <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">.</span> <span class="pre">=</span> <span class="pre">...</span></code> translates to <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">with</span> <span class="pre">x</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>. This is an abbreviation:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w">  </span><span class="n">ary</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">syntax</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="o">.</span><span class="p">}</span><span class="ow">=</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">ary</span><span class="p">}</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">namespace</span><span class="w"> </span><span class="n">unpack</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">ary</span><span class="p">}</span><span class="w">       </span><span class="o">//</span><span class="w"> </span><span class="n">plan</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="n">symbol</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="exports-and-internal-symbols">
<h2>Exports and internal symbols<a class="headerlink" href="#exports-and-internal-symbols" title="Permalink to this heading"></a></h2>
<p>Module exports can similarly be limited:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">C</span><span class="w"> </span><span class="p">(</span><span class="nf">a</span><span class="p">)</span><span class="w"></span>

<span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="w"></span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;y&quot;</span><span class="w"></span>
<span class="o">#</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">accessible</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">termed</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="s">&quot;internal&quot;</span><span class="w"> </span><span class="n">symbol</span><span class="w"></span>
</pre></div>
</div>
<p>Sometimes it is necessary to access internal symbols, so they are actually still accessible with <code class="docutils literal notranslate"><span class="pre">C.__internal.b</span></code> .</p>
<p>You can also limit the exports to exclude named clauses of reduction rules (by default all reduction rules are exported regardless of limiting exported symbols):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">C</span><span class="w"> </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span><span class="w"> </span><span class="n">hiding</span><span class="w"> </span><span class="n">c2</span><span class="w"></span>

<span class="nf">symbol</span><span class="w"> </span><span class="n">f</span><span class="w"></span>

<span class="nf">clause</span><span class="w"> </span><span class="n">c1</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>

<span class="nf">clause</span><span class="w"> </span><span class="n">c2</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="o">#</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">reduce</span><span class="w"> </span><span class="n">outside</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="kr">module</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="parameters">
<h2>Parameters<a class="headerlink" href="#parameters" title="Permalink to this heading"></a></h2>
<p>Modules also take parameters, passed implicitly; every undefined identifier becomes a parameter. In a working program these parameters will mostly be other modules, but macro definitions can also be passed in. Undefined values in a declaration will be part of that declaration’s parameters rather than the module’s. Technically, what we have been talking are really module definitions rather than modules, i.e. they are functions producing modules. A fully instantiated module doesn’t take any parameters and is simply a record.</p>
</section>
<section id="linking">
<h2>Linking<a class="headerlink" href="#linking" title="Permalink to this heading"></a></h2>
<p>Linking all of these module definitions together is done at the top level. The list of modules is defined in a project file, explicitly or as an enumeration of the file tree. Then they are all tied into one big recursive knot of overloaded definitions. But this process is actually defined by the project file; the project file acts like a build script and can do arbitrarily complex linking things if necessary. There’s a set of convenient functions that cover common cases.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">project</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;src/**.sct&quot;</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<section id="imports">
<h3>Imports<a class="headerlink" href="#imports" title="Permalink to this heading"></a></h3>
<p>The primitive underlying the project file is the import; this reads a file path and parses it into an implicit function. The file path can be relative and resolved relative to the path of the importing file. For example, if the file dir1/dir2/foo contains import “bar”, the compiler will look for dir1/dir2/bar, and import “../bar” would be dir1/bar.</p>
<p>Direct importing is easier to understand conceptually but the recursive fixed point is more powerful and supports libraries better. Direct importing allows IDE tools to statically analyze files without configuring the project file location.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">}</span> <span class="o">=</span> <span class="kn">import</span> <span class="s2">&quot;Alphabet&quot;</span>          <span class="c1"># import a, b, c from Alphabet</span>
<span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">d</span><span class="p">}</span> <span class="o">=</span> <span class="kn">import</span> <span class="s2">&quot;Alphabet&quot;</span>  <span class="c1"># import a, b, c from Alphabet, import ‘c’ as ‘d’</span>

<span class="p">(</span> <span class="o">.</span> <span class="p">)</span> <span class="o">=</span> <span class="kn">import</span> <span class="s2">&quot;Alphabet&quot;</span>     <span class="c1"># import * from Alphabet</span>
<span class="p">{</span> <span class="o">.</span> <span class="p">}</span> <span class="o">=</span> <span class="kn">import</span> <span class="s2">&quot;Alphabet&quot;</span> <span class="c1"># import * from Alphabet</span>

<span class="n">Alphabet</span> <span class="o">=</span> <span class="kn">import</span> <span class="s2">&quot;Alphabet&quot;</span> <span class="c1"># import Alphabet, Alphabet.X</span>
</pre></div>
</div>
</section>
</section>
<section id="overrides">
<h2>Overrides<a class="headerlink" href="#overrides" title="Permalink to this heading"></a></h2>
<p>By default, methods are scoped to their module. Every definition <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">=</span> <span class="pre">a</span></code> binds the identifier <code class="docutils literal notranslate"><span class="pre">Module.foo</span></code>, and each module creates a new identifier. The <code class="docutils literal notranslate"><span class="pre">override</span></code> statement prevents creating a new identifier, so that instead a base identifer can be extended.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># module 1</span>
<span class="n">foo</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># module 2</span>
<span class="kn">import</span> <span class="mi">1</span>
<span class="n">override</span> <span class="n">foo</span>
<span class="n">foo</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c1"># module 3</span>
<span class="kn">import</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">foo</span> <span class="mi">1</span> <span class="c1"># 1</span>
<span class="n">foo</span> <span class="mi">2</span> <span class="c1"># 3</span>
</pre></div>
</div>
<p>If the override statement was not in module 2, then using <code class="docutils literal notranslate"><span class="pre">foo</span></code> in module 3 would result in an ambiguous name resolution error.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Fexprs.html" class="btn btn-neutral float-left" title="Metaprogramming" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Dispatch.html" class="btn btn-neutral float-right" title="Dispatch" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>