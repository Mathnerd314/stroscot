<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Memory &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Logic" href="Logic.html" />
    <link rel="prev" title="Dispatch" href="Dispatch.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fexprs.html">Metaprogramming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Memory</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#value-representation">Value representation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pointers">Pointers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#concept">Concept</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operations">Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#optimizing-access">Optimizing access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#destructors">Destructors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#finalizers">Finalizers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pointer-conversion">Pointer conversion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#types">Types</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Commentary/index.html">Commentary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Language Reference</a> &raquo;</li>
      <li>Memory</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Reference/Memory.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="memory">
<h1>Memory<a class="headerlink" href="#memory" title="Permalink to this headline"></a></h1>
<p>There are two main models of memory. The concrete model models memory as a an integer-indexed array of 2^32 or 2^64 words. The symbolic model models memory as an associative array from symbols (potentially infinite in number) to “cells”, arrays of words of various lengths. In Stroscot these models correspond to pointers and references respectively. Combinations of these can be made, for example the “quasi-concrete model” which uses a data type that starts out containing a reference, implements various arithmetic operations symbolically, but switches to a pointer once an integer address is requested. <span id="id1">[<a class="reference internal" href="../zzreferences.html#id44" title="Jeehoon Kang, Chung-Kil Hur, William Mansky, Dmitri Garbuzov, Steve Zdancewic, and Viktor Vafeiadis. A formal C memory model supporting integer-pointer casts. In Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation, 326–335. Portland OR USA, June 2015. ACM. URL: https://dl.acm.org/doi/10.1145/2737924.2738005 (visited on 2021-06-14), doi:10.1145/2737924.2738005.">KHM+15</a>]</span></p>
<section id="value-representation">
<h2>Value representation<a class="headerlink" href="#value-representation" title="Permalink to this headline"></a></h2>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Bit</span> <span class="ow">=</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span>
<span class="kt">MaskedBit</span> <span class="ow">=</span> <span class="kt">Bit</span> <span class="o">|</span> <span class="kt">Masked</span>
<span class="kt">MaskedByte</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">7</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">MaskedBit</span>
<span class="kt">Cell</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">MaskedByte</span><span class="p">]</span>
<span class="kt">Object</span> <span class="ow">=</span> <span class="p">(</span><span class="n">cell</span> <span class="kt">:</span> <span class="kt">Cell</span><span class="p">,</span> <span class="n">unpack</span> <span class="kt">:</span> <span class="kt">Cell</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">pack</span> <span class="kt">:</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Object</span>
</pre></div>
</div>
<p>The memory representation of a value is defined by an overloaded <code class="docutils literal notranslate"><span class="pre">pack</span></code> function. The result of pack is an <em>object</em>, a tuple containing a cell and a matched unpack function to read the value back from the cell. Usually <code class="docutils literal notranslate"><span class="pre">unpack</span></code> will be a function pointer and Stroscot can use constant propagation to optimize it out of the object.</p>
<p>Cells are contiguous arrays of bytes. They can be reallocated and copied freely by the runtime. Cells are garbage collected, deallocated automatically when the cell is no longer used/accessible. Cells have a mask of unused bits to allow making holes. For example <code class="docutils literal notranslate"><span class="pre">010</span></code> masked with <code class="docutils literal notranslate"><span class="pre">101</span></code> produces <code class="docutils literal notranslate"><span class="pre">0*0</span></code>, moving 3 bits. The runtime is free to use the center bit for garbage collection purposes.</p>
<p><code class="docutils literal notranslate"><span class="pre">pack</span></code> must always succeed. <code class="docutils literal notranslate"><span class="pre">unpack</span></code> can fail or succeed on data not produced by <code class="docutils literal notranslate"><span class="pre">pack</span></code>, the behavior is irrelevant. <code class="docutils literal notranslate"><span class="pre">unpack</span></code> should not depend on the value of any bits masked by <code class="docutils literal notranslate"><span class="pre">pack</span></code>.</p>
<p>For correctness we require <code class="docutils literal notranslate"><span class="pre">unpack</span> <span class="pre">(pack</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">x</span></code>. Using this constraint we can derive <code class="docutils literal notranslate"><span class="pre">unpack</span></code> from <code class="docutils literal notranslate"><span class="pre">pack</span></code>, or vice-versa, if the format isn’t too complicated.</p>
</section>
<section id="pointers">
<h2>Pointers<a class="headerlink" href="#pointers" title="Permalink to this headline"></a></h2>
<p>Pointers provide a low-level API for interfacing with the OS or other languages (mainly C), an unavoidable task in most programs. To use them you just have to import the module, there is no unsafe block.</p>
<section id="concept">
<h3>Concept<a class="headerlink" href="#concept" title="Permalink to this headline"></a></h3>
<p>A pointer is a numeric index into a global mutable array, <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">Word</span> <span class="pre">(BitIdx</span> <span class="pre">-&gt;</span> <span class="pre">Status)</span></code>. The statuses allow storing metadata. The array is indexed at the bit level because that’s the granularity <a class="reference external" href="https://valgrind.org/docs/manual/mc-manual.html#mc-manual.machine">Valgrind’s Memcheck</a> uses, but most of the status will be the same for a byte or page. The status is <a href="#id3"><span class="problematic" id="id4">`an ADT &lt;https://github.com/Mathnerd314/stroscot/blob/master/src/model/MemoryStatus.hs`__</span></a> .</p>
</section>
<section id="operations">
<h3>Operations<a class="headerlink" href="#operations" title="Permalink to this headline"></a></h3>
<p>Various functions record different statuses for chunks of memory. Memory functions check the status of memory before operating (prevention of double free / access to undefined memory). Inaccessible memory cannot be read/written (prevention of use after free).</p>
<p>Most addresses will not be allocated (status Free/Unknown), hence the array is sparse in some sense. It is in fact possible to implement the typical <a class="reference external" href="https://developer.android.com/reference/android/util/SparseArray">sparse array operations</a>. There are functions to directly allocate memory at an address. Reading and writing are done directly in assembly. The list of currently mapped pages can be had from <code class="docutils literal notranslate"><span class="pre">/proc/self/maps</span></code> and <a class="reference external" href="https://reverseengineering.stackexchange.com/questions/8297/proc-self-maps-equivalent-on-windows/8299">VirtualQueryEx</a>, although this has to be filtered to remove pages reserved by the kernel and internal pages allocated by the runtime, and looks slow - it’s easier to wrap the allocation functions and maintain a separate list of user-level allocations. Clearing mappings, hashing memory, and indexing by mapped pages all work when restricted to the list of user pages.</p>
<p>It’s a little more complicated than simple sparsity because there are actually two pairs of operations, reserve/release to manage virtual address space and commit/decommit for backing pages.</p>
<p>In practice fixed-address allocation is never used and instead there are <code class="docutils literal notranslate"><span class="pre">mmap</span> <span class="pre">NULL</span></code> and <code class="docutils literal notranslate"><span class="pre">malloc</span></code> which allocate memory with system-chosen location. This means that the program behavior must be observationally equivalent no matter what addresses the system picks. The limitations on the system’s choice are that the allocation must be suitably aligned and disjoint from all unrevoked allocations. (The system can also return an out of memory error, but this doesn’t have to result in equivalent behavior so it can be ignored.)</p>
<p>There is also the C library API alloc/realloc/free for non-page-sized allocations.</p>
<p>The memory management system uses the pointer API internally, just with a special tag to avoid overlapping with user data.</p>
</section>
<section id="optimizing-access">
<h3>Optimizing access<a class="headerlink" href="#optimizing-access" title="Permalink to this headline"></a></h3>
<p>Eliminating pointer reads amounts to tracking down the matching pointer write, which can be accomplished by tracing control flow. Eliminating pointer writes requires proving that the address is never read before deallocation, which requires a global analysis of pointer reads. They’re both a bit tricky as they have to make assumptions about what pointers foreign code will use and analyze the possible values a dereference may take. But, should be possible.</p>
</section>
</section>
<section id="destructors">
<span id="id2"></span><h2>Destructors<a class="headerlink" href="#destructors" title="Permalink to this headline"></a></h2>
<p>Destructors allow the prompt freeing of allocated memory and resources like thread handles, file handles, and sockets.  A destructor is a magic value created with the operation <code class="docutils literal notranslate"><span class="pre">newDestructor</span> <span class="pre">:</span> <span class="pre">Op</span> <span class="pre">Destructor</span></code>. It supports equality, hashing, and an operation <code class="docutils literal notranslate"><span class="pre">lastUse</span> <span class="pre">:</span> <span class="pre">Destructor</span> <span class="pre">-&gt;</span> <span class="pre">Op</span> <span class="pre">Bool</span></code>. All calls to <code class="docutils literal notranslate"><span class="pre">lastUse</span></code> but the last in the program return false; the last <code class="docutils literal notranslate"><span class="pre">lastUse</span></code> returns true. There is also <code class="docutils literal notranslate"><span class="pre">useForever</span> <span class="pre">:</span> <span class="pre">Destructor</span> <span class="pre">-&gt;</span> <span class="pre">Command</span></code> which ensures that <code class="docutils literal notranslate"><span class="pre">lastUse</span></code> always returns false.</p>
<p>Stroscot checks a leak property for each destructor <code class="docutils literal notranslate"><span class="pre">x</span></code> that exactly one of the following holds:
* <code class="docutils literal notranslate"><span class="pre">lastUse</span> <span class="pre">x</span></code> is called infinitely often, returning false each time
* <code class="docutils literal notranslate"><span class="pre">lastUse</span> <span class="pre">x</span></code> returns true and is never called thereafter
* <code class="docutils literal notranslate"><span class="pre">useForever</span> <span class="pre">x</span></code> is called</p>
<p>If the control flow does not allow this leak property to hold, Stroscot will error.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">reduce</span> <span class="p">(</span><span class="kt">NewDestructor</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">f</span> <span class="ow">=</span> <span class="n">freshSymbol</span>
  <span class="n">reduce</span> <span class="p">(</span><span class="n">c</span> <span class="n">f</span><span class="p">)</span>
<span class="nf">reduce</span> <span class="p">(</span><span class="kt">Use</span> <span class="n">f</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">will_call</span> <span class="p">(</span><span class="kt">Use</span> <span class="n">f</span><span class="p">)</span> <span class="n">c</span>
    <span class="n">reduce</span> <span class="p">(</span><span class="n">c</span> <span class="kt">False</span><span class="p">)</span>
  <span class="kr">else</span> <span class="kr">if</span> <span class="o">!</span><span class="p">(</span><span class="n">could_call</span> <span class="p">(</span><span class="kt">Use</span> <span class="n">f</span><span class="p">)</span> <span class="n">c</span><span class="p">)</span>
    <span class="n">reduce</span> <span class="p">(</span><span class="n">c</span> <span class="kt">True</span><span class="p">)</span>
  <span class="kr">else</span>
    <span class="ne">error</span>
</pre></div>
</div>
<p>TODO: can it be shared across threads</p>
</section>
<section id="finalizers">
<h2>Finalizers<a class="headerlink" href="#finalizers" title="Permalink to this headline"></a></h2>
<p>Finalizers are a more relaxed approach to resource management. It is a magic value created with the one-argument function <code class="docutils literal notranslate"><span class="pre">newFinalizer</span> <span class="pre">:</span> <span class="pre">(free</span> <span class="pre">:</span> <span class="pre">Command)</span> <span class="pre">-&gt;</span> <span class="pre">Op</span> <span class="pre">Finalizer</span></code>. It supports equality, hashing, and a command <code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">:</span> <span class="pre">Finalizer</span> <span class="pre">-&gt;</span> <span class="pre">Command</span></code>.</p>
<p>The semantics is that <code class="docutils literal notranslate"><span class="pre">free</span></code> will be called as soon as it is known that <code class="docutils literal notranslate"><span class="pre">use</span></code> will no longer be called. The general transformation:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">reduce</span> <span class="p">(</span><span class="kt">NewFinalizer</span> <span class="n">free</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">f</span> <span class="ow">=</span> <span class="n">freshSymbol</span>
  <span class="n">transform</span> <span class="p">(</span><span class="n">c</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span><span class="n">free</span><span class="p">,</span><span class="n">f</span><span class="p">}</span>

<span class="nf">transform</span> <span class="kt">:</span> <span class="kt">Task</span> <span class="ow">-&gt;</span> <span class="kt">Task</span>
<span class="nf">transform</span> <span class="n">c</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">could_call</span> <span class="p">(</span><span class="kt">Use</span> <span class="n">f</span><span class="p">)</span> <span class="n">c</span>
    <span class="kr">let</span> <span class="n">c&#39;</span> <span class="ow">=</span> <span class="n">continuation</span> <span class="n">c</span>
    <span class="n">c</span> <span class="p">{</span> <span class="n">continuation</span> <span class="ow">=</span> <span class="n">transform</span> <span class="n">c&#39;</span> <span class="p">}</span>
  <span class="kr">else</span>
    <span class="n">reduce</span> <span class="p">(</span><span class="n">free</span> <span class="p">{</span><span class="n">continuation</span> <span class="ow">=</span> <span class="n">c</span><span class="p">})</span>
</pre></div>
</div>
<p>Destructors are very similar to finalizers. In fact we can use them to implement <em>prompt</em> finalizers, that guarantee <code class="docutils literal notranslate"><span class="pre">free</span></code> is called immediately after some <code class="docutils literal notranslate"><span class="pre">use</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">newPromptFinalizer</span> <span class="n">free</span> <span class="ow">=</span>
  <span class="n">d</span> <span class="ow">=</span> <span class="n">newDestructor</span>
  <span class="kr">let</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">PromptFinalizer</span> <span class="n">free</span> <span class="n">d</span>
  <span class="n">use</span> <span class="n">f</span>
  <span class="n">return</span> <span class="n">f</span>
<span class="nf">use</span> <span class="p">(</span><span class="kt">PromptFinalizer</span> <span class="n">free</span> <span class="n">d</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">l</span> <span class="ow">=</span> <span class="n">lastUse</span> <span class="n">d</span>
  <span class="kr">if</span> <span class="n">l</span>
    <span class="n">free</span>
</pre></div>
</div>
<p>However, a prompt finalizer would give an error on programs such as the following:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">free</span> <span class="ow">=</span> <span class="n">print</span> <span class="s">&quot;Freed.&quot;</span>
<span class="nf">f</span> <span class="ow">=</span> <span class="n">newFinalizer</span> <span class="n">free</span>
<span class="nf">use</span> <span class="n">f</span>
<span class="nf">b</span> <span class="ow">=</span> <span class="n">input</span> <span class="kt">Bool</span>
<span class="kr">if</span> <span class="n">b</span>
  <span class="n">print</span> <span class="s">&quot;A&quot;</span>
  <span class="n">use</span> <span class="n">f</span>
<span class="kr">else</span>
  <span class="n">print</span> <span class="s">&quot;B&quot;</span>
</pre></div>
</div>
<p>Instead of erroring, Stroscot will insert a call to <code class="docutils literal notranslate"><span class="pre">free</span></code> before the <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;B&quot;</span></code> statement in the else branch.</p>
<p>Finalizers are as prompt as prompt finalizers, on the programs where prompt finalizers do not error. With this guarantee, finalizers subsume manual memory management. Taking a program written with standard <code class="docutils literal notranslate"><span class="pre">malloc/free</span></code>, we can change it:
* <code class="docutils literal notranslate"><span class="pre">malloc</span></code> is wrapped to return a tuple with <code class="docutils literal notranslate"><span class="pre">newPromptFinalizer</span></code>, <code class="docutils literal notranslate"><span class="pre">free</span></code> is replaced with <code class="docutils literal notranslate"><span class="pre">use</span></code>
* every operation is modified to call <code class="docutils literal notranslate"><span class="pre">use</span></code>
* the prompt finalizer is replaced with a finalizer</p>
<p>The finalizer program compiles identically to the original, but is more robust to changes.</p>
<p>Finalizers run in the order of creation, first created first.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline"></a></h2>
<p>An reference is a symbolic index into a global associative array of objects, <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">Reference</span> <span class="pre">Object</span></code>. Operations on references are stateful and include allocation, reading, and perhaps writing. But references can be compared for equality and hashed to an integer. References can be packed to a 64-bit word and unpacked to the identical reference. The value of the word is internal to the memory system but can be assumed to be in pointer format.</p>
<section id="pointer-conversion">
<h3>Pointer conversion<a class="headerlink" href="#pointer-conversion" title="Permalink to this headline"></a></h3>
<p>A reference has a pointer associated with it, but GC can move the reference and change the address. So operations using the pointer are wrapped, <code class="docutils literal notranslate"><span class="pre">withPointer</span> <span class="pre">ref</span> <span class="pre">{</span> <span class="pre">\address</span> <span class="pre">-&gt;</span> <span class="pre">doWhatever</span> <span class="pre">address</span> <span class="pre">}</span></code>, locking the object in place for the duration of the operation. The alignment of the pointer can be specified when the reference is constructed, <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x</span> <span class="pre">{</span> <span class="pre">alignment</span> <span class="pre">=</span> <span class="pre">...</span> <span class="pre">}</span></code>. The default is no alignment, to allow packing data compactly, although the MMS may use aligned locations for speed.</p>
</section>
<section id="types">
<h3>Types<a class="headerlink" href="#types" title="Permalink to this headline"></a></h3>
<section id="immutable">
<h4>Immutable<a class="headerlink" href="#immutable" title="Permalink to this headline"></a></h4>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span> <span class="ow">=</span> <span class="n">imm</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="nf">read</span> <span class="n">x</span> <span class="o">#</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>

<span class="o">#</span> <span class="kr">if</span> <span class="n">the</span> <span class="n">value</span> <span class="n">is</span> <span class="n">a</span> <span class="n">list</span>
<span class="nf">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">#</span> <span class="mi">1</span>
</pre></div>
</div>
<p>An immutable reference is fixed once created, i.e. it cannot be written. It can be freely shared across threads.</p>
<p>Reading uses the memory in-place. But threads might create multiple copies of the data.</p>
</section>
<section id="variable">
<h4>Variable<a class="headerlink" href="#variable" title="Permalink to this headline"></a></h4>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span> <span class="ow">=</span> <span class="n">mut</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="nf">x</span> <span class="kt">:=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="nf">read</span> <span class="n">x</span> <span class="o">#</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>

<span class="o">#</span> <span class="kr">if</span> <span class="n">the</span> <span class="n">value</span> <span class="n">is</span> <span class="n">a</span> <span class="n">list</span>
<span class="nf">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="kt">:=</span> <span class="mi">3</span>
<span class="nf">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">#</span> <span class="mi">3</span>
</pre></div>
</div>
<p>A variable is a thread-local reference that can store arbitrary packable values. Thread local means that reading/writing from a different thread than the owning thread returns an error. You can get/set the owner with <code class="docutils literal notranslate"><span class="pre">getOwner/setOwner</span></code>. Initially the thread that allocates the variable owns it.</p>
<p>Reading elides the copy if the reference is dead after the read, otherwise copies.</p>
</section>
<section id="shared-memory">
<h4>Shared memory<a class="headerlink" href="#shared-memory" title="Permalink to this headline"></a></h4>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span> <span class="ow">=</span> <span class="n">mem</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>A reference to shared memory is a fixed-size array of contiguous bits. The size is restricted to a multiple of bytes or words depending on the ISA. The operations are defined by the CPU; you can use fences, atomics, whatever is in the ISA.</p>
<p>Reading always copies (into a register, usually).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="kt">:=</span> <span class="mi">3</span>
<span class="nf">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">#</span> <span class="mi">3</span> <span class="n">or</span> <span class="n">the</span> <span class="n">value</span> <span class="n">from</span> <span class="n">some</span> <span class="n">other</span> <span class="n">thread</span>
</pre></div>
</div>
<p>Each word is its own reference; this uses the word sized load-store operations of the ISA.</p>
</section>
<section id="thread-local-storage">
<h4>Thread-local storage<a class="headerlink" href="#thread-local-storage" title="Permalink to this headline"></a></h4>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span> <span class="ow">=</span> <span class="n">tls</span> <span class="mi">0</span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://docs.microsoft.com/en-us/windows/win32/procthread/using-thread-local-storage">https://docs.microsoft.com/en-us/windows/win32/procthread/using-thread-local-storage</a></p>
<p>Essentially it’s a shared memory variable that stores <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">ThreadId</span> <span class="pre">Word</span></code>, and each thread only sees/writes its own id. So in that sense it behaves similarly to a variable, but OTOH all threads can use it.</p>
</section>
<section id="symbol">
<h4>Symbol<a class="headerlink" href="#symbol" title="Permalink to this headline"></a></h4>
<p>A symbol can be thought of as a type of reference. It supports neither reading nor writing, but has an identity.</p>
</section>
<section id="wrapper">
<h4>Wrapper<a class="headerlink" href="#wrapper" title="Permalink to this headline"></a></h4>
<p>A wrapper reference is a custom implementation of the basic allocate/get/set operations. There’s no special support needed in the language for this beyond overloading.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span> <span class="kt">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">read</span> <span class="n">x</span> <span class="o">#</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>For example, there is a wrapper API around shared memory to allow load/store of non-word values; it packs and writes or reads and unpacks, erroring if the value doesn’t fit in the array. Hence a 1-word shared memory reference can be used like a variable containing a word.</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Dispatch.html" class="btn btn-neutral float-left" title="Dispatch" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Logic.html" class="btn btn-neutral float-right" title="Logic" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2020 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>