<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Memory &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Build system" href="BuildSystem.html" />
    <link rel="prev" title="Dispatch" href="Dispatch.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Values.html">Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fexprs.html">Metaprogramming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Memory</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#value-representation">Value representation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pointers">Pointers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#concept">Concept</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operations">Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#optimizing-access">Optimizing access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#finalizers">Finalizers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#freed-on-exit">Freed on exit</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pointer-conversion">Pointer conversion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#types">Types</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Ambiguous identifier</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#automatic-error-propagation">Automatic error propagation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#bad-indentation">Bad indentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#shadowing-in-a-block">Shadowing in a block</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#confusuable-unicode">Confusuable Unicode</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#default-arguments">Default arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#deprecated-default-arguments">Deprecated default arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#equal-priority-clauses">Equal priority clauses</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#failed-assert">Failed assert</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#implicit-argument-not-passed">Implicit argument not passed</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#inapplicable-to-type">Inapplicable to type</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#invalid-utf8">Invalid UTF8</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#map-on-non-collection">Map on non-collection</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#meaningless-term">Meaningless term</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#missing-override">Missing override</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#shadowing-nested-block">Shadowing nested block</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#no-fixed-point">No fixed point</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#nondeterministic-use-of-concurrency">Nondeterministic use of concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#nondeterministic-use-of-exceptions">Nondeterministic use of exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#top-level-non-deteterministic-dispatch">Top-level non-deteterministic dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#applying-a-non-function">Applying a non-function</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#non-nfc">Non-NFC</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#non-syntactic-use-of-variadic-arguments">Non-syntactic use of variadic arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#too-many-arguments">Too many arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#typos-in-variable-name">Typos in variable name</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#unhandled-exception">Unhandled exception</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#unreachable-case">Unreachable case</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#unreducible-expression">Unreducible expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#unused-argument">Unused argument</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#unused-import">Unused import</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#unused-result">Unused result</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html#unused-definition">Unused definition</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Commentary/index.html">Commentary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Language Reference</a></li>
      <li class="breadcrumb-item active">Memory</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Reference/Memory.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="memory">
<h1>Memory<a class="headerlink" href="#memory" title="Permalink to this heading">ÔÉÅ</a></h1>
<p>There are two main models of memory. The concrete model models memory as a an integer-indexed array of 2^32 or 2^64 words. The symbolic model models memory as an associative array from symbols (potentially infinite in number) to ‚Äúcells‚Äù, arrays of words of various lengths. In Stroscot these models correspond to pointers and references respectively. Combinations of these can be made, for example the ‚Äúquasi-concrete model‚Äù which uses a data type that starts out containing a reference, implements various arithmetic operations symbolically, but switches to a pointer once an integer address is requested. <span id="id1">[<a class="reference internal" href="../zzreferences.html#id82" title="Jeehoon Kang, Chung-Kil Hur, William Mansky, Dmitri Garbuzov, Steve Zdancewic, and Viktor Vafeiadis. A formal C memory model supporting integer-pointer casts. In Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation, 326‚Äì335. Portland OR USA, June 2015. ACM. URL: https://dl.acm.org/doi/10.1145/2737924.2738005 (visited on 2021-06-14), doi:10.1145/2737924.2738005.">KHM+15</a>]</span></p>
<section id="value-representation">
<h2>Value representation<a class="headerlink" href="#value-representation" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>We don‚Äôt consider memory a scarce resource, hence pure values can be created and destroyed as needed by the RTS. But the RTS allows controlling the in-memory representation with user-written code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Bit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="kt">MaskedBit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bit</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Masked</span><span class="w"></span>
<span class="kt">Word</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="p">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bit</span><span class="w"></span>
<span class="kt">Addr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Word</span><span class="w"></span>
<span class="kt">MaskedWord</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="p">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">MaskedBit</span><span class="w"></span>
<span class="kt">Store</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="kt">Addr</span><span class="w"> </span><span class="kt">MaskedWord</span><span class="w"></span>
<span class="kt">Write</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Alloc</span><span class="w"> </span><span class="p">(</span><span class="kt">Size</span><span class="p">,</span><span class="kt">Align</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Addr</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Write</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Store</span><span class="w"></span>
<span class="kt">Read</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="kt">Addr</span><span class="w"> </span><span class="kt">Word</span><span class="w"></span>
<span class="kt">Unpack</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Addr</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Read</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="kt">Object</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Write</span><span class="p">,</span><span class="w"> </span><span class="kt">Unpack</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="nf">pack</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Object</span><span class="w"></span>
</pre></div>
</div>
<p>The memory representation of a value is defined by an overloaded <code class="docutils literal notranslate"><span class="pre">pack</span></code> function. The result of pack is an <em>object</em>, a tuple containing how to write the value to memory and a matched unpack function to read the value back. Usually <code class="docutils literal notranslate"><span class="pre">unpack</span></code> will be a function pointer and Stroscot can use constant propagation to optimize it out of the object. In the worst case <code class="docutils literal notranslate"><span class="pre">unpack</span></code> captures the full value and Stroscot will use its default representation for the closure.</p>
<p>The write procedure may use only fixed/constant addresses or no addresses, in which case the unpack function doesn‚Äôt get an address. Otherwise the first allocation is considered the base address and is passed to unpack.</p>
<p>Allocations are finite contiguous arrays of bytes. They can be reallocated and moved/copied freely by the runtime, in which case it will run <code class="docutils literal notranslate"><span class="pre">pack</span> <span class="pre">.</span> <span class="pre">unpack</span></code>. Allocations are garbage collected, deallocated automatically when the cell is no longer used/accessible. Allocations have a mask of unused bits to allow making holes. For example <code class="docutils literal notranslate"><span class="pre">010</span></code> masked with <code class="docutils literal notranslate"><span class="pre">101</span></code> produces <code class="docutils literal notranslate"><span class="pre">0*0</span></code>, spanning 3 bits but only using 2. The maask allows the runtime to use the masked bits for garbage collection purposes.</p>
<p><code class="docutils literal notranslate"><span class="pre">pack</span></code> must always succeed. <code class="docutils literal notranslate"><span class="pre">unpack</span></code> can fail or succeed on data not produced by <code class="docutils literal notranslate"><span class="pre">pack</span></code>, the behavior is irrelevant. <code class="docutils literal notranslate"><span class="pre">unpack</span></code> should not depend on the value of any bits masked by <code class="docutils literal notranslate"><span class="pre">pack</span></code>.</p>
<p>For correctness we require <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">let</span> <span class="pre">(w,u)</span> <span class="pre">=</span> <span class="pre">pack</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">munge</span> <span class="pre">u</span> <span class="pre">w</span></code> to be the identity function, for a suitable munging function. Using this constraint we can derive <code class="docutils literal notranslate"><span class="pre">unpack</span></code> from <code class="docutils literal notranslate"><span class="pre">pack</span></code>, or vice-versa, if the format isn‚Äôt too complicated.</p>
</section>
<section id="pointers">
<h2>Pointers<a class="headerlink" href="#pointers" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>Pointers provide a low-level API for interfacing with the OS or other languages (mainly C), an unavoidable task in most programs. To use them you have to import the <code class="docutils literal notranslate"><span class="pre">Pointer</span></code> module.</p>
<section id="concept">
<h3>Concept<a class="headerlink" href="#concept" title="Permalink to this heading">ÔÉÅ</a></h3>
<p>A pointer is a numeric index into a global mutable array, <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">Word</span> <span class="pre">(BitIdx</span> <span class="pre">-&gt;</span> <span class="pre">Status)</span></code>. The statuses allow storing metadata. The array is indexed at the bit level because that‚Äôs the granularity <a class="reference external" href="https://valgrind.org/docs/manual/mc-manual.html#mc-manual.machine">Valgrind‚Äôs Memcheck</a> uses, but most of the status will be the same for a byte or page. The status is <a class="reference external" href="https://github.com/Mathnerd314/stroscot/blob/master/src/model/MemoryStatus.hs">an ADT</a> .</p>
</section>
<section id="operations">
<h3>Operations<a class="headerlink" href="#operations" title="Permalink to this heading">ÔÉÅ</a></h3>
<p>Various functions record different statuses for chunks of memory. Memory functions check the status of memory before operating, hence preventing common errrors like double free, access to undefined memory, null pointer dereferencing, etc. Similarly inaccessible memory cannot be read/written, preventing use after free.</p>
<p>Most addresses will not be allocated (status Free/Unknown), hence the array is sparse in some sense. It is in fact possible to implement the typical <a class="reference external" href="https://developer.android.com/reference/android/util/SparseArray">sparse array operations</a>. There are functions to directly allocate memory at an address. Reading and writing are done directly in assembly. The list of currently mapped pages can be had from <code class="docutils literal notranslate"><span class="pre">/proc/self/maps</span></code> and <a class="reference external" href="https://reverseengineering.stackexchange.com/questions/8297/proc-self-maps-equivalent-on-windows/8299">VirtualQueryEx</a>, although this has to be filtered to remove pages reserved by the kernel and internal pages allocated by the runtime, and looks slow - it‚Äôs easier to wrap the allocation functions and maintain a separate list of user-level allocations. Clearing mappings, hashing memory, and indexing by mapped pages all work when restricted to the list of user pages. It‚Äôs a little more complicated than simple sparsity because there are many different statuses and the operations overlap.</p>
<p>In practice fixed-address allocation is never used and instead there are <code class="docutils literal notranslate"><span class="pre">mmap</span> <span class="pre">NULL</span></code> and <code class="docutils literal notranslate"><span class="pre">malloc</span></code> which allocate memory with system-chosen location. This means that the program behavior must be observationally equivalent no matter what addresses the system picks. The limitations on the system‚Äôs choice are that the allocation must be suitably aligned and disjoint from all unrevoked allocations. (The system can also return an out of memory error, but this doesn‚Äôt have to result in equivalent behavior so it can be ignored.)</p>
<p>There is also the C library API alloc/realloc/free for non-page-sized allocations.</p>
<p>The memory management system uses the pointer API internally, just with a special status tag to avoid overlapping with user data.</p>
</section>
<section id="optimizing-access">
<h3>Optimizing access<a class="headerlink" href="#optimizing-access" title="Permalink to this heading">ÔÉÅ</a></h3>
<p>Eliminating pointer reads amounts to tracking down the matching pointer write, which can be accomplished by tracing control flow. Eliminating pointer writes requires proving that the address is never read before deallocation, which requires a global analysis of pointer reads. They‚Äôre both a bit tricky as they have to make assumptions about what pointers foreign code will use and analyze the possible values a dereference may take. But, should be possible.</p>
</section>
</section>
<section id="finalizers">
<span id="id2"></span><h2>Finalizers<a class="headerlink" href="#finalizers" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>Finalizers are a relaxed approach to prompt resource management. They allow the prompt freeing of allocated memory and resources like thread handles, file handles, and sockets, but do not require explicit marking of the free operation. A finalizer is a magic value created with the one-argument function <code class="docutils literal notranslate"><span class="pre">newFinalizer</span> <span class="pre">:</span> <span class="pre">(free</span> <span class="pre">:</span> <span class="pre">Command)</span> <span class="pre">-&gt;</span> <span class="pre">Op</span> <span class="pre">Finalizer</span></code>. It supports equality, hashing, and command <code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">:</span> <span class="pre">Finalizer</span> <span class="pre">-&gt;</span> <span class="pre">Command</span></code> and <code class="docutils literal notranslate"><span class="pre">useForever</span> <span class="pre">:</span> <span class="pre">Finalizer</span> <span class="pre">-&gt;</span> <span class="pre">Op</span> <span class="pre">Command</span></code>.</p>
<p>The semantics is that <code class="docutils literal notranslate"><span class="pre">free</span></code> will be called as soon as it is known that <code class="docutils literal notranslate"><span class="pre">use</span></code> and <code class="docutils literal notranslate"><span class="pre">useForever</span></code> will not be called. Calling <code class="docutils literal notranslate"><span class="pre">use</span></code> delays finalization until after the <code class="docutils literal notranslate"><span class="pre">use</span></code>, and <code class="docutils literal notranslate"><span class="pre">useForever</span></code> cancels the finalizer and returns the free operation. The general transformation:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">reduce</span><span class="w"> </span><span class="p">(</span><span class="kt">NewFinalizer</span><span class="w"> </span><span class="n">free</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">freshSymbol</span><span class="w"></span>
<span class="w">  </span><span class="n">transform</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="n">free</span><span class="p">,</span><span class="n">f</span><span class="p">}</span><span class="w"></span>
<span class="nf">reduce</span><span class="w"> </span><span class="p">(</span><span class="kt">Use</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="nf">reduce</span><span class="w"> </span><span class="p">(</span><span class="kt">UseForever</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">free</span><span class="w"></span>

<span class="nf">transform</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Task</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Task</span><span class="w"></span>
<span class="nf">transform</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="n">will_call</span><span class="w"> </span><span class="p">(</span><span class="kt">UseForever</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="w">    </span><span class="n">reduce</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="w">  </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">will_call</span><span class="w"> </span><span class="p">(</span><span class="kt">Use</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">c&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">continuation</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="w">    </span><span class="n">reduce</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">continuation</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">transform</span><span class="w"> </span><span class="n">c&#39;</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">  </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">could_call</span><span class="w"> </span><span class="p">(</span><span class="kt">Use</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">could_call</span><span class="w"> </span><span class="p">(</span><span class="kt">UseForever</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">reduce</span><span class="w"> </span><span class="p">(</span><span class="n">free</span><span class="w"> </span><span class="p">{</span><span class="n">continuation</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">c</span><span class="p">})</span><span class="w"></span>
<span class="w">  </span><span class="kr">else</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">could_call</span><span class="w"> </span><span class="p">(</span><span class="kt">Use</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">could_call</span><span class="w"> </span><span class="p">(</span><span class="kt">UseForever</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Delaying finalizer due to conditional usage&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">c&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">continuation</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="w">    </span><span class="n">reduce</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">continuation</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">transform</span><span class="w"> </span><span class="n">c&#39;</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
</pre></div>
</div>
<p>The info can be an error if prompt memory management is desired. The situation happens when freeing depends on input data:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">af</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"></span>
<span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newFinalizer</span><span class="w"> </span><span class="n">af</span><span class="w"></span>
<span class="kr">if</span><span class="w"> </span><span class="n">randomBool</span><span class="w"> </span><span class="kr">then</span><span class="w"></span>
<span class="w">  </span><span class="n">exit</span><span class="w"></span>
<span class="kr">else</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="n">exit</span><span class="w"></span>
</pre></div>
</div>
<p>Because <code class="docutils literal notranslate"><span class="pre">a</span></code> is used in the else branch, it cannot be freed before the condition. It is freed as soon as it is known it will not be used, hence this program is equivalent to:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">af</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"></span>
<span class="kr">if</span><span class="w"> </span><span class="n">randomBool</span><span class="w"> </span><span class="kr">then</span><span class="w"></span>
<span class="w">  </span><span class="n">af</span><span class="w"></span>
<span class="w">  </span><span class="n">exit</span><span class="w"></span>
<span class="kr">else</span><span class="w"></span>
<span class="w">  </span><span class="n">af</span><span class="w"></span>
<span class="w">  </span><span class="n">exit</span><span class="w"></span>
</pre></div>
</div>
<p>If multiple finalizers simultaneously become able to call <code class="docutils literal notranslate"><span class="pre">free</span></code>, the finalizer instruction insertions are run in the order of creation, first created first. This means the free calls will execute most recent first.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newFinalizer</span><span class="w"> </span><span class="p">(</span><span class="n">print</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">)</span><span class="w"></span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newFinalizer</span><span class="w"> </span><span class="p">(</span><span class="n">print</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">)</span><span class="w"></span>

<span class="kr">if</span><span class="w"> </span><span class="n">randomBool</span><span class="w"> </span><span class="kr">then</span><span class="w"></span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="w"></span>
<span class="w">  </span><span class="n">exit</span><span class="w"></span>
<span class="kr">else</span><span class="w"></span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">  </span><span class="n">exit</span><span class="w"></span>

<span class="o">#</span><span class="w"> </span><span class="n">when</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">false</span><span class="kt">:</span><span class="w"> </span><span class="n">cab</span><span class="w"></span>
<span class="o">#</span><span class="w"> </span><span class="n">when</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">true</span><span class="kt">:</span><span class="w"> </span><span class="n">bac</span><span class="w"></span>
</pre></div>
</div>
<section id="freed-on-exit">
<h3>Freed on exit<a class="headerlink" href="#freed-on-exit" title="Permalink to this heading">ÔÉÅ</a></h3>
<p>Many resources are automatically freed by the OS on exit: memory, file handles, etc. In this circumstance  <code class="docutils literal notranslate"><span class="pre">useForever</span></code> can mark the resource as not needing finalization. As an optimization you can call it on every allocated resource once you are on the termination path and know that no further resources will be allocated, or that there are sufficient spare resources that any further allocation can be satisfied without deallocation. But prompt deallocation is the better policy.</p>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>An reference is a symbolic index into a global associative array of objects, <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">Reference</span> <span class="pre">Object</span></code>. Operations on references are stateful and include allocation, reading, and perhaps writing. But references can be compared for equality and hashed to an integer. Reference values can be packed to a 64-bit word and unpacked to the identical reference. The value of the word is internal to the memory system but can be assumed to be in pointer format.</p>
<section id="pointer-conversion">
<h3>Pointer conversion<a class="headerlink" href="#pointer-conversion" title="Permalink to this heading">ÔÉÅ</a></h3>
<p>A reference has at least one pointer associated with it. There can be multiple copies of the data hence multiple pointers. GC can move/copy the reference so the set of pointers varies over time.</p>
<p>Often operations are simpler with pointers, so you can pin the object to a pointer, <code class="docutils literal notranslate"><span class="pre">(address,</span> <span class="pre">unpinner)</span> <span class="pre">=</span> <span class="pre">getPointer</span> <span class="pre">ref</span></code>. <code class="docutils literal notranslate"><span class="pre">unpinner</span></code> is a finalizer that unpins the object after you are finished with the pointer. The alignment of the pointer can be specified when the reference is constructed, <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x</span> <span class="pre">{</span> <span class="pre">alignment</span> <span class="pre">=</span> <span class="pre">...</span> <span class="pre">}</span></code>. The default is no alignment, to allow packing data compactly, although of course the location may be aligned anyway.</p>
</section>
<section id="types">
<h3>Types<a class="headerlink" href="#types" title="Permalink to this heading">ÔÉÅ</a></h3>
<section id="immutable">
<h4>Immutable<a class="headerlink" href="#immutable" title="Permalink to this heading">ÔÉÅ</a></h4>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">imm</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="nf">read</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>

<span class="o">#</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">list</span><span class="w"></span>
<span class="nf">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>The contents of an immutable reference are fixed once created, i.e. an immutable reference cannot be written. It can be freely shared across threads.</p>
<p>Reading generally uses the memory in-place. It is almost a pure operation, except that the read operation prolongs the lifetime of the reference, hence for GC purposes the read operation must have a definite timestamp.</p>
</section>
<section id="variable">
<h4>Variable<a class="headerlink" href="#variable" title="Permalink to this heading">ÔÉÅ</a></h4>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mut</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="nf">x</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="nf">read</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>

<span class="o">#</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">list</span><span class="w"></span>
<span class="nf">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="nf">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
</pre></div>
</div>
<p>A variable is a thread-local reference that can store arbitrary packable values. Thread local means that reading/writing from a different thread than the owning thread returns an error. You can get/set the owner with <code class="docutils literal notranslate"><span class="pre">getOwner/setOwner</span></code>. Initially the thread that allocates the variable owns it.</p>
<p>Reading elides the copy if the reference is dead after the read, otherwise copies.</p>
</section>
<section id="shared-memory">
<h4>Shared memory<a class="headerlink" href="#shared-memory" title="Permalink to this heading">ÔÉÅ</a></h4>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>A reference to shared memory is a fixed-size array of contiguous bits. The size is restricted to a multiple of bytes or words depending on the ISA. The operations are defined by the CPU; you can use fences, atomics, whatever is in the ISA.</p>
<p>Reading always copies (into a register, usually).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="nf">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">thread</span><span class="w"></span>
</pre></div>
</div>
<p>Each word is its own reference; this uses the word sized load-store operations of the ISA.</p>
</section>
<section id="thread-local-storage">
<h4>Thread-local storage<a class="headerlink" href="#thread-local-storage" title="Permalink to this heading">ÔÉÅ</a></h4>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">tls</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://docs.microsoft.com/en-us/windows/win32/procthread/using-thread-local-storage">https://docs.microsoft.com/en-us/windows/win32/procthread/using-thread-local-storage</a></p>
<p>Essentially it‚Äôs a shared memory variable that stores <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">ThreadId</span> <span class="pre">Word</span></code>, and each thread only sees/writes its own id. So in that sense it behaves similarly to a variable, but OTOH all threads can use it.</p>
</section>
<section id="symbol">
<h4>Symbol<a class="headerlink" href="#symbol" title="Permalink to this heading">ÔÉÅ</a></h4>
<p>A symbol can be thought of as a type of reference. It supports neither reading nor writing, but has an identity.</p>
</section>
<section id="wrapper">
<h4>Wrapper<a class="headerlink" href="#wrapper" title="Permalink to this heading">ÔÉÅ</a></h4>
<p>A wrapper reference is a custom implementation of the read/modify operations. There‚Äôs no special support needed in the language for this beyond overloading <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">(Wrapper</span> <span class="pre">{read,modify})</span> <span class="pre">=</span> <span class="pre">read</span></code> and <code class="docutils literal notranslate"><span class="pre">(Wrapper</span> <span class="pre">{read,modify})</span> <span class="pre">:=</span> <span class="pre">newV</span> <span class="pre">=</span> <span class="pre">modify</span> <span class="pre">newV</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">inner</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mut</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="nf">cell_0</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">newWrapper</span><span class="w"></span>
<span class="w">  </span><span class="n">read</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">read</span><span class="w"> </span><span class="n">inner</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">modify</span><span class="w"> </span><span class="n">newV</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">    </span><span class="n">inner</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">inner</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newV</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="nf">read</span><span class="w"> </span><span class="n">cell_0</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
</pre></div>
</div>
<p>For example, there is a wrapper API around shared memory to allow load/store of non-word values; it packs and writes or reads and unpacks, erroring if the value doesn‚Äôt fit in the array. Hence a 1-word shared memory reference can be used like a variable containing a word.</p>
<p>The wrapper should satisfy <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">modify</span> <span class="pre">r</span> <span class="pre">x;</span> <span class="pre">read</span> <span class="pre">r</span> <span class="pre">}</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">modify</span> <span class="pre">r</span> <span class="pre">x;</span> <span class="pre">return</span> <span class="pre">x</span> <span class="pre">}</span></code>.</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Dispatch.html" class="btn btn-neutral float-left" title="Dispatch" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="BuildSystem.html" class="btn btn-neutral float-right" title="Build system" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>