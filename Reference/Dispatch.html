<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dispatch &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=7f41d439"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Memory" href="Memory.html" />
    <link rel="prev" title="Modules" href="Modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Values.html">Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fexprs.html">Metaprogramming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Dispatch</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#formal-definition">Formal definition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conditions">Conditions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#priorities">Priorities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#next-method">Next method</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-methods">List methods</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Memory.html">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Commentary/index.html">Commentary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Language Reference</a></li>
      <li class="breadcrumb-item active">Dispatch</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Reference/Dispatch.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="dispatch">
<h1>Dispatch<a class="headerlink" href="#dispatch" title="Link to this heading"></a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<p>Stroscot is based on a term rewriting formalism and supports higher order terms, pattern matching, and predicate dispatch (conditional rewriting). In general rules are not ordered - they overlap and run in parallel. If multiple rules match, all cases are tried nondeterministically and run. It is required that for each possibility the program either throws an exception or produces the same output.</p>
<p>Local functions are applied in the same way as global ones, i.e., the argument patterns of each rule are matched against the actual function arguments nondeterministically and optimal reduction is performed.</p>
<p>If none of the rules match then the term does not reduce (it becomes a normal form) - to raise an exception a catch-all clause must be defined.</p>
</section>
<section id="formal-definition">
<h2>Formal definition<a class="headerlink" href="#formal-definition" title="Link to this heading"></a></h2>
<p>The substitution calculus consists of:</p>
<ul class="simple">
<li><p>A set A of preterms, defined to be the sequent trees of Stroscot’s core logic.</p></li>
<li><p>The binary relation <code class="docutils literal notranslate"><span class="pre">R1</span> <span class="pre">:</span> <span class="pre">A</span> <span class="pre">times</span> <span class="pre">A</span></code> of cut elimination (actually a function), forming an abstract rewriting system on the preterms.</p></li>
<li><p>A countably infinite subset <code class="docutils literal notranslate"><span class="pre">V</span></code> of preterms called variables, in particular applications of the Use rule.</p></li>
<li><p>A substitution operation <code class="docutils literal notranslate"><span class="pre">sθ</span></code> taking a preterm <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">:</span> <span class="pre">A</span></code> and a mapping <code class="docutils literal notranslate"><span class="pre">θ</span> <span class="pre">:</span> <span class="pre">V</span> <span class="pre">-&gt;</span> <span class="pre">A</span></code> and producing another preterm. A finite mapping which maps variables <code class="docutils literal notranslate"><span class="pre">xi</span></code> to preterms <code class="docutils literal notranslate"><span class="pre">ti</span></code> and leaves all other variables unchanged is written as <code class="docutils literal notranslate"><span class="pre">[x1</span> <span class="pre">:=</span> <span class="pre">t1,</span> <span class="pre">...,</span> <span class="pre">xn</span> <span class="pre">:=</span> <span class="pre">tn]</span></code>. The substitution should be a homomorphism on <code class="docutils literal notranslate"><span class="pre">A</span></code>, i.e. for each syntactic construct of <code class="docutils literal notranslate"><span class="pre">A</span></code> such as <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">a</span></code> (application) or <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> (abstraction) we should have <code class="docutils literal notranslate"><span class="pre">sθ</span> <span class="pre">=</span> <span class="pre">(fθ)</span> <span class="pre">(aθ)</span> <span class="pre">``</span> <span class="pre">or</span> <span class="pre">``sθ</span> <span class="pre">=</span> <span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">aθ</span></code>.</p></li>
</ul>
<p>Finite terms <code class="docutils literal notranslate"><span class="pre">T_f</span></code> are representatives of equivalence classes of preterms under equivalence <code class="docutils literal notranslate"><span class="pre">E</span> <span class="pre">=</span> <span class="pre">(R1</span> <span class="pre">union</span> <span class="pre">R1</span> <span class="pre">inverse)*</span></code> of the substitution calculus. A variable <code class="docutils literal notranslate"><span class="pre">x</span></code> is free in a term <code class="docutils literal notranslate"><span class="pre">t</span></code> if <code class="docutils literal notranslate"><span class="pre">t[x:=s]</span> <span class="pre">!=</span> <span class="pre">t</span></code> for some preterm <code class="docutils literal notranslate"><span class="pre">s</span></code>. A term with no free variables is called closed, otherwise open. A context is a term with a distinguished free variable <code class="docutils literal notranslate"><span class="pre">□</span></code> called the hole. The notation <code class="docutils literal notranslate"><span class="pre">C[x]</span></code> where <code class="docutils literal notranslate"><span class="pre">C</span></code> is a context means <code class="docutils literal notranslate"><span class="pre">C[□</span> <span class="pre">:=</span> <span class="pre">x]</span></code>.</p>
<p>The set of terms <code class="docutils literal notranslate"><span class="pre">T</span></code> includes both finite and infinite terms, and is defined as the <a class="reference external" href="https://en.wikipedia.org/wiki/Complete_metric_space#Completion">metric completion</a> of finite terms with a distance function <span class="math notranslate nohighlight">\(2^{-n}\)</span> if the n-th level of the terms is the first level where a difference appears and 0 if the terms are equal. As a convention the top level is level zero.</p>
<p>A rewriting system consists of a substitution calculus and a set of conditional rewrite rules <code class="docutils literal notranslate"><span class="pre">RL</span> <span class="pre">:</span> <span class="pre">T</span> <span class="pre">times</span> <span class="pre">P</span> <span class="pre">times</span> <span class="pre">T</span></code>, where <code class="docutils literal notranslate"><span class="pre">P</span></code> are predicates <code class="docutils literal notranslate"><span class="pre">(T</span> <span class="pre">times</span> <span class="pre">T)</span> <span class="pre">times</span> <span class="pre">T</span> <span class="pre">times</span> <span class="pre">(V</span> <span class="pre">-&gt;</span> <span class="pre">A)</span></code> depending on the rewrite relation, left hand side, and match substitution.</p>
<p>The single-step rewrite relation <code class="docutils literal notranslate"><span class="pre">R2</span> <span class="pre">:</span> <span class="pre">(T</span> <span class="pre">times</span> <span class="pre">T)</span> <span class="pre">-&gt;</span> <span class="pre">T</span> <span class="pre">times</span> <span class="pre">T</span></code> is defined as <code class="docutils literal notranslate"><span class="pre">\R</span> <span class="pre">-&gt;</span> <span class="pre">{</span> <span class="pre">(t,C[rθ])</span> <span class="pre">|</span> <span class="pre">C</span> <span class="pre">:</span> <span class="pre">context,</span> <span class="pre">θ</span> <span class="pre">:</span> <span class="pre">V</span> <span class="pre">-&gt;</span> <span class="pre">A,</span> <span class="pre">t</span> <span class="pre">E</span> <span class="pre">C[lθ],</span> <span class="pre">(R,t,θ)</span> <span class="pre">in</span> <span class="pre">p,</span> <span class="pre">(l,p,r)</span> <span class="pre">in</span> <span class="pre">RL</span> <span class="pre">}</span></code>. The reflexive transitive closure of reduction <code class="docutils literal notranslate"><span class="pre">R2*</span></code> is defined as, given <code class="docutils literal notranslate"><span class="pre">R</span></code>, the smallest set containing <code class="docutils literal notranslate"><span class="pre">R2</span></code> that is reflexively, transitively, and topologically closed.</p>
<p>We then condense the relation: an SCC is a set S of terms such that for all s in S and terms t, <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">R2*</span> <span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">R2*</span> <span class="pre">s</span></code> implies t in S. We define a new condensed reduction relation <code class="docutils literal notranslate"><span class="pre">R3</span></code> on terms, such that <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">R3</span> <span class="pre">y</span></code> given <code class="docutils literal notranslate"><span class="pre">R</span></code> iff, letting A be the SCC of x and B the SCC of y, exists a in A, b in B such that a R2* b, A neq B. <code class="docutils literal notranslate"><span class="pre">R3</span></code> is acyclic, since the condensed terms are maximal, and transitively but not reflexively closed.</p>
<p>The set of meaningless terms <code class="docutils literal notranslate"><span class="pre">U</span> <span class="pre">subset</span> <span class="pre">T</span></code> is defined w.r.t. <code class="docutils literal notranslate"><span class="pre">R3</span></code> given <code class="docutils literal notranslate"><span class="pre">R</span></code> to be the smallest set with the following properties:</p>
<ul class="simple">
<li><p>Contains all root-active terms. A term t is root-active if every reduct of t can be reduced to a term with a top-level redex.</p></li>
<li><p>Closure under reduction. If <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">∈</span> <span class="pre">U</span></code>, <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">→</span> <span class="pre">N</span></code> then <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">∈</span> <span class="pre">U</span></code>.</p></li>
<li><p>Closure under substitution. For all <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">∈</span> <span class="pre">U</span></code>, <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">/.</span> <span class="pre">σ</span> <span class="pre">∈</span> <span class="pre">U</span></code></p></li>
<li><p>Overlap. If a redex t overlaps a subterm, and this subterm is in U, then t in U.</p></li>
<li><p>Indiscernibility - the meaningfullness of a term does not depend on its meaningless subterms. For all M, N, if N can be obtained from M by replacing a set of pairwise disjoint subterms in U with other terms of U, then M ∈ U if and only if N ∈ U.</p></li>
<li><p>Topological closure</p></li>
</ul>
<p>We extend <code class="docutils literal notranslate"><span class="pre">R3</span></code> with reductions from meaningless terms to the <code class="docutils literal notranslate"><span class="pre">Meaningless</span></code> exception to obtain <code class="docutils literal notranslate"><span class="pre">R4</span></code> given <code class="docutils literal notranslate"><span class="pre">R</span></code>. This is our final relation <code class="docutils literal notranslate"><span class="pre">Rf</span></code>.</p>
<p>So far <code class="docutils literal notranslate"><span class="pre">R</span></code> been a parameter, so <code class="docutils literal notranslate"><span class="pre">Rf</span></code> is a function <code class="docutils literal notranslate"><span class="pre">(T</span> <span class="pre">times</span> <span class="pre">T)</span> <span class="pre">-&gt;</span> <span class="pre">T</span> <span class="pre">times</span> <span class="pre">T</span></code>. We take the “optimal prefixedpoint”, the intersection of the maximal prefixedpoints. I.e. we find the sets <code class="docutils literal notranslate"><span class="pre">Pre</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">R</span> <span class="pre">:</span> <span class="pre">R</span> <span class="pre">subseteq</span> <span class="pre">Rf(R)</span> <span class="pre">},</span> <span class="pre">PreMax</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">R</span> <span class="pre">in</span> <span class="pre">Pre</span> <span class="pre">:</span> <span class="pre">forall</span> <span class="pre">R'</span> <span class="pre">in</span> <span class="pre">Pre,</span> <span class="pre">R</span> <span class="pre">subseteq</span> <span class="pre">R'</span> <span class="pre">implies</span> <span class="pre">R=</span> <span class="pre">R'</span> <span class="pre">},</span> <span class="pre">R</span> <span class="pre">=</span> <span class="pre">intersection</span> <span class="pre">PreMax</span></code>. We warn on all the reductions in <code class="docutils literal notranslate"><span class="pre">Rf(R)</span> <span class="pre">\</span> <span class="pre">R</span></code> that are missing from <code class="docutils literal notranslate"><span class="pre">R</span></code> and make <code class="docutils literal notranslate"><span class="pre">R</span></code> not a fixed point of <code class="docutils literal notranslate"><span class="pre">Rf</span></code>.</p>
<p>Evaluation an expression <code class="docutils literal notranslate"><span class="pre">e</span></code> first computes its set of normal forms <code class="docutils literal notranslate"><span class="pre">NF(e)</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">e</span> <span class="pre">R</span> <span class="pre">x,</span> <span class="pre">not(exists</span> <span class="pre">y.</span> <span class="pre">x</span> <span class="pre">R</span> <span class="pre">y)</span> <span class="pre">}</span></code>. If there are any non-exception values in <code class="docutils literal notranslate"><span class="pre">NF(e)</span></code>, then the result is <code class="docutils literal notranslate"><span class="pre">{x</span> <span class="pre">in</span> <span class="pre">NF(e)</span> <span class="pre">|</span> <span class="pre">not(x</span> <span class="pre">:</span> <span class="pre">Exception)</span> <span class="pre">}</span></code>. Otherwise if there are one or more exceptions the compiler arbitrarily chooses an exception value. If the result of evaluation is a set with one element, that element is said to be the value of the expression.</p>
<p>It is an error if the top-level expression does not evaluate to a value.</p>
</section>
<section id="conditions">
<h2>Conditions<a class="headerlink" href="#conditions" title="Link to this heading"></a></h2>
<p>For the TRS we have defined a condition as a predicate, but syntactically it is more limited. I’m thinking these forms:</p>
<ul class="simple">
<li><p>a boolean guard <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">condexpr</span></code> - the predicate holds if the expression reduces to true and does not reduce to false.</p></li>
<li><p>a pattern guard <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">pat</span> <span class="pre">&lt;-</span> <span class="pre">exp</span></code> - the predicate holds if <code class="docutils literal notranslate"><span class="pre">exp</span></code> reduces to a form that is matched by <code class="docutils literal notranslate"><span class="pre">pat</span></code> and does not evaluate to a form not matching <code class="docutils literal notranslate"><span class="pre">pat</span></code>. A boolean guard is almost a pattern guard <code class="docutils literal notranslate"><span class="pre">True</span> <span class="pre">&lt;-</span> <span class="pre">g</span></code> but will match values like <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">amb</span> <span class="pre">true</span></code>.</p></li>
<li><p>a non-linear pattern like <code class="docutils literal notranslate"><span class="pre">[x,x]</span></code> - this is converted to a linear pattern like <code class="docutils literal notranslate"><span class="pre">[x,y]</span></code>, and the predicate holds if <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are in normal form and syntactically identical.</p></li>
</ul>
</section>
<section id="priorities">
<h2>Priorities<a class="headerlink" href="#priorities" title="Link to this heading"></a></h2>
<p>The way sequential matching expands is that there is a chain of priorities.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">clause</span><span class="w"> </span><span class="n">c1</span>
<span class="nf">f</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>

<span class="nf">clause</span><span class="w"> </span><span class="n">c2</span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>

<span class="nf">clause</span><span class="w"> </span><span class="n">c3</span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">3</span>

<span class="nf">prioConstrain</span><span class="w"> </span><span class="n">prioHigh</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">prioLow</span>
</pre></div>
</div>
<p>Each clause has its own priority, which is the tuple (declared priority, specificity) ordered by lexicographical order. If a declared priority is not specified then it is an unnamed fresh priority with the relation <code class="docutils literal notranslate"><span class="pre">prioLow</span> <span class="pre">&lt;</span> <span class="pre">fresh</span> <span class="pre">&lt;</span> <span class="pre">prioHigh</span></code>. Specificity is a poset relation defined by an SMT solver: <code class="docutils literal notranslate"><span class="pre">a</span></code> is more specific than (higher priority) <code class="docutils literal notranslate"><span class="pre">b</span></code> if <code class="docutils literal notranslate"><span class="pre">UNSAT(a</span> <span class="pre">&amp;</span> <span class="pre">not</span> <span class="pre">b)</span></code> and <code class="docutils literal notranslate"><span class="pre">SAT</span> <span class="pre">(not</span> <span class="pre">a</span> <span class="pre">&amp;</span> <span class="pre">b)</span></code>.</p>
<p>Clauses with lower priority are shadowed by clauses with higher priorities. Clauses with incomparable priorities are run in parallel. Clauses with equal priorities give a warning and are run in parallel.</p>
<p>There is a macro to give all clauses in a region the same priority, which makes the specificity implementation more useful.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prioAll</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">isDoor</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">no</span>
<span class="w">   </span><span class="n">isDoor</span><span class="w"> </span><span class="s">&quot;garden gate&quot;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">yes</span>
<span class="p">}</span>
<span class="c1">-- the second clause is more specific than the first, hence overrides it</span>

<span class="nf">prioAll</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">isPerson</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">no</span>
<span class="w">   </span><span class="n">isPerson</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">isMan</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">yes</span>

<span class="w">   </span><span class="n">isMan</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">no</span>
<span class="w">   </span><span class="n">isMan</span><span class="w"> </span><span class="s">&quot;Steve&quot;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">yes</span>

<span class="w">   </span><span class="n">isDoor</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">no</span>
<span class="w">   </span><span class="n">isDoor</span><span class="w"> </span><span class="s">&quot;Steve&quot;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">yes</span>

<span class="w">   </span><span class="n">describe</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">isPerson</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Humanoid&quot;</span>
<span class="w">   </span><span class="n">describe</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">isMan</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Masculine&quot;</span>
<span class="w">   </span><span class="c1">-- describe m | isDoor m = &quot;Door&quot; -- conflict with isMan for &quot;Steve&quot;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">-- again each clause overrides the second</span>
</pre></div>
</div>
<p>You can get the priority of a clause with <code class="docutils literal notranslate"><span class="pre">prioOf</span> <span class="pre">{</span> <span class="pre">clause</span> <span class="pre">|</span> <span class="pre">condition</span> <span class="pre">}</span></code>, so as to constrain a clause that has an anonymous priority. The AST must match exactly.</p>
<p>There is also <code class="docutils literal notranslate"><span class="pre">prioBound</span> <span class="pre">{}</span></code>, similar in syntax to <code class="docutils literal notranslate"><span class="pre">prioAll</span></code> but puts a top/bottom constraint on fresh priorities.</p>
<p>You can also define sets of priorities, either by listing or with <code class="docutils literal notranslate"><span class="pre">prioSet</span> <span class="pre">{</span> <span class="pre">}</span></code>, and use <code class="docutils literal notranslate"><span class="pre">prioSetDef</span></code> to define large-scale orderings. You can resolve conflicts in the priority ordering definitions by declaring the priorities (meta-priorities) of the definitions. See Posets.</p>
<section id="next-method">
<h3>Next method<a class="headerlink" href="#next-method" title="Link to this heading"></a></h3>
<p>High priority methods shadow lower-priority methods, rather than entirely replacing them. <code class="docutils literal notranslate"><span class="pre">next-method</span></code> allows access to these shadowed methods. The shadowed methods are run in parallel.</p>
<p>You can run the methods with different parameters, <code class="docutils literal notranslate"><span class="pre">next-method</span> <span class="pre">{</span> <span class="pre">silently=true</span> <span class="pre">}</span></code>.</p>
<p>You can also call a specific clause, <code class="docutils literal notranslate"><span class="pre">callClause</span> <span class="pre">{</span> <span class="pre">clause</span> <span class="pre">|</span> <span class="pre">guard,</span> <span class="pre">module</span> <span class="pre">=</span> <span class="pre">...,</span> <span class="pre">priority</span> <span class="pre">=</span> <span class="pre">...</span> <span class="pre">}</span></code>, or its <code class="docutils literal notranslate"><span class="pre">next-method</span></code>, <code class="docutils literal notranslate"><span class="pre">callClauseNext</span></code>.</p>
</section>
<section id="list-methods">
<h3>List methods<a class="headerlink" href="#list-methods" title="Link to this heading"></a></h3>
<p>Stroscot also supports Common Lisp’s custom qualifier <code class="docutils literal notranslate"><span class="pre">list</span></code>. <code class="docutils literal notranslate"><span class="pre">list</span></code> simply produces the list of applicable methods (ones whose guard is OK). This list can then be applied or manipulated as needed. It is an error to define a list method if there are any normal methods defined.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Modules.html" class="btn btn-neutral float-left" title="Modules" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Memory.html" class="btn btn-neutral float-right" title="Memory" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>