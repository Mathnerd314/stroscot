

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Types &mdash; Stroscot  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Using destructors" href="Destructors.html" />
    <link rel="prev" title="How to install Stroscot" href="Install.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">How to</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Install.html">How to install Stroscot</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sets">Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dependent-types">Dependent types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#adts">ADTs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#records">Records</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-synthesis">Type synthesis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#roles">Roles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Destructors.html">Using destructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Transactions.html">Transactions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Explanation/index.html">Discussion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">How to</a> &raquo;</li>
        
      <li>Types</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/HowTo/Types.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="types">
<h1>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h1>
<p>Programmers can use types to annotate syntactic constructs. Types restrict the possible range of values an identifier may take, allowing the compiler to optimize to a specific runtime representation.</p>
<p>Stroscot mainly follows a dynamically typed semantics, allowing ad-hoc polymorphism and other nice dynamic features that a static semantics would make difficult. But the compiler still tries to prove properties about execution, so you can get errors if a function is not defined on a value, and the whole-program analysis narrows the storage class of values.</p>
<p>Type inference is undecidable in general, and the reduction is to weird problems like <a class="reference external" href="https://www.quora.com/Why-is-type-inference-in-System-F-undecidable">semi-unification</a>, so Stroscot doesn’t deal with types internally. Instead it uses model checking / automata theory, which better encodes undecidable properties. <span id="id1">[<a class="reference internal" href="../zzreferences.html#id50" title="Mayur Naik and Jens Palsberg. A type system equivalent to a model checker. ACM Transactions on Programming Languages and Systems, 30(5):1–24, August 2008. URL: https://dl.acm.org/doi/10.1145/1387673.1387678 (visited on 2021-07-15), doi:10.1145/1387673.1387678.">NP08</a>]</span> provides a method to interpret the model produced by a model checker as a type derivation using flow, intersection, and union types; maybe this can be used as type inference. But the types will be complex and precise, e.g. <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">:</span> <span class="pre">(Nil--&gt;0)</span> <span class="pre">&amp;</span> <span class="pre">(Cons</span> <span class="pre">a</span> <span class="pre">b--&gt;1+(length</span> <span class="pre">b))</span></code>. OTOH when there’s a type error, model checking produces a concrete program trace of a failing path, which should be easy to turn into a good error message.</p>
<p>Although types are not first-class, sets are. Type annotations are translated to assertions, and these assertions are statically checked. <code class="docutils literal notranslate"><span class="pre">assert</span></code> is deeply special, since it has to work with descriptions of executable properties, so unfortunately not all programs/properties will produce an answer.</p>
<p>We don’t have substructural types because the language itself is substructural (based on linear logic).</p>
<div class="section" id="sets">
<h2>Sets<a class="headerlink" href="#sets" title="Permalink to this headline">¶</a></h2>
<p>Since types are assertions and assertions are boolean-valued just like set membership, we can think of types as sets of values defined by a predicate <code class="docutils literal notranslate"><span class="pre">isElemOf</span> <span class="pre">S</span></code>. Since distributive lattices are isomorphic to collections of sets this is equivalent to the definition of types in <span id="id2">[<a class="reference internal" href="../zzreferences.html#id20" title="Stephen Dolan. Algebraic Subtyping. PhD thesis, University of Cambridge, September 2016. URL: https://www.cs.tufts.edu/~nr/cs257/archive/stephen-dolan/thesis.pdf.">Dol16</a>]</span>. Often a type will be a simple definition checking whether an element has a given tag, but the set can describe almost any side effect free computation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span> <span class="kt">:</span> <span class="kt">T</span> <span class="ow">=</span> <span class="p">{</span> <span class="n">assert</span><span class="p">(</span><span class="n">a</span> <span class="n">isElemOf</span> <span class="kt">T</span><span class="p">);</span> <span class="n">a</span> <span class="p">}</span>
<span class="kt">T</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="kt">:</span> <span class="kt">T</span>
</pre></div>
</div>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<p>Function type declarations come in two forms. The first version simply checks compatibility, that the return type is as expected on the given input.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">S</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="kt">A</span> <span class="ow">=</span> <span class="o">...</span>

<span class="c1">-- expands to</span>

<span class="nf">s</span> <span class="ow">=</span> <span class="n">arbElem</span><span class="nb">()</span>
<span class="nf">assume</span><span class="p">(</span><span class="n">s</span> <span class="n">isElemOf</span> <span class="kt">S</span><span class="p">)</span>
<span class="nf">assert</span><span class="p">(</span><span class="kt">A</span> <span class="n">s</span> <span class="n">isElemOf</span> <span class="kt">Int</span><span class="p">)</span>
<span class="kt">A</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>The second version, “strict typing”, restricts the definition of the function so it is only defined on the type, i.e. it will throw an error if given something outside its type. You can define multiple strict functions to obtain overloaded behavior on different types.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">strict</span>
   <span class="kt">A</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">S</span><span class="p">,</span><span class="kt">T</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
   <span class="kt">A</span> <span class="ow">=</span> <span class="o">...</span>

<span class="c1">-- expands to</span>

<span class="kt">A</span><span class="o">$</span><span class="n">untyped</span> <span class="ow">=</span> <span class="o">...</span>
<span class="kt">A</span> <span class="ow">=</span> <span class="p">{</span>
   <span class="n">assert</span> <span class="p">(</span><span class="o">$</span><span class="n">args</span> <span class="n">isElemOf</span> <span class="p">(</span><span class="kt">S</span><span class="p">,</span><span class="kt">T</span><span class="p">))</span>
   <span class="n">ret</span> <span class="ow">=</span> <span class="kt">A</span><span class="o">$</span><span class="n">untyped</span> <span class="o">$</span><span class="n">args</span>
   <span class="n">assert</span> <span class="p">(</span><span class="n">ret</span> <span class="n">isElemOf</span> <span class="kt">Int</span><span class="p">)</span>
   <span class="n">ret</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="dependent-types">
<h3>Dependent types<a class="headerlink" href="#dependent-types" title="Permalink to this headline">¶</a></h3>
<p>The types (assertions) can bind the value, so Stroscot can express dependent types.
And the values are in scope in the type, so even <a class="reference external" href="https://github.com/UlfNorell/insane/">insanely dependent types</a> can be defined:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">A</span> <span class="kt">:</span> <span class="p">(</span><span class="n">s</span> <span class="kt">:</span> <span class="kt">S</span> <span class="n">s</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">s</span>
<span class="kt">A</span> <span class="ow">=</span> <span class="o">...</span>

<span class="c1">-- expands to</span>
<span class="nf">s</span> <span class="ow">=</span> <span class="n">arbElem</span><span class="nb">()</span>
<span class="nf">assume</span><span class="p">(</span><span class="n">s</span> <span class="n">isElemOf</span> <span class="kt">S</span> <span class="n">s</span><span class="p">)</span>
<span class="nf">assert</span><span class="p">(</span><span class="kt">A</span> <span class="n">s</span> <span class="n">isElemOf</span> <span class="kt">T</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="adts">
<h2>ADTs<a class="headerlink" href="#adts" title="Permalink to this headline">¶</a></h2>
<p>Abstract data types are sets containing trees of uninterpreted symbols. So a datatype declaration (from <a class="reference external" href="https://github.com/UlfNorell/insane/blob/master/Context.agda">here</a>)</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Cxt</span> <span class="p">[</span> <span class="kt">Ty</span> <span class="kt">:</span> <span class="kt">Cxt</span> <span class="kt">Ty</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="p">]</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
   <span class="n">nil</span>  <span class="kt">:</span> <span class="kt">Cxt</span> <span class="kt">Ty</span>
   <span class="n">snoc</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">G</span> <span class="kt">:</span> <span class="kt">Cxt</span> <span class="kt">Ty</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Ty</span> <span class="kt">G</span> <span class="ow">-&gt;</span> <span class="kt">Cxt</span> <span class="kt">Ty</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">symbol</span> <span class="n">nil</span>
<span class="nf">symbol</span> <span class="n">snoc</span>
<span class="kt">Cxt</span> <span class="kt">Ty</span> <span class="ow">=</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">arbElem</span><span class="nb">()</span><span class="p">;</span> <span class="n">assume</span><span class="p">(</span><span class="n">a</span> <span class="n">isOfType</span> <span class="kt">Cxt</span> <span class="kt">Ty</span><span class="p">);</span> <span class="n">assert</span><span class="p">(</span><span class="kt">Ty</span> <span class="n">a</span> <span class="n">isElemOf</span> <span class="kt">Set</span><span class="p">);</span> <span class="kt">Set</span> <span class="p">{</span> <span class="n">x</span> <span class="kr">where</span>
   <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">nil</span>
   <span class="n">or</span> <span class="n">exists</span> <span class="kt">G</span> <span class="n">y</span><span class="o">.</span> <span class="n">x</span> <span class="o">==</span> <span class="p">(</span><span class="n">snoc</span> <span class="kt">G</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="kt">G</span> <span class="n">isElemOf</span> <span class="p">(</span><span class="kt">Cxt</span> <span class="kt">Ty</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="n">isElemOf</span> <span class="p">(</span><span class="kt">Ty</span> <span class="kt">G</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The recursive appearance of <code class="docutils literal notranslate"><span class="pre">Cxt</span> <span class="pre">Ty</span></code> is interpreted using the least pre-fixed point and Bekić’s theorem as in <span id="id3">[<a class="reference internal" href="../zzreferences.html#id21" title="Stephen Dolan and Alan Mycroft. Polymorphism, subtyping, and type inference in MLsub. In Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages, POPL 2017, 60–72. Paris, France, January 2017. Association for Computing Machinery. URL: https://doi.org/10.1145/3009837.3009882 (visited on 2020-06-15), doi:10.1145/3009837.3009882.">DM17</a>]</span> section 2.2.</p>
</div>
<div class="section" id="records">
<h2>Records<a class="headerlink" href="#records" title="Permalink to this headline">¶</a></h2>
<p>You can pass <code class="docutils literal notranslate"><span class="pre">{a:</span> <span class="pre">undefined,</span> <span class="pre">b:</span> <span class="pre">2}</span></code> to a function <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">rec</span> <span class="pre">=</span> <span class="pre">rec.b</span></code>. This is similar to structural subtyping. If the function used <code class="docutils literal notranslate"><span class="pre">a</span></code>, it would give an error.</p>
</div>
<div class="section" id="type-synthesis">
<h2>Type synthesis<a class="headerlink" href="#type-synthesis" title="Permalink to this headline">¶</a></h2>
<p>Type synthesis is tricky, but with the termination checker we don’t have any visible types. The optimizer does a form of type synthesis when it assigns formats to values, but the formats can be conditional on state, and the optimizer will use a catch-all format for hard cases, so the formats are complete but not sound. The only useful case for a complex type synthesis algorithm might be pretty-printed type signatures in documentation, but there having the developer specify type signatures is a viable option.</p>
<p>But <a class="reference external" href="https://github.com/UlfNorell/insane/">dependent</a>
<a class="reference external" href="https://github.com/gelisam/circular-sig">circular</a> dependent types will presumably ruin all the fun and require type signatures.</p>
</div>
<div class="section" id="roles">
<h2>Roles<a class="headerlink" href="#roles" title="Permalink to this headline">¶</a></h2>
<p>Roles are just an optimization for <code class="docutils literal notranslate"><span class="pre">coerce</span></code>, but there are better ways to implement optimizations. It seems like a dirty hack to solve a pressing problem. I think Stroscot can get by without them.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Destructors.html" class="btn btn-neutral float-right" title="Using destructors" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="Install.html" class="btn btn-neutral float-left" title="How to install Stroscot" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019-2020 Mathnerd314.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>