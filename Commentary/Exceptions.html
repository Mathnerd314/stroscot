<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exceptions &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="F2 G2" href="F2G2_example.html" />
    <link rel="prev" title="Evaluation strategy" href="Evaluation-Strategy.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Exceptions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#exception-menagerie">Exception menagerie</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#non-example-process-commands">Non-example: Process commands</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronous-exceptions">Synchronous exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#asynchronous-exceptions">Asynchronous exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-categorizations">Other categorizations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#patterns">Patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#handle">Handle</a></li>
<li class="toctree-l4"><a class="reference internal" href="#propagate">Propagate</a></li>
<li class="toctree-l4"><a class="reference internal" href="#frequency">Frequency</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#traces">Traces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#top-level">Top level</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cleanup">Cleanup</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cleanup-and-exceptions">Cleanup and exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exception-safety">Exception safety</a></li>
<li class="toctree-l4"><a class="reference internal" href="#poisoning">Poisoning</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#syntax">Syntax</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#try">Try</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exit-points">Exit points</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#signatures">Signatures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#call-chains">Call chains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#java-checked-exceptions">Java checked exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#default-signature-type">Default signature type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fresh-exceptions">Fresh exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#composability">Composability</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#return-codes">Return codes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#continuations">Continuations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unwinding-tables">Unwinding tables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#zero-overhead">Zero overhead</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interruptible-cleanup">Interruptible cleanup</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#injection">Injection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#masking">Masking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interruptible-operations">Interruptible operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unmask-is-not-an-inverse">Unmask is not an inverse</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="F2G2_example.html">F2 G2</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fexprs.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">About</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Imperative programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Commentary</a> &raquo;</li>
      <li>Exceptions</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Exceptions.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="exceptions">
<h1>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this heading"></a></h1>
<section id="exception-menagerie">
<h2>Exception menagerie<a class="headerlink" href="#exception-menagerie" title="Permalink to this heading"></a></h2>
<p>The first question is what an exception is. Let us try to list all the types of exceptions, or everything that can use an exception-like semantic. The number of exceptions is unquestionably large.</p>
<section id="non-example-process-commands">
<h3>Non-example: Process commands<a class="headerlink" href="#non-example-process-commands" title="Permalink to this heading"></a></h3>
<p>SIGKILL/SIGSTOP cannot be blocked or handled by the program, so aren’t exceptions. Similarly C’s <code class="docutils literal notranslate"><span class="pre">exit</span></code> function doesn’t return.</p>
</section>
<section id="synchronous-exceptions">
<h3>Synchronous exceptions<a class="headerlink" href="#synchronous-exceptions" title="Permalink to this heading"></a></h3>
<p>Synchronous exceptions are thrown at a clearly defined point in the instruction stream. This means the compiler can omit exception handling code if it can prove no exceptions can occur.</p>
<section id="domain-exception">
<h4>Domain exception<a class="headerlink" href="#domain-exception" title="Permalink to this heading"></a></h4>
<p>A domain exception is an “alternate result” returned when the precondition for success is false, i.e. the operation is called on an invalid argument outside of its domain. This is used when checking the domain via a separate function would be tedious.</p>
<p>Examples:</p>
<ul class="simple">
<li><p>Converting a string to an integer may fail on invalid characters. It is easier to return a <code class="docutils literal notranslate"><span class="pre">NotAnInt</span></code> value from the operation than to restrict the type to strings that represent integers.</p></li>
<li><p>Looking up a nonexistent key in a dictionary may return <code class="docutils literal notranslate"><span class="pre">KeyNotFound</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">&quot;x&quot;</span> <span class="pre">then</span> <span class="pre">...</span> <span class="pre">else</span> <span class="pre">...</span></code> returns <code class="docutils literal notranslate"><span class="pre">InvalidCondition</span></code></p></li>
<li><p>A case statement returns <code class="docutils literal notranslate"><span class="pre">FailedMatch</span></code> if the argument doesn’t match any of the patterns</p></li>
<li><p>C++ allows <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">x</span></code> where <code class="docutils literal notranslate"><span class="pre">x</span></code> can be any value. Most other languages limit <code class="docutils literal notranslate"><span class="pre">x</span></code> to be of a type <code class="docutils literal notranslate"><span class="pre">Exception</span></code>.</p></li>
</ul>
</section>
<section id="system-exception">
<h4>System exception<a class="headerlink" href="#system-exception" title="Permalink to this heading"></a></h4>
<p>These are used in C functions with the convention that a zero or positive return is success and a negative return is an exception. As such the exception codes are all negative. On Linux/POSIX there is EINTR, EINVAL, ENOENT, ETIMEDOUT, etc., on Windows there are the types NTSTATUS and HRESULT.</p>
<p>In many ways these are similar to domain exceptions, but the difference is that the failure is not predictable in advance with a predicate because state may have changed between the predicate and the call.</p>
<p>The other difference is that the set of possible exception codes is not small. The kernel is complex and a system call may return almost any exception code, hence requiring hundreds of cases. But typically there is only one way the call can succeed. Hence the argument for exceptions, to handle all the cases you don’t care about in a uniform manner.</p>
<p>Also the set of possible exception codes is not fixed. New kernels may add and use new exception codes. So in addition to exceptions for all known exception codes there also needs to be a family <code class="docutils literal notranslate"><span class="pre">UnknownExceptionCode</span> <span class="pre">123</span></code>.</p>
<p>Examples:</p>
<ul class="simple">
<li><p>Reading into a buffer may return more data than the buffer so can fill it to to capacity and return a <code class="docutils literal notranslate"><span class="pre">PartialRead</span></code> exception so more can be read on the next call.</p></li>
<li><p>Opening a file may fail with a <code class="docutils literal notranslate"><span class="pre">FileNotFound</span></code> exception. The file may have been deleted too recently to be detected by any previously performed checks.</p></li>
<li><p>A query to a database might fail with <code class="docutils literal notranslate"><span class="pre">DatabaseCorrupted</span></code>.</p></li>
</ul>
</section>
<section id="hardware-exceptions">
<h4>Hardware exceptions<a class="headerlink" href="#hardware-exceptions" title="Permalink to this heading"></a></h4>
<p>Hardware exceptions on Linux are transformed to signals SIGBUS, SIGFPE, SIGILL, SIGSEGV, SIGTRAP, SIGEMT (emulator trap, not used on x86) <a class="reference external" href="https://github.com/torvalds/linux/blob/a931dd33d370896a683236bba67c0d6f3d01144d/arch/x86/kernel/traps.c">in the kernel</a>. The type of exception is in si_code in siginfo_t SIGFPE-&gt;FPE_INTDIV (DE), SIGSEGV (<a class="reference external" href="https://github.com/torvalds/linux/blob/a931dd33d370896a683236bba67c0d6f3d01144d/arch/x86/mm/fault.c#L1487">PF</a>, GP), SIGBUS (SS, AC), SIGILL (UD), etc. The signals can only be handled by the thread that raises them and are delivered immediately (synchronously); queueing and letting the thread continue normally doesn’t make sense. The exceptions must be handled: execution cannot resume where it left off.</p>
<p>On Windows the equivalent of signals for hardware exceptions is <a class="reference external" href="https://docs.microsoft.com/en-us/cpp/cpp/structured-exception-handling-c-cpp?view=msvc-160">Structured Exception Handling</a> or more specifically <a class="reference external" href="https://docs.microsoft.com/en-us/windows/win32/debug/vectored-exception-handling">Vectored Exception Handlers</a>. In Visual C++ we can actually catch hardware exceptions inline with <code class="docutils literal notranslate"><span class="pre">__try</span> <span class="pre">{</span> <span class="pre">}</span> <span class="pre">__except</span></code>. But GCC / LLVM haven’t implemented SEH. (LLVM is <a class="reference external" href="https://reviews.llvm.org/D80344">in progress</a>)</p>
<p>SEH can be thought of much like temporarily registered signal handlers, where the exceptional conditions are signals, the __try blocks define where the handler is in effect, and the __except and __finally blocks are the handlers if the “signal” is received. In 64-bit Windows there are instruction tables that do unwinding.</p>
<p><a class="reference external" href="https://github.com/ziglang/zig/blob/e2b954c2738c683a85b864eb33530f0e3dbbc480/lib/std/debug.zig#L1527">Zig</a> implements a signal handler for hardware exceptions that dumps the stacktrace and aborts. But we can do better and, like Windows SEH, allow unwinding to a handler in the code. Signal handlers can only call async-signal-safe functions. In practice we can get around this with <code class="docutils literal notranslate"><span class="pre">siglongjmp</span></code>. A further extension should be able to do DWARF unwinding and allow pretending that hardware exceptions are simply return values from instructions. Really what happens is that the handler jumps to a failure continuation, and this failure continuation is <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">DivByZero</span></code>, while the success continuation is <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">123</span></code> or whatever.</p>
</section>
<section id="logic-exceptions">
<h4>Logic exceptions<a class="headerlink" href="#logic-exceptions" title="Permalink to this heading"></a></h4>
<p>A logic exception is the result of an undefined operation or programming bug. Examples: incorrect cast, attempt to dereference null, array out-of-bounds access, pattern match failure, assertion failure, contract failure, TODO marker.</p>
<p>Assertions and contracts are statically checked by default, but when the compiler cannot prove them it may emit runtime checks. These checks throw logic exceptions if the assertion doesn’t hold. It’s of course better to have the compiler prove the assertions, but some people are lazy and only fix things when they actually break in production.</p>
<p>Furthermore this category is not particularly distinguished from domain exceptions. A hash table lookup with a nonexistent key returns <code class="docutils literal notranslate"><span class="pre">NotFound</span></code>; why does an array lookup with an out-of-bounds index crash the program? The claim is that “the code should be fixed” but this same argument applies to adding a member check to the hash table lookup.</p>
</section>
<section id="arithmetic-exceptions">
<h4>Arithmetic exceptions<a class="headerlink" href="#arithmetic-exceptions" title="Permalink to this heading"></a></h4>
<p>These can thrown in floating point with certain flags in Ada, Fortran (F90 and later), C++ and C (C99, fenv.h, float.h on certain compilers).</p>
<p>Divide-by-zero also throws. You want NaN-style propagation for DbZ.</p>
</section>
<section id="representation-exceptions">
<h4>Representation exceptions<a class="headerlink" href="#representation-exceptions" title="Permalink to this heading"></a></h4>
<p>These happen when the result doesn’t fit in the specified representation, e.g. arithmetic over/underflow. These can represent a security vulnerability.</p>
</section>
<section id="resource-exhaustion">
<h4>Resource exhaustion<a class="headerlink" href="#resource-exhaustion" title="Permalink to this heading"></a></h4>
<p>This covers allocation failure due to running out of memory (OOM), stack overflow, out of file descriptors, etc. Resource exhaustion exceptions appear in the typical way, as an expression reducing to an exception rather than its expected value.</p>
<p>OOMs are unpredictable at runtime because threads compete for memory. Any allocation attempt might fail, because the developer doesn’t know the total resources available on the target system, and because other threads and other processes are simultaneously competing for that same unknown pool. But OOM locations are predictable to the compiler because it knows exactly where allocations occur and can throw an exception if the allocation fails. Hence OOM is not “asynchronous” - it originates from the allocation statement.</p>
<p>But the programmer cannot generally predict whether evaluating an expression will allocate and hence potentially throw an OOM, because of implicit allocations. Here are some examples:
* Implicit boxing, causing value types to be instantiated on the heap.
* marshaling and unmarshaling for the FFI
* immutable array operations
* graph reduction
* JITing a method or basic block, generating VTables or trampolines</p>
<p>But programming OOM-free is consistent, in the sense that if the compiler is able to eliminate all allocations and hence eliminate the possibility of OOM, then these will most likely be consistently eliminated on every compile. So asserting that a function or block can’t OOM is possible. .NET had Constrained Execution Regions which implemented this, with various hacks such JITing the region at load time rather than when the region was first executed. So there’s precedent.</p>
<p>So then there are two ways to handle OOM: let it crash, or try to recover. Recovering from OOM is hard, since you can’t allocate more memory. It is allowed to try to allocate memory, and this can succeed, e.g. if another thread freed memory since the OOM was thrown, but the handler should still be designed to expect this to fail. The JVM apparently has weird bugs when you catch OOM, like 2 + 3 = 7, so crashing is the only real option there. But you can restore invariants, e.g. release locks.</p>
<p>Stack overflow is more tractable than OOM, in the sense that there is no asynchronous competition for the resource, hence a static analysis can show that there is sufficient stack. It is also easy to handle stack overflow by switching to an alternate stack. It is also fairly predictable to determine whether an expression uses the C stack: it must call a C function.</p>
<p>Stack overflow can leave a Windows critical section in a corrupt state. Windows user routines likely have many stack overflow bugs, this isn’t something it’s hardened against. So maybe stack overflow isn’t recoverable on Windows. On Linux the syscalls don’t use a stack so should be fine.</p>
<p>Out of file descriptors is pretty easy to handle. Since few operations allocate file descriptors, it is easy to avoid allocating FDs in a handler.</p>
</section>
<section id="deadlock">
<h4>Deadlock<a class="headerlink" href="#deadlock" title="Permalink to this heading"></a></h4>
<p>It can be detected that a thread is stuck when it is waiting on an MVar with no other references. Then the runtime can replace the takeMVar with throwing a BlockedIndefinitelyOnMVar exception. Similarly with Deadlock and some other Haskell concurrency exceptions.</p>
<p>These are synchronous exceptions in that they’re directly attributable to the action the current thread is taking. But Haskell uses the asynchronous delivery mechanism for implementation convenience. IMO it’s a bug, they should be delivered synchronously and not be maskable.</p>
</section>
<section id="nontermination">
<h4>Nontermination<a class="headerlink" href="#nontermination" title="Permalink to this heading"></a></h4>
<p>Infinite loops can be detected in some cases and replaced with a Nontermination or Loop exception. Dynamically, this can be implemented by decrementing a fuel counter on every reduction and throwing an exception. Whatever the starting fuel, an infinite loop is guaranteed to run it out. Statically the analyses are more general and can prove termination or nontermination without requiring an arbitrary initial fuel. Most functions terminate, but totality checkers are not omniscient.</p>
</section>
<section id="exception-groups">
<h4>Exception groups<a class="headerlink" href="#exception-groups" title="Permalink to this heading"></a></h4>
<p>Consider a parallel map, e.g. something like <code class="docutils literal notranslate"><span class="pre">parallel-map</span> <span class="pre">arr</span> <span class="pre">$</span> <span class="pre">\(i,v)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">i</span> <span class="pre">v</span></code> that can execute multiple <code class="docutils literal notranslate"><span class="pre">f</span></code>’s concurrently. Now there may be 0, 1, or multiple failures of <code class="docutils literal notranslate"><span class="pre">f</span></code>. If there are no failures everything is fine. But if there are 1 or multiple failures, we cannot return an array, and must throw an exception. If there is one exception we can just throw that exception. But if there are multiple, then what? In general all <code class="docutils literal notranslate"><span class="pre">f</span></code> may run in parallel, but if we execute some range on a thread then an earlier <code class="docutils literal notranslate"><span class="pre">f</span></code> exception will stop the thread and later <code class="docutils literal notranslate"><span class="pre">f</span></code> exceptions will not be reported. So reporting the complete set of (potential) exceptions is impossible, we can only report the exception encountered by each thread. And in fact the controller may kill all the worker threads after receiving the “first” exception, so the later threads will stop abruptly. This “first” exception may not be chronologically first due to scheduling vagaries, but it is logically the first as seen by the controller.</p>
<p>So, since all the other threads will be killed anyway after this first exception, the exceptions these other threads may or may not have encountered can be ignored, and we can just report the first exception to the caller. But this discards information.</p>
<p>Instead, the <code class="docutils literal notranslate"><span class="pre">ThreadKilled</span></code> exceptions can be reported along with the first exception and any other exceptions that manage to make it through. This is important enough that Joe Duffy <a class="reference external" href="http://joeduffyblog.com/2009/06/23/concurrency-and-exceptions/">added</a> an “AggregateException” and a Python PEP added <a class="reference external" href="https://www.python.org/dev/peps/pep-0654">Exception Groups</a>. It does require a new catch mechanism <code class="docutils literal notranslate"><span class="pre">try-except*</span></code>, but it provides more control over exception handling in concurrent systems.</p>
<p>Of course true recovery still requires handling all exceptions inside the thread, before they are reported to the controller.</p>
</section>
<section id="aborts">
<h4>Aborts<a class="headerlink" href="#aborts" title="Permalink to this heading"></a></h4>
<p>An <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread.abort?view=net-6.0">abort</a> is an exception that can’t be suppressed unless you defuse it by calling <code class="docutils literal notranslate"><span class="pre">ResetAbort</span></code> with the correct token inside the catch handler. The abort is automatically re-raised at the end of any catch block that catches it without defusing it. A similar idea is an exception with a freshly defined type that can’t be matched by anything but a corresponding handler.</p>
<p>Examples include aborting a UI computation before it finishes due to a redraw, and returning a solution directly from inside a search tree’s call stack.</p>
<p>This got removed from .NET, so it’s not clear that the rethrowing/defusing behavior is needed in practice. The control flow pattern can be implemented directly with continuations.</p>
</section>
<section id="process-exit">
<h4>Process exit<a class="headerlink" href="#process-exit" title="Permalink to this heading"></a></h4>
<p>Using a <code class="docutils literal notranslate"><span class="pre">ProcessExit</span></code> exception for exiting ensures graceful cleanup and allows cancelling the exit via catching, e.g. in the case of a sandbox or interactive interpreter. But of course there is an underlying <code class="docutils literal notranslate"><span class="pre">exit</span></code> command which always shuts the program down and does not return.</p>
</section>
<section id="serious-bugs">
<h4>Serious bugs<a class="headerlink" href="#serious-bugs" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p>ExecutionEngineException</p></li>
<li><p>An Access Violation inside mscorwks.dll or mscoree.dll</p></li>
<li><p>A corrupt GC heap</p></li>
</ul>
<p>These are thrown in the runtime or core standard libraries when safety invariants have been violated. Although it’s generally a security risk to continue execution, there are cases where these exceptions can be handled, e.g. write barrier code that catches access violations and converts them into NullReferenceExceptions.</p>
</section>
</section>
<section id="asynchronous-exceptions">
<h3>Asynchronous exceptions<a class="headerlink" href="#asynchronous-exceptions" title="Permalink to this heading"></a></h3>
<p>Asynchronous exceptions originate outside the thread or flow of computation. The runtime system requires specific support to inject asynchronous exceptions into the thread, ideally allowing an exception to be injected at an arbitrary location in the code. Once injected they bubble up like synchronous exceptions. Proving the absence of asynchronous exceptions requires a global cross-thread analysis, as well as analysis of signal IPC if those are modeled as asynchronous exceptions. Hence the tagline “async exceptions are terrible.” But Stroscot follows Haskell in having them anyway. The timeout and cancel functions in Haskell’s async package use async exceptions to great benefit. The Warp webserver bases all of its slowloris protection on async exceptions.</p>
<p>The programmer must be aware of asynchronous exceptions and code so that unwinding restores any necessary invariants, or track the invariant violations down
when they inevitably forget.
Functional programming which avoids mutation and side-effects except in the outermost loops
naturally has very few invariants; propagating an exception simply abandons all the work done up to that point.
However, complex mutations
cannot be trivially reversed.  Packets cannot be unsent. It
is inherently dangerous to asynchronously unwind from an arbitrary point.
The language has some responsibility to help here. It is not clear if invariant checking and finalizers are sufficient.
It is certainly possible to write code that handles asynchronous
exceptions correctly; and pragmatically, unwinding through most
code will generally just work.</p>
<section id="wrappers">
<h4>Wrappers<a class="headerlink" href="#wrappers" title="Permalink to this heading"></a></h4>
<p>We distinguish sync/async with disjoint types; to allow throwing sync exceptions as async and vice-versa there are special “AsyncToSync” and vice-versa wrapper exceptions.</p>
</section>
<section id="thread-cancellation">
<h4>Thread cancellation<a class="headerlink" href="#thread-cancellation" title="Permalink to this heading"></a></h4>
<p>Often processes are too coarse and one wishes to gracefully cancel a thread from another thread. Uses: timeouts, aborting speculative computation, handling resource exhaustion. The solution is an asynchronous exception <code class="docutils literal notranslate"><span class="pre">ThreadCancelled</span></code>.</p>
<p>With cancellation you should only do cleanup. Thread cancellation is a message from outside of your current execution saying “you must die as soon as possible.” If you swallow the exception, you break the very nature of the cancellation mechanism. Similarly cleanup in response to cancellation should be minimal, avoiding long pauses, to ensure quick cancellation.</p>
<p>The full power of thread cancellation is not always needed. Usually one can get away with setting a flag, emptying a queue, etc. that gets checked in the processing loop and then the thread can exit itself gracefully.</p>
</section>
<section id="signals">
<h4>Signals<a class="headerlink" href="#signals" title="Permalink to this heading"></a></h4>
<p>This mainly means <a class="reference external" href="https://man7.org/linux/man-pages/man7/signal.7.html">Linux signals</a>, excluding process commands and hardware exceptions that also use the signal API. Signals can be process-directed (kernel op, ctrl-C in terminal SIGINT, kill(2), sigqueue(2), SIGEV_SIGNAL) or thread-directed (tgkill(2), pthread_kill(3), pthread_sigqueue(3), SIGEV_THREAD_ID). A process-directed signal can be delivered to any thread of the process that isn’t masked. A thread-directed signal can only be delivered to the specified thread. The signal isn’t necessarily delivered immediately but is queued if all targeted threads are masked. The limit is 1 pending signal of each type for standard signals (id&lt;32), but real-time signals (33 to 63) can queue more up to some limit and also can carry an int-sized datum.</p>
<p>The most obvious signal is <code class="docutils literal notranslate"><span class="pre">SIGINT</span></code>, sent by doing Ctrl-C in a terminal. On Windows console Ctrl-C handling starts a new thread in the process with whatever function is passed to <code class="docutils literal notranslate"><span class="pre">SetConsoleCtrlHandler</span></code>. Also similar is Windows’ graphical UI message queue, you can get a WM_CLOSE message when the window’s X is clicked. Signals can be queued up similarly using DJB’s self-pipe trick.</p>
<p>The general idea is to do unwinding/injection in a signal handler. Since most signals are out-of-band it is natural to make them resumable.</p>
</section>
</section>
<section id="other-categorizations">
<h3>Other categorizations<a class="headerlink" href="#other-categorizations" title="Permalink to this heading"></a></h3>
<p>Some languages try to create separate categories such as unrecoverable failures, catastrophic exceptions, programming mistakes, and so on. For example there is Rust’s Result vs panic, and Herb Sutter claims logic exceptions are not “errors” or “exceptions” as they “cannot be meaningfully handled”. But this is completely bogus as panics and logic exceptions can be handled with the containment strategy just fine. So we classify them here as exceptions.</p>
<p>In general, splitting exceptions into hard categories seems to be very subjective and doomed to failure because there are always special cases to the special cases - what is “rare” to one person might be another’s bread and butter. There’s a very clear drawback of a hard split for exceptions - it may be unclear to programmers which side to use.</p>
<p>The sync/async split seems fine because async is distinguished by originating outside the thread, and this is a clear definition.</p>
</section>
</section>
<section id="patterns">
<h2>Patterns<a class="headerlink" href="#patterns" title="Permalink to this heading"></a></h2>
<p>When a function call throws an exception a programmer must decide: handle or propagate.</p>
<section id="handle">
<h3>Handle<a class="headerlink" href="#handle" title="Permalink to this heading"></a></h3>
<p>Log: Set a flag or write to a log file and use another handling strategy</p>
<p>Recover: Execute an alternate code path that does not produce an exception or produces an exception unrelated to the original. Generally you want to recover as close to the exception’s source as possible, but sometimes there is not enough context and it has to propagate a few levels before recovering.</p>
<p>Presubstitution: don’t call function again (abandon attempt), return a default value. Often the function’s range is expanded to accommodate this. For example <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">0</span></code> returns <code class="docutils literal notranslate"><span class="pre">Infinity</span></code>.  Simplest form of recovery.</p>
<p>Resume: The exception value contains a continuation. The handler performs some work and then calls the continuation. A more complex version of recovery.</p>
<p>Retry: execute a recovery block and call the block again with modified arguments. The block is treated as a transaction, meaning that the application state is not modified by the failed block. Most complex version of recovery.</p>
<p>Containment: All exceptions are caught at a level boundary (pokemon exception handling). It’s not recovery - it doesn’t fix the exception at the source, but merely restricts the damage. The inner level cleans up its resources when the exception propagates. The outer level terminates the inner level and (often) does logging, filtering, and display. Usually the outer level is close to the base of the program. For example, an event loop or thread pool, and only an throwing task gets terminated. Or a thread terminates but not the process. Or an exception gets caught before an FFI boundary to avoid polluting the API. In a high-reliability context containment is dangerous because code may cause damage if it continues and the other threads might not be isolated from it. But it can prevent DOS attacks by allowing partial restarts, and poisoning locks ensures isolation. Another issue is that exceptions may be handled incorrectly in the middle of the call stack. Still, a common and useful pattern.</p>
<p>Terminate (abort): Ask to OS to end the process. Similar to containment but the boundary is the OS. Termination makes people more productive at writing code, because exceptions are obvious during testing. But it doesn’t allow graceful communication to the user. It makes the system very brittle. But it is safe if the program is crash-only, designed to handle SIGKILL without data loss. In such a case termination is one method call away. Crash-only affects design, e.g. a network protocol cannot demand a goodbye message, and file I/O must use shadow copies, etc., so it cannot be the only option.</p>
<p>Backtrack: Try another path of execution at a previously encountered nondeterministic choice</p>
<p>Trap: Suspend process and signal exception. Wait for another process (e.g. interactive debugger) to fix</p>
</section>
<section id="propagate">
<h3>Propagate<a class="headerlink" href="#propagate" title="Permalink to this heading"></a></h3>
<p>Unwind: Behave as if the block immediately returned the exception</p>
<p>Serialize: Unwinding but across a process or thread boundary. Catch action, convert to value, pass value via IPC, convert back to exception and rethrow.</p>
<p>Cleanup: Perform some actions such as freeing resources or unlocking mutexes, then continue unwinding</p>
<p>Wrap: As cleanup, but change the exception returned. Often this loses fidelity by replacing a very specific exception with a more generic one, making it harder to perform recovery.</p>
</section>
<section id="frequency">
<h3>Frequency<a class="headerlink" href="#frequency" title="Permalink to this heading"></a></h3>
<p>The most common behavior is unwinding, followed by containment or termination. Recovery also occurs for some interfaces that use exceptions for common cases.</p>
</section>
</section>
<section id="traces">
<h2>Traces<a class="headerlink" href="#traces" title="Permalink to this heading"></a></h2>
<p>A trace is built by keeping track of the exception as it propagates. Since exceptions are lazy the propagation is demand-driven. E.g. <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">{}.x</span> <span class="pre">of</span> <span class="pre">1</span> <span class="pre">-&gt;</span> <span class="pre">...</span></code> produces <code class="docutils literal notranslate"><span class="pre">MissingCaseException</span> <span class="pre">{</span> <span class="pre">trace</span> <span class="pre">=</span> <span class="pre">NoSuchAttributeException</span> <span class="pre">{...},</span> <span class="pre">...}</span></code>. With fancy formatting the nested exceptions will look like a stacktrace. The semantics are a little different, but should be close enough. For example the trace can become infinite, if you accumulate over an infinite list.</p>
<p>Traces are mainly used for debugging as the exception value is sufficient for handling purposes. Optimization (tail calls) means entries may be added or missing. Space considerations limit the depth of stack traces. So the trace is in general an implementation detail.</p>
<p>Also, building a trace is somewhat expensive. Throwing an exception should be cheap. So how can we allow handling the exception without building a trace at all?</p>
<p>One strategy is to not provide traces for exception values. With reversible debugging the trace and any other information can be extracted after-the-fact. But it means that production code has to run in deterministic tracing mode all the time by default to have a hope of debugging exceptions. It’s possible to get the overheads low, but the strategy of recording a trace at the time of throwing is more established and it will take a lot of work to overturn.</p>
<p>Another solution is to only provide the first trace entry (closest to raising the exception). This is not too costly, and at least provides the file, line number, and attempted operation. E.g. assertions record the failing predicate expression.</p>
<p>But the main solution IMO is to determine that the exception is caught by a handler that doesn’t use the stack trace and optimize it away as an unused read-only operation.</p>
</section>
<section id="top-level">
<h2>Top level<a class="headerlink" href="#top-level" title="Permalink to this heading"></a></h2>
<p>There is always a top-level catch-all exception handler, which is guaranteed to not throw during handling. So exceptions never pop off the whole stack.</p>
<p>For a stateful function, the top-level handler has to figure out what to do in the case of an exception. For the most part the exceptions are known in advance, so this simply means running the exception or failure continuation in the <code class="docutils literal notranslate"><span class="pre">Task</span></code> instead of the success continuation. The failure continuation will in turn most likely retrieve the exception from the state and return it to the program continuation as an exception value. But the failure continuation could also stop the program or do something completely separate from the main program.</p>
</section>
<section id="cleanup">
<h2>Cleanup<a class="headerlink" href="#cleanup" title="Permalink to this heading"></a></h2>
<p>A function can return early if an exception is thrown. Combined with return/goto/break/continue there can be complex non-linear control flow. It is easy to forget about exceptions when writing some code.</p>
<p>Exception safe code works correctly even when the functions it calls throw exceptions. To avoids an explosion of exception handling code, many languages have a built-in language pattern for performing “cleanups”, actions that must be performed even if an exception is thrown. Often the only reasonable way to ensure exception safety is to use cleanups habitually.</p>
<p>Examples of cleanups are resource deallocation, releasing locks, and rolling back a transaction after failure. Recognizing that an exception can leave things in an unwanted state and that a cleanup pattern should be used may be tricky for inexperienced programmers. Generally, a clean-up action becomes necessary as the result of some “acquire” operation.</p>
<p>C’s <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(err)</span> <span class="pre">goto</span> <span class="pre">cleanup;</span> <span class="pre">...</span> <span class="pre">;</span> <span class="pre">cleanup:</span> <span class="pre">f</span></code> pattern and <code class="docutils literal notranslate"><span class="pre">finally</span></code> place cleanup code after the code that can throw, allowing reading the code top-to-bottom. But then throws act as go-downs and you have to scan down almost the whole function to the finally block to see what cleanups are waiting and if an allocation has a matching clean-up. Also there is an indentation pyramid with nested try-finally. Java 6’s nested <code class="docutils literal notranslate"><span class="pre">finally</span></code> patterns <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">newThing;</span> <span class="pre">try</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span> <span class="pre">finally</span> <span class="pre">{</span> <span class="pre">cleanUp</span> <span class="pre">x</span> <span class="pre">}</span></code> (<a class="reference external" href="http://www.javapractices.com/topic/TopicAction.do?Id=25">standard pattern</a>) and <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">var</span> <span class="pre">null;</span> <span class="pre">try</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">newThing;</span> <span class="pre">...</span> <span class="pre">}</span> <span class="pre">finally</span> <span class="pre">{</span> <span class="pre">if</span> <span class="pre">(x</span> <span class="pre">!=</span> <span class="pre">null)</span> <span class="pre">then</span> <span class="pre">cleanUp</span> <span class="pre">x</span> <span class="pre">}</span></code> (<a class="reference external" href="https://stackoverflow.com/questions/2699209/java-io-ugly-try-finally-block">here</a>) are both awkward and verbose and have been replaced with try-with-resources <code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">(f</span> <span class="pre">=</span> <span class="pre">newThing)</span> <span class="pre">{</span> <span class="pre">}</span></code> (which is still awkward with <a class="reference external" href="https://stackoverflow.com/questions/12552863/correct-idiom-for-managing-multiple-chained-resources-in-try-with-resources-bloc">chained resources</a>). C# has a similar <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">(f</span> <span class="pre">=</span> <span class="pre">newThing)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> syntax. For all of these interleaving resource usages to get <code class="docutils literal notranslate"><span class="pre">alloc</span> <span class="pre">a;</span> <span class="pre">alloc</span> <span class="pre">b;</span> <span class="pre">free</span> <span class="pre">a;</span> <span class="pre">free</span> <span class="pre">b</span></code> is impossible.</p>
<p>Go/Zig’s <code class="docutils literal notranslate"><span class="pre">defer</span></code>, <a class="reference external" href="http://ddili.org/ders/d.en/scope.html">D</a>‘s <code class="docutils literal notranslate"><span class="pre">scope(exit)</span></code>, <code class="docutils literal notranslate"><span class="pre">scope(success)</span></code>, and <code class="docutils literal notranslate"><span class="pre">scope(failure)</span></code> (referring to exiting the scope unconditionally as with <code class="docutils literal notranslate"><span class="pre">defer</span></code>, without exception, or by exception respectively) put the cleanup before the code that uses the resource, right after the code that’s being cleaned up after. It’s easy to verify that allocations match up with their nearby cleanups, but the clean-up is delayed to the scope’s exit. The syntax is very compact, just specify a cleanup function, but is a statement rather than an expression, meaning that the acquire must also be a statement. The pattern nests in the sense that <code class="docutils literal notranslate"><span class="pre">defer</span></code>-ed statements are run latest-defined to earliest-defined on exit, but again doesn’t allow interleaving. <code class="docutils literal notranslate"><span class="pre">defer</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> do not allow returning a resource from a function and skipping the cleanup. They also introduce memory allocation questions since the deferred expressions can capture local variables.</p>
<p>RAII is very similar to <code class="docutils literal notranslate"><span class="pre">defer</span></code> but puts the cleanup in a destructor in a class. The class constructor is the resource handle allocation function, and the destructor is automatically run at the end of the function scope, resulting in no visible syntax overhead - just acquire a resource. It ensures you cannot insert any failure points between the allocation and the start of the cleanup’s scope. A resource can even be allocated with its corresponding cleanup in the middle of an expression. But defining a new class for every cleanup operation is tedious - fortunately in C++0x it is possible to define one “RAII lambda” class and be done. And C++’s semantics define lambda memory handling so there is no allocation issue. Also with C++17 it is apparently possible to copy/move RAII types and store them in a data structure or return them from a function, but it seems fragile.</p>
<p>Finalizers are inspired by RAII but free resources “promptly” as opposed to at the end of the function scope. Similarly to <code class="docutils literal notranslate"><span class="pre">defer</span></code> the cleanup is placed before the code but similarly to <code class="docutils literal notranslate"><span class="pre">finally</span></code> there is a marker at the end of the scope. The pattern is <code class="docutils literal notranslate"><span class="pre">newFinalizer</span> <span class="pre">f;</span> <span class="pre">...</span> <span class="pre">;</span> <span class="pre">use</span> <span class="pre">f</span></code>, where the <code class="docutils literal notranslate"><span class="pre">use</span></code> is at the function or block’s end. The finalizer will run after the <code class="docutils literal notranslate"><span class="pre">use</span></code> if code flows normally and soon after raising an exception otherwise. Finalizers allow nesting, in the natural way <code class="docutils literal notranslate"><span class="pre">newFinalizer</span> <span class="pre">a;</span> <span class="pre">newFinalizer</span> <span class="pre">b;</span> <span class="pre">...;</span> <span class="pre">use</span> <span class="pre">b;</span> <span class="pre">use</span> <span class="pre">a</span></code>, and interleaving, by reordering to <code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">a;</span> <span class="pre">use</span> <span class="pre">b</span></code>. But the execution order on an exception is latest-first. Finalizers also allow returning the allocated resource. It is also possible to embed the finalizer in a resource handle and use RAII style programming - each operation calls <code class="docutils literal notranslate"><span class="pre">use</span></code> and extends the finalizer’s life.</p>
<p>For control flow purposes (ignoring async exceptions) finally can be <a class="reference external" href="https://hackage.haskell.org/package/base-4.16.0.0/docs/src/Control.Exception.Base.html#finally">easily implemented</a> in terms of catch:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="n">finally</span><span class="w"> </span><span class="n">sequel</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="n">catch</span><span class="w"> </span><span class="nf">\</span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">sequel</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">r</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">sequel</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>As an idiom this is verbose due to the repetition of <code class="docutils literal notranslate"><span class="pre">sequel</span></code>, but as a library function this doesn’t matter. Per <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch">JS semantics</a> a try-catch-finally is <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">catch</span> <span class="pre">b)</span> <span class="pre">finally</span> <span class="pre">c</span></code>.</p>
<p>This doesn’t work for two catch clauses though; that translates as <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">catch</span> <span class="pre">(\case</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">...;</span> <span class="pre">c</span> <span class="pre">-&gt;</span> <span class="pre">...)</span></code> rather than <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">catch</span> <span class="pre">b)</span> <span class="pre">catch</span> <span class="pre">c</span></code>.</p>
<section id="cleanup-and-exceptions">
<h3>Cleanup and exceptions<a class="headerlink" href="#cleanup-and-exceptions" title="Permalink to this heading"></a></h3>
<p>Throwing an exception from a cleanup action is somewhat tricky. Say we have</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newFinalizer</span><span class="w"> </span><span class="p">(</span><span class="n">throw</span><span class="w"> </span><span class="kt">Bar</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">throw</span><span class="w"> </span><span class="kt">Foo</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">f</span><span class="w"></span>

<span class="nf">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">catch</span><span class="w"> </span><span class="nf">\</span><span class="kr">case</span><span class="w"></span>
<span class="w">        </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="w"></span>
<span class="w">        </span><span class="kt">Bar</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="s">&quot;bar&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>The finalizer runs as soon as it is known that <code class="docutils literal notranslate"><span class="pre">use</span></code> will not be called - i.e. before the <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">Foo</span></code>. So it is equivalent to <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">Bar;</span> <span class="pre">throw</span> <span class="pre">Foo</span></code> - then <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">Bar</span></code> wins and hence <code class="docutils literal notranslate"><span class="pre">y</span></code> outputs <code class="docutils literal notranslate"><span class="pre">bar</span></code>.</p>
<p>As far as I can tell this is the obvious choice and the choice C++ should have made, but they instead decided to terminate on throwing exceptions from destructors during exception handling. The only justification seems to be that it simplifies the implementation of unwinding.</p>
<p>Finalizers directly implement <code class="docutils literal notranslate"><span class="pre">scope(exit)</span></code>, and with an extra flag variable they can implement <code class="docutils literal notranslate"><span class="pre">scope(success)</span></code> and <code class="docutils literal notranslate"><span class="pre">scope(failure)</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">scope_failure</span><span class="w"> </span><span class="n">rollback</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">flag</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mut</span><span class="w"> </span><span class="n">true</span><span class="w"></span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newFinalizer</span><span class="w"> </span><span class="p">(</span><span class="kr">if</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">rollback</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="p">{})</span><span class="w"></span>
<span class="w">  </span><span class="kt">ScopeFailure</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">f</span><span class="w"></span>

<span class="nf">use</span><span class="w"> </span><span class="p">(</span><span class="kt">ScopeFailure</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">   </span><span class="n">flag</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">false</span><span class="w"></span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">f</span><span class="w"></span>


<span class="nf">s</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">scope_failure</span><span class="w"> </span><span class="n">rollback</span><span class="w"></span>
<span class="nf">code</span><span class="w"></span>
<span class="nf">use</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
</pre></div>
</div>
<p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4152.pdf">Herb Sutter</a> claims that the extra <code class="docutils literal notranslate"><span class="pre">use</span></code> is “tedious and fragile” and forces the programmer to think about the placement of failure determination.</p>
<p>Well, you can define a proper <code class="docutils literal notranslate"><span class="pre">scope_failure</span> <span class="pre">rollback</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> combinator, and even redefine return/continue/break to not run the rollback. But personally I think the finalizers are more powerful because they allow interleaving scopes. The combinators only allow nesting which isn’t as expressive. In Haskell land Snoyman created <a class="reference external" href="https://hackage.haskell.org/package/resourcet">ResourceT</a> even though there was <code class="docutils literal notranslate"><span class="pre">bracket</span></code>, exactly because of this.</p>
<p>The <a class="reference external" href="https://vimeo.com/97329153">D guy</a> claims you need an even larger combinator than bracket, which goes as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span><span class="w"> </span><span class="n">action</span><span class="w"> </span><span class="kr">then</span><span class="w"></span>
<span class="w">  </span><span class="n">when</span><span class="w"> </span><span class="o">!</span><span class="n">next</span><span class="w"></span>
<span class="w">    </span><span class="n">rollback</span><span class="w"></span>
<span class="w">  </span><span class="n">cleanup</span><span class="w"></span>
</pre></div>
</div>
<p>With masking this looks like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">generalBracket</span><span class="w"> </span><span class="n">action</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="n">rollback</span><span class="w"> </span><span class="n">cleanup</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">mask</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">unmasked</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="n">resource</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">action</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">unmasked</span><span class="w"> </span><span class="p">(</span><span class="n">next</span><span class="w"> </span><span class="n">resource</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="n">catch</span><span class="p">`</span><span class="w"> </span><span class="nf">\</span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="kr">_</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">rollback</span><span class="w"> </span><span class="n">resource</span><span class="w"></span>
<span class="w">      </span><span class="kr">_</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">cleanup</span><span class="w"> </span><span class="n">resource</span><span class="w"></span>
<span class="w">      </span><span class="n">throw</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">cleanup</span><span class="w"> </span><span class="n">resource</span><span class="w"></span>
<span class="w">    </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>action has to be masked because there could be an async exception between the action and running next.</p>
</section>
<section id="exception-safety">
<h3>Exception safety<a class="headerlink" href="#exception-safety" title="Permalink to this heading"></a></h3>
<p>This code in Rust or C++ is not exception safe: (based on <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1995/N0623.asc">this code</a> and <a class="reference external" href="https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md#background-what-is-exception-safety-in-rust">this code</a>)</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">push_ten_more</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Vec</span><span class="w"> </span><span class="kt">T</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Op</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Vec</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="o">|</span><span class="n">uninitialized</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="nf">push_ten_more</span><span class="w"> </span><span class="p">(</span><span class="n">this</span><span class="o">@</span><span class="p">(</span><span class="n">readRef</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Vector</span><span class="w"> </span><span class="n">arr</span><span class="p">))</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">new_arr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">alloc</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">indexes</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">copy</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">new_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="n">delete</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="n">this</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="kt">Vector</span><span class="w"> </span><span class="n">new_arr</span><span class="w"></span>

<span class="w">  </span><span class="n">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">t</span><span class="o">.</span><span class="n">clone</span><span class="nb">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The update to the Vector happens when the next 10 elements are uninitialized, and <code class="docutils literal notranslate"><span class="pre">Vec</span></code> has an internal invariant that its elements are safe to deallocate. So if <cite>t.clone</cite> throws then the initialization will not be called. Vec’s destructor that assumes the invariant will then free uninitialized memory.</p>
<p>The basic issue is that Rust and C++ confuse values with resources. Values can be copied without side effects, while resources are expensive to copy. In this code the Rust/C++ semantics require calling a destructor <code class="docutils literal notranslate"><span class="pre">delete</span></code> on each element of a <code class="docutils literal notranslate"><span class="pre">vec</span></code>, and copying values with <code class="docutils literal notranslate"><span class="pre">copy_to_</span></code> and <code class="docutils literal notranslate"><span class="pre">clone</span></code> operations that can fail - almost everything is a resource. In Stroscot almost everything is a value, inert data - copy/clone is built into the language and can’t fail. Similarly we wouldn’t necessarily call any finalizers (<code class="docutils literal notranslate"><span class="pre">delete</span></code>) - the finalizer is called after the last use, and likely there are other copies and this is not the last use. Even if the Stroscot code was written to call an operation <code class="docutils literal notranslate"><span class="pre">clone</span></code> that could throw exceptions, the rest of the elements will be deallocated if needed, but otherwise not. In all cases memory is safe due to the finalizer semantics.</p>
<p>A smaller issue is the uninitialized array. This means the array may be filled with <code class="docutils literal notranslate"><span class="pre">uninitialized</span></code> values (exceptions). The result type reflects this possibility. With careful rewriting, the code can provide the strong guarantee that the resulting vector only contains values of type T. This can be done by extending the array one element at a time or by saving the exception(s) thrown in a separate list and rethrowing at the end as an exception group.</p>
<p>Besides explicit memory management, broken logical invariants are rarely observed. Reasoning about invariants with pure values is straightforward, and fail-fast coding styles mean that the program doesn’t live long. And when writing cleanups the programmer is already thinking about exception safety and restoring invariants, so will write an exception-safe cleanup.</p>
<p>To write an exception safe operation on a mutable data structure, there are two steps:
* identify invariants of data structures. These can be written as assertions using the pure read operations on stores. With this the static verification will identify the function and the exceptional control flow that breaks the invariant.
* place exception cleanup handlers to restore broken invariants</p>
<p>C++ has <a class="reference external" href="https://en.wikipedia.org/wiki/Exception_safety">levels of safety</a> for stateful functions based on what invariants are preserved.</p>
<ul class="simple">
<li><p>no-throw means forward progress is guaranteed and no exceptions will emerge. This can be enforced by never throwing exceptions, only calling other no-throw functions, and forbidding async exceptions. But the entire ecosystem uses exceptions. So people create forks of existing libraries that eradicate exceptions. The Windows kernel, for instance, has its own fork of the STL that doesn’t use exceptions. This bifurcation of the ecosystem is neither pleasant nor practical to sustain.</p></li>
<li><p>Strong safety means that state transitions happen atomically and a failure will return to the old state. To ensure this one needs basic safety and to copy the relevant data beforehand and write it back afterwards.  This is infeasible for even simple data structures in C++ due to overloaded assignment and copy operators being able to throw.</p></li>
<li><p>Basic safety means that the final state will be valid, i.e. all invariants hold. You need to safeguard against each function call throwing. This requires adding handling code to each call and trusting the documentation for the list of thrown exceptions (or using no-throw).</p></li>
</ul>
<p>These levels only work for stateful data structures that call a small and easily auditable set of other functions.</p>
<p>A simple example is <code class="docutils literal notranslate"><span class="pre">TwoList</span></code>, which maintains two mutable linked lists with the invariant that they are the same. What does adding an element look like?</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">List</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">head</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">l</span><span class="w"></span>
<span class="w">  </span><span class="n">l</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">head</span><span class="w"></span>

<span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">TwoLists</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="n">l2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">l1</span><span class="w"></span>
<span class="w">  </span><span class="n">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">l2</span><span class="w"></span>
</pre></div>
</div>
<p>But this is not exception safe for the invariant, because an async exception between the two adds may add a to l1 but not l2.</p>
<p>If add is no-throw we can fix this just by adding uninterruptibleMask. But add allocates so can throw out of memory. But remove is no-throw so we can use remove:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">TwoLists</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="n">l2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">mask_</span><span class="w"> </span><span class="o">$</span><span class="w"></span>
<span class="w">    </span><span class="kr">case</span><span class="w"> </span><span class="n">try</span><span class="w"> </span><span class="p">(</span><span class="n">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">l1</span><span class="p">)</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">      </span><span class="kt">Err</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
<span class="w">      </span><span class="kt">Ok</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">        </span><span class="kr">case</span><span class="w"> </span><span class="n">try</span><span class="w"> </span><span class="p">(</span><span class="n">allowInterrupt</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">l2</span><span class="p">)</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">          </span><span class="kt">Ok</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">return</span><span class="w"></span>
<span class="w">          </span><span class="kt">Err</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">uninterruptibleMask</span><span class="w"> </span><span class="p">(</span><span class="n">remove</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">l1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
</pre></div>
</div>
<p>Here add should have strong safety, i.e. it restores the state if an exception is thrown during the add.</p>
</section>
<section id="poisoning">
<h3>Poisoning<a class="headerlink" href="#poisoning" title="Permalink to this heading"></a></h3>
<p>Rust has “poisoning” for taking locks. Essentially this uses the scope_failure cleanup to poison the lock on failure:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">getGuard</span><span class="w"> </span><span class="n">mutex</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">acquireLock</span><span class="w"> </span><span class="n">mutex</span><span class="w"></span>
<span class="w">  </span><span class="n">flag</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mut</span><span class="w"> </span><span class="n">true</span><span class="w"></span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newFinalizer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="kr">then</span><span class="w"></span>
<span class="w">      </span><span class="n">poisonLock</span><span class="w"> </span><span class="n">mutex</span><span class="w"></span>
<span class="w">    </span><span class="n">releaseLock</span><span class="w"> </span><span class="n">mutex</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kt">Guard</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">f</span><span class="w"></span>

<span class="nf">finishGuard</span><span class="w"> </span><span class="p">(</span><span class="kt">Guard</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">flag</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">false</span><span class="w"></span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">f</span><span class="w"></span>
</pre></div>
</div>
<p>Once the lock is poisoned then locking the mutex will throw an exception. This is a safeguard against trying to use data that was corrupted due to an exception, e.g. a concurrent heap that doesn’t have the heap property anymore.</p>
<p>Although poisoning by default allows using multithreading without having to consider exception safety across threads (as poisoned data will tear down all connected threads), invariant checking also covers single-threaded exception safety. But a PoisoningMutex can at least be in the standard library for those who want the functionality.</p>
</section>
</section>
<section id="syntax">
<h2>Syntax<a class="headerlink" href="#syntax" title="Permalink to this heading"></a></h2>
<p>The Swift error handling rationale classifies unwinding by the syntax required:</p>
<ul class="simple">
<li><p>manual: propagation is done with control operators or structures (if return code in C, NSError out parameter in Objective-C, Maybe or Either ADT in Haskell)</p></li>
<li><p>automatic: propagation happens according to rules defined by the language</p></li>
</ul>
<p>Manual propagation has tedious repetitive boilerplate, making programmers discouraged and code less readable and maintainable. But since manually propagated exceptions can be implemented with basic language facilities (out parameters, conditionals) they don’t need any special considerations and are always available. The boilerplate marks the call site and that the function can throw exceptions (e.g. an out-parameter named <code class="docutils literal notranslate"><span class="pre">error</span></code>), so it is also marked propagation and typed propagation. Ignoring an exception that is returned through a side channel is a coding error - it does not make manual exception propagation “untyped” as the Swift document claims. Unsafe, perhaps.</p>
<p>Automatic propagation is more succinct and efficient, and besides complicating the language there’s not much reason to avoid it.</p>
<p><code class="docutils literal notranslate"><span class="pre">throw</span></code> / <code class="docutils literal notranslate"><span class="pre">catch</span></code> have become the common keywords after C++ and Java, but it’s syntactically heavyweight. Exceptions aren’t magic and don’t need special syntax. With a variant type like <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b|Exception</span></code> a function returns either a value or an exception. So just use the normal <code class="docutils literal notranslate"><span class="pre">return</span></code> keyword to return exceptions. Then to respond to specific exceptions programmatically, returned exception-or-values can be pattern-matched like any other return value:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="kt">AnException</span><span class="w"></span>

<span class="nf">bar</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">  </span><span class="kt">AnException</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="s">&quot;ohno&quot;</span><span class="w"></span>
<span class="w">  </span><span class="n">r</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="s">&quot;success&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>The case handling syntax seems easy and clear, and it’s possible to locally reason about and decide how best to react to exceptions.
But a Quorum-style study should check on what’s clearest to beginners. Limiting <code class="docutils literal notranslate"><span class="pre">return</span></code> to normal values and using <code class="docutils literal notranslate"><span class="pre">throw</span></code> for <code class="docutils literal notranslate"><span class="pre">Exception</span></code> values is also a possibility.</p>
<p>Just because there is shared syntax doesn’t mean exceptions don’t propagate, exceptions still unwind if they aren’t caught by the case statement. They can be wrapped up in a Result type though to prevent propagation.</p>
<p><code class="docutils literal notranslate"><span class="pre">error</span> <span class="pre">&quot;something</span> <span class="pre">bad</span> <span class="pre">happened&quot;</span></code> creates an exception in a pure value that needs to be evaluated before it’s thrown. But it’s bad practice. String-based exception messages make proper exception handling difficult. Instead, it’s best to define a custom exception type SomethingBad, which is trivial to catch, <code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">(\SomethingBad</span> <span class="pre">-&gt;</span> <span class="pre">...)</span></code>.</p>
<blockquote>
<div><p>wheres <code class="docutils literal notranslate"><span class="pre">throwM</span></code> throws it in the monad and gives ordering guarantees.</p>
</div></blockquote>
<p>try X else catch - wraps into Either type, an exception value (failure) or a normal value (success)
try X else Y - presubstitute Y on exception</p>
<p>NaN style propagation - <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> is either an exception or the sum. Problem: <code class="docutils literal notranslate"><span class="pre">ExceptionA</span> <span class="pre">+</span> <span class="pre">ExceptionB</span></code>, which exception gets returned? Depends on evaluation strategy, compiler implementation detail. (SPJ says “nondeterministic”)</p>
<p>exception type - In C integer constants. Used for Linux / Windows kernel programming. Go uses tuple (result,exception code) with nil code on success. Rust uses polymorphic Result type. Swift uses an Error protocol (interface class). Java uses a Throwable class.</p>
<p>In C style you use an OUT parameter and a boolean flag for exception or value. The out parameter can hold either the flag or the actual return value. With the return value in the out parameter, a nested function call <code class="docutils literal notranslate"><span class="pre">f(g(x))</span></code> looks like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">auto</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="kt">ERROR</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="p">))</span><span class="w"></span>
<span class="w">     </span><span class="n">errorhandling</span><span class="p">;</span><span class="w"></span>
<span class="nf">auto</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="kt">ERROR</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">))</span><span class="w"></span>
<span class="w">     </span><span class="n">errorhandling</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Here we need a temporary for each return value and the exception details are stored in a global variable. Objective C uses an out-parameter <code class="docutils literal notranslate"><span class="pre">NSError**</span></code>.</p>
<p>With the flag/exception as an out parameter it looks like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">NSError</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="nf">auto</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>
<span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="n">isError</span><span class="p">(</span><span class="n">err</span><span class="p">))</span><span class="w"></span>
<span class="w">     </span><span class="n">errorhandling</span><span class="p">;</span><span class="w"></span>
<span class="nf">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"></span>
<span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="n">isError</span><span class="p">(</span><span class="n">err</span><span class="p">))</span><span class="w"></span>
<span class="w">     </span><span class="n">errorhandling</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The same variable is used as an out-parameter multiple times; but the exception must be checked each time to avoid later calls overwriting the variable.
Either way it’s ugly and annoying but it’s better than getting magic unexpected gotos sprinkled throughout your code at unpredictable places.</p>
<p>Go uses multiple return values for exception codes. You reuse err for each call, so you write:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">v1</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="kt">Foo</span><span class="p">(</span><span class="n">false</span><span class="p">)</span><span class="w"></span>
<span class="kr">if</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">fmt</span><span class="o">.</span><span class="kt">Println</span><span class="p">(</span><span class="s">&quot;error&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">return</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nf">fmt</span><span class="o">.</span><span class="kt">Println</span><span class="p">(</span><span class="s">&quot;first&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">)</span><span class="w"></span>
<span class="nf">v2</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="kt">Foo</span><span class="p">(</span><span class="n">true</span><span class="p">)</span><span class="w"></span>
<span class="kr">if</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">fmt</span><span class="o">.</span><span class="kt">Println</span><span class="p">(</span><span class="s">&quot;error&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">return</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nf">fmt</span><span class="o">.</span><span class="kt">Println</span><span class="p">(</span><span class="s">&quot;second&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>You can forget the if condition. Because <cite>err</cite> is used in other places it will not trigger an unused variable warning, but the errcheck linter finds missing checks every time.</p>
<p>In functional languages there’s the <code class="docutils literal notranslate"><span class="pre">Either</span></code> variant type or its less informative cousin <code class="docutils literal notranslate"><span class="pre">Optional</span> <span class="pre">=</span> <span class="pre">Either</span> <span class="pre">()</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">write_line</span> <span class="pre">:</span> <span class="pre">(&amp;mut</span> <span class="pre">self,</span> <span class="pre">s:</span> <span class="pre">&amp;str)</span> <span class="pre">-&gt;</span> <span class="pre">Result&lt;(),</span> <span class="pre">IoError&gt;</span></code> in Rust, Scala’s Option/Try, <a class="reference external" href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html">https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html</a>.
This forces the caller to deal with the exception if they want to use the
result.  This works well unless the call does not really have a
meaningful result (as <code class="docutils literal notranslate"><span class="pre">write_line</span></code> does not); then it depends on
whether there is a warning for ignoring results. Variant types
also tends to create a lot of nesting, one level for every sequential
computation that can fail:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fn</span><span class="w"> </span><span class="n">parse_two_ints_and_add_them</span><span class="nb">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">match</span><span class="w"> </span><span class="n">parse_int</span><span class="nb">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">Err</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Err</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
<span class="w">    </span><span class="kt">Ok</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="n">parse_int</span><span class="nb">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">Err</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Err</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
<span class="w">      </span><span class="kt">Ok</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Ok</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A bind operator addresses the exception handling but still requires nesting:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fn</span><span class="w"> </span><span class="n">parse_two_ints_and_add_them</span><span class="nb">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">parse_int</span><span class="nb">()</span><span class="o">.</span><span class="n">and_then</span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">    </span><span class="n">parse_int</span><span class="nb">()</span><span class="o">.</span><span class="n">and_then</span><span class="p">(</span><span class="nf">\</span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">      </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>To solve nesting Rust has introduced the question mark operator:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fn</span><span class="w"> </span><span class="n">parse_two_ints_and_add_them</span><span class="nb">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">parse_int</span><span class="nb">()</span><span class="o">?</span><span class="w"></span>
<span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">parse_int</span><span class="nb">()</span><span class="o">?</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="kt">OK</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>defining a custom exception type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">symbol</span><span class="w"> </span><span class="kt">SomethingBad</span><span class="w"></span>
<span class="nf">show</span><span class="w"> </span><span class="kt">SomethingBad</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;something bad happened&quot;</span><span class="w"></span>
<span class="nf">isException</span><span class="w"> </span><span class="kt">SomethingBad</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">true</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="kt">SomethingBad</span><span class="w"></span>
</pre></div>
</div>
<p>Example: interacting with a file.
Let’s consider the simplest form, suitable for scripting tasks and other things where you don’t want to think too much:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">readFile</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">handle</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">openFile</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="kt">ReadMode</span><span class="w"></span>
<span class="w">  </span><span class="n">readAllBytes</span><span class="w"> </span><span class="n">handle</span><span class="w"></span>
</pre></div>
</div>
<p>Opening might fail and interacting with the file handle might fail. How do we handle this?</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">readFileHandled</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">handle</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">openFile</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="kt">ReadMode</span><span class="w"></span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">NoSuchThing</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">handle</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="kr">_</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Handle</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">readAllBytes</span><span class="w"> </span><span class="n">handle</span><span class="w"></span>

<span class="nf">readFileSafe</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">eres</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">try</span><span class="w"> </span><span class="p">(</span><span class="n">openFile</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="kt">ReadMode</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">eres</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">Error</span><span class="w"> </span><span class="kt">NoSuchThing</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">eres</span><span class="w"></span>
<span class="w">    </span><span class="kt">Result</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">readAllBytes</span><span class="w"> </span><span class="n">handle</span><span class="w"></span>
</pre></div>
</div>
<p>In first, we represent failure via return values. E.g. if the file doesn’t exist, <code class="docutils literal notranslate"><span class="pre">openFile</span></code> returns <code class="docutils literal notranslate"><span class="pre">NoSuchThing</span></code> rather than a file handle, i.e. <code class="docutils literal notranslate"><span class="pre">openFile</span> <span class="pre">&quot;nonexistent&quot;</span></code> reduces to <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">NoSuchThing</span></code> (<code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">NoSuchThing</span></code>), type <code class="docutils literal notranslate"><span class="pre">((Handle|Error)</span> <span class="pre">-&gt;</span> <span class="pre">Task)</span> <span class="pre">-&gt;</span> <span class="pre">Task</span></code>. In second, the task instead reduces to an exception (a non-task value), i.e. <code class="docutils literal notranslate"><span class="pre">openFile</span> <span class="pre">&quot;nonexistent&quot;</span></code> reduces to <code class="docutils literal notranslate"><span class="pre">NoSuchThing</span></code>, type <code class="docutils literal notranslate"><span class="pre">(Handle</span> <span class="pre">-&gt;</span> <span class="pre">Task)</span> <span class="pre">-&gt;</span> <span class="pre">TaskE</span> <span class="pre">where</span> <span class="pre">TaskE</span> <span class="pre">=</span> <span class="pre">Exception</span> <span class="pre">|</span> <span class="pre">Task</span> <span class="pre">{</span> <span class="pre">Task</span> <span class="pre">=</span> <span class="pre">TaskE</span> <span class="pre">}</span></code>.</p>
<p>So the programs look like <code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">&gt;&gt;=</span> <span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">readAllBytes</span> <span class="pre">NoSuchThing</span> <span class="pre">cont</span></code> versus <code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">&gt;&gt;=</span> <span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">NoSuchThing</span> <span class="pre">(\handle</span> <span class="pre">-&gt;</span> <span class="pre">readAllBytes</span> <span class="pre">handle</span> <span class="pre">cont)</span></code>. With strict semantics both of these reduce to <code class="docutils literal notranslate"><span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">NoSuchThing</span></code>.</p>
<p>With the second we need <code class="docutils literal notranslate"><span class="pre">try</span></code> to walk through the <code class="docutils literal notranslate"><span class="pre">Task</span></code> structure until it hits an exception or the end of the continuation. So the first is nicer. But the second might be useful for tasks that don’t return a value and fail rarely.</p>
<p>The two approaches can be stacked; <code class="docutils literal notranslate"><span class="pre">openFile</span></code> could return a <code class="docutils literal notranslate"><span class="pre">Symlink</span></code> value as well as reducing to a <code class="docutils literal notranslate"><span class="pre">NoSuchThing</span></code> exception. Then <code class="docutils literal notranslate"><span class="pre">try</span></code> will return <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">Symlink</span></code> but a <code class="docutils literal notranslate"><span class="pre">Error</span> <span class="pre">NoSuchThing</span></code>. But this is an abomination.</p>
<p>Consider the following function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">func</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lookup</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">  </span><span class="n">bar</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lookup</span><span class="w"> </span><span class="s">&quot;bar&quot;</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">  </span><span class="n">baz</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lookup</span><span class="w"> </span><span class="s">&quot;baz&quot;</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="n">baz</span><span class="w"></span>
</pre></div>
</div>
<p>We want composability and a unified interface across Maybe, Either, and IO. Say we need to know about why a lookup failed. <code class="docutils literal notranslate"><span class="pre">lookup</span> <span class="pre">k</span></code> could throw <code class="docutils literal notranslate"><span class="pre">KeyNotFound</span> <span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">lookup</span> <span class="pre">::</span> <span class="pre">(Eq</span> <span class="pre">k)</span> <span class="pre">=&gt;</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">[(k,</span> <span class="pre">v)]</span> <span class="pre">-&gt;</span> <span class="pre">(KeyNotFound</span> <span class="pre">k|v)</span></code>. Exceptions should unwind like Either, so if any of the lookups fail then func returns the failure. We should be able to specify a default for lookup like with <code class="docutils literal notranslate"><span class="pre">maybe</span></code>, <code class="docutils literal notranslate"><span class="pre">lookup</span> <span class="pre">key</span> <span class="pre">m</span> <span class="pre">{KeyNotFound</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">Nothing}</span></code>.  The type of <code class="docutils literal notranslate"><span class="pre">f</span></code> should not contain the lookup exceptions, <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">::</span> <span class="pre">SomeVal</span> <span class="pre">-&gt;</span> <span class="pre">SomeVal</span> <span class="pre">-&gt;</span> <span class="pre">SomeVal</span> <span class="pre">-&gt;</span> <span class="pre">(F'sExceptionType|F'sResult)</span></code>.</p>
<section id="try">
<h3>Try<a class="headerlink" href="#try" title="Permalink to this heading"></a></h3>
<p>Swift/Rust define syntactic markers for local exception propagation points, a “try” or “?” keyword at the call site. <code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">foo()</span></code> examines the ValueOrError type that <code class="docutils literal notranslate"><span class="pre">foo()</span></code> returns. If it is an exception, <code class="docutils literal notranslate"><span class="pre">try</span></code> unwinds/propagates/throws/returns the exception from the function, otherwise the function continues with the value. The claim is that without <code class="docutils literal notranslate"><span class="pre">try</span></code> exceptions are silent or invisible.</p>
<p>But in practice this is very burdensome. Every call involves an annotation, either on the function (to say it cannot generate exceptions) or on the call site (to mark propagation). It’s a lot of bookkeeping. Many languages have implemented exception handling just fine without this burden.</p>
<p>Precise signatures (discussed in the next section) offer a similar guarantee - the throwing function must be annotated to say it can throw, and the catching function must be annotated to say it can catch. But unlike <code class="docutils literal notranslate"><span class="pre">try</span></code>, with precise signatures for a call chain <code class="docutils literal notranslate"><span class="pre">A-B-C</span></code> the intervening <code class="docutils literal notranslate"><span class="pre">B</span></code> does not need any modification when <code class="docutils literal notranslate"><span class="pre">C</span></code> starts throwing exceptions, and the modifications must still be made even if <code class="docutils literal notranslate"><span class="pre">C</span></code> already throws exceptions.</p>
<p>Even without <code class="docutils literal notranslate"><span class="pre">try</span></code>, it is still possible to understand the control flow of a function - just assume every operation may throw an exception, and code accordingly. Indeed, async exceptions, OOM, and other “universal” exceptions can be thrown from almost anywhere, so <code class="docutils literal notranslate"><span class="pre">try</span></code> is just noise on every function call if these are included.</p>
<p>Still though, some people may like seeing where exceptions come from. So there is a warning <code class="docutils literal notranslate"><span class="pre">-Wunmarked-exception</span></code> that takes a set of exceptions as argument and warns for each callsite not marked with the identity function <code class="docutils literal notranslate"><span class="pre">rethrowing</span></code> that can propagate exceptions from the set. With this warning you can get Swift-like behavior for a subset of exceptions.</p>
</section>
<section id="exit-points">
<h3>Exit points<a class="headerlink" href="#exit-points" title="Permalink to this heading"></a></h3>
<p>non-local control problem: To know the resulting state by the time exception gets caught, need to know
- a program’s state at the time of the throw
- the state changes that occur while that exception is propagated up the call stack - and possibly across threads in a concurrent program</p>
<p>exceptions create an abrupt jump from one point of code to another, like goto. They create too many possible exit points for a function. To write correct code, you really have to think about every possible code path through your function. Every time you call a function that can raise an exception and don’t catch it on the spot, you create opportunities for surprise bugs caused by functions that terminated abruptly, leaving data in an inconsistent state, or other code paths that you didn’t think about.</p>
<p>It is true that what should be a simple 3 line program often blossoms to 48 lines when you put in good exception checking, but that’s life, and papering it over with exceptions does not make your program more robust.</p>
</section>
</section>
<section id="signatures">
<h2>Signatures<a class="headerlink" href="#signatures" title="Permalink to this heading"></a></h2>
<p>Callers have to code to handle the exceptions, so they need to know which exceptions are thrown. The exception set is part of the return type and function semantics.</p>
<p>Sample signature styles (enforced by the compiler where relevant):
1. <code class="docutils literal notranslate"><span class="pre">precise</span></code> - the set of thrown exceptions is listed in the signature. All possible exceptions given the types of the arguments are listed, and no unreachable exceptions are allowed in the list.
2. <code class="docutils literal notranslate"><span class="pre">lower</span></code> - a set of definitely thrown exceptions are listed, but other exceptions may be thrown
3. <code class="docutils literal notranslate"><span class="pre">upper</span></code> - like precise, all possible exceptions must be listed, but unreachable excpetions may also be listed</p>
<p>With <code class="docutils literal notranslate"><span class="pre">lower</span></code> it is not possible to say that a function doesn’t throw, but with the other two it is.</p>
<section id="call-chains">
<h3>Call chains<a class="headerlink" href="#call-chains" title="Permalink to this heading"></a></h3>
<p>The <a class="reference external" href="http://web.archive.org/web/20060101083304/http://discuss.develop.com/archives/wa.exe?A2=ind0011A&amp;L=DOTNET&amp;P=R32820">C# post</a> complains that if you have a chain <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">catch</span> <span class="pre">...;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">c;</span> <span class="pre">c</span> <span class="pre">=</span> <span class="pre">d;</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">...</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code> is changed from no-throw to throwing <code class="docutils literal notranslate"><span class="pre">SomeException</span></code>, then <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code> must have <code class="docutils literal notranslate"><span class="pre">...|SomeException</span></code> added to their type.</p>
<p>This is similar to Java’s checked exceptions and Swift says they like this requirement because it adds extra static safety. When you add a new exception to <code class="docutils literal notranslate"><span class="pre">d</span></code> you get exception messages for all the call sites and can decide to handle or propagate to fix each site. Swift gets a similar but less precise safety check from marking call sites as throwing with <code class="docutils literal notranslate"><span class="pre">try</span></code>.</p>
<p>But the C# posts says having to change all the type signatures just to throw an exception is a pain. It encourages “swallowing” exceptions by catching and ignoring them, instead of changing the signatures. Swallowing can result in an inconsistent state with no debugging traces. Handling exceptions at the appropriate place is better - e.g. in this case function <code class="docutils literal notranslate"><span class="pre">a</span></code> might have more knowledge of the state of the world.</p>
<p>With exception set synonyms the amount of work needed to add an exception can be minimized. Java only allows defining synonyms with superclasses, which isn’t really composable if you have different libraries. But set union and difference are quite useful and mean that the program can adapt to exception behavior without advance planning.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">lower</span></code> style of signature doesn’t require any synonyms because exceptions can be omitted from the signatures. This is the most efficient in terms of productivity because the code requires no extra work for exception changes. If a user wants to document that some exceptions are thrown they can add them to the signature. But it isn’t required, and it adds extra work later if you want to stop throwing the exception.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">upper</span></code> a synonym style is to define one exception set <code class="docutils literal notranslate"><span class="pre">LibraryException</span></code> with all the common exceptions your library throws (overflow, divide by zero, out of memory, etc.) and use that in each signature. It is not too hard to maintain a single exception set for a library. It’s a little better than Java’s <code class="docutils literal notranslate"><span class="pre">throws</span> <span class="pre">Exception</span></code> because the exception set is finite, but requires almost as little maintenance as <code class="docutils literal notranslate"><span class="pre">lower</span></code>. Exceptions that people should care about can be documented by adding them redundantly to the signature, <code class="docutils literal notranslate"><span class="pre">DivideByZero|LibraryException</span></code>. And exceptions that aren’t thrown can be asserted by removing them, e.g. <code class="docutils literal notranslate"><span class="pre">LibraryException\DivideByZero</span></code>.
Application code can use set operations to build a combined set, <code class="docutils literal notranslate"><span class="pre">AppException=(Library1Exception|Library2Exception)\(HandledException1|HandledException2)</span></code>.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">precise</span></code>, the style I came up with is to have a built-in compiler function <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">_</span></code> that computes the exception set of each function. Then for the actual signature you can write a self-referential signature <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">...</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">|</span> <span class="pre">exceptions</span> <span class="pre">a</span></code>, if you don’t want to make any guarantees about exception behavior, or <code class="docutils literal notranslate"><span class="pre">Int</span> <span class="pre">|</span> <span class="pre">(exceptions</span> <span class="pre">a</span> <span class="pre">\</span> <span class="pre">SomeException)</span></code>, to say that <code class="docutils literal notranslate"><span class="pre">SomeException</span></code> is not thrown, or <code class="docutils literal notranslate"><span class="pre">Int</span> <span class="pre">|</span> <span class="pre">(exceptions</span> <span class="pre">a</span> <span class="pre">|</span> <span class="pre">SomeException)</span></code>, to say that <code class="docutils literal notranslate"><span class="pre">SomeException</span></code> is definitely thrown. <code class="docutils literal notranslate"><span class="pre">exception</span> <span class="pre">x</span></code> is somewhat magical is that it knows the rest of the signature and scopes the list of exceptions appropriately, e.g. for the signature <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">|</span> <span class="pre">ExceptionA</span></code>, <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">ExceptionA</span></code>, but for the signature <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span> <span class="pre">|</span> <span class="pre">ExceptionB</span></code>, <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">ExceptionB</span></code>, and similarly in the signature <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">|</span> <span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">|</span> <span class="pre">Bool</span> <span class="pre">|</span> <span class="pre">exceptions</span> <span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">ExceptionA</span> <span class="pre">|</span> <span class="pre">ExceptionB</span></code>.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">precise</span></code> you can also write a specification without referencing <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">a</span></code>. doing a “full list” of all the component exceptions, or a “computed list” writing the set as a computation of child functions. So if <code class="docutils literal notranslate"><span class="pre">a</span></code> returns <code class="docutils literal notranslate"><span class="pre">Int</span></code> normally and calls <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code> and catches <code class="docutils literal notranslate"><span class="pre">SomeException</span></code> from <code class="docutils literal notranslate"><span class="pre">b</span></code>, then the computed list would be <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">|</span> <span class="pre">(exceptions</span> <span class="pre">b</span> <span class="pre">\</span> <span class="pre">SomeException)</span> <span class="pre">|</span> <span class="pre">exceptions</span> <span class="pre">c</span></code>. Both types of list cost some thought but ensure reliability as every exception is accounted for. A full list ensures that control flow is local because newly thrown exceptions must be caught or added to the list for every method in the chain. A computed list does not list exceptions that propagate through the function, so is less verbose. To newly throw an exception, it only needs to listed where it is thrown and where it is caught.</p>
<p>Lists are somewhat mindless in that the compiler knows the exceptions thrown better than the developer. The compiler should be able to compute <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">x</span></code> precisely and report it to the user, even if no annotations are used. In fact there should be two ways of reporting it, to follow the two styles of list: listing out all the thrown exceptions as a set (using predefined sets but not referencing any computed <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">x</span></code>), or printing how to compute the thrown exceptions based on the thrown exceptions of the child functions (using <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">x</span></code> as closely as possible). Then the developer can read the spec, see that it looks alright, and copy it as a signature, and with an IDE fix signatures in just a few clicks.</p>
<p>So with <code class="docutils literal notranslate"><span class="pre">lower</span></code> or the self-referential <code class="docutils literal notranslate"><span class="pre">precise</span></code> style, no extra work is required to throw an exception, with <code class="docutils literal notranslate"><span class="pre">upper</span></code> one synonym has to be changed (the global list), with <code class="docutils literal notranslate"><span class="pre">precise</span></code> “computed list” style two signatures have to be changed (the thrower and the catcher), and with <code class="docutils literal notranslate"><span class="pre">precise</span></code> “full list” style all signatures between thrower and catcher have to be changed.</p>
<p>The full list style is attractive for small projects, but as Gunnerson says, for large projects this requires too much maintenance and thus decreases productivity and code quality. But there are various viable alternatives, with varying levels of precision.</p>
</section>
<section id="java-checked-exceptions">
<h3>Java checked exceptions<a class="headerlink" href="#java-checked-exceptions" title="Permalink to this heading"></a></h3>
<p>Java uses <code class="docutils literal notranslate"><span class="pre">upper</span></code> but with a set of unchecked exceptions (Error and RuntimeException) implicitly included as possibilities. For practical purposes this is basically the same as <code class="docutils literal notranslate"><span class="pre">upper</span></code>. With the call chain-compatible style it’s just defining <code class="docutils literal notranslate"><span class="pre">LibraryException=...|RuntimeException</span></code> - it doesn’t really affect the style. RuntimeException is overly broad, for example division by zero should be checked.</p>
<p>A minimal set of common exceptions is those that pure functions can throw without using an explicit throw statement: async exceptions, OOM, stack overflow, and nontermination. But here it is still arguable that nontermination shouldn’t be a common exception because most pure functions terminate and knowing that a function doesn’t return is useful. With <code class="docutils literal notranslate"><span class="pre">upper</span></code> the problem is resolved definitively because there are no implicitly allowed exceptions.</p>
<p>A reduction in the cost of checked exceptions is to use a single “throws” keyword that allows all checked exceptions (similar to “throws Exception” in Java). The pain of versioning is reduced: either a function fails or it doesn’t. The failure code is often irrelevant to handling. Swift, Midori approach. I like the synonym style of <code class="docutils literal notranslate"><span class="pre">upper</span></code> better, and using <code class="docutils literal notranslate"><span class="pre">|Exception</span></code> with <code class="docutils literal notranslate"><span class="pre">upper</span></code> to mimic this style is an option.</p>
</section>
<section id="default-signature-type">
<h3>Default signature type<a class="headerlink" href="#default-signature-type" title="Permalink to this heading"></a></h3>
<p>For user types what exception style should signatures like <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> use by default?</p>
<p>The compiler will use model checking for coverage checking and code generation, so most spurious warnings that an impossible exception can escape won’t appear - e.g. checking that a string contains only digits will ensure that the <code class="docutils literal notranslate"><span class="pre">parseInteger</span></code> function doesn’t fail, so the compiler won’t warn about an uncaught <code class="docutils literal notranslate"><span class="pre">FailedParse</span></code> exception. If the compiler can’t prove it directly then an assertion will ensure an assertion failure  is thrown instead of the exception.</p>
<p>And the return type doesn’t matter for overloading. But there is still the input validation situation where you know that a file is CSV but the compiler will warn that the parse can fail.</p>
<p>Going off of Haskell pure functions are common and should use minimal syntax. But pure functions can still fail with exceptions - assertions, OOM, etc. Similarly system calls may throw rare exception codes that don’t need to be handled in practical programming. <code class="docutils literal notranslate"><span class="pre">precise</span></code> or <code class="docutils literal notranslate"><span class="pre">upper</span></code> would be verbose with maintaining the exception lists. <code class="docutils literal notranslate"><span class="pre">lower</span></code> gives succinct type signatures: write the exceptions that callers should care about and ignore the rest.  So for example one can write <code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">:</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">:</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">a|EmptyListException</span></code> depending on what’s important.</p>
<p>With proper set definitions as in the previous section <code class="docutils literal notranslate"><span class="pre">precise</span></code> and <code class="docutils literal notranslate"><span class="pre">upper</span></code> may not be so bad. These styles are definitely useful, but even so the signatures may be too complex for most users. In the end my preference is <code class="docutils literal notranslate"><span class="pre">lower</span></code> by default and <code class="docutils literal notranslate"><span class="pre">precise</span></code> for <code class="docutils literal notranslate"><span class="pre">total</span></code> declarations. But it still needs a survey to confirm this, as with most syntax decisions.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">lower</span></code> there can be a warning that a listed exception has no handling code anywhere in the program (uncaught exception). Doing a similar thing with <code class="docutils literal notranslate"><span class="pre">upper</span></code> or <code class="docutils literal notranslate"><span class="pre">precise</span></code> would give false positives for uncommon exceptions like the unknown system call codes that don’t need to be handled.</p>
</section>
<section id="fresh-exceptions">
<h3>Fresh exceptions<a class="headerlink" href="#fresh-exceptions" title="Permalink to this heading"></a></h3>
<p>A model where every function can randomly return exceptions is good <a class="reference external" href="https://en.wikipedia.org/wiki/Chaos_engineering">chaos engineering</a>. A function that doesn’t throw exceptions can still be typed as throwing exceptions, and with automatic exception propagation, there is often no actual handling code needed when adding a new exception. We can formalize this with the notion of “fresh” exceptions, exceptions using new (fresh) symbols that may or may not be in various sets. Propagating and catching such exceptions is dependent entirely on the sets the exception is in and are the same for all fresh exceptions in the same sets. If the function is written to handle one such “fresh” exception appropriately then it can be inferred to handle all fresh exceptions appropriately. And with async exceptions, all functions must be written to handle fresh exceptions or to handle async exceptions as a set.</p>
<p>Adding or removing a fresh exception to a function throwing a lot of fresh exceptions is not a semantic change - the function still throws fresh exceptions. The semantic behavior comes when there is a handler that matches on the exception. Removing said exception from the throw list results in dead code but does not break any contracts if the function’s invariants still hold. So the only breaking API change is adding a non-fresh exception that client code unexpectedly matches. For example if you have <code class="docutils literal notranslate"><span class="pre">{a;</span> <span class="pre">b}</span> <span class="pre">catch</span> <span class="pre">(\FooException</span> <span class="pre">-&gt;</span> <span class="pre">...)</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span></code> is throwing <code class="docutils literal notranslate"><span class="pre">FooException</span></code>, then <code class="docutils literal notranslate"><span class="pre">b</span></code> also throwing <code class="docutils literal notranslate"><span class="pre">FooException</span></code> could lead to unexpected results if the handler for <code class="docutils literal notranslate"><span class="pre">FooException</span></code> is only designed to handle <code class="docutils literal notranslate"><span class="pre">a</span></code>. This can be avoided by always using fresh symbols for new exceptions.</p>
<p>So the lifecycle looks like:</p>
<div class="graphviz"><object data="../_images/graphviz-c34385eb2654c2cdb40249a2f7e1a566cd233d05.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {

nonexistent [label=&quot;not thrown, not caught&quot;]
fresh [label=&quot;thrown, not caught&quot;]
dead [label=&quot;not thrown, caught&quot;]
mature [label=&quot;thrown, caught&quot;]

nonexistent -&gt; fresh [label=&quot;add failure&quot;]
fresh -&gt; mature [label=&quot;add handler&quot;]

mature -&gt; dead [label=&quot;remove failure&quot;]
fresh -&gt; nonexistent [label=&quot;remove failure&quot;]

dead -&gt; nonexistent [label=&quot;remove handler&quot;]
mature -&gt; fresh [label=&quot;remove handler&quot;]

}</p></object></div>
<p>The key here is that removing an in-use failure from a function is not reversible; you can only add a fresh exception, not an in-use exception. This is an “open-world” style of exception handling.</p>
<p>There is also a “closed-world” style enforced by <code class="docutils literal notranslate"><span class="pre">upper</span></code>, where the code is not designed to allow adding fresh exceptions and expects to deal with a fixed set of exceptions. Here it is not possible to add exceptions without breaking the API. But removal is fine. This can be worked around by wrapping new exceptions in old exception types and “escaping” the type checking, but it’s better to break the API.</p>
</section>
<section id="composability">
<h3>Composability<a class="headerlink" href="#composability" title="Permalink to this heading"></a></h3>
<p>Function types which cannot generate exceptions are subtypes of function types which can. To use higher order functions like map, polymorphic types like <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a</span> <span class="pre">b.</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">t</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">t</span> <span class="pre">b</span></code> should allow <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> to contain exceptions. To reason about this properly <code class="docutils literal notranslate"><span class="pre">upper</span></code> or <code class="docutils literal notranslate"><span class="pre">precise</span></code> types are needed. There doesn’t seem to be any downside to deferring exception propagation and treating exceptions as values when applying higher-order functions.</p>
<p>q: how do lower/upper/precise types work in functions</p>
<p>It is quite useful for optimization to know that functions cannot generate exceptions. This can be achieved manually via overloading or the compiler can specialize code.</p>
<p>Higher-order exception handling constructs are possible, but in practice most Haskell code seems to stick with catch or try. The only really complex construct is <code class="docutils literal notranslate"><span class="pre">bracket</span></code> but that’s handled in Stroscot with finalizers.</p>
<p>Sets allow unions, e.g. you can express throwing <code class="docutils literal notranslate"><span class="pre">MyException</span></code> or <code class="docutils literal notranslate"><span class="pre">HisException</span></code> as <code class="docutils literal notranslate"><span class="pre">MyException|HisException</span></code>. This makes combining libraries and their exception types fairly straightforward. But this is impossible in many languages. The common solution is to use an unstructured catch-all type such as Exception.</p>
<p>It’s not clear how useful the ability to define subsets of exceptions is - Java only has a few superclasses such as IOException and ReflectiveOperationException. Swift claims reacting to an arbitrary IOException is difficult. But IOExceptions are exceptions from I/O operations, so they can use an operation failure path that for example retries the operation a couple times, while Exceptions are so general that retrying may not make sense.</p>
<p>A similar pattern uses Text instead of Exception. This avoids the need for a real exception type, but means all exceptions are unstructured and can’t be handled appropriately.</p>
<p>It’s better to use constraints, <code class="docutils literal notranslate"><span class="pre">(Throws</span> <span class="pre">m</span> <span class="pre">MyException,</span> <span class="pre">Throws</span> <span class="pre">m</span> <span class="pre">HisException)</span> <span class="pre">=&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">Int</span></code>. Then the existential quantification limits the exceptions to those listed, because it’s not necessarily an IO monad.</p>
</section>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this heading"></a></h2>
<p>The implementation needs to transfer control from throw to catch, and run finalizers.</p>
<p>To illustrate take a simple example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="kt">Exception</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="nf">bar</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">foo</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="nf">baz</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="p">`</span><span class="n">catch</span><span class="p">`</span><span class="w"> </span><span class="nf">\</span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">print</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<section id="return-codes">
<h3>Return codes<a class="headerlink" href="#return-codes" title="Permalink to this heading"></a></h3>
<p>With return codes this becomes:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">throw</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"></span>
<span class="c1">-- foo unchanged</span><span class="w"></span>
<span class="nf">bar</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">tmp</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">foo</span><span class="w"></span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">isException</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="n">e</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="nf">baz</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">tmp</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">bar</span><span class="w"></span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">isException</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>The tagged union for the value and the exception code costs extra registers/memory. It’s setup/teardown on every call. Inlining helps, as does encoding the union as a machine word by returning exceptions via unusual return values such as negative numbers or zero. The values are often specific to the function and the values of the arguments.</p>
<p>Also checking the codes creates branches. Although the branches can usually be predicted they still pollute the cache and the duplicated exception-checking code takes up a lot of space. The branches add overhead to the non-exception path. But the exception path suffers no significant penalties compared to the non-exception path - it’s a symmetric approach.</p>
</section>
<section id="continuations">
<h3>Continuations<a class="headerlink" href="#continuations" title="Permalink to this heading"></a></h3>
<p>The continuation-based approach depends on two things: callCC and dynamic scoping. Both of these are somewhat tricky to implement but end up with minimal overhead in compiled code. Basically, <code class="docutils literal notranslate"><span class="pre">throw</span></code> ends up being a continuation action passed via dynamic scoping. The interesting behavior is all in <code class="docutils literal notranslate"><span class="pre">catch</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">body</span><span class="w"> </span><span class="n">catch</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">old</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">throw</span><span class="w"></span>
<span class="w">  </span><span class="n">callCC</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">ec</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">    </span><span class="n">return</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">{</span><span class="n">throw</span><span class="ow">=</span><span class="n">old</span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">continue</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">continue</span><span class="w"> </span><span class="p">{</span><span class="n">throw</span><span class="ow">=</span><span class="n">old</span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">break</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">break</span><span class="w"> </span><span class="p">{</span><span class="n">throw</span><span class="ow">=</span><span class="n">old</span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">throw</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">ex</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">ec</span><span class="w"> </span><span class="p">(</span><span class="n">handler</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">throw</span><span class="ow">=</span><span class="n">old</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">body</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The throw is unregistered if the function returns normally, otherwise <code class="docutils literal notranslate"><span class="pre">throw</span></code> restores the context and jumps to the handler.</p>
<p><code class="docutils literal notranslate"><span class="pre">setjmp</span></code> / <code class="docutils literal notranslate"><span class="pre">longjmp</span></code> are an explicitly stack-based implementation of continuations. The registers must all be saved, costing a lot on both exception and non-exception paths. It’s disliked.</p>
</section>
<section id="unwinding-tables">
<h3>Unwinding tables<a class="headerlink" href="#unwinding-tables" title="Permalink to this heading"></a></h3>
<p>Unwinding tables are another stack-based implementation of continuations. The instruction pointer is used to find the loaded segment and its corresponding unwinding table. Every non-leaf function has an entry, and the return address on the stack is looked up to jump into handling code or code to pop the stack frame and restore register invariants. Since the tables can be cold and there’s no branches on the non-exception path, the non-exception path is quite fast. But it’s not zero cost because the exception path may keep registers alive that the non-exception path doesn’t use, the code to read the tables takes up some space, and there are relocations at load time for the tables themselves.</p>
<p>Unwinding tables both help and harm performance. They require lots of data for the runtime support to unwind stacks, search for handlers, and so on. And compared to exception values these tables are slow to look up for the exception path. But if you have many levels of unwinding the normal path is faster because the values aren’t wrapped and the handlers are cold and aren’t dirtying your instruction cache or TLB.</p>
<p>The table-based system ended up being roughly 7% smaller and 4% faster (geomean) than the return code-based on some key benchmarks.</p>
<p>Another optimization is to cache exceptions as static data, so that throw doesn’t allocate.</p>
<p>stack overflow in SEH filter clauses can be interpreted as not handling the exception.</p>
<p>Microsoft’s implementation of C++ exceptions allocates on the stack, and delays deallocation until the end of a C++ catch clause. It is quite inefficient in terms of stack usage.</p>
</section>
<section id="zero-overhead">
<h3>Zero overhead<a class="headerlink" href="#zero-overhead" title="Permalink to this heading"></a></h3>
<p>Just turning on exception handling support in a C++ project previously compiled without exception support, not throwing any exceptions at all, gives +15-52% bloat. The overhead arises from jump tables, additional
stack space per thread (e.g., a 1K reservation, to save a dynamic allocation) and additional thread-local storage. For this reason many C+ projects disable exceptions.</p>
<p>With a flexible implementation it should be possible to optimize exceptions so that it doesn’t cost anything to not use exceptions.</p>
<p>exception propagation for common exceptions should be handled by exception codes.
It would be good to bias the implementation somewhat towards the
non-exception path, perhaps by moving exception paths to the ends of functions
and cleanups out of the hot code path, but not enough to seriously compromise performance.
It should not use table-based unwinding except for really rare exceptions.</p>
</section>
</section>
<section id="interruptible-cleanup">
<h2>Interruptible cleanup<a class="headerlink" href="#interruptible-cleanup" title="Permalink to this heading"></a></h2>
<p>Interruptible cleanup actions - the interaction of async exceptions and cleanups. A cleanup function which may block and should be interruptible to avoid a long delay in execution.</p>
<p>When closing a file one often wants to flush buffers (fsync). So there are 3 variants of hClose:
* The flush marks a checkpoint, and should retry until complete regardless of interruptions
* The flush is unnecessary, just close the file
* The flush is productive but interruptible (EINTR), and should not be retried on interrupt. This avoids the situation where the flush takes a long time and the thread is unkillable. Note that it requires two async exceptions to kill the thread, one to enter the cleanup handler and another to interrupt the flush.</p>
<p>The Linux close syscall is interruptible, but it is guaranteed to close the file even if interrupted. Similarly hClose should close the file handle in all cases. Except when hClose is used outside the context of a cleanup, e.g. in the acquire part of bracket, interrupting should avoid visible side effects and interrupted hClose should not close the file.</p>
<p>sending a final “goodbye” message over a TCP connection.</p>
<p>putMVar/takeMVar: these should use tryPutMvar/tryTakeMVar</p>
<p>the default: with interruptibleMask or a separate bracketInterruptible this is a matter of taste. uninterruptibleMask provides behavior that is easier to reason about, but may block for an unbounded amount of time, possibly leading to deadlock.</p>
<p>“I don’t want this action to throw exceptions. Sync exceptions are all caught, now I want uninterruptibleMask to disable async exceptions.” or “I want this interruptible action for logging; I ensured the resource will be released if this action fails, so I disable async exceptions here only because the policy requires that”.</p>
<p>an openFile might talk to a network mounted NFS drive and take 30s or so in the worst case. but this is where async exceptions interrupt the operation.</p>
<section id="injection">
<h3>Injection<a class="headerlink" href="#injection" title="Permalink to this heading"></a></h3>
<p>Most languages use polling solutions to implement semi-asynchronous exceptions. These make various operations interruptible, i.e. before/after executing they check for async exceptions and if so inject the exception. But this isn’t good enough since a lot of time may be spent between checks. A true async solution has no polling, the thread jumps directly to handling code.</p>
<p>On Linux we can use the <code class="docutils literal notranslate"><span class="pre">pthread_kill</span></code> API to inject true async exceptions as signals. This sends a signal to interrupt the thread, which if unhandled will simply terminate the process, so one must install a signal handler. Similar to hardware exceptions this handler does the equivalent of a <code class="docutils literal notranslate"><span class="pre">siglongjmp</span></code> to return from the signal handler into a normal execution context, and then does the unwinding magic (using DWARF or similar).</p>
<p>On Windows there is <a class="reference external" href="https://stackoverflow.com/questions/37378035/how-to-signal-a-specific-thread-in-windows">no direct equivalent</a> to <code class="docutils literal notranslate"><span class="pre">pthread_kill</span></code>. But internally the functionality is there: a kernel-mode APC sets <code class="docutils literal notranslate"><span class="pre">RequestInterrupt=TRUE</span></code> so the scheduler will interrupt a running thread even if it’s in a long computation. But we cannot directly create a kernel-mode APC from user code. There are some options:
* The QueueUserAPCEx Windows driver implements an API to create a kernel-mode APC. But signing drivers on recent versions of Windows is impossible.
* SuspendThread issues a kernel-mode APC (API intended for debuggers). So we pause the thread with SuspendThread, save its state via GetThreadContext, make a new context with the instruction pointer set to the handler, and resume the thread with SetThreadContext and ResumeThread. But it’s low-level and requires several kernel roundtrips. Also GetThreadContext may <a class="reference external" href="https://stackoverflow.com/questions/3444190/windows-suspendthread-doesnt-getthreadcontext-fails">fail</a>.
* Windows 10 RS5 adds “Special User APCs” (QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC) which are delivered quickly via a kernel-mode APC, but then run as a user APC. The kernel-level API passes in a CONTEXT argument containing the registers from before the APC, like Linux’s signal handler, but the documented API doesn’t have this info. It may be possible to get it somehow with the documented API, or can live dangerously and use the kernel-level API.</p>
<p>System calls on Windows are implemented with layers of C in between, so the handler has to ensure the C code completes to ensure proper cleanup. So it walks the stack and overwrites the first user-mode frame with an exception handling information frame, skipping internal Windows stack frames. This functionality is also useful on Linux, if we’re using glibc.</p>
<p>throwTo the calling thread is an interesting academic question - the easiest is to define it as throw. GHC has some weird suspension behavior that interacts with unsafePerformIO.</p>
</section>
<section id="masking">
<h3>Masking<a class="headerlink" href="#masking" title="Permalink to this heading"></a></h3>
<p>Asynchronous exceptions can be masked, then they get delayed to the unmask call. It allows writing “reliable” code that functions correctly even if an async exception is sent. But, if you mask async exceptions all the time, async cancellation will hang indefinitely. Use finalizers instead of masking wherever possible.</p>
<p>Most code should run unmasked, and if you do mask the scope of the mask should be minimized to ensure that asynchronous exceptions can be handled ASAP.</p>
<p>The mask function is <code class="docutils literal notranslate"><span class="pre">mask</span> <span class="pre">io</span> <span class="pre">=</span> <span class="pre">if</span> <span class="pre">Masked</span> <span class="pre">then</span> <span class="pre">io</span> <span class="pre">{unmask</span> <span class="pre">=</span> <span class="pre">id}</span> <span class="pre">else</span> <span class="pre">io</span> <span class="pre">{Masked</span> <span class="pre">=</span> <span class="pre">True,</span> <span class="pre">unmask</span> <span class="pre">io</span> <span class="pre">=</span> <span class="pre">io</span> <span class="pre">{Masked</span> <span class="pre">=</span> <span class="pre">False}</span> <span class="pre">}</span></code>. To make masking composable, only the outermost mask takes effect - mask within a mask is a no-op and similarly the unmask it creates. This solves the “wormhole” <a class="reference external" href="https://mail.haskell.org/pipermail/libraries/2010-March/013310.html">problem</a>.</p>
<p>How to implement masking? Linux provide a masking API to block signals, which queues them up. So we can just use that. On Windows the only way to mask kernel-mode interrupts is to use a critical region, which is again a kernel mode API and not something we can use. So the handler itself must check if the thread is masked and if so store the exception somewhere to be thrown on unmask.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">\</span><span class="n">cont</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">  </span><span class="kt">Block</span><span class="w"></span>
<span class="w">    </span><span class="kt">TakeMVar</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">      </span><span class="n">catch</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Unblock</span><span class="w"> </span><span class="p">(</span><span class="n">compute</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">Block</span><span class="w"> </span><span class="n">c</span><span class="p">)))</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nf">\</span><span class="n">e</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">PutMVar</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">throw</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nf">\</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">PutMVar</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="kt">Unblock</span><span class="w"> </span><span class="n">cont</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="interruptible-operations">
<h3>Interruptible operations<a class="headerlink" href="#interruptible-operations" title="Permalink to this heading"></a></h3>
<p>Some operations can block for a long time. Async exceptions must be able to interrupt this blocking for timely injection. So every operation which may block comes in two versions, interruptible and uninterruptible. An interruptible operation is conceptually similar to <code class="docutils literal notranslate"><span class="pre">allowInterrupt;</span> <span class="pre">&lt;op&gt;</span></code>, but it only polls for asynchronous exceptions while blocked, and does not throw an asynchronous exception if it does not block.</p>
<p>Uninterruptible operations do not poll for async exceptions and hence can block indefinitely. They should only be used in exception cleanup code and only if there is no correct alternative. Sometimes there is no alternative, e.g. flushing a file cannot be avoided. Other times concurrency operations can be replaced with non-blocking versions, e.g. putMVar with tryPutMVar.</p>
<p>With uninterruptibleMask / interruptibleMask you can switch between the modes, and they only affect operations that can block. The mask itself is unaffected. So conceptually it is the operations that are uninterruptible.
<code class="docutils literal notranslate"><span class="pre">mask</span> <span class="pre">$</span> <span class="pre">do</span> <span class="pre">{</span> <span class="pre">...;</span> <span class="pre">uninterruptibleMask_</span> <span class="pre">$</span> <span class="pre">op;</span> <span class="pre">...</span> <span class="pre">}</span></code>.</p>
<p>In C interruptible functions are specified to fail with errno set to [EINTR] if a signal handler interrupts the program. I.e., the system routine will return but fail to complete its action and one must call the system routine again. The SA_RESTART flag on the signal handler restarts the call, but the duration of the timeout is unspecified, so it is better to do it from user code, particularly when writing an asynchronous event loop that uses select or poll.</p>
<p>So to make calls reliably, when a program is using signals without SA_RESTART, it must check whether the return value of interruptible system calls is -1 EINTR, and restart the system call if it is the case. This is annoying to write; so, skalibs provides small wrappers around interruptible system calls, so that programmers can just call those safe wrappers and never bother with this again. The performance loss from having a wrapper layer is totally negligible compared to the cost of using a system call in the first place.</p>
</section>
<section id="unmask-is-not-an-inverse">
<h3>Unmask is not an inverse<a class="headerlink" href="#unmask-is-not-an-inverse" title="Permalink to this heading"></a></h3>
<p>These pieces of code are not equivalent:</p>
<ol class="arabic simple">
<li><p>mask $ restore -&gt; (uninterruptiblePutMVar var x &gt;&gt;= foo) <cite>catch</cite> e -&gt; bar</p></li>
<li><p>mask $ restore -&gt; (putMVar var x &gt;&gt;= foo) <cite>catch</cite> e -&gt; bar</p></li>
<li><p>mask $ restore -&gt; (restore $ putMVar var x &gt;&gt;= foo) <cite>catch</cite> e -&gt; bar</p></li>
<li><p>(uninterruptiblePutMVar var x &gt;&gt;= foo) <cite>catch</cite> e -&gt; bar</p></li>
</ol>
<dl class="simple">
<dt>The first snippet has two scenarios:</dt><dd><p>putMVar succeeds, foo executes
putMVar throws deadlock, bar executes</p>
</dd>
<dt>The second has an additional scenario:</dt><dd><p>putMVar throws async exception, bar executes</p>
</dd>
<dt>The third adds another scenario:</dt><dd><p>putMVar succeeds, the restore throws an async exception, bar executes</p>
</dd>
</dl>
<p>It’s not a no-op to unmask an interruptible operation. There is a gap between putMvar and the end of the restore - an async exception can occur after the operation succeeds but before the transition from unmasked to masked.</p>
<p>It is wrong to wrap an ExceptT, EitherT, or ErrorT around an IO-based transformer stack. For example <code class="docutils literal notranslate"><span class="pre">myFunction</span> <span class="pre">::</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">ExceptT</span> <span class="pre">MyException</span> <span class="pre">IO</span> <span class="pre">Int</span></code>. The IO code can always throw exceptions, async exceptions if nothing else. You haven’t limited the possibility of exceptions, you’ve only added one extra avenue by which an exception can be thrown.</p>
<blockquote>
<div><p>handling GHC’s broken <a class="reference external" href="https://www.fpcomplete.com/blog/2018/04/async-exception-handling-haskell/">asynchronous exception system</a>. The system is broken because it is so complicated that nobody can agree on the desired behavior / correct form of even simple examples. The prototypical example of using it is <a class="reference external" href="https://hackage.haskell.org/package/unliftio-0.2.13.1/docs/UnliftIO-Exception.html#v:bracket">bracket</a>:</p>
</div></blockquote>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bracket</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">MonadUnliftIO</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="nf">bracket</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">withRunInIO</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">run</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">EUnsafe</span><span class="o">.</span><span class="n">mask</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">restore</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="n">before</span><span class="w"></span>
<span class="w">  </span><span class="n">res1</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">EUnsafe</span><span class="o">.</span><span class="n">try</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">restore</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">res1</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">Left</span><span class="w"> </span><span class="p">(</span><span class="n">e1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">SomeException</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="kr">_</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Either</span><span class="w"> </span><span class="kt">SomeException</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">EUnsafe</span><span class="o">.</span><span class="n">try</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">EUnsafe</span><span class="o">.</span><span class="n">uninterruptibleMask_</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">      </span><span class="kt">EUnsafe</span><span class="o">.</span><span class="n">throwIO</span><span class="w"> </span><span class="n">e1</span><span class="w"></span>
<span class="w">    </span><span class="kt">Right</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="kr">_</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">EUnsafe</span><span class="o">.</span><span class="n">uninterruptibleMask_</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">      </span><span class="n">return</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>
<p>Here we use 4 operations: mask, try, <code class="docutils literal notranslate"><span class="pre">uninterruptibleMask_</span></code>, throwIO. mask shields the cleanup action from being attacked by asynchronous exceptions, allowing exceptions inside restore. try catches exceptions and allows cleanup to occur. <code class="docutils literal notranslate"><span class="pre">uninterruptibleMask_</span></code> blocks interrupts from interrupting the after handler. Finally throwIO rethrows the exception, so that any exception inside the after handler will be swallowed.</p>
<p>Apparently, though, nobody can agree on whether the after handle should run with an uninterruptible mask.</p>
<p>Transformers</p>
<p>foo :: Int -&gt; IO String
can always be generalized with a usage of liftIO to:
foo :: MonadIO m =&gt; Int -&gt; m String</p>
<p>However,
bar :: FilePath -&gt; (Handle -&gt; IO a) -&gt; IO a
needs lifted-base or exceptions, and gets:
bar :: MonadBaseControl IO m =&gt; FilePath -&gt; (Handle -&gt; m a) -&gt; m a
bar :: (MonadIO m, MonadMask m) =&gt; FilePath -&gt; (Handle -&gt; m a) -&gt; m a</p>
<p>This applies to exception handling and forking threads. use the Acquire type from resourcet.</p>
<p>Custom exception types</p>
<p>Some people prefer <code class="docutils literal notranslate"><span class="pre">display</span></code> for user-friendly display, and think <code class="docutils literal notranslate"><span class="pre">show</span></code> should always use literal syntax.</p>
<p>but exception code-style of checking done everywhere leads to huge amounts of untested/broken code-paths.</p>
<p>An exception in a pure computation does not immediately halt the program, but instead returns an exception value that propagates through the pure code and halts the program when it is used in an imperative instruction, close in spirit to what LLVM calls a <a class="reference external" href="https://llvm.org/devmtg/2020-09/slides/Lee-UndefPoison.pdf">poison value</a> . This enforces nonstrict execution of pure code, enabling speculation, discarding unused code, etc. Unlike LLVM which only has the exception value ‘poison’, Stroscot has numerous exception values. The exception values are contained in sets, which can form the exception value hierarchies found in Java or Haskell but can also express other relationships.</p>
<p>Under the hood an exception value is simply a normal value with <code class="docutils literal notranslate"><span class="pre">isException</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">true</span></code>. exception values can be loaded/stored into a variable or array. Pattern matching on an exception value will execute a matching or catch-all case if present, allowing exception recovery, but otherwise propagate a <code class="docutils literal notranslate"><span class="pre">MissingCase</span></code> exception. When an exception value reaches the top-level <code class="docutils literal notranslate"><span class="pre">Task</span></code> structure, the handler will detect that the exception is not allowed in the <code class="docutils literal notranslate"><span class="pre">Task</span></code>, print the exception value, and exit the program. Tracking whether something can be an exception value requires the usual analysis to identify its type (possible set of values).</p>
<p>We can redefine exception values to be something else, e.g. add a definition <code class="docutils literal notranslate"><span class="pre">NoSuchAttributeException</span> <span class="pre">{}</span> <span class="pre">&quot;x&quot;</span> <span class="pre">=</span> <span class="pre">3</span></code>. Then <code class="docutils literal notranslate"><span class="pre">{}.x</span> <span class="pre">==</span> <span class="pre">3</span></code> and the exception is silenced. Similarly we can do <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">{}.x</span> <span class="pre">of</span> <span class="pre">NoSuchAttributeException</span> <span class="pre">{}</span> <span class="pre">&quot;x&quot;</span> <span class="pre">-&gt;</span> <span class="pre">3</span></code>, or pass the exception to a function that does such exception-handling. We can also match on generic exceptions, <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">{}.x</span> <span class="pre">of</span> <span class="pre">e</span> <span class="pre">|</span> <span class="pre">isException</span> <span class="pre">e</span> <span class="pre">-&gt;</span> <span class="pre">3</span></code>. The alternative to <code class="docutils literal notranslate"><span class="pre">isException</span></code> is a single standard exception constructor <code class="docutils literal notranslate"><span class="pre">Exception</span> <span class="pre">x</span></code>, IDK.</p>
<p>The exceptions also store the arguments to the exception, e.g. a <code class="docutils literal notranslate"><span class="pre">MissingCaseException</span></code> will store the value and the case itself, <code class="docutils literal notranslate"><span class="pre">x,</span> <span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">case</span> <span class="pre">x</span> <span class="pre">of</span> <span class="pre">...</span></code>. These compose up the stack so that we can pass in a value at any point and resume computing.</p>
<p>I guess there is ABI stability to consider.  says the interface will be added to and not have things removed from it. This means I have to assume (for forward compatibility) that any positive integer could be added to the interface and returned as an exception code. So I need a catch-all anyway. But I can support up to some kernel version, and make the catch-all crash the program, instead of figuring out a reasonable behavior.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Evaluation-Strategy.html" class="btn btn-neutral float-left" title="Evaluation strategy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="F2G2_example.html" class="btn btn-neutral float-right" title="F2 G2" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2020 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>