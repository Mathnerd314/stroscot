<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exceptions &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="As fast as C" href="Fastest.html" />
    <link rel="prev" title="Evaluation strategy" href="Evaluation-Strategy.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler-Library.html">Compiler library</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Exceptions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#exception-menagerie">Exception menagerie</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#failure">Failure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#domain-exception">Domain exception</a></li>
<li class="toctree-l4"><a class="reference internal" href="#system-exception">System exception</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-exceptions">Hardware exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#resource-exhaustion">Resource exhaustion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deadlock">Deadlock</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nontermination">Nontermination</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exception-groups">Exception groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aborts">Aborts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#runtime-bugs">Runtime bugs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cancellation">Cancellation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#signals">Signals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#non-categorizations">Non-categorizations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#unrecoverable-errors">Unrecoverable errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#soft-errors">Soft errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#undefined-behavior">Undefined behavior</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sync-async">Sync/async</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#patterns">Patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#handle">Handle</a></li>
<li class="toctree-l4"><a class="reference internal" href="#propagate">Propagate</a></li>
<li class="toctree-l4"><a class="reference internal" href="#frequency">Frequency</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#traces">Traces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#top-level">Top level</a></li>
<li class="toctree-l3"><a class="reference internal" href="#automatic-propagation">Automatic propagation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#no-throw">no-throw</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exception-api">Exception API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#value">Value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defining-errors">Defining errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exceptions-in-io">Exceptions in IO</a></li>
<li class="toctree-l4"><a class="reference internal" href="#try">Try</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exit-points">Exit points</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#signatures">Signatures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#call-chains">Call chains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#java-checked-exceptions">Java checked exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#default-signature-type">Default signature type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fresh-exceptions">Fresh exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#composability">Composability</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#return-codes">Return codes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#continuations">Continuations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#zero-overhead">Zero overhead</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interruptible-cleanup">Interruptible cleanup</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#injection">Injection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#masking">Masking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interruptible-operations">Interruptible operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unmask-is-not-an-inverse">Unmask is not an inverse</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#assertions">Assertions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Intrinsics.html">Intrinsics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#resources">Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#metrics">Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#methods">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#action">Action</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#caches">Caches</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard-Library.html">Standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Exceptions</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Exceptions.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="exceptions">
<h1>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this heading"></a></h1>
<p>Exceptions allow us to focus on the normal (non-exceptional) case when performing operations that might fail. The downside is that it is more tricky to reason about how the failure cases are handled, because the handling code may be many levels of function calls removed from the operation.</p>
<section id="exception-menagerie">
<h2>Exception menagerie<a class="headerlink" href="#exception-menagerie" title="Permalink to this heading"></a></h2>
<p>The first question is what an exception is. Let us try to classify all the exceptions, everything that can use an exception-like semantic. The space of exceptions is unquestionably large so this list is probably incomplete.</p>
<section id="failure">
<h3>Failure<a class="headerlink" href="#failure" title="Permalink to this heading"></a></h3>
<p>The most obvious exception is one that is thrown explicitly. Languages provide several ways to throw an exception:</p>
<ul class="simple">
<li><p>Haskell provides a TODO marker <code class="docutils literal notranslate"><span class="pre">undefined</span></code> that throws a predefined exception like <code class="docutils literal notranslate"><span class="pre">ErrorCall</span> <span class="pre">&quot;undefined&quot;</span></code>.</p></li>
<li><p>Haskell allows throwing a string, like <code class="docutils literal notranslate"><span class="pre">error</span> <span class="pre">&quot;something</span> <span class="pre">bad</span> <span class="pre">happened&quot;</span></code>.</p></li>
<li><p>VB allows raising a numbered message, like <code class="docutils literal notranslate"><span class="pre">Error</span> <span class="pre">1234</span></code>, with a more complex <code class="docutils literal notranslate"><span class="pre">Err.Raise</span></code> method with optional parameters <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">source</span> <span class="pre">=</span> <span class="pre">&quot;CurrentProject.CurrentFile&quot;,</span> <span class="pre">description</span> <span class="pre">=</span> <span class="pre">&quot;Application-defined</span> <span class="pre">or</span> <span class="pre">object-defined</span> <span class="pre">error&quot;,</span> <span class="pre">helpfile</span> <span class="pre">=</span> <span class="pre">&quot;C:/VBHelp/DefaultVBHelp.hlp&quot;,</span> <span class="pre">helpcontext</span> <span class="pre">=</span> <span class="pre">lookup</span> <span class="pre">number</span> <span class="pre">vbhelpfile</span>&#160; <span class="pre">}</span></code>. The numbers are supposed to be unique declared constants so really they should be understood as module-qualified symbols.</p></li>
<li><p>C++ allows throwing any value like <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">x</span></code></p></li>
<li><p>Haskell/Java/C#/Python similarly allow <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">x</span></code> but limit throwable values to be of a type <code class="docutils literal notranslate"><span class="pre">Throwable</span></code>, <code class="docutils literal notranslate"><span class="pre">Exception</span></code>, or <code class="docutils literal notranslate"><span class="pre">BaseException</span></code>.</p></li>
</ul>
<p>A superclass <code class="docutils literal notranslate"><span class="pre">Exception</span></code> type seems more straightforward than C++’s “throw any value” - every value can be wrapped in a constructor such as <code class="docutils literal notranslate"><span class="pre">ExceptionWrapper</span> <span class="pre">x</span></code>, and this avoids the semantic issues of having exceptional values which “aren’t exceptions”. Python switched from no common superclass required in v2 to requiring membership in <code class="docutils literal notranslate"><span class="pre">BaseException</span></code> in v3.</p>
</section>
<section id="domain-exception">
<h3>Domain exception<a class="headerlink" href="#domain-exception" title="Permalink to this heading"></a></h3>
<p>A domain exception is an “alternate result” returned from a function when its precondition for success is false, e.g. when the operation is called on an “invalid” argument outside of its domain. A domain exception is used when checking the domain via a separate function would be tedious - instead the caller can check the returned value to see if the precondition was satisfied.</p>
<p>In high-reliability scenarios, it’s best to statically prove the nonexistence of domain exceptions or that the domain exception is limited to a small region. For example arithmetic overflows can represent security vulnerabilities and should generally be handled immediately. But otherwise there is a dynamic semantics for domain exceptions which lends itself to containment strategies.</p>
<p>Examples:</p>
<ul class="simple">
<li><p>Converting a (user-input) string to an integer may fail on invalid characters and return <code class="docutils literal notranslate"><span class="pre">NotAnInt</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">&quot;x&quot;</span> <span class="pre">then</span> <span class="pre">...</span> <span class="pre">else</span> <span class="pre">...</span></code> returns <code class="docutils literal notranslate"><span class="pre">InvalidCondition</span></code></p></li>
<li><p>A case statement where the scrutinee doesn’t match any of the patterns returns <code class="docutils literal notranslate"><span class="pre">FailedMatch</span></code></p></li>
<li><p>Divide by zero returns <code class="docutils literal notranslate"><span class="pre">DivideByZero</span></code></p></li>
<li><p>An arithmetic computation where the result doesn’t fit in the specified representation, e.g. <code class="docutils literal notranslate"><span class="pre">IntegerOverflow</span></code></p></li>
<li><p>A floating-point exception, when signaling is enabled</p></li>
<li><p>A cast of a value to a type that it isn’t</p></li>
<li><p>An assertion or contract failure</p></li>
<li><p>Looking up a nonexistent key in a dictionary returns <code class="docutils literal notranslate"><span class="pre">KeyNotFound</span></code></p></li>
<li><p>Looking up an out-of-bounds index in an array returns <code class="docutils literal notranslate"><span class="pre">IndexOutOfBounds</span></code></p></li>
</ul>
</section>
<section id="system-exception">
<h3>System exception<a class="headerlink" href="#system-exception" title="Permalink to this heading"></a></h3>
<p>These are used in C functions with the convention that a zero or positive return is success and a negative return is an exception. As such the exception codes are all negative. On Linux/POSIX there is EINTR, EINVAL, ENOENT, ETIMEDOUT, etc., on Windows there are the types NTSTATUS and HRESULT.</p>
<p>In many ways these are similar to domain exceptions, but the difference is that the failure is not predictable in advance with a predicate because it depends on external state that may change at any moment, in particular during the few nanoseconds between checking the predicate and executing the call.</p>
<p>The other difference is that the set of possible exception codes is not small or fixed. The kernel is complex and a system call may return almost any exception code, hence requiring hundreds of cases. Furthermore new kernels may add and use new exception codes. So in addition to exceptions for all known exception codes there also needs to be a family <code class="docutils literal notranslate"><span class="pre">UnknownExceptionCode</span> <span class="pre">123</span></code>.</p>
<p>Generally there is only one way a call can succeed. Hence exceptions are very useful to handle all the failure cases you don’t care or know about in an aggregate manner.</p>
<p>Examples:</p>
<ul class="simple">
<li><p>Opening a file may fail with a <code class="docutils literal notranslate"><span class="pre">FileNotFound</span></code> exception. The file may have been deleted too recently to be detected by any previously performed checks.</p></li>
<li><p>A query to a database might fail with <code class="docutils literal notranslate"><span class="pre">DatabaseCorrupted</span></code>.</p></li>
<li><p>A network operation might fail with an unreachable host exception, often split into many sub-exceptions for different levels of unreachability.</p></li>
<li><p>Dereferencing a null or invalid pointer may return <code class="docutils literal notranslate"><span class="pre">InvalidPointerException</span></code></p></li>
<li><p>Reading a file consisting of 10 blocks into a 1-block buffer may fill the buffer to capacity and return a <code class="docutils literal notranslate"><span class="pre">PartialRead</span></code> exception to alert that more can be read with another call. Arguably this is an “alternate success” but it still fits naturally into the system exception category.</p></li>
</ul>
</section>
<section id="hardware-exceptions">
<h3>Hardware exceptions<a class="headerlink" href="#hardware-exceptions" title="Permalink to this heading"></a></h3>
<p>Hardware exceptions are similar to system exceptions except that they are a small set of exceptions that can be triggered on almost every instruction. They take a convoluted path, first the thread triggers an interrupt, the interrupt is handled by the OS, then if the OS decides it’s an exception it injects it into the thread that caused the exception. The exceptions are delivered immediately (synchronously); the thread cannot continue execution cannot resume where it left off.</p>
<p>On Linux hardware exceptions are transformed to signals SIGBUS, SIGFPE, SIGILL, SIGSEGV, SIGTRAP, SIGEMT (emulator trap, not used on x86) <a class="reference external" href="https://github.com/torvalds/linux/blob/a931dd33d370896a683236bba67c0d6f3d01144d/arch/x86/kernel/traps.c">in the kernel</a>. The type of exception is in si_code in siginfo_t, rather haphazardly: DE translates to SIGFPE with si_code FPE_INTDIV, <a class="reference external" href="https://github.com/torvalds/linux/blob/a931dd33d370896a683236bba67c0d6f3d01144d/arch/x86/mm/fault.c#L1487">PF/GP</a> to SIGSEGV, SS/AC to SIGBUS, UD to SIGILL, etc.</p>
<p>On Windows / Visual C++ hardware exceptions are handled with <a class="reference external" href="https://docs.microsoft.com/en-us/cpp/cpp/structured-exception-handling-c-cpp?view=msvc-160">Structured Exception Handling</a>. We can catch hardware exceptions inline in code with <code class="docutils literal notranslate"><span class="pre">__try</span> <span class="pre">{</span> <span class="pre">}</span> <span class="pre">__except</span></code>. SEH can be thought of much like temporarily registered signal handlers, where the exceptional conditions are signals. The __try blocks define where the handler is in effect, and the __except and __finally blocks are the handlers if the “signal” is received. In 32-bit Windows the handlers are on a stack, in 64-bit Windows SEH uses instruction tables to do unwinding. GCC / LLVM haven’t implemented SEH. (LLVM is <a class="reference external" href="https://reviews.llvm.org/D102817">in progress</a>) There is also <a class="reference external" href="https://docs.microsoft.com/en-us/windows/win32/debug/vectored-exception-handling">Vectored Exception Handlers</a> which provides thread-wide hardware exception handling similar to Linux.</p>
<p><a class="reference external" href="https://github.com/ziglang/zig/blob/e2b954c2738c683a85b864eb33530f0e3dbbc480/lib/std/debug.zig#L1527">Zig</a> implements a signal handler for hardware exceptions that dumps the stacktrace and aborts. But we can do better and, like Windows SEH, allow unwinding to a handler in the code. In C signal handlers can only call async-signal-safe functions, but <code class="docutils literal notranslate"><span class="pre">siglongjmp</span></code> is async-signal-safe so in practice any code can be executed so long as <code class="docutils literal notranslate"><span class="pre">sigsetjmp</span></code> is called first. A further extension should be able to do DWARF unwinding and allow pretending that hardware exceptions are simply return values from instructions. Really what happens is that the handler jumps to a failure continuation, and this failure continuation is <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">DivByZero</span></code>, while the success continuation is <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">123</span></code> or whatever.</p>
</section>
<section id="resource-exhaustion">
<h3>Resource exhaustion<a class="headerlink" href="#resource-exhaustion" title="Permalink to this heading"></a></h3>
<p>This covers running out of memory (OOM), stack (stack overflow), sockets, and file descriptors. Generally resource exhaustion exceptions are system exceptions from a failed allocation call.</p>
<p>Threads compete for resources. Any allocation attempt might fail, because the developer doesn’t know the total resources available on the target system, and because other threads and other processes are simultaneously competing for that same unknown pool. But OOM locations are predictable to the compiler because it knows exactly where allocations occur and can throw an exception if the allocation fails. Hence OOMs can be localized to the source code that generates the allocation statement.</p>
<p>OOM isn’t reliably reported by the OS because by default page allocation doesn’t fail even in a low-memory condition. Instead the pages get swapped to disk and the system just gets really slow. On Linux even without swap the programs gets paused on trying to access the page and the OOM killer just selects a process to kill. Similarly ulimit just segfaults on OOM. To reliably enforce a limit it has to be checked by the allocator. But 32-bit address space exhaustion is reliably reported.</p>
<p>Stack overflow is more tractable than OOM, in the sense that there is no asynchronous competition for the resource, hence a static analysis can show that there is sufficient stack. It is also easy to handle stack overflow by switching to an alternate stack. It is also fairly predictable to determine whether an expression uses the C stack: it must call a C function.</p>
<p>Stack overflow can leave a Windows critical section in a corrupt state. Windows user routines likely have many stack overflow bugs, this isn’t something it’s hardened against. So maybe stack overflow isn’t recoverable on Windows. On Linux the syscalls don’t use a stack so should be fine.</p>
<p>If an application only uses a few pages of memory then the overhead for reserves is significant, so the amount of reserved space should be configurable or calculated to its minimum viable size.</p>
<p>Out of file descriptors is pretty easy to handle, since few operations allocate file descriptors and it is easy to avoid those.</p>
</section>
<section id="deadlock">
<h3>Deadlock<a class="headerlink" href="#deadlock" title="Permalink to this heading"></a></h3>
<p>It can be detected that a thread is stuck when it is waiting on an MVar with no other references. Then the runtime can replace the takeMVar with throwing a BlockedIndefinitelyOnMVar exception. Similarly with Deadlock and some other Haskell concurrency exceptions.</p>
<p>These are synchronous exceptions in that they’re directly attributable to the action the current thread is taking. But Haskell uses the asynchronous delivery mechanism for implementation convenience. IMO it’s a bug, they should be delivered synchronously and not be maskable.</p>
</section>
<section id="nontermination">
<h3>Nontermination<a class="headerlink" href="#nontermination" title="Permalink to this heading"></a></h3>
<p>Infinite loops can be detected and replaced with a Nontermination or Loop exception. Dynamically, this can be implemented by decrementing a fuel counter on every reduction step and throwing an exception when it runs out. Whatever the starting fuel, an infinite loop is guaranteed to throw an exception. Statically the analyses are more general and can prove termination or nontermination without requiring the arbitrary choice of initial fuel. Most functions can be classified, but totality checkers are not omniscient.</p>
</section>
<section id="exception-groups">
<h3>Exception groups<a class="headerlink" href="#exception-groups" title="Permalink to this heading"></a></h3>
<p>Consider a parallel map, e.g. something like <code class="docutils literal notranslate"><span class="pre">parallel-map</span> <span class="pre">arr</span> <span class="pre">$</span> <span class="pre">\(i,v)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">i</span> <span class="pre">v</span></code> that can execute multiple <code class="docutils literal notranslate"><span class="pre">f</span></code>’s concurrently. Now there may be 0, 1, or multiple failures of <code class="docutils literal notranslate"><span class="pre">f</span></code>. If there are no failures everything is fine. But if there are 1 or multiple failures, we cannot return an array, and must throw an exception. If there is one exception we can just throw that exception. But if there are multiple, then what? In general all <code class="docutils literal notranslate"><span class="pre">f</span></code> may run in parallel, but if we execute some range on a thread then an earlier <code class="docutils literal notranslate"><span class="pre">f</span></code> exception will stop the thread and later <code class="docutils literal notranslate"><span class="pre">f</span></code> exceptions will not be reported. So reporting the complete set of (potential) exceptions is impossible, we can only report the exception encountered by each thread. And in fact the controller may kill all the worker threads after receiving the “first” exception, so the later threads will stop abruptly. This “first” exception may not be chronologically first due to scheduling vagaries, but it is logically the first as seen by the controller.</p>
<p>So, since all the other threads will be killed anyway after this first exception, the exceptions these other threads may or may not have encountered can be ignored, and we can just report the first exception to the caller. But this discards information.</p>
<p>Instead, the <code class="docutils literal notranslate"><span class="pre">ThreadKilled</span></code> exceptions can be reported along with the first exception and any other exceptions that manage to make it through. This is important enough that Joe Duffy <a class="reference external" href="http://joeduffyblog.com/2009/06/23/concurrency-and-exceptions/">added</a> an “AggregateException” and a Python PEP added <a class="reference external" href="https://www.python.org/dev/peps/pep-0654">Exception Groups</a>. It does require a new catch mechanism <code class="docutils literal notranslate"><span class="pre">try-except*</span></code>, to filter individual exceptions in the group, but it provides more control over exception handling in concurrent systems.</p>
<p>Of course true recovery still requires handling all exceptions inside the thread, before they are reported to the controller.</p>
</section>
<section id="aborts">
<h3>Aborts<a class="headerlink" href="#aborts" title="Permalink to this heading"></a></h3>
<p>An <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread.abort?view=net-6.0">abort</a> is an exception that can’t be suppressed unless you defuse it by calling <code class="docutils literal notranslate"><span class="pre">ResetAbort</span></code> with the correct token inside the catch handler. The abort is automatically re-raised at the end of any catch block that catches it without defusing it. A similar idea is an exception with a freshly defined type that can’t be matched by anything but a corresponding handler.</p>
<p>Examples include aborting a UI computation before it finishes due to a redraw, and returning a solution directly from inside a search tree’s call stack.</p>
<p>This got removed from .NET, so it’s not clear that the rethrowing/defusing behavior is needed in practice. The control flow pattern can be implemented directly with continuations.</p>
</section>
<section id="runtime-bugs">
<h3>Runtime bugs<a class="headerlink" href="#runtime-bugs" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>ExecutionEngineException</p></li>
<li><p>An Access Violation inside mscorwks.dll or mscoree.dll</p></li>
<li><p>A corrupt GC heap</p></li>
</ul>
<p>These are thrown in the runtime or core standard libraries when safety invariants have been violated. Although it’s generally a security risk to continue execution, there are cases where these exceptions can be handled, e.g. write barrier code that catches access violations and converts them into NullReferenceExceptions.</p>
</section>
<section id="cancellation">
<h3>Cancellation<a class="headerlink" href="#cancellation" title="Permalink to this heading"></a></h3>
<p>SIGKILL/SIGSTOP cannot be blocked or handled by the program, so aren’t exceptions. Similarly C’s <code class="docutils literal notranslate"><span class="pre">exit</span></code> function and the Linux <code class="docutils literal notranslate"><span class="pre">exit</span></code> syscall always shut the program down and don’t return. But Haskell provides a <code class="docutils literal notranslate"><span class="pre">ProcessCancelled</span></code> exception that propagates normally and does a hard process exit when it reaches the top level. Often processes are too coarse and one wishes to gracefully cancel a thread, so there is also a <code class="docutils literal notranslate"><span class="pre">ThreadCancelled</span></code> exception. Even finer is a <code class="docutils literal notranslate"><span class="pre">TaskCancelled</span></code> exception for a task runner library.</p>
<p>Generally with a cancellation exception you should only do cleanup. Cancellation is a message from outside of your current execution saying “you must die as soon as possible.” If you swallow the exception, you break the very nature of the cancellation mechanism. Similarly cleanup in response to cancellation should be minimal, avoiding long pauses, to ensure quick cancellation.</p>
<p>However catching the cancellation and containing it is possible, e.g. in the case of a sandbox or REPL that catches a <code class="docutils literal notranslate"><span class="pre">ProcessCancelled</span></code> exception and aborts the current evaluation instead of terminating the whole process.</p>
<p>Cancellation is not always needed. Usually one can get away with setting a flag, emptying a queue, etc. that gets checked in the processing loop and then the thread/process can finish gracefully by returning.</p>
<p>Haskell’s asynchronous exceptions allow sending a cancellation exception to another thread. Uses: timeouts, aborting speculative computation, handling resource exhaustion.</p>
</section>
<section id="signals">
<h3>Signals<a class="headerlink" href="#signals" title="Permalink to this heading"></a></h3>
<p>This mainly means <a class="reference external" href="https://man7.org/linux/man-pages/man7/signal.7.html">Linux signals</a>, excluding process commands and hardware exceptions that also use the signal API. Signals can be process-directed (kernel op, ctrl-C in terminal SIGINT, kill(2), sigqueue(2), SIGEV_SIGNAL) or thread-directed (tgkill(2), pthread_kill(3), pthread_sigqueue(3), SIGEV_THREAD_ID). A process-directed signal can be delivered to any thread of the process that isn’t masked. A thread-directed signal can only be delivered to the specified thread. The signal isn’t necessarily delivered immediately but is queued if all targeted threads are masked. The limit is 1 pending signal of each type for standard signals (id&lt;32), but real-time signals (33 to 63) can queue more up to some limit and also can carry an int-sized datum.</p>
<p>The most obvious signal is <code class="docutils literal notranslate"><span class="pre">SIGINT</span></code>, sent by doing Ctrl-C in a terminal. On Windows console Ctrl-C handling starts a new thread in the process with whatever function is passed to <code class="docutils literal notranslate"><span class="pre">SetConsoleCtrlHandler</span></code>. Also similar is Windows’ graphical UI message queue, you can get a WM_CLOSE message when the window’s X is clicked. Signals can be queued up similarly using DJB’s self-pipe trick.</p>
<p>The general idea is to do unwinding/injection in a signal handler. Since most signals are out-of-band it is natural to make them resumable.</p>
</section>
</section>
<section id="non-categorizations">
<h2>Non-categorizations<a class="headerlink" href="#non-categorizations" title="Permalink to this heading"></a></h2>
<p>The above provides a field guide to exceptions. But splitting exceptions into categories is rather loose. There are always special cases to the special cases - what is “rare” to one person might be another’s bread and butter. Some people categorize exceptions with the idea of hard-coding how a category is handled. There are very clear drawbacks of hardcoding a handling pattern - it will be unclear to programmers whether they should opt-in to the handling, and for exceptions on the fence, programmers will have to constantly convert into and out of the category. But let’s go through these proposals.</p>
<section id="unrecoverable-errors">
<h3>Unrecoverable errors<a class="headerlink" href="#unrecoverable-errors" title="Permalink to this heading"></a></h3>
<p>Joe Duffy of Midori distinguishes “recoverable errors” from “bugs”, and Herb Sutter claims “Programs bugs are not recoverable run-time errors and so should not be reported as exceptions or error codes” and “cannot be meaningfully handled”. The idea is that recoverable errors use the typical exception mechanism, while bugs panic and fail-fast. These mechanisms have been adopted in Go and Rust. But, if you look at these so-called unrecoverable errors, they turn out to be easily recoverable with a handling or containment strategy. And <a class="reference external" href="https://lkml.org/lkml/2022/9/19/1105">Linus</a> says “in the kernel, ‘panic and stop’ is not an option”. The kernel has a hard requirement that it limps along, no matter what happens, because there is no separate environment outside the kernel that can recover. There is no line in the sand where you can say “fundamental rule X has been violated, time to halt irrevocably”. If it’s not good enough for the kernel, it can’t be a mandatory design in a general-purpose language like Stroscot.</p>
<p>For example Duffy considers null pointer exceptions unrecoverable. But a command <code class="docutils literal notranslate"><span class="pre">dereference</span> <span class="pre">0</span></code> is just like a hash table lookup in terms of semantics. There is nobody saying that trying to look up a missing element in a hash table should crash the program. In fact many pointer issues cause no problems in C programs in practice and there is an <code class="docutils literal notranslate"><span class="pre">-fno-delete-null-pointer-checks</span></code> option to avoid the dumb “standard” behavior.</p>
<p>Herb Sutter wants to make allocation failures unrecoverable. But <a class="reference external" href="https://lkml.org/lkml/2022/9/19/1250">Linus</a> says “‘allocation failures cannot panic’ […] is a major kernel requirement”. Even in application programming, although it’s generally fine to panic on allocation by default, as soon as your program starts running into resource limits you start wanting more control. Being able to cancel a specific task or method call instead of the whole process is really useful. Of course here you are dealing with “soft” limits as physically running out of memory is all but impossible to due to swap.</p>
<p>Duffy argues that assertion failure is pervasive, so it must be unrecoverable so that we can make asserting functions no-throw. This is like saying that if you have a headache you should solve it by cutting off your head. There are less drastic options - fundamentally this is just a type signature problem. Stroscot is designed so you don’t need type signatures in the first place, the “lethargy” solution. Another option, “loosening”, is to include these pervasive errors in the function arrow, so a signature <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> is really <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b|Fail</span></code>. A third option “verification”  is to actually check if the assertions can be thrown, so that <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">false</span></code> must have <code class="docutils literal notranslate"><span class="pre">Fail</span></code> in the signature but tricky type signatures like <code class="docutils literal notranslate"><span class="pre">divide</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">(Int\{0})</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code> do not. Similarly, since allocation failure is configuration-dependent, it can be written to check code as though it is using an ideal memory allocator that never OOMs, or to use an analysis that allows omitting <code class="docutils literal notranslate"><span class="pre">OOM</span></code> in the signature if the function does not allocate.</p>
</section>
<section id="soft-errors">
<h3>Soft errors<a class="headerlink" href="#soft-errors" title="Permalink to this heading"></a></h3>
<p>Google says in their C++ style guide: “Invalid user input should not cause exceptions to be thrown”. This also is an overreach. Invalid input is a perfectly fine exception, because often you are in the middle of parsing a part of the input and it needs to bubble up a few levels to get an input chunk large enough to report. This style recommendation seems to be to avoid uncaught exceptions, although it’s hard to say because this is just a 1-line note in a blanket “Don’t use exceptions” prohibition and they end it with the cop out “We would need to make the style guide even longer to document these restrictions!” In Stroscot uncaught exceptions will show up as soon as you write a type signature.</p>
</section>
<section id="undefined-behavior">
<h3>Undefined behavior<a class="headerlink" href="#undefined-behavior" title="Permalink to this heading"></a></h3>
<p>Per <a class="reference external" href="https://stackoverflow.com/a/6793463">SO</a>  undefined behavior (UB) was a term originally used by the C standard to allow language constructs to behave differently across hardware. For example dereferencing 0 gave 0 on the PDP-11 but was a useful address on Interdata. These behaviors were documented in platform-specific addenda to the C standard provided by computer manufacturers and compiler implementors. Over time, the standard has moved some of this vagueness to the term “implementation-defined”. Also any discussion of “undefined behavior” has disappeared, e.g. the platform-specific addenda have disappeared, leaving compilers to define what UB means. This has made ISO C unusable for OS development. <span id="id1">[]</span> As of 2022, UB in LLVM refers to the following constructs:</p>
<ul class="simple">
<li><p>nasal demons - Examples are division by zero and null pointer read, i.e. various domain exceptions. Encountering these is supposed to be “impossible” for any conforming program, so any execution path leading to this is dead and and any transformation of this codepath that doesn’t affect defined execution paths is fine. AFAICT only gcc compiler writers like the nasal demons interpretation. It got introduced because it allowed removing checks in inner loops for significant speedups. Nasal demons can lead to unwanted optimizations - for example gcc will delete a null pointer check because the pointer was previously dereferenced hence it being null is “impossible” (Linux kernel CVE). LLVM is relatively conservative on the nasal demons and <a class="reference external" href="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html">uses traps in many cases</a></p></li>
<li><p>poison - basically an exception. Example is the result of integer overflow on non-wrapping operations. It propagates like an exception through most operations. Certain operations such as phi, select, and freeze have recovery behavior. <a class="reference external" href="https://llvm.org/docs/LangRef.html#poisonvalues">Other operations</a> such as branches, address dereference, division, returns, and calls, trigger nasal demons on poison instead of propagating.</p></li>
<li><p>undef - Examples are uninitialized variables, clobbered registers, and flags reserved by the CPU manufacturer. It’s a register with indeterminate value (kind of). It represents the set of all possible bit patterns at the specified width, with an actual value chosen non-deterministically at each read. There are <a class="reference external" href="https://web.archive.org/web/20180621011720/http://sunfishcode.github.io/blog/2014/07/14/undef-introduction.html">some issues</a> with specifying when the read occurs. LLVM is resolving these issues by replacing the value <code class="docutils literal notranslate"><span class="pre">undef</span></code> with the operation <code class="docutils literal notranslate"><span class="pre">freeze</span> <span class="pre">poison</span></code> - because it is an operation, the non-determinism side effect is precisely located. So this form of UB is effectively deprecated in favor of <code class="docutils literal notranslate"><span class="pre">poison</span></code>.</p></li>
</ul>
<p>There is a simple transformation of replacing UB with the “safe” behavior of doing runtime checks and throwing an exception upon encountering what would otherwise be UB. In particular the CompCert C interpreter’s <a class="reference external" href="https://compcert.org/man/manual004.html">UB semantics</a> are that a fatal exception is thrown once any UB is encountered.</p>
<p>Usability-wise getting rid of UB by default is great. Users like programs to either work or not work - debugging silent corruption due to a new compiler optimization is not fun. As further evidence, most new languages have decided to avoid UB and be “safe”. The most notable is Java with its VM semantics. Rust similarly panics on division by zero and <a class="reference external" href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md">panics or is well-defined for most other operations</a>.</p>
<p>Cost-wise safety is not usually that expensive. LLVM traps on UB in most cases anyways, and the general improvement in processors seems to have gotten runtime checking / exception throwing to be sufficiently fast that there is little benefit to nasal demons. Java’s HotSpot optimizations like moving checks out of tight loops get code very nearly as fast as removing the checks entirely, and memory bandwidth dominates most code anyway. The checks are all inline code with cold paths so the only real cost is a few instruction and branch prediction cache misses.</p>
<p>Static verification can make safe code zero-cost over UB by proving that a block of code cannot throw any exceptions and then removing all the exception codepaths. There is the usual reject/defer/override choice if the analysis fails. For example Zig provides “disable safety checks” compilation modes / per-block annotations which say the undefined behavior is unreachable, enabling nasal demons behavior. Zig also has a force-enable runtime safety for the disable compilation modes, but IMO this is overcomplicating and it’s simpler to drop the compilation modes and say the checks are always on unless disabled in the source.</p>
<p>Still though, there is some cost if an operation’s semantics doesn’t match the hardware - the checks cannot be eliminated by static verification. Providing “bare-metal” operations that do map 1-1 to hardware will solve this. Such operations are “safe” as well and have no undefined behavior because the hardware defines the behavior. So for example we would have x86 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">DivideError</span></code> and ARM <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0</span></code>, and these would compile to one instruction on their respective platforms (plus some unwinding code for hardware exception signal handling in the case of x86).</p>
<p>This palette of options should satisfy almost all use cases. The default of throwing exceptions is quite usable, and for speed one can code with the near-assembly bare-metal operations or fiddle around with static verification. In fact we can still get the nasal demons behavior by overriding the static verification analysis. But in this context we are clearly doing something unsafe so will expect the silent corruption if the override is incorrect.</p>
<p>Examples from <a class="reference external" href="https://www.youtube.com/watch?v=yG1OZ69H_-o">Chandler Carruth</a> and how Stroscot deals with them:</p>
<ul class="simple">
<li><p>null pointer dereference - standard operation throws exception, hardware-specific operation may produce something useful</p></li>
<li><p>sink finding algorithm on cyclic graph - reduces to <code class="docutils literal notranslate"><span class="pre">Meaningless</span></code> exception if compiler notices it, otherwise infinite loop. Quoting Chandler: “You cannot actually do this [detect infinite loops]. You will run out of the ability to detect errors and the trade-offs you’re making in performance are insane here.” But AProve identified termination in 316/497 C programs in TERMCOMP 2022, so this is in fact possible to some extent. If the termination checker can solve most of the simple cases then giving a warning for hard cases will be useful to some.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(1</span> <span class="pre">:</span> <span class="pre">u32)</span> <span class="pre">&lt;&lt;</span> <span class="pre">33</span></code> - standard operation throws exception, hardware-specific operation may produce something useful</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(1</span> <span class="pre">:</span> <span class="pre">i32)</span> <span class="pre">&lt;&lt;</span> <span class="pre">31</span></code>, <code class="docutils literal notranslate"><span class="pre">(0b11</span> <span class="pre">:</span> <span class="pre">i32)</span> <span class="pre">&lt;&lt;</span> <span class="pre">30</span></code>, <code class="docutils literal notranslate"><span class="pre">(0b111</span> <span class="pre">:</span> <span class="pre">i32)</span> <span class="pre">&lt;&lt;</span> <span class="pre">30</span></code>, <code class="docutils literal notranslate"><span class="pre">(-1</span> <span class="pre">:</span> <span class="pre">i32)</span> <span class="pre">&lt;&lt;</span> <span class="pre">31</span></code>, <code class="docutils literal notranslate"><span class="pre">(-2</span> <span class="pre">:</span> <span class="pre">i32)</span> <span class="pre">&lt;&lt;</span> <span class="pre">30</span></code> - standard operation multiplies by power of 2 like <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">(2</span> <span class="pre">^</span> <span class="pre">y)</span></code>, throws exception on overflow</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alloc(16</span> <span class="pre">+(n-1)*8)</span></code> - warn that exception may be thrown due to allocation size being negative if <code class="docutils literal notranslate"><span class="pre">n&lt;=-1</span></code>. Arbitrary-precision by default so no risk of wrapping.</p></li>
<li><p>32-bit unsigned integer index increment - follow Zig/Swift, have standard unsigned integer operations error on overflow and specialized operations that wrap</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(min_bound</span> <span class="pre">i32)</span> <span class="pre">&gt;&gt;</span> <span class="pre">7</span></code> - standard operation uses 2’s complement.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">memcpy</span> <span class="pre">null</span> <span class="pre">null</span> <span class="pre">0</span></code> - whatever makes sense to newbies. probably throws an exception.</p></li>
</ul>
</section>
<section id="sync-async">
<h3>Sync/async<a class="headerlink" href="#sync-async" title="Permalink to this heading"></a></h3>
<p>The sync/async split seems fine because they are clearly distinguished. Most languages avoid C++’s “throw any value” design and require  <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">:</span> <span class="pre">Exception</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, providing a wrapper constructor <code class="docutils literal notranslate"><span class="pre">error</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Exception</span></code> to inject values into the exception type. Similarly (per Snoyman) sync/async use different library calls, so we should require disjoint types, like <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">:</span> <span class="pre">SyncException</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">throwTo</span> <span class="pre">:</span> <span class="pre">ThreadId</span> <span class="pre">-&gt;</span> <span class="pre">AsyncException</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> and use <code class="docutils literal notranslate"><span class="pre">AsyncE</span> <span class="pre">/</span> <span class="pre">SyncE</span></code> wrappers to convert other values.</p>
<p>Also they are distinguished based on semantics. Synchronous exceptions are thrown at a clearly defined point in the instruction stream. This means the compiler can omit exception handling code if it can prove no exceptions can occur. Asynchronous exceptions originate outside the thread or flow of computation. The runtime system requires specific support to inject asynchronous exceptions into the thread, ideally allowing an exception to be injected at an arbitrary location in the code. Purely functional programming which avoids mutation and side-effects naturally has very few injection points; propagating an exception simply abandons the computation. Once injected the async exceptions bubble up like synchronous exceptions. Proving the absence of asynchronous exceptions requires a global cross-thread analysis, as well as analysis of signal IPC if those are modeled as asynchronous exceptions.</p>
<p>The general feeling seems to be “async exceptions are terrible” and to not bother. But Stroscot follows Haskell in having async exceptions anyway. The timeout and cancel functions in Haskell’s async package use async exceptions to great benefit. The Warp webserver bases all of its slowloris protection on async exceptions. The downside is that the programmer must be aware of asynchronous exceptions if they are in use by a library, in particular being aware of injection points, but this is facilitated by splitting sync and async types.</p>
</section>
</section>
<section id="patterns">
<h2>Patterns<a class="headerlink" href="#patterns" title="Permalink to this heading"></a></h2>
<p>When a function call throws an exception, a programmer must decide: handle or propagate.</p>
<section id="handle">
<h3>Handle<a class="headerlink" href="#handle" title="Permalink to this heading"></a></h3>
<p>Log: Set a flag or write to a log file and use another handling strategy</p>
<p>Recover: Swallow the exception and execute an alternate code path that does not produce an exception or produces an exception unrelated to the original. Generally you want to recover as close to the exception’s source as possible, but sometimes there is not enough context and it has to propagate a few levels before recovering.</p>
<p>While recovering from an OOM exception you have to assume that you can’t allocate more memory. The program can try to allocate memory, and this can succeed, e.g. if another thread freed memory since the OOM was thrown, but the handler should still be designed to expect this to fail. So one can’t call any memory-allocating functions - hence memory allocation should be visible in a compiler query and it should be possible to assert that a block doesn’t allocate memory. But with a little work you can restore invariants, e.g. release locks or gracefully close network connections. A high-level catch-and-dump works if you pre-allocate a buffer for the dump. If there is a reasonable boundary then a containment strategy that terminates the current task, frees up its memory, and moves on is possible. Specialized code trying to do fine-grained OOM recovery needs extensive fuzzing or real-world use; most such code is incorrect the first time around. Generally it needs to do explicit memory management and test for OOM at every allocation.</p>
<p>Presubstitution: Behave as if the exception was a specific non-exception value. Simplest form of recovery, used by IEEE floating point. For example <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">0</span></code> returns the exception <code class="docutils literal notranslate"><span class="pre">Infinity</span></code>, but <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">Infinity</span></code> is presubstituted to 0 instead of propagating the exception.</p>
<p>Resume: The exception value contains a continuation. The handler performs some work and then calls the continuation. A more complex version of recovery.</p>
<p>Retry: execute a recovery block and call the block again with modified arguments. The block is treated as a transaction, meaning that the application state is not modified by the failed block. Most complex version of recovery.</p>
<p>Containment: All exceptions are caught at a level boundary (pokemon exception handling). It’s not recovery - it doesn’t fix the exception at the source, but merely restricts the damage. The inner level cleans up its resources when the exception propagates. The outer level terminates the inner level and (often) does logging, filtering, and display. Usually the outer level is close to the base of the program. For example, an event loop or thread pool, and only an throwing task gets terminated. Or a thread terminates but not the process. Or an exception gets caught before an FFI boundary to avoid polluting the API. In a high-reliability context containment is dangerous because code may cause damage if it continues and the other threads might not be isolated from it. But it can prevent DOS attacks by allowing partial restarts, and poisoning locks ensures isolation. Another issue is that exceptions may be handled incorrectly in the middle of the call stack. Still, a common and useful pattern.</p>
<p>Terminate (abort, crash): Ask to OS to end the process. Similar to containment but the boundary is the OS. The program must be designed to be crash-only, able to handle SIGKILL without data loss. This requirement is pervasive, e.g. a network protocol cannot demand a goodbye message, file I/O must use shadow copies, etc. But in a large fraction of cases termination is the right design anyway. For example the JVM apparently has weird bugs when you catch OOM, like computing 2 + 3 = 7, so termination is the only real option. Crash-only makes people more productive at writing code, because the error case is just a single call to terminate and there are no exploitable corner cases. But termination can’t be the only handling mechanism because it doesn’t allow graceful communication to the user or containing the restart to a thread. Still, it is good practice to start with termination, find unwanted terminations during testing, and replace with a different strategy.</p>
<p>Dump core: Similar to termination but the contents of memory is written out.</p>
<p>Backtrack: Try another path of execution at a previously encountered nondeterministic choice</p>
<p>Trap: Suspend process and signal exception. Wait for another process (e.g. interactive debugger) to fix</p>
</section>
<section id="propagate">
<h3>Propagate<a class="headerlink" href="#propagate" title="Permalink to this heading"></a></h3>
<p>Unwind: Perform cleanup such as freeing resources, unlocking mutexes, restoring invariants, or setting a connection to an error state, then return the exception. The cleanup part is hard to specify - Stroscot provides invariant checking and finalizers, but it is not clear if these are sufficient. It is certainly possible to write code that unwinds correctly; and pragmatically, most code will work without any cleanup, or at least not corrupt user data.</p>
<p>Serialize: Unwinding but across a process or thread boundary. Catch action, convert to value, pass value via IPC, convert back to exception and rethrow.</p>
<p>Wrap: As unwind, but change the exception returned. Often this loses fidelity by replacing a very specific exception with a more generic one, making it harder to perform recovery unless the original exception is chained in.</p>
</section>
<section id="frequency">
<h3>Frequency<a class="headerlink" href="#frequency" title="Permalink to this heading"></a></h3>
<p>The most common behavior is unwinding, followed by containment or termination. Recovery also occurs for some interfaces that use exceptions for common cases.</p>
</section>
</section>
<section id="traces">
<h2>Traces<a class="headerlink" href="#traces" title="Permalink to this heading"></a></h2>
<p>A trace is built by keeping track of the exception as it propagates. The semantics are a little different with lazy evaluation because the propagation is demand-driven, but should be close enough. E.g. <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">{}.x</span> <span class="pre">of</span> <span class="pre">1</span> <span class="pre">-&gt;</span> <span class="pre">...</span></code> produces <code class="docutils literal notranslate"><span class="pre">MissingCaseException</span> <span class="pre">{</span> <span class="pre">trace</span> <span class="pre">=</span> <span class="pre">NoSuchAttributeException</span> <span class="pre">{...},</span> <span class="pre">...}</span></code>. With fancy formatting the nested exceptions will look like a stacktrace. Space considerations limit the depth and detail of stack traces.  For example if you accumulate over an infinite list, traces are theoretically infinite, but properly the trace display should compress this somehow. Similarly tail calls mean entries may be added or missing. So the trace is a best-effort guess subject to compiler whims - it has no formal contract. Traces are mainly useful as a light reminder to the programmer of where to look in the code in a large codebase.</p>
<p>Alas, building a trace is expensive. Throwing an exception should be cheap. What do?</p>
<p>The basic strategy is to not provide traces in the language. Code should not use traces - the exception value should contain all relevant information to handle the exception. And a trace is mostly useless for debugging as it does not contain memory values - the programmer is better off walking through a dump with a debugger. Dumping core at the time of throwing is an established practice</p>
<blockquote>
<div><p>And with reversible debugging the trace and any other information can be extracted after-the-fact in a debug environment. But how do we debug production crashes? We could run in deterministic tracing mode all the time by default. rr shows it’s possible to get the overheads low, but so far only works on Linux. Another solution is to and should allow recovery of the trace.</p>
</div></blockquote>
<p>Erlang’s solution is to only provide the first trace entry (closest to raising the exception). This is not too costly, and at least provides the file, line number, and attempted operation. E.g. assertions record the failing predicate expression.</p>
<p>But the main solution IMO is to determine that the exception is caught by a handler that doesn’t use the stack trace and optimize it away as an unused read-only operation.</p>
</section>
<section id="top-level">
<h2>Top level<a class="headerlink" href="#top-level" title="Permalink to this heading"></a></h2>
<p>There is always a top-level catch-all exception handler, which is guaranteed to not throw during handling. So exceptions never pop off the whole stack.</p>
<p>For a stateful function, the top-level handler has to figure out what to do in the case of an exception. For the most part the exceptions are known in advance, so this simply means running the exception or failure continuation in the <code class="docutils literal notranslate"><span class="pre">Task</span></code> instead of the success continuation. The failure continuation will in turn most likely retrieve the exception from the state and return it to the program continuation as an exception value. But the failure continuation could also stop the program or do something completely separate from the main program.</p>
</section>
<section id="automatic-propagation">
<h2>Automatic propagation<a class="headerlink" href="#automatic-propagation" title="Permalink to this heading"></a></h2>
<p>Exception handling can be classified as explicit or implicit, or to use <a class="reference external" href="https://github.com/apple/swift/blob/main/docs/ErrorHandlingRationale.rst#kinds-of-propagation">the Swift error handling rationale’s terms</a>, manual and automatic. Manual handling requires visible operators or control structures (markers) when calling a function that can throw exceptions, while automatic handling does not. Manual handling marks that the called function can throw exceptions, so it is also marked and typed per the Swift definitions. Automatic handling is unmarked and may be typed or untyped depending on if there is a type signature listing the possibly thrown exceptions.</p>
<p>With manual handling in unsafe languages such as C one can forget the marker, or (if it is not a single operator) write it incorrectly. Safe languages have checks for the marker integrated into the compiler - for example, Go’s errcheck linter finds unhandled exceptions and missing exception checks every time. But since the markers can be inserted automatically, why write them at all?</p>
<p>The answer I’ve come up with is that the visible marker encourages beginners to write robust code because it provides a starting point to write down all the cases and reason through their handling. It is easier to identify errors in code using manual propagation because the erroneous cases are often visibly missing or underhandled. However, specialized marker syntaxes such as Swift’s <code class="docutils literal notranslate"><span class="pre">try</span></code> or Rust’s <code class="docutils literal notranslate"><span class="pre">?</span></code> remove this advantage, making the marker just syntactic noise. It’s really only a difference for beginners, so the tutorial can garner the same advantage so long as it introduces explicit error handling first and emphasizes that automatic error propagation is a shortcut syntax and exception safety should always be considered.</p>
<p>The most common syntax is unwinding, and manual unwinding code, even if a single character, is still repetitive, tedious, ugly, and annoying boilerplate, making programmers discouraged and code less readable and maintainable. In particular there is the case where you are in a call chain several levels deep and want to throw an exception that is handled higher up - with manual propagation you would have to add unwinding code to each intervening function. But since this boilerplate is visible and translates into basic language facilities it is easy for beginners to understand. The sequencing is explicit in the translation so there is no ambiguity.</p>
<p>Automatic propagation is a language feature that makes it very easy to do unwinding. Vaguely, it decorates every expression with an early return of the form <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">expr</span> <span class="pre">of</span> <span class="pre">(e</span> <span class="pre">:</span> <span class="pre">Exception)</span> <span class="pre">-&gt;</span> <span class="pre">return</span> <span class="pre">e;</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x</span></code>. But this definition doesn’t specify which exception gets returned, e.g. from <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">throw</span> <span class="pre">b</span></code>. The more correct (operational) semantics is that as soon as an exception is evaluated (thrown) it is immediately propagated to the nearest applicable exception-catching context and the remaining part of the expression is discarded. This exposes the evaluation strategy of the language implementation. Java says left-to-right, but this prevents many optimizations. Stroscot’s answer is that the exception returned is a deterministic function of the expression and compiler version. However the compiler’s evaluation strategy is not exposed to the static verification system, so type signatures must be written as if either exception could be returned.</p>
<p><span id="id2">[<a class="reference internal" href="../zzreferences.html#id126" title="Simon Peyton Jones, Alastair Reid, Fergus Henderson, Tony Hoare, and Simon Marlow. A semantics for imprecise exceptions. ACM SIGPLAN Notices, 34(5):25–36, May 1999. URL: https://doi.org/10.1145/301631.301637 (visited on 2022-07-25), doi:10.1145/301631.301637.">PJRH+99</a>]</span> says that because automatic propagation is “nondeterministic”, <code class="docutils literal notranslate"><span class="pre">catch</span></code> should be an operation of the I/O monad - but in fact nothing in their semantics makes use of the I/O monad. <code class="docutils literal notranslate"><span class="pre">getException</span></code> is just <code class="docutils literal notranslate"><span class="pre">return</span></code> and pattern matching (section 4.4, page 9). Their approach merely uses the I/O monad as a “sin bin” for nondeterminism. Stroscot’s choice to expose the nondeterminism allows more concise and flexible pure exception handling. But since the verification system models the set of exceptions and <code class="docutils literal notranslate"><span class="pre">catch</span></code> as randomly picking one, it robustly checks all evaluation strategies, including strange possibilities such as <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">throw</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">throw</span> <span class="pre">2</span> <span class="pre">in</span> <span class="pre">try</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">try</span> <span class="pre">x</span></code> evaluating to false. (CBN expansion duplicates x, then try/catch picks different branches)</p>
<p>According to <a class="reference external" href="https://www.joelonsoftware.com/2003/10/13/13/">Joel</a> automatic propagation sucks because the early returns mean magic gotos are invisibly sprinkled throughout your code. It does take some training to learn to read code as if every line, expression, and subexpression could throw an exception and to use finalizers appropriately. But automatic propagation gives streamlined syntax. With automatic propagation it does not require any changes to a call chain to throw an exception and catch it several layers higher up. Generally, it is easy to quickly write code for the happy path using automatic propagation because you don’t mark any error paths.</p>
<p>The correctness of code using automatic propagation is hard to judge. An exception code path may unwind too soon and not restore its state properly, but this may not be obvious. There are a few mutable state strategies that are easy to check:</p>
<ul class="simple">
<li><p>construct pure values, then commit all of them at once with an atomic operation</p></li>
<li><p>use RAII so that every resource is disposed of properly</p></li>
<li><p>use type signatures to verify exception safety invariants</p></li>
</ul>
<p>But in general, these cannot guarantee that the returned state is correct. So to satisfy the Joels, Stroscot uses manual handling by default, allows opting into automatic propagation on a per-exception value basis, and out on a per-file/function basis via a warning. Stroscot also allows manual handling all the time, regardless of whether or not automatic propagation is enabled.</p>
<blockquote>
<div><p>With a variant type like <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b|Exception</span></code> a function returns either a value or an exception. So just use the normal <code class="docutils literal notranslate"><span class="pre">return</span></code> keyword to return exceptions. Then to respond to specific exceptions programmatically, returned exception-or-values can be pattern-matched like any other return value:</p>
</div></blockquote>
<p>The case handling syntax seems easy and clear, and it’s possible to locally reason about and decide how best to react to exceptions.
But a Quorum-style study should check on what’s clearest to beginners. Limiting <code class="docutils literal notranslate"><span class="pre">return</span></code> to normal values and using <code class="docutils literal notranslate"><span class="pre">throw</span></code> for <code class="docutils literal notranslate"><span class="pre">Exception</span></code> values is also a possibility.</p>
<p>Just because there is shared syntax doesn’t mean exceptions don’t propagate, exceptions still unwind if they aren’t caught by the case statement. They can be wrapped up in a Result type though to prevent propagation.</p>
</section>
<section id="syntax">
<h2>Syntax<a class="headerlink" href="#syntax" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">throw</span></code> / <code class="docutils literal notranslate"><span class="pre">catch</span></code> are the common syntax, like in Java:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BadInputError</span><span class="p">(</span><span class="s">&quot;xyz&quot;</span><span class="p">)</span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">BadInputError</span><span class="w"> </span><span class="n">badInputErr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;bad input error occurred: %s\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">badInputErr</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However these duplicate <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">/</span> <span class="pre">case</span></code>. Exceptions aren’t magic and don’t need special syntax, so we just use <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">/</span> <span class="pre">case</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="p">(</span><span class="kt">BadInputError</span><span class="w"> </span><span class="s">&quot;xyz&quot;</span><span class="p">)</span><span class="w"> </span><span class="kr">of</span>
<span class="w">  </span><span class="kt">BadInputError</span><span class="w"> </span><span class="n">badInputErr</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">printf</span><span class="w"> </span><span class="s">&quot;bad input error occurred: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="n">badInputErr</span>
<span class="w">  </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="nb">()</span>
</pre></div>
</div>
<p>Go introduced panic-recover-defer to replace throw-catch-finally.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">defer</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">recover</span><span class="p">().(</span><span class="kt">error</span><span class="p">)</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">badInputErr</span><span class="w"> </span><span class="o">*</span><span class="nx">BadInputError</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">errors</span><span class="p">.</span><span class="nx">As</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">badInputErr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;bad input error occurred: %s\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">badInputErr</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}()</span>

<span class="w">  </span><span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;validateInput: %w&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">BadInputError</span><span class="p">{</span><span class="nx">input</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;xyz&quot;</span><span class="p">}))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Per <a class="reference external" href="https://groups.google.com/g/golang-nuts/c/HOXNBQu5c-Q/m/ltQ-QHBrw9gJ">Rob Pike</a> it is deliberately hard to discriminate exceptions with the recover mechanism because “fine-grained exception handling makes code unreadable in practice”. try-catch makes the code “inside-out”.</p>
<p>Swift:
try X else catch - wraps into Either type, an exception value (failure) or a normal value (success)
try X else Y - presubstitute Y on exception</p>
</section>
<section id="no-throw">
<h2>no-throw<a class="headerlink" href="#no-throw" title="Permalink to this heading"></a></h2>
<p>The standard C++ ecosystem uses exceptions. But the extra paths introduced by exceptions <a class="reference external" href="https://grenouillebouillie.wordpress.com/2022/05/09/the-hidden-cost-of-exception-handling/">add measurable overhead</a>.  So people create forks of existing libraries that eradicate exceptions. The Windows kernel, for instance, has its own fork of the STL that doesn’t use exceptions. This bifurcation of the ecosystem is neither pleasant nor practical to sustain.</p>
</section>
<section id="exception-api">
<h2>Exception API<a class="headerlink" href="#exception-api" title="Permalink to this heading"></a></h2>
<section id="value">
<h3>Value<a class="headerlink" href="#value" title="Permalink to this heading"></a></h3>
<p>Semantically an exception-throwing function returns a tagged union of the exception value or the returned value. The exception value can store a little or a lot of data. Zig uses a global u16 enum <code class="docutils literal notranslate"><span class="pre">err</span></code> (for now, possibly to be expanded to a tagged union), with compiler support that allows writing individual error subset types across files. In C an error is an integer constant. Java uses a Throwable class. Go and Swift use an Error protocol/interface. In C++ any value can be thrown. Rust uses a polymorphic Result type that can specialize to <a class="reference external" href="https://pcarleton.com/2021/04/28/rust-what-to-pick-for-the-type-when-writing-your-own-result-type/">most of the above</a>:
* an enum containing various types of library-specific errors
* the enum <code class="docutils literal notranslate"><span class="pre">std::io::Error</span></code>, which is an ADT <code class="docutils literal notranslate"><span class="pre">Os</span> <span class="pre">i32|Simple</span> <span class="pre">ErrorKind|SimpleMessage</span> <span class="pre">ErrorKind</span> <span class="pre">str|Custom</span> <span class="pre">ErrorKind</span> <span class="pre">std::error::Error</span></code> packed to fit into a pointer-sized word
* a boxed <code class="docutils literal notranslate"><span class="pre">std:error::Error</span></code> trait</p>
<p>In languages without a tagged union type a boolean flag and two pointers are used - because the flag variable is often re-used, it will often not trigger an unused variable warning, meaning exceptions are unsafe in these languages.</p>
<p>For example, C puts the return value in an out parameter, the error in the global variable <code class="docutils literal notranslate"><span class="pre">errno</span></code>, and the boolean flag as the return, sometimes mixed with useful return info. We generally need a temporary for each return value and out parameter. So a nested function call <code class="docutils literal notranslate"><span class="pre">f(g(x))</span></code> looks like:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">tmp</span><span class="p">,</span><span class="w"> </span><span class="n">HRESULT</span><span class="w"> </span><span class="n">hr</span><span class="p">;</span>
<span class="n">hr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">)</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isError</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span>
<span class="w">     </span><span class="n">errorhandling</span><span class="p">(</span><span class="n">hr</span><span class="p">,</span><span class="w"> </span><span class="n">errno</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">hr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result</span><span class="p">)</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isError</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span>
<span class="w">     </span><span class="n">errorhandling</span><span class="p">(</span><span class="n">hr</span><span class="p">,</span><span class="w"> </span><span class="n">errno</span><span class="p">);</span>
<span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
</pre></div>
</div>
<p>Objective C uses an out-parameter <code class="docutils literal notranslate"><span class="pre">NSError**</span> <span class="pre">err</span></code> for the flag and exception data. <code class="docutils literal notranslate"><span class="pre">err</span></code> is declared locally in the calling function and used as an out-parameter multiple times. This looks like:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">NSError</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isError</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
<span class="w">     </span><span class="n">errorhandling</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isError</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
<span class="w">     </span><span class="n">errorhandling</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
</pre></div>
</div>
<p>Go uses multiple return values for exception codes. You reuse err for each call, so for <code class="docutils literal notranslate"><span class="pre">f(g(x))</span></code> you write:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">v1</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;error&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span>
<span class="p">}</span>
<span class="nx">v2</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">v1</span><span class="p">)</span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;error&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span>
<span class="p">}</span>
<span class="k">return</span><span class="w"> </span><span class="nx">v2</span>
</pre></div>
</div>
<p>C++ generally aims to give exceptions a streamlined calling convention, so that the “happy path” has no overhead. But the extra conditionals can still give significant code bloat.</p>
<p>Languages with variant types can use a single value to represent the failure/success/flag trifecta. In Haskell there’s the <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">Left</span> <span class="pre">a</span> <span class="pre">|</span> <span class="pre">Right</span> <span class="pre">b</span></code> variant type or its less informative cousin <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Either</span> <span class="pre">()</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Nothing</span> <span class="pre">|</span> <span class="pre">Just</span> <span class="pre">a</span></code>. Furthermore there is the monad transfomer <a class="reference external" href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html">ExceptT</a> equal to <code class="docutils literal notranslate"><span class="pre">ExceptT</span> <span class="pre">(m</span> <span class="pre">(Either</span> <span class="pre">e</span> <span class="pre">a))</span></code>. Scala has Either, <code class="docutils literal notranslate"><span class="pre">Option</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">a</span> <span class="pre">|</span> <span class="pre">None</span></code>, and <code class="docutils literal notranslate"><span class="pre">Try</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Success</span> <span class="pre">a</span> <span class="pre">|</span> <span class="pre">Failure</span> <span class="pre">Throwable</span></code>. Rust has Option like Scala and <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">T</span> <span class="pre">E</span> <span class="pre">=</span> <span class="pre">OK</span> <span class="pre">T</span> <span class="pre">|</span> <span class="pre">Err</span> <span class="pre">E</span></code>.</p>
<p>Variants force the caller to deal with the exception if they want to use the result.  This works well unless the call does not really have a meaningful result (e.g. <code class="docutils literal notranslate"><span class="pre">write_line</span> <span class="pre">:</span> <span class="pre">(&amp;mut</span> <span class="pre">self,</span> <span class="pre">s:</span> <span class="pre">&amp;str)</span> <span class="pre">-&gt;</span> <span class="pre">Result&lt;(),</span> <span class="pre">IoError&gt;</span></code> in Rust); then it depends on whether there is a warning for ignoring results. Variant types also tends to create a lot of nesting, one level for every sequential computation that can fail.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">parse_two_ints_and_add_them</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">parse_int</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">Err</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="w"> </span><span class="n">e</span>
<span class="w">    </span><span class="nb">Ok</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">parse_int</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nb">Err</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="w"> </span><span class="n">e</span>
<span class="w">      </span><span class="nb">Ok</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A bind operator addresses the repetitive exception handling logic but still requires nesting:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">parse_two_ints_and_add_them</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">parse_int</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>
<span class="w">    </span><span class="n">parse_int</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">y</span><span class="o">|</span>
<span class="w">      </span><span class="n">x</span><span class="o">+</span><span class="n">y</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>
</pre></div>
</div>
<p>Returning errors early from the function addresses nesting:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">parse_two_ints_and_add_them</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">parse_int</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">Err</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">Err</span><span class="w"> </span><span class="n">e</span><span class="p">)</span>
<span class="w">    </span><span class="nb">Ok</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">parse_int</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">Err</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="nb">Err</span><span class="w"> </span><span class="n">e</span><span class="p">)</span>
<span class="w">    </span><span class="nb">Ok</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">y</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To solve nesting and repetition simultaneously Rust has introduced the question mark syntax:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">parse_two_ints_and_add_them</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_int</span><span class="p">()</span><span class="o">?</span>
<span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_int</span><span class="p">()</span><span class="o">?</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">OK</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="defining-errors">
<h3>Defining errors<a class="headerlink" href="#defining-errors" title="Permalink to this heading"></a></h3>
<p>Per Snoyman <code class="docutils literal notranslate"><span class="pre">error</span> <span class="pre">&quot;something</span> <span class="pre">bad</span> <span class="pre">happened&quot;</span></code> is bad practice. String-based exception messages make proper exception handling difficult. Instead, it’s best to define a custom exception type SomethingBad, which is trivial to catch, <code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">(\SomethingBad</span> <span class="pre">-&gt;</span> <span class="pre">...)</span></code>. Syntax for defining a custom exception type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">symbol</span><span class="w"> </span><span class="kt">SomethingBad</span>
<span class="nf">show</span><span class="w"> </span><span class="kt">SomethingBad</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;something bad happened&quot;</span>
<span class="nf">isException</span><span class="w"> </span><span class="kt">SomethingBad</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">true</span>

<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="kt">SomethingBad</span>
</pre></div>
</div>
<p>It’s still a bit wordy though, a macro is better:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">exception</span><span class="w"> </span><span class="kt">SomethingBad</span><span class="w"> </span><span class="s">&quot;something bad happened&quot;</span>
</pre></div>
</div>
</section>
<section id="exceptions-in-io">
<h3>Exceptions in IO<a class="headerlink" href="#exceptions-in-io" title="Permalink to this heading"></a></h3>
<p>In Haskell there are two primitives for throwing an exception, <code class="docutils literal notranslate"><span class="pre">raise#</span> <span class="pre">:</span> <span class="pre">Exception</span> <span class="pre">-&gt;</span> <span class="pre">a|Exception</span></code> and <code class="docutils literal notranslate"><span class="pre">raiseIO#</span> <span class="pre">:</span> <span class="pre">Exception</span> <span class="pre">-&gt;</span> <span class="pre">Cmd</span></code>, wrapped as <code class="docutils literal notranslate"><span class="pre">throw</span></code> and <code class="docutils literal notranslate"><span class="pre">throwIO</span></code>. <code class="docutils literal notranslate"><span class="pre">throw</span></code> creates an exception which will propagate as soon as it is evaluated. <code class="docutils literal notranslate"><span class="pre">throwIO</span></code> is a command which will propagate once it is executed.</p>
<p>Example: interacting with a file.
Let’s consider the simplest program, suitable for scripting tasks and other things where you don’t want to think too much:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">readFile</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">handle</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">openFile</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="kt">ReadMode</span>
<span class="w">  </span><span class="n">readAllBytes</span><span class="w"> </span><span class="n">handle</span>
</pre></div>
</div>
<p>Opening might fail and interacting with the file handle might fail. How do we handle this?</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">readFileHandled</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">handle</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">openFile</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="kt">ReadMode</span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="kr">of</span>
<span class="w">    </span><span class="kt">NoSuchThing</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">handle</span>
<span class="w">    </span><span class="p">(</span><span class="kr">_</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Handle</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">readAllBytes</span><span class="w"> </span><span class="n">handle</span>

<span class="nf">readFileSafe</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">eres</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">try</span><span class="w"> </span><span class="p">(</span><span class="n">openFile</span><span class="w"> </span><span class="n">fp</span><span class="w"> </span><span class="kt">ReadMode</span><span class="p">)</span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">eres</span><span class="w"> </span><span class="kr">of</span>
<span class="w">    </span><span class="kt">Error</span><span class="w"> </span><span class="kt">NoSuchThing</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">eres</span>
<span class="w">    </span><span class="kt">Result</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">readAllBytes</span><span class="w"> </span><span class="n">handle</span>
</pre></div>
</div>
<p>In first, we represent failure via return values. E.g. if the file doesn’t exist, <code class="docutils literal notranslate"><span class="pre">openFile</span></code> reduces to an action that returns <code class="docutils literal notranslate"><span class="pre">NoSuchThing</span></code>, rather than a file handle, i.e. <code class="docutils literal notranslate"><span class="pre">openFile</span> <span class="pre">&quot;nonexistent&quot;</span></code> reduces to <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">NoSuchThing</span></code> (<code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">NoSuchThing</span></code>), type <code class="docutils literal notranslate"><span class="pre">((Handle|Error)</span> <span class="pre">-&gt;</span> <span class="pre">Task)</span> <span class="pre">-&gt;</span> <span class="pre">Task</span></code>. In second, the task instead reduces to an exception (a non-task value), i.e. <code class="docutils literal notranslate"><span class="pre">openFile</span> <span class="pre">&quot;nonexistent&quot;</span></code> reduces to <code class="docutils literal notranslate"><span class="pre">NoSuchThing</span></code>, type <code class="docutils literal notranslate"><span class="pre">(Handle</span> <span class="pre">-&gt;</span> <span class="pre">Task)</span> <span class="pre">-&gt;</span> <span class="pre">TaskE</span> <span class="pre">where</span> <span class="pre">TaskE</span> <span class="pre">=</span> <span class="pre">Exception</span> <span class="pre">|</span> <span class="pre">Task</span> <span class="pre">{</span> <span class="pre">Task</span> <span class="pre">=</span> <span class="pre">TaskE</span> <span class="pre">}</span></code>.</p>
<p>So the programs look like <code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">&gt;&gt;=</span> <span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">readAllBytes</span> <span class="pre">NoSuchThing</span> <span class="pre">cont</span></code> versus <code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">&gt;&gt;=</span> <span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">NoSuchThing</span> <span class="pre">(\handle</span> <span class="pre">-&gt;</span> <span class="pre">readAllBytes</span> <span class="pre">handle</span> <span class="pre">cont)</span></code>. With strict semantics both of these reduce to <code class="docutils literal notranslate"><span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">NoSuchThing</span></code>.</p>
<p>With the second we need <code class="docutils literal notranslate"><span class="pre">try</span></code> to walk through the <code class="docutils literal notranslate"><span class="pre">Task</span></code> structure until it hits an exception or the end of the continuation. So the first is nicer. But the second might be useful for tasks that don’t return a value and fail rarely.</p>
<p>The two approaches can be stacked; <code class="docutils literal notranslate"><span class="pre">openFile</span></code> could return a <code class="docutils literal notranslate"><span class="pre">Symlink</span></code> exceptional value or reduce to a <code class="docutils literal notranslate"><span class="pre">NoSuchThing</span></code> control-flow exception. Then <code class="docutils literal notranslate"><span class="pre">try</span></code> will return <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">(Handle|Symlink)</span> <span class="pre">|</span> <span class="pre">Error</span> <span class="pre">NoSuchThing</span></code>. But this is really verbose to handle, we really want <code class="docutils literal notranslate"><span class="pre">Result</span> <span class="pre">Handle</span> <span class="pre">|</span> <span class="pre">Error</span> <span class="pre">(Symlink|NoSuchThing)</span></code>.</p>
<p>Consider the following function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">func</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lookup</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="w"> </span><span class="n">m</span>
<span class="w">  </span><span class="n">bar</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lookup</span><span class="w"> </span><span class="s">&quot;bar&quot;</span><span class="w"> </span><span class="n">m</span>
<span class="w">  </span><span class="n">baz</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lookup</span><span class="w"> </span><span class="s">&quot;baz&quot;</span><span class="w"> </span><span class="n">m</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="n">baz</span>
</pre></div>
</div>
<p>We want composability and a unified interface across Maybe, Either, and IO. Say we need to know about why a lookup failed. <code class="docutils literal notranslate"><span class="pre">lookup</span> <span class="pre">k</span></code> could throw <code class="docutils literal notranslate"><span class="pre">KeyNotFound</span> <span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">lookup</span> <span class="pre">::</span> <span class="pre">(Eq</span> <span class="pre">k)</span> <span class="pre">=&gt;</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">[(k,</span> <span class="pre">v)]</span> <span class="pre">-&gt;</span> <span class="pre">(KeyNotFound</span> <span class="pre">k|v)</span></code>. Exceptions should unwind like Either, so if any of the lookups fail then func returns the failure. We should be able to specify a default for lookup like with <code class="docutils literal notranslate"><span class="pre">maybe</span></code>, <code class="docutils literal notranslate"><span class="pre">lookup</span> <span class="pre">key</span> <span class="pre">m</span> <span class="pre">{KeyNotFound</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">Nothing}</span></code>.  The type of <code class="docutils literal notranslate"><span class="pre">f</span></code> should not contain the lookup exceptions, <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">::</span> <span class="pre">SomeVal</span> <span class="pre">-&gt;</span> <span class="pre">SomeVal</span> <span class="pre">-&gt;</span> <span class="pre">SomeVal</span> <span class="pre">-&gt;</span> <span class="pre">(F'sExceptionType|F'sResult)</span></code>.</p>
</section>
<section id="try">
<h3>Try<a class="headerlink" href="#try" title="Permalink to this heading"></a></h3>
<p>Swift/Rust define syntactic markers for local exception propagation points, a “try” or “?” keyword at the call site. <code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">foo()</span></code> examines the ValueOrError type that <code class="docutils literal notranslate"><span class="pre">foo()</span></code> returns. If it is an exception, <code class="docutils literal notranslate"><span class="pre">try</span></code> unwinds/propagates/throws/returns the exception from the function, otherwise the function continues with the value. The claim is that without <code class="docutils literal notranslate"><span class="pre">try</span></code> exceptions are silent or invisible.</p>
<p>But in practice this is very burdensome. Every call involves an annotation, either on the function (to say it cannot generate exceptions) or on the call site (to mark propagation). It’s a lot of bookkeeping. Many languages have implemented exception handling just fine without this burden.</p>
<p>Precise type signatures offer a similar guarantee - the throwing function must be annotated to say it can throw, and the catching function must be annotated to say it can catch. But unlike <code class="docutils literal notranslate"><span class="pre">try</span></code>, with precise signatures for a call chain <code class="docutils literal notranslate"><span class="pre">A-B-C</span></code> the intervening <code class="docutils literal notranslate"><span class="pre">B</span></code> does not need any modification when <code class="docutils literal notranslate"><span class="pre">C</span></code> starts throwing exceptions, and the modifications must still be made even if <code class="docutils literal notranslate"><span class="pre">C</span></code> already throws exceptions.</p>
<p>Even without <code class="docutils literal notranslate"><span class="pre">try</span></code>, it is still possible to understand the control flow of a function - just assume every operation may throw an exception, and code accordingly. Indeed, async exceptions, OOM, and other “universal” exceptions can be thrown from almost anywhere, so <code class="docutils literal notranslate"><span class="pre">try</span></code> is just noise on every function call if these are included.</p>
<p>Still though, some people may like seeing where exceptions come from. So there is a warning <code class="docutils literal notranslate"><span class="pre">-Wunmarked-exception</span></code> that takes a set of exceptions as argument and warns for each callsite not marked with the identity function <code class="docutils literal notranslate"><span class="pre">rethrowing</span></code> that can propagate exceptions from the set. With this warning you can get Swift-like behavior for a subset of exceptions.</p>
</section>
<section id="exit-points">
<h3>Exit points<a class="headerlink" href="#exit-points" title="Permalink to this heading"></a></h3>
<p>non-local control problem: To know the resulting state by the time exception gets caught, need to know
- a program’s state at the time of the throw
- the state changes that occur while that exception is propagated up the call stack - and possibly across threads in a concurrent program</p>
<p>exceptions create an abrupt jump from one point of code to another, like goto. They create too many possible exit points for a function. To write correct code, you really have to think about every possible code path through your function. Every time you call a function that can raise an exception and don’t catch it on the spot, you create opportunities for surprise bugs caused by functions that terminated abruptly, leaving data in an inconsistent state, or other code paths that you didn’t think about.</p>
<p>It is true that what should be a simple 3 line program often blossoms to 48 lines when you put in good exception checking, but that’s life, and papering it over with exceptions does not make your program more robust.</p>
</section>
</section>
<section id="signatures">
<h2>Signatures<a class="headerlink" href="#signatures" title="Permalink to this heading"></a></h2>
<p>Callers have to code to handle the exceptions, so they need to know which exceptions are thrown. The exception set is part of the return type and function semantics.</p>
<p>There are several warnings that check exception lists:</p>
<ul class="simple">
<li><p>unused-exception - an exception or exception set is listed, but there is no way to throw it</p></li>
<li><p>unlisted-exception - an exception may be thrown on a given input, but is not contained in the return type</p></li>
<li><p>duplicate-exception - supposing the return type is <code class="docutils literal notranslate"><span class="pre">E1|E2|R</span></code>, both <code class="docutils literal notranslate"><span class="pre">E1|R</span></code> and <code class="docutils literal notranslate"><span class="pre">E2|R</span></code> are valid signatures</p></li>
</ul>
<p>Sample signature styles (enforced by the compiler where relevant):</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">precise</span></code> - the set of thrown exceptions is listed in the signature. All possible exceptions given the types of the arguments are listed, and no unreachable exceptions are allowed in the list.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lower</span></code> - a set of definitely thrown exceptions are listed, but other exceptions may be thrown</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">upper</span></code> - like precise, all possible exceptions must be listed, but unreachable excpetions may also be listed</p></li>
</ol>
<p>With <code class="docutils literal notranslate"><span class="pre">lower</span></code> it is not possible to say that a function doesn’t throw, but with the other two it is.</p>
<section id="call-chains">
<h3>Call chains<a class="headerlink" href="#call-chains" title="Permalink to this heading"></a></h3>
<p>The <a class="reference external" href="http://web.archive.org/web/20060101083304/http://discuss.develop.com/archives/wa.exe?A2=ind0011A&amp;L=DOTNET&amp;P=R32820">C# post</a> complains that if you have a chain <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">catch</span> <span class="pre">...;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">c;</span> <span class="pre">c</span> <span class="pre">=</span> <span class="pre">d;</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">...</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code> is changed from no-throw to throwing <code class="docutils literal notranslate"><span class="pre">SomeException</span></code>, then <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code> must have <code class="docutils literal notranslate"><span class="pre">...|SomeException</span></code> added to their type.</p>
<p>This is similar to Java’s checked exceptions and Swift says they like this requirement because it adds extra static safety. When you add a new exception to <code class="docutils literal notranslate"><span class="pre">d</span></code> you get exception messages for all the call sites and can decide to handle or propagate to fix each site. Swift gets a similar but less precise safety check from marking call sites as throwing with <code class="docutils literal notranslate"><span class="pre">try</span></code>.</p>
<p>But the C# posts says having to change all the type signatures just to throw an exception is a pain. It encourages “swallowing” exceptions by catching and ignoring them, instead of changing the signatures. Swallowing can result in an inconsistent state with no debugging traces. Handling exceptions at the appropriate place is better - e.g. in this case function <code class="docutils literal notranslate"><span class="pre">a</span></code> might have more knowledge of the state of the world.</p>
<p>With exception set synonyms the amount of work needed to add an exception can be minimized. Java only allows defining synonyms with superclasses, which isn’t really composable if you have different libraries. But set union and difference are quite useful and mean that the program can adapt to exception behavior without advance planning.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">lower</span></code> style of signature doesn’t require any synonyms because exceptions can be omitted from the signatures, but uses synonyms for commonly occuring sets of exceptions. This is the most efficient in terms of productivity because the code requires no extra work for exception changes. If a user wants to document that some exceptions are thrown they can add them to the signature. But it isn’t required, and it adds extra work later if you want to stop throwing the exception.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">upper</span></code> a synonym style is to define one exception set <code class="docutils literal notranslate"><span class="pre">LibraryException</span></code> with all the common exceptions your library throws (overflow, divide by zero, out of memory, etc.) and use that in each signature. It is not too hard to maintain a single exception set for a library. It’s a little better than Java’s <code class="docutils literal notranslate"><span class="pre">throws</span> <span class="pre">Exception</span></code> because the exception set is finite, but requires almost as little maintenance as <code class="docutils literal notranslate"><span class="pre">lower</span></code>. Exceptions that people should care about can be documented by adding them redundantly to the signature, <code class="docutils literal notranslate"><span class="pre">DivideByZero|LibraryException</span></code>. And exceptions that aren’t thrown can be asserted by removing them, e.g. <code class="docutils literal notranslate"><span class="pre">LibraryException\DivideByZero</span></code>.
Application code can use set operations to build a combined set, <code class="docutils literal notranslate"><span class="pre">AppException=(Library1Exception|Library2Exception)\(HandledException1|HandledException2)</span></code>.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">precise</span></code>, the style I came up with is to have a built-in compiler function <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">_</span></code> that computes the exception set of each function. Then for the actual signature you can write a self-referential signature <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">...</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">|</span> <span class="pre">exceptions</span> <span class="pre">a</span></code>, if you don’t want to make any guarantees about exception behavior, or <code class="docutils literal notranslate"><span class="pre">Int</span> <span class="pre">|</span> <span class="pre">(exceptions</span> <span class="pre">a</span> <span class="pre">\</span> <span class="pre">SomeException)</span></code>, to say that <code class="docutils literal notranslate"><span class="pre">SomeException</span></code> is not thrown, or <code class="docutils literal notranslate"><span class="pre">Int</span> <span class="pre">|</span> <span class="pre">(exceptions</span> <span class="pre">a</span> <span class="pre">|</span> <span class="pre">SomeException)</span></code>, to say that <code class="docutils literal notranslate"><span class="pre">SomeException</span></code> is definitely thrown. <code class="docutils literal notranslate"><span class="pre">exception</span> <span class="pre">x</span></code> is somewhat magical is that it knows the rest of the signature and scopes the list of exceptions appropriately, e.g. for the signature <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">|</span> <span class="pre">ExceptionA</span></code>, <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">ExceptionA</span></code>, but for the signature <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span> <span class="pre">|</span> <span class="pre">ExceptionB</span></code>, <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">ExceptionB</span></code>, and similarly in the signature <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">|</span> <span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">|</span> <span class="pre">Bool</span> <span class="pre">|</span> <span class="pre">exceptions</span> <span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">ExceptionA</span> <span class="pre">|</span> <span class="pre">ExceptionB</span></code>.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">precise</span></code> you can also write a specification without referencing <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">a</span></code>. doing a “full list” of all the component exceptions, or a “computed list” writing the set as a computation of child functions. So if <code class="docutils literal notranslate"><span class="pre">a</span></code> returns <code class="docutils literal notranslate"><span class="pre">Int</span></code> normally and calls <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code> and catches <code class="docutils literal notranslate"><span class="pre">SomeException</span></code> from <code class="docutils literal notranslate"><span class="pre">b</span></code>, then the computed list would be <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">|</span> <span class="pre">(exceptions</span> <span class="pre">b</span> <span class="pre">\</span> <span class="pre">SomeException)</span> <span class="pre">|</span> <span class="pre">exceptions</span> <span class="pre">c</span></code>. Both types of list cost some thought but ensure reliability as every exception is accounted for. A full list ensures that control flow is local because newly thrown exceptions must be caught or added to the list for every method in the chain. A computed list does not list exceptions that propagate through the function, so is less verbose. To newly throw an exception, it only needs to listed where it is thrown and where it is caught.</p>
<p>Lists are somewhat mindless in that the compiler knows the exceptions thrown better than the developer. The compiler should be able to compute <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">x</span></code> precisely and report it to the user, even if no annotations are used. In fact there should be two ways of reporting it, to follow the two styles of list: listing out all the thrown exceptions as a set (using predefined sets but not referencing any computed <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">x</span></code>), or printing how to compute the thrown exceptions based on the thrown exceptions of the child functions (using <code class="docutils literal notranslate"><span class="pre">exceptions</span> <span class="pre">x</span></code> as closely as possible). Then the developer can read the spec, see that it looks alright, and copy it as a signature, and with an IDE fix signatures in just a few clicks.</p>
<p>So with <code class="docutils literal notranslate"><span class="pre">lower</span></code> or the self-referential <code class="docutils literal notranslate"><span class="pre">precise</span></code> style, no extra work is required to throw an exception, with <code class="docutils literal notranslate"><span class="pre">upper</span></code> one synonym has to be changed (the global list), with <code class="docutils literal notranslate"><span class="pre">precise</span></code> “computed list” style two signatures have to be changed (the thrower and the catcher), and with <code class="docutils literal notranslate"><span class="pre">precise</span></code> “full list” style all signatures between thrower and catcher have to be changed.</p>
<p>The full list style is attractive for small projects, but as Gunnerson says, for large projects this requires too much maintenance and thus decreases productivity and code quality. But there are various viable alternatives, with varying levels of precision.</p>
</section>
<section id="java-checked-exceptions">
<h3>Java checked exceptions<a class="headerlink" href="#java-checked-exceptions" title="Permalink to this heading"></a></h3>
<p>Java uses <code class="docutils literal notranslate"><span class="pre">upper</span></code> but with a set of unchecked exceptions (Error and RuntimeException) implicitly included as possibilities. For practical purposes this is basically the same as <code class="docutils literal notranslate"><span class="pre">upper</span></code>. With the call chain-compatible style it’s just defining <code class="docutils literal notranslate"><span class="pre">LibraryException=...|RuntimeException</span></code> - it doesn’t really affect the style. RuntimeException is overly broad, for example division by zero should be checked.</p>
<p>A minimal set of common exceptions is those that pure functions can throw without using an explicit throw statement: async exceptions, OOM, stack overflow, and nontermination. But here it is still arguable that nontermination shouldn’t be a common exception because most pure functions terminate and knowing that a function doesn’t return is useful. With <code class="docutils literal notranslate"><span class="pre">upper</span></code> the problem is resolved definitively because there are no implicitly allowed exceptions.</p>
<p>A reduction in the cost of checked exceptions is to use a single “throws” keyword that allows all checked exceptions (similar to “throws Exception” in Java). The pain of versioning is reduced: either a function fails or it doesn’t. The failure code is often irrelevant to handling. Swift, Midori approach. I like the synonym style of <code class="docutils literal notranslate"><span class="pre">upper</span></code> better, and using <code class="docutils literal notranslate"><span class="pre">|Exception</span></code> with <code class="docutils literal notranslate"><span class="pre">upper</span></code> to mimic this style is an option.</p>
</section>
<section id="default-signature-type">
<h3>Default signature type<a class="headerlink" href="#default-signature-type" title="Permalink to this heading"></a></h3>
<p>For user types what exception style should signatures like <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> use by default?</p>
<p>The compiler will use model checking for coverage checking and code generation, so most spurious warnings that an impossible exception can escape won’t appear - e.g. checking that a string contains only digits will ensure that the <code class="docutils literal notranslate"><span class="pre">parseInteger</span></code> function doesn’t fail, so the compiler won’t warn about an uncaught <code class="docutils literal notranslate"><span class="pre">FailedParse</span></code> exception. If the compiler can’t prove it directly then an assertion will ensure an assertion failure  is thrown instead of the exception.</p>
<p>And the return type doesn’t matter for overloading. But there is still the input validation situation where you know that a file is CSV but the compiler will warn that the parse can fail.</p>
<p>Going off of Haskell pure functions are common and should use minimal syntax. But pure functions can still fail with exceptions - assertions, OOM, etc. Similarly system calls may throw rare exception codes that don’t need to be handled in practical programming. <code class="docutils literal notranslate"><span class="pre">precise</span></code> or <code class="docutils literal notranslate"><span class="pre">upper</span></code> would be verbose with maintaining the exception lists. <code class="docutils literal notranslate"><span class="pre">lower</span></code> gives succinct type signatures: write the exceptions that callers should care about and ignore the rest.  So for example one can write <code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">:</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">:</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">a|EmptyListException</span></code> depending on what’s important.</p>
<p>With proper set definitions as in the previous section <code class="docutils literal notranslate"><span class="pre">precise</span></code> and <code class="docutils literal notranslate"><span class="pre">upper</span></code> may not be so bad. These styles are definitely useful, but even so the signatures may be too complex for most users. In the end my preference is <code class="docutils literal notranslate"><span class="pre">lower</span></code> by default and <code class="docutils literal notranslate"><span class="pre">precise</span></code> for <code class="docutils literal notranslate"><span class="pre">total</span></code> declarations. But it still needs a survey to confirm this, as with most syntax decisions.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">lower</span></code> there can be a warning that a listed exception has no handling code anywhere in the program (uncaught exception). Doing a similar thing with <code class="docutils literal notranslate"><span class="pre">upper</span></code> or <code class="docutils literal notranslate"><span class="pre">precise</span></code> would give false positives for uncommon exceptions like the unknown system call codes that don’t need to be handled.</p>
</section>
<section id="fresh-exceptions">
<h3>Fresh exceptions<a class="headerlink" href="#fresh-exceptions" title="Permalink to this heading"></a></h3>
<p>A model where every function can randomly return exceptions is good <a class="reference external" href="https://en.wikipedia.org/wiki/Chaos_engineering">chaos engineering</a>. A function that doesn’t throw exceptions can still be typed as throwing exceptions, and with automatic exception propagation, there is often no actual handling code needed when adding a new exception. We can formalize this with the notion of “fresh” exceptions, exceptions using new (fresh) symbols that may or may not be in various sets. Propagating and catching such exceptions is dependent entirely on the sets the exception is in and are the same for all fresh exceptions in the same sets. If the function is written to handle one such “fresh” exception appropriately then it can be inferred to handle all fresh exceptions appropriately. And with async exceptions, all functions must be written to handle fresh exceptions or to handle async exceptions as a set.</p>
<p>Adding or removing a fresh exception to a function throwing a lot of fresh exceptions is not a semantic change - the function still throws fresh exceptions. The semantic behavior comes when there is a handler that matches on the exception. Removing said exception from the throw list results in dead code but does not break any contracts if the function’s invariants still hold. So the only breaking API change is adding a non-fresh exception that client code unexpectedly matches. For example if you have <code class="docutils literal notranslate"><span class="pre">{a;</span> <span class="pre">b}</span> <span class="pre">catch</span> <span class="pre">(\FooException</span> <span class="pre">-&gt;</span> <span class="pre">...)</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span></code> is throwing <code class="docutils literal notranslate"><span class="pre">FooException</span></code>, then <code class="docutils literal notranslate"><span class="pre">b</span></code> also throwing <code class="docutils literal notranslate"><span class="pre">FooException</span></code> could lead to unexpected results if the handler for <code class="docutils literal notranslate"><span class="pre">FooException</span></code> is only designed to handle <code class="docutils literal notranslate"><span class="pre">a</span></code>. This can be avoided by always using fresh symbols for new exceptions.</p>
<p>So the lifecycle looks like:</p>
<div class="graphviz"><object data="../_images/graphviz-c34385eb2654c2cdb40249a2f7e1a566cd233d05.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {

nonexistent [label=&quot;not thrown, not caught&quot;]
fresh [label=&quot;thrown, not caught&quot;]
dead [label=&quot;not thrown, caught&quot;]
mature [label=&quot;thrown, caught&quot;]

nonexistent -&gt; fresh [label=&quot;add failure&quot;]
fresh -&gt; mature [label=&quot;add handler&quot;]

mature -&gt; dead [label=&quot;remove failure&quot;]
fresh -&gt; nonexistent [label=&quot;remove failure&quot;]

dead -&gt; nonexistent [label=&quot;remove handler&quot;]
mature -&gt; fresh [label=&quot;remove handler&quot;]

}</p></object></div>
<p>The key here is that removing an in-use failure from a function is not reversible; you can only add a fresh exception, not an in-use exception. This is an “open-world” style of exception handling.</p>
<p>There is also a “closed-world” style enforced by <code class="docutils literal notranslate"><span class="pre">upper</span></code>, where the code is not designed to allow adding fresh exceptions and expects to deal with a fixed set of exceptions. Here it is not possible to add exceptions without breaking the API. But removal is fine. This can be worked around by wrapping new exceptions in old exception types and “escaping” the type checking, but it’s better to break the API.</p>
</section>
<section id="composability">
<h3>Composability<a class="headerlink" href="#composability" title="Permalink to this heading"></a></h3>
<p>Function types which cannot generate exceptions are subtypes of function types which can. To use higher order functions like map, polymorphic types like <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a</span> <span class="pre">b.</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">t</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">t</span> <span class="pre">b</span></code> should allow <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> to contain exceptions. To reason about this properly <code class="docutils literal notranslate"><span class="pre">upper</span></code> or <code class="docutils literal notranslate"><span class="pre">precise</span></code> types are needed. There doesn’t seem to be any downside to deferring exception propagation and treating exceptions as values when applying higher-order functions. Higher-order exception handling constructs are possible, but in practice most Haskell code seems to stick with catch or try. The only really complex construct is <code class="docutils literal notranslate"><span class="pre">bracket</span></code> but that’s handled in Stroscot with finalizers.</p>
<p>It is quite useful to know the domain for which a function cannot generate exceptions. So usually a function will have two signatures, a “narrow” type for which the function doesn’t throw exceptions and a “wide” type for which it does, e.g. <code class="docutils literal notranslate"><span class="pre">(/)</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">(Int\{0})</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code> and <code class="docutils literal notranslate"><span class="pre">(/)</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int|DivisionByZero</span></code>. Ideally the compiler can prove that the narrow type is appropriate and specialize code to not use exceptions. This can be ensured by specifying a signature at the usage site that excludes the exceptions.</p>
<p>Stroscot’s sets allow unions, e.g. you can express throwing <code class="docutils literal notranslate"><span class="pre">MyException</span></code> or <code class="docutils literal notranslate"><span class="pre">HisException</span></code> as <code class="docutils literal notranslate"><span class="pre">x|MyException|HisException</span></code>. This makes combining libraries and their exception types fairly straightforward. This is impossible in many languages. Java’s workaround is to instead use superclass catch-all types such as IOException and ReflectiveOperationException. It’s not clear how useful these superclasses are - Swift claims reacting to an arbitrary IOException is difficult. IOExceptions can at least use an operation failure path that for example retries the operation a couple times, while Exceptions are so general that retrying may not make sense. But Storscot’s subsets allow fine-grained definition so are much more expressive.</p>
<p>Snoyman <a class="reference external" href="https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell/">discusses</a> using a <code class="docutils literal notranslate"><span class="pre">Text</span></code> type - it avoids the need for a real exception type, but means all exceptions are unstructured and can’t be handled appropriately. His preferred approach is the constraint <code class="docutils literal notranslate"><span class="pre">MonadThrow</span> <span class="pre">m</span></code>, but this throws <code class="docutils literal notranslate"><span class="pre">Exception</span></code> and isn’t fine-grained. We could generalize by adding a type parameter to <code class="docutils literal notranslate"><span class="pre">MonadThrow</span></code>, <code class="docutils literal notranslate"><span class="pre">(MonadThrows</span> <span class="pre">m</span> <span class="pre">MyException,</span> <span class="pre">MonadThrows</span> <span class="pre">m</span> <span class="pre">HisException)</span> <span class="pre">=&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">Int</span></code>, but now it’s clear that this is the <a class="reference external" href="https://web.archive.org/web/20200510033212/https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/">existential typeclass antipattern</a> and <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">Int|MyException|HisException</span></code> is much clearer.</p>
<p>Another note is that Stroscot’s signatures are independent - they all are checked against the implementation, rather than a type interface. For example the following:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="o">|</span><span class="kt">Exception</span>
<span class="nf">a</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="kt">NegativeException</span>

<span class="nf">b</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="o">|</span><span class="kt">NegativeException</span>
<span class="nf">b</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

<span class="nf">c</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">3</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">a</span></code> can define a broad type for programmer convenience. But <code class="docutils literal notranslate"><span class="pre">b</span></code> can defined a precise type, e.g. for an exported interface. <code class="docutils literal notranslate"><span class="pre">c</span></code> declares that it throws no exceptions even though it calls exception-throwing functions, because the compiler can rule out those exceptions. With Java’s checked exceptions, <code class="docutils literal notranslate"><span class="pre">a</span></code>’s signature would require <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code> to declare <code class="docutils literal notranslate"><span class="pre">throws</span> <span class="pre">Exception</span></code> or write a useless try-catch.</p>
</section>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this heading"></a></h2>
<p>The implementation needs to transfer control from throw to catch, and run finalizers.</p>
<p>To illustrate take a simple example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="kt">Exception</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="mi">42</span>
<span class="nf">bar</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">foo</span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="nf">baz</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="p">`</span><span class="n">catch</span><span class="p">`</span><span class="w"> </span><span class="nf">\</span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">print</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span>
</pre></div>
</div>
<section id="return-codes">
<h3>Return codes<a class="headerlink" href="#return-codes" title="Permalink to this heading"></a></h3>
<p>With return codes this becomes:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">throw</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span>
<span class="c1">-- foo unchanged</span>
<span class="nf">bar</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">tmp</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">foo</span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="kr">of</span>
<span class="w">    </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">isException</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="n">e</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="nf">baz</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">tmp</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">bar</span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="kr">of</span>
<span class="w">    </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">isException</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">x</span>
</pre></div>
</div>
<p>The tagged union for the value and the exception code costs extra registers/memory. It’s setup/teardown on every call. Inlining helps, as does encoding the union as a machine word by returning exceptions via unusual return values such as negative numbers or zero. The values are often specific to the function and the values of the arguments.</p>
<p>Also checking the codes creates branches. Although the branches can usually be predicted they still pollute the cache and the duplicated exception-checking code takes up a lot of space. The branches add overhead to the non-exception path. But the exception path suffers no significant penalties compared to the non-exception path - it’s a symmetric approach.</p>
</section>
<section id="continuations">
<h3>Continuations<a class="headerlink" href="#continuations" title="Permalink to this heading"></a></h3>
<p>The continuation-based approach depends on two things: callCC and dynamic scoping. Both of these are somewhat tricky to implement but end up with minimal overhead in compiled code. Basically, <code class="docutils literal notranslate"><span class="pre">throw</span></code> ends up being a continuation action passed via dynamic scoping. The interesting behavior is all in <code class="docutils literal notranslate"><span class="pre">catch</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">body</span><span class="w"> </span><span class="n">catch</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">old</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">throw</span>
<span class="w">  </span><span class="n">callCC</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">ec</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">    </span><span class="n">return</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">{</span><span class="n">throw</span><span class="ow">=</span><span class="n">old</span><span class="p">}</span>
<span class="w">    </span><span class="n">continue</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">continue</span><span class="w"> </span><span class="p">{</span><span class="n">throw</span><span class="ow">=</span><span class="n">old</span><span class="p">}</span>
<span class="w">    </span><span class="n">break</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">break</span><span class="w"> </span><span class="p">{</span><span class="n">throw</span><span class="ow">=</span><span class="n">old</span><span class="p">}</span>
<span class="w">    </span><span class="n">throw</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">ex</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">ec</span><span class="w"> </span><span class="p">(</span><span class="n">handler</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">throw</span><span class="ow">=</span><span class="n">old</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">body</span>
<span class="w">  </span><span class="p">)</span>
</pre></div>
</div>
<p>The throw is unregistered if the function returns normally, otherwise <code class="docutils literal notranslate"><span class="pre">throw</span></code> restores the context and jumps to the handler.</p>
<section id="setjmp-longjmp">
<h4>setjmp / longjmp<a class="headerlink" href="#setjmp-longjmp" title="Permalink to this heading"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">setjmp</span></code> / <code class="docutils literal notranslate"><span class="pre">longjmp</span></code> are an inefficient stack-based implementation of continuations. The registers must all be saved, costing a lot on both exception and non-exception paths. It’s disliked.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">body</span><span class="w"> </span><span class="n">catch</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">e</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="kt">NoException</span>
<span class="w">  </span><span class="n">ctx</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">setjmp</span><span class="nb">()</span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">NoException</span>
<span class="w">    </span><span class="n">body</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="n">ex</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">ex</span><span class="p">;</span><span class="w"> </span><span class="n">longjmp</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kr">else</span>
<span class="w">    </span><span class="n">handler</span><span class="w"> </span><span class="p">(</span><span class="n">read</span><span class="w"> </span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="unwinding-tables">
<h4>Unwinding tables<a class="headerlink" href="#unwinding-tables" title="Permalink to this heading"></a></h4>
<p>Unwinding tables are another stack-based implementation of continuations. The instruction pointer is used to find the loaded segment and its corresponding unwinding table. Every non-leaf function has an entry, and the return address on the stack is looked up to jump into handling code or code to pop the stack frame and restore register invariants. Since the tables can be cold and there’s no branches on the non-exception path, the non-exception path is quite fast. But it’s not zero cost because the exception path may keep registers alive that the non-exception path doesn’t use, the code to read the tables takes up some space, and there are relocations at load time for the tables themselves.</p>
<p>Unwinding tables both help and harm performance. They require lots of data for the runtime support to unwind stacks, search for handlers, and so on. And compared to exception values these tables are slow to look up for the exception path. But if you have many levels of unwinding the normal path is faster because the values aren’t wrapped and the handlers are cold and aren’t dirtying your instruction cache or TLB.</p>
<p>The table-based system ended up being roughly 7% smaller and 4% faster (geomean) than the return code-based on some key benchmarks.</p>
<p>Another optimization is to cache exceptions as static data, so that throw doesn’t allocate.</p>
<p>stack overflow in SEH filter clauses can be interpreted as not handling the exception.</p>
<p>Microsoft’s implementation of C++ exceptions allocates on the stack, and delays deallocation until the end of a C++ catch clause. It is quite inefficient in terms of stack usage.</p>
</section>
</section>
<section id="zero-overhead">
<h3>Zero overhead<a class="headerlink" href="#zero-overhead" title="Permalink to this heading"></a></h3>
<p>Whatever marketing you have heard about zero-overhead C++ exceptions is misleading. Per <a class="reference external" href="https://grenouillebouillie.wordpress.com/2022/05/09/the-hidden-cost-of-exception-handling/">measurements</a> (also in Herb Sutter’s thing IIRC), just turning on exception handling support in a C++ project previously compiled without exception support, not throwing any exceptions at all, gives a 15-52% binary size increase. The overhead arises from jump tables, additional stack space per thread (e.g., a 1K reservation, to save a dynamic allocation) and additional thread-local storage. For this reason many C++ projects disable exceptions.</p>
<p>With a proper design, a flag to turn off exceptions should not be needed. The compiler should be able to prove that code cannot throw exceptions and optimize away catch handlers accordingly. Only assertions that a function cannot throw are needed, to help the compiler with its proofs.</p>
<p>As far as strategy I’m thinking to switch between return codes and continuations depending on how hot the exception path is. Exception propagation for common exceptions (above 30%) should be handled by return codes. It would be good to bias the implementation somewhat towards the hot path (exception or not), e.g. by moving cleanup code on the cold path to the end of the function, out of the hot code path, but missing this isn’t enough to seriously compromise performance. Continuation-based unwinding should be reserved for really rare exceptions, 1 in 100 or less, where cache misses predominate.</p>
</section>
</section>
<section id="interruptible-cleanup">
<h2>Interruptible cleanup<a class="headerlink" href="#interruptible-cleanup" title="Permalink to this heading"></a></h2>
<p>Interruptible cleanup actions - the interaction of async exceptions and cleanups. A cleanup function which may block and should be interruptible to avoid a long delay in execution.</p>
<p>When closing a file one often wants to flush buffers (fsync). So there are 3 variants of hClose:
* The flush marks a checkpoint, and should retry until complete regardless of interruptions
* The flush is unnecessary, just close the file
* The flush is productive but interruptible (EINTR), and should not be retried on interrupt. This avoids the situation where the flush takes a long time and the thread is unkillable. Note that it requires two async exceptions to kill the thread, one to enter the cleanup handler and another to interrupt the flush.</p>
<p>The Linux close syscall is interruptible, but it is guaranteed to close the file even if interrupted. Similarly hClose should close the file handle in all cases. Except when hClose is used outside the context of a cleanup, e.g. in the acquire part of bracket, interrupting should avoid visible side effects and interrupted hClose should not close the file.</p>
<p>sending a final “goodbye” message over a TCP connection.</p>
<p>putMVar/takeMVar: these should use tryPutMvar/tryTakeMVar</p>
<p>the default: with interruptibleMask or a separate bracketInterruptible this is a matter of taste. uninterruptibleMask provides behavior that is easier to reason about, but may block for an unbounded amount of time, possibly leading to deadlock.</p>
<p>“I don’t want this action to throw exceptions. Sync exceptions are all caught, now I want uninterruptibleMask to disable async exceptions.” or “I want this interruptible action for logging; I ensured the resource will be released if this action fails, so I disable async exceptions here only because the policy requires that”.</p>
<p>an openFile might talk to a network mounted NFS drive and take 30s or so in the worst case. but this is where async exceptions interrupt the operation.</p>
<section id="injection">
<h3>Injection<a class="headerlink" href="#injection" title="Permalink to this heading"></a></h3>
<p>Most languages use polling solutions to implement semi-asynchronous exceptions. These make various operations interruptible, i.e. before/after executing they check for async exceptions and if so inject the exception. But this isn’t good enough since a lot of time may be spent between checks. A true async solution has no polling, the thread jumps directly to handling code.</p>
<p>On Linux we can use the <code class="docutils literal notranslate"><span class="pre">pthread_kill</span></code> API to inject true async exceptions as signals. This sends a signal to interrupt the thread, which if unhandled will simply terminate the process, so one must install a signal handler. Similar to hardware exceptions this handler does the equivalent of a <code class="docutils literal notranslate"><span class="pre">siglongjmp</span></code> to return from the signal handler into a normal execution context, and then does the unwinding magic (using DWARF or similar).</p>
<p>On Windows there is <a class="reference external" href="https://stackoverflow.com/questions/37378035/how-to-signal-a-specific-thread-in-windows">no direct equivalent</a> to <code class="docutils literal notranslate"><span class="pre">pthread_kill</span></code>. But internally the functionality is there: a kernel-mode APC sets <code class="docutils literal notranslate"><span class="pre">RequestInterrupt=TRUE</span></code> so the scheduler will interrupt a running thread even if it’s in a long computation. But we cannot directly create a kernel-mode APC from user code. There are some options:</p>
<ul class="simple">
<li><p>The QueueUserAPCEx Windows driver implements an API to create a kernel-mode APC. But signing drivers on recent versions of Windows is impossible.</p></li>
<li><p>SuspendThread issues a kernel-mode APC (API intended for debuggers). So we pause the thread with SuspendThread, save its state via GetThreadContext, make a new context with the instruction pointer set to the handler, and resume the thread with SetThreadContext and ResumeThread. But it’s low-level and requires several kernel roundtrips. Also GetThreadContext may <a class="reference external" href="https://stackoverflow.com/questions/3444190/windows-suspendthread-doesnt-getthreadcontext-fails">fail</a>.</p></li>
<li><p>Windows 10 RS5 adds “Special User APCs” (QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC) which are delivered quickly via a kernel-mode APC, but then run as a user APC. The kernel-level API passes in a CONTEXT argument containing the registers from before the APC, like Linux’s signal handler, but the documented API doesn’t have this info. It may be possible to get it somehow with the documented API, or we can live dangerously and use the kernel-level API.</p></li>
</ul>
<p>System calls on Windows are implemented with layers of C in between, so the handler has to ensure the C code completes to ensure proper cleanup. So it walks the stack and overwrites the first user-mode frame with an exception handling information frame, skipping internal Windows stack frames. This functionality is also useful on Linux, if we’re using glibc.</p>
<p>throwTo the calling thread is an interesting academic question - the easiest is to define it as throw. GHC has some weird suspension behavior that interacts with unsafePerformIO.</p>
</section>
<section id="masking">
<h3>Masking<a class="headerlink" href="#masking" title="Permalink to this heading"></a></h3>
<p>Asynchronous exceptions can be masked, then they get delayed to the unmask call. It allows writing “reliable” code that functions correctly even if an async exception is sent. But, if you mask async exceptions all the time, async cancellation will hang indefinitely. Use finalizers instead of masking wherever possible.</p>
<p>Most code should run unmasked, and if you do mask the scope of the mask should be minimized to ensure that asynchronous exceptions can be handled ASAP.</p>
<p>The mask function is <code class="docutils literal notranslate"><span class="pre">mask</span> <span class="pre">io</span> <span class="pre">=</span> <span class="pre">if</span> <span class="pre">Masked</span> <span class="pre">then</span> <span class="pre">io</span> <span class="pre">{unmask</span> <span class="pre">=</span> <span class="pre">id}</span> <span class="pre">else</span> <span class="pre">io</span> <span class="pre">{Masked</span> <span class="pre">=</span> <span class="pre">True,</span> <span class="pre">unmask</span> <span class="pre">io</span> <span class="pre">=</span> <span class="pre">io</span> <span class="pre">{Masked</span> <span class="pre">=</span> <span class="pre">False}</span> <span class="pre">}</span></code>. To make masking composable, only the outermost mask takes effect - mask within a mask is a no-op and similarly the unmask it creates. This solves the “wormhole” <a class="reference external" href="https://mail.haskell.org/pipermail/libraries/2010-March/013310.html">problem</a>.</p>
<p>How to implement masking? Linux provide a masking API to block signals, which queues them up. So we can just use that. On Windows the only way to mask kernel-mode interrupts is to use a critical region, which is again a kernel mode API and not something we can use. So the handler itself must check if the thread is masked and if so store the exception somewhere to be thrown on unmask.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">\</span><span class="n">cont</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">Block</span>
<span class="w">    </span><span class="kt">TakeMVar</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">      </span><span class="n">catch</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Unblock</span><span class="w"> </span><span class="p">(</span><span class="n">compute</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">Block</span><span class="w"> </span><span class="n">c</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="nf">\</span><span class="n">e</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">PutMVar</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">throw</span><span class="w"> </span><span class="n">e</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nf">\</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">PutMVar</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="kt">Unblock</span><span class="w"> </span><span class="n">cont</span><span class="p">))</span>
<span class="w">    </span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="interruptible-operations">
<h3>Interruptible operations<a class="headerlink" href="#interruptible-operations" title="Permalink to this heading"></a></h3>
<p>Some operations can block for a long time. Async exceptions must be able to interrupt this blocking for timely injection. So every operation which may block comes in two versions, interruptible and uninterruptible. An interruptible operation is conceptually similar to <code class="docutils literal notranslate"><span class="pre">allowInterrupt;</span> <span class="pre">&lt;op&gt;</span></code>, but it only polls for asynchronous exceptions while blocked, and does not throw an asynchronous exception if it does not block.</p>
<p>Uninterruptible operations do not poll for async exceptions and hence can block indefinitely. They should only be used in exception cleanup code and only if there is no correct alternative. Sometimes there is no alternative, e.g. flushing a file cannot be avoided. Other times concurrency operations can be replaced with non-blocking versions, e.g. putMVar with tryPutMVar.</p>
<p>With uninterruptibleMask / interruptibleMask you can switch between the modes, and they only affect operations that can block. The mask itself is unaffected. So conceptually it is the operations that are uninterruptible.
<code class="docutils literal notranslate"><span class="pre">mask</span> <span class="pre">$</span> <span class="pre">do</span> <span class="pre">{</span> <span class="pre">...;</span> <span class="pre">uninterruptibleMask_</span> <span class="pre">$</span> <span class="pre">op;</span> <span class="pre">...</span> <span class="pre">}</span></code>.</p>
<p>In C interruptible functions are specified to fail with errno set to [EINTR] if a signal handler interrupts the program. I.e., the system routine will return but fail to complete its action and one must call the system routine again. The SA_RESTART flag on the signal handler restarts the call, but the duration of the timeout is unspecified, so it is better to do it from user code, particularly when writing an asynchronous event loop that uses select or poll.</p>
<p>So to make calls reliably, when a program is using signals without SA_RESTART, it must check whether the return value of interruptible system calls is -1 EINTR, and restart the system call if it is the case. This is annoying to write; so, skalibs provides small wrappers around interruptible system calls, so that programmers can just call those safe wrappers and never bother with this again. The performance loss from having a wrapper layer is totally negligible compared to the cost of using a system call in the first place.</p>
</section>
<section id="unmask-is-not-an-inverse">
<h3>Unmask is not an inverse<a class="headerlink" href="#unmask-is-not-an-inverse" title="Permalink to this heading"></a></h3>
<p>These pieces of code are not equivalent:</p>
<ol class="arabic simple">
<li><p>mask $ restore -&gt; (uninterruptiblePutMVar var x &gt;&gt;= foo) <cite>catch</cite> e -&gt; bar</p></li>
<li><p>mask $ restore -&gt; (putMVar var x &gt;&gt;= foo) <cite>catch</cite> e -&gt; bar</p></li>
<li><p>mask $ restore -&gt; (restore $ putMVar var x &gt;&gt;= foo) <cite>catch</cite> e -&gt; bar</p></li>
<li><p>(uninterruptiblePutMVar var x &gt;&gt;= foo) <cite>catch</cite> e -&gt; bar</p></li>
</ol>
<dl class="simple">
<dt>The first snippet has two scenarios:</dt><dd><p>putMVar succeeds, foo executes
putMVar throws deadlock, bar executes</p>
</dd>
<dt>The second has an additional scenario:</dt><dd><p>putMVar throws async exception, bar executes</p>
</dd>
<dt>The third adds another scenario:</dt><dd><p>putMVar succeeds, the restore throws an async exception, bar executes</p>
</dd>
</dl>
<p>It’s not a no-op to unmask an interruptible operation. There is a gap between putMvar and the end of the restore - an async exception can occur after the operation succeeds but before the transition from unmasked to masked.</p>
<p>It is wrong to wrap an ExceptT, EitherT, or ErrorT around an IO-based transformer stack. For example <code class="docutils literal notranslate"><span class="pre">myFunction</span> <span class="pre">::</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">ExceptT</span> <span class="pre">MyException</span> <span class="pre">IO</span> <span class="pre">Int</span></code>. The IO code can always throw exceptions, async exceptions if nothing else. You haven’t limited the possibility of exceptions, you’ve only added one extra avenue by which an exception can be thrown.</p>
<blockquote>
<div><p>handling GHC’s broken <a class="reference external" href="https://www.fpcomplete.com/blog/2018/04/async-exception-handling-haskell/">asynchronous exception system</a>. The system is broken because it is so complicated that nobody can agree on the desired behavior / correct form of even simple examples. The prototypical example of using it is <a class="reference external" href="https://hackage.haskell.org/package/unliftio-0.2.13.1/docs/UnliftIO-Exception.html#v:bracket">bracket</a>:</p>
</div></blockquote>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bracket</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">MonadUnliftIO</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">c</span>
<span class="nf">bracket</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">withRunInIO</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">run</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">EUnsafe</span><span class="o">.</span><span class="n">mask</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">restore</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="n">before</span>
<span class="w">  </span><span class="n">res1</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">EUnsafe</span><span class="o">.</span><span class="n">try</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">restore</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">res1</span><span class="w"> </span><span class="kr">of</span>
<span class="w">    </span><span class="kt">Left</span><span class="w"> </span><span class="p">(</span><span class="n">e1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">SomeException</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span>
<span class="w">      </span><span class="kr">_</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Either</span><span class="w"> </span><span class="kt">SomeException</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">EUnsafe</span><span class="o">.</span><span class="n">try</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">EUnsafe</span><span class="o">.</span><span class="n">uninterruptibleMask_</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">x</span>
<span class="w">      </span><span class="kt">EUnsafe</span><span class="o">.</span><span class="n">throwIO</span><span class="w"> </span><span class="n">e1</span>
<span class="w">    </span><span class="kt">Right</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span>
<span class="w">      </span><span class="kr">_</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">EUnsafe</span><span class="o">.</span><span class="n">uninterruptibleMask_</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">x</span>
<span class="w">      </span><span class="n">return</span><span class="w"> </span><span class="n">y</span>
</pre></div>
</div>
<p>Here we use 4 operations: mask, try, <code class="docutils literal notranslate"><span class="pre">uninterruptibleMask_</span></code>, throwIO. mask shields the cleanup action from being attacked by asynchronous exceptions, allowing exceptions inside restore. try catches exceptions and allows cleanup to occur. <code class="docutils literal notranslate"><span class="pre">uninterruptibleMask_</span></code> blocks interrupts from interrupting the after handler. Finally throwIO rethrows the exception, so that any exception inside the after handler will be swallowed.</p>
<p>Apparently, though, nobody can agree on whether the after handle should run with an uninterruptible mask.</p>
<p>Transformers</p>
<p>foo :: Int -&gt; IO String
can always be generalized with a usage of liftIO to:
foo :: MonadIO m =&gt; Int -&gt; m String</p>
<p>However,
bar :: FilePath -&gt; (Handle -&gt; IO a) -&gt; IO a
needs lifted-base or exceptions, and gets:
bar :: MonadBaseControl IO m =&gt; FilePath -&gt; (Handle -&gt; m a) -&gt; m a
bar :: (MonadIO m, MonadMask m) =&gt; FilePath -&gt; (Handle -&gt; m a) -&gt; m a</p>
<p>This applies to exception handling and forking threads. use the Acquire type from resourcet.</p>
<p>Custom exception types</p>
<p>Some people prefer <code class="docutils literal notranslate"><span class="pre">display</span></code> for user-friendly display, and think <code class="docutils literal notranslate"><span class="pre">show</span></code> should always use literal syntax.</p>
<p>but exception code-style of checking done everywhere leads to huge amounts of untested/broken code-paths.</p>
<p>An exception in a pure computation does not immediately halt the program, but instead returns an exception value that propagates through the pure code and halts the program when it is used in an imperative instruction, close in spirit to what LLVM calls a <a class="reference external" href="https://llvm.org/devmtg/2020-09/slides/Lee-UndefPoison.pdf">poison value</a> . This enforces nonstrict execution of pure code, enabling speculation, discarding unused code, etc. Unlike LLVM which only has the exception value ‘poison’, Stroscot has numerous exception values. The exception values are contained in sets, which can form the exception value hierarchies found in Java or Haskell but can also express other relationships.</p>
<p>Under the hood an exception value is simply a normal value with <code class="docutils literal notranslate"><span class="pre">isException</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">true</span></code>. exception values can be loaded/stored into a variable or array. Pattern matching on an exception value will execute a matching or catch-all case if present, allowing exception recovery, but otherwise propagate a <code class="docutils literal notranslate"><span class="pre">MissingCase</span></code> exception. When an exception value reaches the top-level <code class="docutils literal notranslate"><span class="pre">Task</span></code> structure, the handler will detect that the exception is not allowed in the <code class="docutils literal notranslate"><span class="pre">Task</span></code>, print the exception value, and exit the program. Tracking whether something can be an exception value requires the usual analysis to identify its type (possible set of values).</p>
<p>We can redefine exception values to be something else, e.g. add a definition <code class="docutils literal notranslate"><span class="pre">NoSuchAttributeException</span> <span class="pre">{}</span> <span class="pre">&quot;x&quot;</span> <span class="pre">=</span> <span class="pre">3</span></code>. Then <code class="docutils literal notranslate"><span class="pre">{}.x</span> <span class="pre">==</span> <span class="pre">3</span></code> and the exception is silenced. Similarly we can do <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">{}.x</span> <span class="pre">of</span> <span class="pre">NoSuchAttributeException</span> <span class="pre">{}</span> <span class="pre">&quot;x&quot;</span> <span class="pre">-&gt;</span> <span class="pre">3</span></code>, or pass the exception to a function that does such exception-handling. We can also match on generic exceptions, <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">{}.x</span> <span class="pre">of</span> <span class="pre">e</span> <span class="pre">|</span> <span class="pre">isException</span> <span class="pre">e</span> <span class="pre">-&gt;</span> <span class="pre">3</span></code>. The alternative to <code class="docutils literal notranslate"><span class="pre">isException</span></code> is a single standard exception constructor <code class="docutils literal notranslate"><span class="pre">Exception</span> <span class="pre">x</span></code>, IDK.</p>
<p>The exceptions also store the arguments to the exception, e.g. a <code class="docutils literal notranslate"><span class="pre">MissingCaseException</span></code> will store the value and the case itself, <code class="docutils literal notranslate"><span class="pre">x,</span> <span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">case</span> <span class="pre">x</span> <span class="pre">of</span> <span class="pre">...</span></code>. These compose up the stack so that we can pass in a value at any point and resume computing.</p>
<p>I guess there is ABI stability to consider.  says the interface will be added to and not have things removed from it. This means I have to assume (for forward compatibility) that any positive integer could be added to the interface and returned as an exception code. So I need a catch-all anyway. But I can support up to some kernel version, and make the catch-all crash the program, instead of figuring out a reasonable behavior.</p>
<blockquote>
<div><p>Exceptions allow higher levels of an application to decide how to handle “can’t happen” failures in deeply nested functions, without boilerplate in between. But you must still examine all of a function’s transitive callers when adding a throw statement. Either the intermediate functions must support the basic exception safety guarantee or the handler must immediately terminate the program. For instance, if f() calls g() calls h(), and h throws an exception that f catches, g has to clean up properly or f has to terminate. Exception safety requires RAII and isolating writing to persistent state into a “commit” phase. This may force obfuscating code to isolate the commit, a cost that could be avoided by avoiding exceptions.</p>
<p>writing no-throw code that uses an exception-throwing function is tedious - you have to handle all the exceptions and update the code whenever the exception list changes. But with precise checking it is pretty straightforward. In C++ integrating exception-throwing code into no-throw code doesn’t work though.</p>
</div></blockquote>
</section>
</section>
<section id="assertions">
<h2>Assertions<a class="headerlink" href="#assertions" title="Permalink to this heading"></a></h2>
<p>An assertion expresses an expectation or requirement for the program state. Assertions function similarly to breakpoints in a debugger - they check a condition and trigger an exceptional situation. But because they appear inline in the source code, they communicate assumptions and constraints to other developers. They are more precise than a comment because they are executable. Depending on where they appear in the program flow and the condition, assertions can express simple defensive sanity checks, loop invariants, pre-conditions, post-conditions, or the presence or absence of side effects. Assertions ensure more reliable code.</p>
<p>At their core, assertions are still just a use of the exception-handling mechanism - <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">cond</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">when</span> <span class="pre">cond</span> <span class="pre">(throw</span> <span class="pre">AssertionFailure)</span></code>. Stroscot also allows generating values non-deterministically and constraining them using <code class="docutils literal notranslate"><span class="pre">assume</span></code>, so that an assertion may check a property of a function over all inputs. This is more commonly referred to as a contract or signature, but there’s no clear distinction between contracts, signatures, and assertions - the type assertion <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code> relies on non-determinism but can appear in the module (acting as a signature and showing up in the documentation) or in the body (checking a property of a value).</p>
<p>In typical languages, assertions have a verbose syntax that clutters the code. Stroscot introduces several specialized compact syntaxes, such as type assertions. This should allow using them more easily and make them suitable for more contexts.</p>
<p>Also, in C++, there are some pitfalls of assertions. To avoid unexpected behavior, Stroscot places several restrictions on assertion expressions. An assertion condition must evaluate to true or false. It must not require any continuation side-effects to evaluate. Ambient state can be read and written, but the state after evaluating the assertion expression is discarded and evaluation continues with the state from before evaluating the assertion expression.</p>
<p>assert - error if trace exists where expression is false, omitted if compiler can prove true, otherwise runtime check with error if expression evaluates to false,
assume expr - prunes traces where expression is false. backtracking implementation at runtime.</p>
<p>Regarding assertions that are only checked in debug builds, it is certainly possible with a statement of the form <code class="docutils literal notranslate"><span class="pre">when</span> <span class="pre">DEBUG</span> <span class="pre">{</span> <span class="pre">assert</span> <span class="pre">X</span> <span class="pre">}</span></code>, and of course it is possible to define a function for this .</p>
<blockquote>
<div><p>in practice unconditionally enabled assertions are more useful/common, particularly if the compiler is good at checking assertions and optimizing them away. Imagine you’re designing a car and put in air bags. You test the car and the air bags in all sorts of configurations and they work great and are much safer. But just as you’re getting ready to go into production to send the car out to consumers, you take out all the airbags. That’s what debug-only assertions are like. It’s for this reason that GCC and clang do not deactivate asserts when compiling with optimizations.</p>
</div></blockquote>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Evaluation-Strategy.html" class="btn btn-neutral float-left" title="Evaluation strategy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Fastest.html" class="btn btn-neutral float-right" title="As fast as C" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>