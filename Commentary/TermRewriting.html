<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Term rewriting &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Time API" href="Time.html" />
    <link rel="prev" title="Syntax" href="Syntax.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Paradigms.html">Comparison</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Term rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rewrite-rules">Rewrite rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#higher-order-rewriting">Higher-order rewriting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#currying">Currying</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conditional-rewriting">Conditional rewriting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cycles">Cycles</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nondeterminism">Nondeterminism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#infinite-reduction">Infinite reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#meaningless-terms">Meaningless terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#equality-and-left-linearity">Equality and left-linearity</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#confluence">Confluence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#normalization">Normalization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#modularity">Modularity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hors">HORS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#concrete-strategies">Concrete strategies</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#higher-order-matching">Higher-order matching</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Commentary</a> &raquo;</li>
      <li>Term rewriting</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/TermRewriting.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="term-rewriting">
<h1>Term rewriting<a class="headerlink" href="#term-rewriting" title="Permalink to this heading"></a></h1>
<section id="rewrite-rules">
<h2>Rewrite rules<a class="headerlink" href="#rewrite-rules" title="Permalink to this heading"></a></h2>
<p>A rewrite rule or clause is applied by matching the left hand side to the term or one of its subterms and applying the resulting substitution to the right hand side. As in predicate dispatch, we consider conditional TRSs so rewrite rules also have conditions - the rewrite rule can only be applied if its condition holds. The execution of a Stroscot program is modeled as applying rewrite rules until no more can be applied. A “value” in a TRS refers to a normal form, a term that cannot be reduced further.</p>
<p>For example, with the rules <code class="docutils literal notranslate"><span class="pre">fact</span> <span class="pre">n</span> <span class="pre">|</span> <span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">fact</span> <span class="pre">(n-1)</span></code> and <code class="docutils literal notranslate"><span class="pre">fact</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">1</span></code>, we get the reduction sequence</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fact</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span><span class="w"></span>
<span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"></span>
<span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="mi">6</span><span class="w"></span>
</pre></div>
</div>
<p>We say that <code class="docutils literal notranslate"><span class="pre">fact</span> <span class="pre">3</span></code> reduces to the value <code class="docutils literal notranslate"><span class="pre">6</span></code>, written more concisely as the rewrite rule <code class="docutils literal notranslate"><span class="pre">fact</span> <span class="pre">3</span> <span class="pre">=</span> <span class="pre">6</span></code>.</p>
</section>
<section id="higher-order-rewriting">
<h2>Higher-order rewriting<a class="headerlink" href="#higher-order-rewriting" title="Permalink to this heading"></a></h2>
<p>A higher order rewriting system (HORS) consists of a substitution calculus and a set of rewrite rules.</p>
<p>A substitution calculus is an abstract rewriting system on a set of preterms. We assume an infinite number of atomic preterms, including variables, holes, symbols, and constants, indexed by integers, with holes being considered a subset of variables. We assume a substitution operation that renames bound variables as needed. A preterm is closed if it contains no free variables. A m-ary precontext is a preterm with holes 1 through m. It is linear if every hole occurs exactly once.</p>
<p>Terms are representatives of equivalence classes of preterms under <code class="docutils literal notranslate"><span class="pre">&lt;-&gt;*</span></code> of the substitution calculus. Contexts are similarly representatives of precontexts.</p>
<p>A rewrite rule is of the form <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code> where <code class="docutils literal notranslate"><span class="pre">l</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span></code> are both closed terms. The rewriting relation on terms is defined by <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">-&gt;</span> <span class="pre">N</span></code> if <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">&lt;-&gt;*</span> <span class="pre">C[l]</span></code> and <code class="docutils literal notranslate"><span class="pre">C[r]</span> <span class="pre">&lt;-&gt;*</span> <span class="pre">N</span></code> for some rewrite rule <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code> and context <code class="docutils literal notranslate"><span class="pre">C</span></code> containing a hole; <code class="docutils literal notranslate"><span class="pre">C[l]</span></code> means <code class="docutils literal notranslate"><span class="pre">C</span></code> with the hole substituted by <code class="docutils literal notranslate"><span class="pre">l</span></code>. Closed terms suffice because binders are in the substitution calculus, e.g. <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">plus</span> <span class="pre">x</span> <span class="pre">y</span></code> can be written as <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">y.</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">\x</span> <span class="pre">y.</span> <span class="pre">plus</span> <span class="pre">x</span> <span class="pre">y</span></code>.</p>
<p>An example is the lambda calculus. The set of preterms is built from nullary symbols (variables, holes, symbols, and constants), applications of two preterms, and abstractions of a variable and a preterm. The substitution calculus rewriting rules are beta reduction and alpha renaming. Eta reduction can be added but makes the system only weakly orthogonal. <span id="id1">[<a class="reference internal" href="../zzreferences.html#id46" title="Jörg Endrullis, Dimitri Hendriks, and Jan Willem Klop. Highlights in infinitary rewriting and lambda calculus. Theoretical Computer Science, 464:48–71, December 2012. URL: https://www.sciencedirect.com/science/article/pii/S030439751200792X (visited on 2022-07-02), doi:10.1016/j.tcs.2012.08.018.">EHK12</a>]</span></p>
</section>
<section id="currying">
<h2>Currying<a class="headerlink" href="#currying" title="Permalink to this heading"></a></h2>
<p>In the literature TRS definitions are usually presented in a “functional” form where n-ary function symbols are applied to terms, forming <code class="docutils literal notranslate"><span class="pre">f(t1,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">tn)</span></code> from n terms t1,…,tn and a function symbol f. In a curried system, also called “applicative”, function symbols are just nullary constants and there is only one form for combining terms, binary application, written as left-associative juxtaposition. Any TRS can be curried by rewriting <code class="docutils literal notranslate"><span class="pre">f(t1,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">tn)</span></code> to <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">t1</span> <span class="pre">...</span> <span class="pre">tn</span></code> in the LHS and RHS of each rule.</p>
<p>When compiling currying we translate the curried system to a set of partially applied function symbols, so that if <code class="docutils literal notranslate"><span class="pre">f</span></code> is the original binary function symbol and <code class="docutils literal notranslate"><span class="pre">f_0</span></code> is the nullary symbol in the curried system, then <code class="docutils literal notranslate"><span class="pre">f_0</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">f_1(a)</span></code> and <code class="docutils literal notranslate"><span class="pre">f_1(a)</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">f(a,b)</span></code>, hence <code class="docutils literal notranslate"><span class="pre">f_0</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">f(a,b)</span></code>.</p>
</section>
<section id="conditional-rewriting">
<h2>Conditional rewriting<a class="headerlink" href="#conditional-rewriting" title="Permalink to this heading"></a></h2>
<p>A conditional rewrite rule has the form <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">-&gt;</span> <span class="pre">r</span> <span class="pre">|</span> <span class="pre">C1,</span> <span class="pre">...,</span> <span class="pre">Cn</span></code>. It consists of an unconditional rewrite rule <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code> and conditions <code class="docutils literal notranslate"><span class="pre">Ci</span></code>. The conditions take the form of predicates <code class="docutils literal notranslate"><span class="pre">Pi(x1,</span> <span class="pre">...,</span> <span class="pre">xm,</span> <span class="pre">-&gt;)</span></code>, where the <code class="docutils literal notranslate"><span class="pre">xi</span></code> are the free variables of <code class="docutils literal notranslate"><span class="pre">l</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span></code>, and <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> is the rewrite relation of the system. Example predicates are:</p>
<ul class="simple">
<li><p>type predicates, term must be of a certain form</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> joins with, rewrites to, or is convertible to <code class="docutils literal notranslate"><span class="pre">b</span></code></p></li>
</ul>
<p>Ideally the rewrite relation would be defined as the fixed point of the rewrite rules. In particular letting <code class="docutils literal notranslate"><span class="pre">S</span></code> be the system we define <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> as a relation <code class="docutils literal notranslate"><span class="pre">R</span></code> such that <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">S(R)</span></code>. Terese presents the least fixed point. However, no fixed point may exist, for example with a rule <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">|</span> <span class="pre">a</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">normal</span> <span class="pre">form</span></code>. In this case <code class="docutils literal notranslate"><span class="pre">S({})</span> <span class="pre">=</span> <span class="pre">{(a,a)}</span></code> and <code class="docutils literal notranslate"><span class="pre">S({a,a})</span> <span class="pre">=</span> <span class="pre">{}</span></code>. We solve this similarly to the optimal fixed point by using the intersection of the maximal prefixedpoints, in this case giving <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">{}</span></code>. We find the sets <code class="docutils literal notranslate"><span class="pre">Pre</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">R</span> <span class="pre">:</span> <span class="pre">R</span> <span class="pre">subseteq</span> <span class="pre">S(R)</span> <span class="pre">},</span> <span class="pre">PreMax</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">R</span> <span class="pre">in</span> <span class="pre">Pre</span> <span class="pre">:</span> <span class="pre">forall</span> <span class="pre">R'</span> <span class="pre">in</span> <span class="pre">Pre,</span> <span class="pre">R</span> <span class="pre">subseteq</span> <span class="pre">R'</span> <span class="pre">implies</span> <span class="pre">R=</span> <span class="pre">R'</span> <span class="pre">},</span> <span class="pre">R</span> <span class="pre">=</span> <span class="pre">intersection</span> <span class="pre">PreMax</span></code>. The choice is correct in that reductions must satisfy conditions, conservative in that systems which have multiple consistent interpretations, like <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">if</span> <span class="pre">not(c</span> <span class="pre">-&gt;</span> <span class="pre">d);</span> <span class="pre">c</span> <span class="pre">-&gt;</span> <span class="pre">d</span> <span class="pre">if</span> <span class="pre">not(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span></code>, do not reduce, but it still is not the least fixed point as it allows <code class="docutils literal notranslate"><span class="pre">a</span></code> to reduce in <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">if</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> .</p>
<p>We can add a form of logic programming by allowing conditions to mention variables not in the LHS or RHS, e.g. <code class="docutils literal notranslate"><span class="pre">precedes</span> <span class="pre">x</span> <span class="pre">z</span> <span class="pre">|</span> <span class="pre">precedes</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">&amp;&amp;</span> <span class="pre">precedes</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">true</span></code> quantifies over all <code class="docutils literal notranslate"><span class="pre">y</span></code>. This further extends to allowing variables on the RHS not present on the LHS. Some syntax like <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">|</span> <span class="pre">exists</span> <span class="pre">x.</span> <span class="pre">C</span> <span class="pre">=</span> <span class="pre">r</span></code> and <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">=</span> <span class="pre">exists</span> <span class="pre">x.</span> <span class="pre">r</span></code> might make this easier to follow.</p>
</section>
<section id="cycles">
<h2>Cycles<a class="headerlink" href="#cycles" title="Permalink to this heading"></a></h2>
<p>The untyped lambda calculus has cycles, e.g. <code class="docutils literal notranslate"><span class="pre">Omega</span> <span class="pre">=</span> <span class="pre">let</span> <span class="pre">w=\x.x</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">w</span> <span class="pre">w</span></code> reduces to itself and <span id="id2">[<a class="reference internal" href="../zzreferences.html#id136" title="Marissa Venturini Zilli. Reduction graphs in the lambda calculus. Theoretical Computer Science, 29(3):251–275, January 1984. URL: https://www.sciencedirect.com/science/article/pii/0304397584900021 (visited on 2022-06-08), doi:10.1016/0304-3975(84)90002-1.">VZ84</a>]</span> shows a 6-cycle <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">M</span> <span class="pre">I</span></code>. Similarly commutativity <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">a</span></code> generates cycles.</p>
<p><span id="id3">[<a class="reference internal" href="../zzreferences.html#id35" title="Nachum Dershowitz and Jean-Pierre Jouannaud. Rewrite systems. In Handbook of Theoretical Computer Science (Vol. B): Formal Models and Semantics, pages 243–320. MIT Press, Cambridge, MA, USA, January 1991.">DJ91</a>]</span>’s notion of a congruence-class rewriting system is helpful - the rewrite rules are split into rules R and reversible equations S, and we consider the system R/S (R mod S). A term where only S rules apply (no R rules apply) is considered a normal form. So similarly we consider the <a class="reference external" href="https://en.wikipedia.org/wiki/Strongly_connected_component#Definitions">condensation</a> of the rewrite graph, condensing each SCC to a single term. A term is a “condensed normal form” if it has no reduction out of its SCC. Hence <code class="docutils literal notranslate"><span class="pre">Omega</span></code>,  <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">M</span> <span class="pre">I</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> would be condensed normal forms since their SCC contains themselves and they have no further reductions. We could further specify the normal form to be a canonical representative of the SCC, e.g. taking the smallest and lexicographically first element of the SCC, but leaving input unchanged seems better.</p>
</section>
<section id="nondeterminism">
<h2>Nondeterminism<a class="headerlink" href="#nondeterminism" title="Permalink to this heading"></a></h2>
<p>A reduction sequence is not necessarily unique, e.g. in reducing <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">*</span> <span class="pre">(2</span> <span class="pre">*</span> <span class="pre">fact</span> <span class="pre">1)</span></code> to <code class="docutils literal notranslate"><span class="pre">6</span></code> we could compute <code class="docutils literal notranslate"><span class="pre">fact</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">1</span></code> or we could first use an associative law <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">*</span> <span class="pre">(2</span> <span class="pre">*</span> <span class="pre">fact</span> <span class="pre">1)</span> <span class="pre">=</span> <span class="pre">(3</span> <span class="pre">*</span> <span class="pre">2)</span> <span class="pre">*</span> <span class="pre">fact</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">6</span> <span class="pre">*</span> <span class="pre">(fact</span> <span class="pre">1)</span></code>. Different reduction sequences can be more efficient in terms of memory usage; the compiler should use heuristics and hints to choose the best strategy.</p>
<p>For maximum expressiveness, we also want to allow local nondeterminism. Even if a term has two or more applicable reduction rules and reduces to two normal forms, the context might give the same behavior on the different values. E.g. this should be allowed:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="o">#</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="n">normal</span><span class="w"> </span><span class="n">forms</span><span class="p">,</span><span class="w"> </span><span class="n">nondeterministic</span><span class="w"></span>

<span class="nf">f</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">d</span><span class="w"></span>

<span class="nf">print</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">deterministically</span><span class="w"> </span><span class="n">prints</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
</pre></div>
</div>
<p>However, top-level method dispatch nondeterminism is unresolvable. E.g. <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">a</span></code> with this example is an error  - there is no way to reconcile <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">c</span></code>, because the user can only see one output.</p>
<p>Exceptions complicate the semantics. We want our reduction strategy to be normalizing, so that if there is any reduction sequence that produces a non-exception value, Stroscot evaluates to that non-exception value, rather than an exception. So <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">amb</span> <span class="pre">(throw</span> <span class="pre">b)</span></code> should reduce to 1. This provides the benefits of lazy evaluation.</p>
<p>Also, exception propagation is nondeterministic. For example <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">throw</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">throw</span> <span class="pre">c</span></code> will throw either <code class="docutils literal notranslate"><span class="pre">b</span></code> or <code class="docutils literal notranslate"><span class="pre">c</span></code> depending on which is evaluated first, and the choice is observable in a program with <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">catch</span> <span class="pre">print</span></code>. Exception nondeterminism is a different category from method dispatch nondeterminism and by default is considered benign, i.e. the compiler will not output a diagnostic and will resolve the <code class="docutils literal notranslate"><span class="pre">catch</span></code> using the exception that is most efficient to dispatch. But you can enable an error or warning that ensures thrown exceptions are unique. Regardless, the verification system will verify properties for all choices of exception, i.e. <code class="docutils literal notranslate"><span class="pre">(case</span> <span class="pre">e</span> <span class="pre">of</span> <span class="pre">Exc</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">1;</span> <span class="pre">Exc</span> <span class="pre">c</span> <span class="pre">-&gt;</span> <span class="pre">&quot;a&quot;)</span> <span class="pre">:</span> <span class="pre">Int</span></code> will fail but <code class="docutils literal notranslate"><span class="pre">(case</span> <span class="pre">(throw</span> <span class="pre">b)</span> <span class="pre">of</span> <span class="pre">Exc</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">1;</span> <span class="pre">Exc</span> <span class="pre">c</span> <span class="pre">-&gt;</span> <span class="pre">&quot;a&quot;)</span> <span class="pre">:</span> <span class="pre">Int</span></code> will not because <code class="docutils literal notranslate"><span class="pre">c</span></code> is unreachable.</p>
</section>
<section id="infinite-reduction">
<h2>Infinite reduction<a class="headerlink" href="#infinite-reduction" title="Permalink to this heading"></a></h2>
<p>Infinite reduction is useful because it is “smoother” than finite reduction - normal forms exist more often, and there are fewer non-converging reduction sequences. For example <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">::</span> <span class="pre">x</span></code> reduces to <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">::</span> <span class="pre">1</span> <span class="pre">::</span> <span class="pre">1</span> <span class="pre">::</span> <span class="pre">...</span></code>, <code class="docutils literal notranslate"><span class="pre">fib</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">::</span> <span class="pre">2</span> <span class="pre">::</span> <span class="pre">zipWith</span> <span class="pre">(+)</span> <span class="pre">fib</span> <span class="pre">(head</span> <span class="pre">fib)</span></code> reduces to <code class="docutils literal notranslate"><span class="pre">fib</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">::</span> <span class="pre">2</span> <span class="pre">::</span> <span class="pre">3</span> <span class="pre">::</span> <span class="pre">...</span></code>, and <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">=</span> <span class="pre">let</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">\x.</span> <span class="pre">x</span> <span class="pre">x</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">t</span> <span class="pre">t</span></code> reduces to <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">=</span> <span class="pre">...</span> <span class="pre">t</span> <span class="pre">t</span> <span class="pre">t</span> <span class="pre">t</span></code>. With infinite reduction all of these terms have a proper denotation, instead of having to work with head normal forms and partially evaluated terms. Also I/O can be modeled as an infinite value with sub-terms for each outcome of the I/O operation.</p>
<p>The idea is to extend our set of terms to include infinite terms, defined as the <a class="reference external" href="https://en.wikipedia.org/wiki/Complete_metric_space#Completion">metric completion</a> of finite terms with a distance function <span class="math notranslate nohighlight">\(2^{-n}\)</span> if the n-th level of the terms is the first level where a difference appears and 0 if the terms are equal. As a convention the top level is level zero.</p>
<p>The literature <span id="id4">[<a class="reference internal" href="../zzreferences.html#id127" title="Jakob Grue Simonsen. Weak Convergence and Uniform Normalization in Infinitary Rewriting. In Christopher Lynch, editor, Proceedings of the 21st International Conference on Rewriting Techniques and Applications, volume 6 of Leibniz International Proceedings in Informatics (LIPIcs), 311–324. Dagstuhl, Germany, 2010. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik. \subsection Other We study infinitary term rewriting systems containing finitely many rules. For these, we show that if a weakly convergent reduction is not strongly convergent, it contains a term that reduces to itself in one step (but the step itself need not be part of the reduction). Using this result, we prove the starkly surprising result that for any orthogonal system with finitely many rules, the system is weakly normalizing under weak convergence if\f\ it is strongly normalizing under weak convergence if\f\ it is weakly normalizing under strong convergence if\f\ it is strongly normalizing under strong convergence. As further corollaries, we derive a number of new results for weakly convergent rewriting: Systems with finitely many rules enjoy unique normal forms, and acyclic orthogonal systems are confluent. Our results suggest that it may be possible to recover some of the positive results for strongly convergent rewriting in the setting of weak convergence, if systems with finitely many rules are considered. Finally, we give a number of counterexamples showing failure of most of the results when infinite sets of rules are allowed. URL: http://drops.dagstuhl.de/opus/volltexte/2010/2660 (visited on 2022-07-25), doi:10.4230/LIPIcs.RTA.2010.311.">Sim10</a>]</span> defines the transitive closure of reduction <span class="math notranslate nohighlight">\(\overset{*}{\to}\)</span> using ordinals, with the identity relation <span class="math notranslate nohighlight">\(\{x\|(x,x)\}\)</span>, the successor relation <span class="math notranslate nohighlight">\(\overset{*}{\to} \circ \to\)</span>, and a limit operation. Some confusion arises because there are multiple definitions for the limit, “weak” convergence which is the standard metric space definition and a newer “strong” convergence which requires that the depth of the redexes contracted in the successive steps tends to infinity. There is the additional complication that reductions may happen after the limit is taken, e.g. <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b;</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">(g</span> <span class="pre">x)</span> <span class="pre">a</span></code> has <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">c</span> <span class="pre">a</span> <span class="pre">-ω&gt;</span> <span class="pre">f</span> <span class="pre">(g</span> <span class="pre">(g</span> <span class="pre">(g</span> <span class="pre">...)))</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">(g</span> <span class="pre">(g</span> <span class="pre">(g</span> <span class="pre">...)))</span> <span class="pre">b</span></code>, <span id="id5">[<a class="reference internal" href="../zzreferences.html#id34" title="Nachum Dershowitz, Stéphane Kaplan, and David A. Plaisted. Rewrite, rewrite, rewrite, rewrite, rewrite, …. Theoretical Computer Science, 83(1):71–96, June 1991. URL: https://www.sciencedirect.com/science/article/pii/0304397591900409 (visited on 2022-07-02), doi:10.1016/0304-3975(91)90040-9.">DKP91</a>]</span> so a reduction sequence must be defined to be of any ordinal length.</p>
<p>I think strong convergence is the wrong direction. If there is a reduction that switches heads, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">(c</span> <span class="pre">X);</span> <span class="pre">b</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">(c</span> <span class="pre">X)</span></code>, then I don’t want to say that there are no w-reductions, as with weak or strong convergence, but instead I want <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">e</span> <span class="pre">-w&gt;</span> <span class="pre">a</span> <span class="pre">(mu</span> <span class="pre">x.</span> <span class="pre">c</span> <span class="pre">x)</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">e</span> <span class="pre">-w&gt;</span> <span class="pre">b</span> <span class="pre">(mu</span> <span class="pre">x.</span> <span class="pre">c</span> <span class="pre">x)</span></code>. TRSs are in general nondeterministic, so definitions requiring a single limit to exist are too strong - the convergence condition should actually be weakened further. For cycle condensation we would like to equate as many terms as possible, so the reduction relation should be as big as possible.</p>
<p>So rather than a single, unique limit, we instead want to define the transitive closure of reduction as the topological closure of the set <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">-&gt;&gt;</span> <span class="pre">b</span> <span class="pre">}</span></code>. Thus <code class="docutils literal notranslate"><span class="pre">b</span></code> is a w-reduct of <code class="docutils literal notranslate"><span class="pre">a</span></code> if it is an <a class="reference external" href="https://en.wikipedia.org/wiki/Adherent_point">adherent point</a>. In particular each w-reduct is either an accumulation point, i.e. a limit of a sequence of distinct reducts (possibly from different reduction sequences), or an isolated point which can be reached in a finite number of reductions from <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>This allows obtaining all infinite reducts without ordinals, because this definition of infinite reduction is transitive. Proof: a reduction <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-w&gt;</span> <span class="pre">b</span> <span class="pre">-w&gt;</span> <span class="pre">c</span></code> means for all depths  <span class="math notranslate nohighlight">\(d_1,d_2 \in \mathbb{N}\)</span> there exists some <span class="math notranslate nohighlight">\(b_c \in \{ b' : b \twoheadleftarrow b' \}\)</span>, <span class="math notranslate nohighlight">\(a_b \in \{ a' : a \twoheadleftarrow a' \}\)</span> such that <span class="math notranslate nohighlight">\(c\)</span> matches <span class="math notranslate nohighlight">\(b_c\)</span> to depth <span class="math notranslate nohighlight">\(d_1\)</span> and <span class="math notranslate nohighlight">\(b\)</span> matches <span class="math notranslate nohighlight">\(a_b\)</span> to depth <span class="math notranslate nohighlight">\(d_2\)</span>. Then for any depth <span class="math notranslate nohighlight">\(d\)</span>, we can set <span class="math notranslate nohighlight">\(d_1=d\)</span> to obtain a term <span class="math notranslate nohighlight">\(b_c\)</span> matching <span class="math notranslate nohighlight">\(c\)</span> to depth <span class="math notranslate nohighlight">\(d\)</span> for which there is a finite reduction <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">-&gt;&gt;</span> <span class="pre">b_c</span></code>. Then we can compute the highest depth of <code class="docutils literal notranslate"><span class="pre">b</span></code> used during this reduction - set <span class="math notranslate nohighlight">\(d_2\)</span> to the maximum of this and <span class="math notranslate nohighlight">\(d\)</span>, obtaining a term <code class="docutils literal notranslate"><span class="pre">a_b</span></code> for which there is a finite reduction <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;&gt;</span> <span class="pre">a_b</span></code> that matches <code class="docutils literal notranslate"><span class="pre">b``to</span> <span class="pre">depth</span> <span class="pre">:math:`d_2`.</span> <span class="pre">Then</span> <span class="pre">replacing</span> <span class="pre">the</span> <span class="pre">subterms</span> <span class="pre">of</span> <span class="pre">``b</span></code> below depth <span class="math notranslate nohighlight">\(d_2\)</span> with those from <code class="docutils literal notranslate"><span class="pre">a_b</span></code> in the reduction <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">-&gt;&gt;</span> <span class="pre">b_c</span></code>, we obtain a reduction <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;&gt;</span> <span class="pre">a_b</span> <span class="pre">-&gt;&gt;</span> <span class="pre">b_c'</span></code> where <code class="docutils literal notranslate"><span class="pre">b_c'</span></code> matches <code class="docutils literal notranslate"><span class="pre">c</span></code> to at least depth <span class="math notranslate nohighlight">\(d\)</span>. Hence <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-w&gt;</span> <span class="pre">c</span></code>.</p>
<p>Using the previous example, with <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">c</span> <span class="pre">a</span> <span class="pre">-ω&gt;</span> <span class="pre">f</span> <span class="pre">(g</span> <span class="pre">(g</span> <span class="pre">(g</span> <span class="pre">...)))</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">(g</span> <span class="pre">(g</span> <span class="pre">(g</span> <span class="pre">...)))</span> <span class="pre">b</span></code>, let’s say we want an approximation of depth 2. <code class="docutils literal notranslate"><span class="pre">b_c</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">(g</span> <span class="pre">(g</span> <span class="pre">(g</span> <span class="pre">...)))</span> <span class="pre">b</span></code> and matches <code class="docutils literal notranslate"><span class="pre">c</span></code> exactly. The highest depth of <code class="docutils literal notranslate"><span class="pre">b</span></code> used in the reduction <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">b_c</span></code> is 1, so <span class="math notranslate nohighlight">\(d_2\)</span> is the approximation depth 2. <code class="docutils literal notranslate"><span class="pre">a_b</span> <span class="pre">=</span>&#160; <span class="pre">f</span> <span class="pre">(g</span> <span class="pre">(g</span> <span class="pre">c))</span> <span class="pre">a</span></code>. Our final reduction is then <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">c</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">(g</span> <span class="pre">(g</span> <span class="pre">c))</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">(g</span> <span class="pre">(g</span> <span class="pre">c))</span> <span class="pre">b</span></code>.</p>
<p>The theorem only works if the rules are limited to finite depth, a common restriction in infinitary TRSs. The main place this might bite is conditional TRSs, where e.g. equality can inspect infinite terms. Equality and type membership have natural approximations of examining to a depth, which can probably be worked into the fixpoint, taking the intersection of the closure of the finite approximations of the prefixedpoints. Other predicates might not be so well behaved, but the infinite reduction is mainly to smooth finite terms so weird behavior on infinite terms doesn’t matter too much.</p>
</section>
<section id="meaningless-terms">
<h2>Meaningless terms<a class="headerlink" href="#meaningless-terms" title="Permalink to this heading"></a></h2>
<p>If a term never reaches a normal form, then there’s not much semantic meaning in it.  We could compute equivalence classes of these terms but it is easier to define them all away. <span id="id6">[<a class="reference internal" href="../zzreferences.html#id79" title="R. Kennaway, V. van Oostrom, and F.-J. de Vries. Meaningless terms in rewriting. Artificial Intelligence Preprint Series, May 1999. URL: https://dspace.library.uu.nl/handle/1874/26465 (visited on 2022-07-09).">KvOdV99</a>]</span> defines the set of “mute” terms, the smallest set with the following properties:</p>
<ul class="simple">
<li><p>Contains all root-active terms. A term t is root-active if every reduct of t can be reduced to a term with a top-level redex.</p></li>
<li><p>Closure under reduction. If <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">∈</span> <span class="pre">U</span></code>, <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">→</span> <span class="pre">N</span></code> then <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">∈</span> <span class="pre">U</span></code>.</p></li>
<li><p>Closure under substitution. For all <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">∈</span> <span class="pre">U</span></code>, <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">/.</span> <span class="pre">σ</span> <span class="pre">∈</span> <span class="pre">U</span></code></p></li>
<li><p>Overlap. For all <code class="docutils literal notranslate"><span class="pre">(\x.M)</span> <span class="pre">∈</span> <span class="pre">U</span></code>, <code class="docutils literal notranslate"><span class="pre">(\x.M)</span> <span class="pre">N</span> <span class="pre">∈</span> <span class="pre">U</span></code>. More generally if M nontrivially matches a subterm of the LHS of some rule, i.e. for some position <code class="docutils literal notranslate"><span class="pre">u</span></code> and substitution <code class="docutils literal notranslate"><span class="pre">σ</span></code>, <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">subterm</span> <span class="pre">(l</span> <span class="pre">/.</span> <span class="pre">σ)</span> <span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">subterm</span> <span class="pre">l</span> <span class="pre">u</span></code> is not a variable, then the overall LHS is in U, <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">/.</span> <span class="pre">σ</span> <span class="pre">∈</span> <span class="pre">U</span></code>.</p></li>
<li><p>Indiscernibility - the meaningfullness of a term does not depend on its meaningless subterms. For all M, N, if N can be obtained from M by replacing a set of pairwise disjoint subterms in U with other terms of U, then M ∈ U if and only if N ∈ U.</p></li>
</ul>
<p>There is also closure under expansion introduced in <span id="id7">[<a class="reference internal" href="../zzreferences.html#id116" title="Paula Severi and Fer-Jan de Vries. Decomposing the Lattice of Meaningless Sets in the Infinitary Lambda Calculus. In Lev D. Beklemishev and Ruy de Queiroz, editors, Logic, Language, Information and Computation, Lecture Notes in Computer Science, 210–227. Berlin, Heidelberg, 2011. Springer. doi:10.1007/978-3-642-20920-8_22.">SdeVries11</a>]</span>: if <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">∈</span> <span class="pre">U</span></code>, <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">→</span> <span class="pre">N</span></code> then <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">∈</span> <span class="pre">U</span></code>. This makes the set easier to reason about, but we want <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">amb</span> <span class="pre">meaningless</span></code> to reduce to 1, so <code class="docutils literal notranslate"><span class="pre">t</span></code> can’t be meaningless itself, hence we don’t want this property.</p>
<p>Mute terms form an easy set, <span id="id8">[<a class="reference internal" href="../zzreferences.html#id20" title="A. Bucciarelli, A. Carraro, G. Favro, and A. Salibra. Graph easy sets of mute lambda terms. Theoretical Computer Science, 629:51–63, May 2016. URL: https://www.sciencedirect.com/science/article/pii/S0304397515011858 (visited on 2022-07-01), doi:10.1016/j.tcs.2015.12.024.">BCFS16</a>]</span> meaning we can safely equate all mute terms to an exception term without changing the semantics of normal terms. In particular we can equate them to a <code class="docutils literal notranslate"><span class="pre">NonTermination</span></code> or <code class="docutils literal notranslate"><span class="pre">Meaningless</span></code> exception.</p>
<p>Every TRS with unique normal forms (UN=) can be extended to a confluent TRS with the same set of normal forms by adding bottom terms and reductions to normal forms and bottoms that preserve the equivalence classes of terms. <span id="id9">[<a class="reference internal" href="../zzreferences.html#id96" title="Aart Middeldorp. Modular aspects of properties of term rewriting systems related to normal forms. In G. Goos, J. Hartmanis, D. Barstow, W. Brauer, P. Brinch Hansen, D. Gries, D. Luckham, C. Moler, A. Pnueli, G. Seegmüller, J. Stoer, N. Wirth, and Nachum Dershowitz, editors, Rewriting Techniques and Applications, volume 355, pages 263–277. Springer Berlin Heidelberg, Berlin, Heidelberg, 1989. URL: http://link.springer.com/10.1007/3-540-51081-8_113 (visited on 2021-09-14), doi:10.1007/3-540-51081-8_113.">Mid89</a>]</span> It’s not clear if meaningless terms accomplish this extension.</p>
</section>
<section id="equality-and-left-linearity">
<span id="trs-equality-linearity"></span><h2>Equality and left-linearity<a class="headerlink" href="#equality-and-left-linearity" title="Permalink to this heading"></a></h2>
<p>There are several notions of equality, here presented in the order of decreasing strength (earlier implies later):</p>
<ul class="simple">
<li><p>strict equality <code class="docutils literal notranslate"><span class="pre">eq_s</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">|</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> - require all variables to be in normal form, reduce both sides to normal form, then compare with syntactic equality.</p></li>
<li><p>syntactic equality matches unreduced terms, hence can match even if the term doesn’t have a normal form. It is the notion used for non-linear TRS in the literature.</p></li>
<li><p>join equality <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">↓</span> <span class="pre">b</span></code> means that a common reduct exists, i.e. there is a term <code class="docutils literal notranslate"><span class="pre">c</span></code> such that <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">c</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">c</span></code>.</p></li>
<li><p>semi-equational equality <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">≈</span> <span class="pre">b</span></code> means that <code class="docutils literal notranslate"><span class="pre">a</span></code> can be rewritten to <code class="docutils literal notranslate"><span class="pre">b</span></code> via rewrites and inverse rewrites.</p></li>
</ul>
<p>Computing any of these equalities is of complexity at least <span class="math notranslate nohighlight">\(\Sigma^0_1\)</span> because it is a nontrivial property of the reduction relation.</p>
<p>Consider <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">c</span> <span class="pre">a;</span> <span class="pre">c</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">d</span> <span class="pre">x</span> <span class="pre">(c</span> <span class="pre">x);</span> <span class="pre">d</span> <span class="pre">x</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">e</span></code>. <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">mu</span> <span class="pre">x.</span> <span class="pre">c</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">mu</span> <span class="pre">x.</span> <span class="pre">d</span> <span class="pre">x</span> <span class="pre">x</span></code>. Abbreviate <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">=</span> <span class="pre">mu</span> <span class="pre">x.</span> <span class="pre">d</span> <span class="pre">x</span> <span class="pre">x</span></code>. For the different equalities:</p>
<ul class="simple">
<li><p>strict equality denies reducing <code class="docutils literal notranslate"><span class="pre">G</span></code>, because if <code class="docutils literal notranslate"><span class="pre">G</span></code> is reducible then it is not a normal form and equality does not hold. Hence <code class="docutils literal notranslate"><span class="pre">G</span></code> is a normal form and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">G</span></code>.</p></li>
<li><p>syntactic equality and join equality allow the reductions <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">=</span> <span class="pre">e</span></code> and <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">=</span> <span class="pre">mu</span> <span class="pre">x.</span> <span class="pre">d</span> <span class="pre">e</span> <span class="pre">x</span></code>, but <code class="docutils literal notranslate"><span class="pre">mu</span> <span class="pre">x.</span> <span class="pre">d</span> <span class="pre">e</span> <span class="pre">x</span> <span class="pre">!=</span> <span class="pre">e</span></code> so the system is nondeterministic for <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></li>
<li><p>semi-equational equality concludes from the nondeterministic reduction that <code class="docutils literal notranslate"><span class="pre">mu</span> <span class="pre">x.</span> <span class="pre">d</span> <span class="pre">e</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">e</span></code>, so the reduction <code class="docutils literal notranslate"><span class="pre">mu</span> <span class="pre">x.</span> <span class="pre">d</span> <span class="pre">e</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">e</span></code> holds and <code class="docutils literal notranslate"><span class="pre">a</span></code> reduces deterministically to <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p></li>
</ul>
<p>More generally, syntactic equality and join equality are not stable, meaning if the terms involved are reduced then they may not be equal anymore (Terese 4.11.1, page 145 / PDF page 165). This instability means that the CTRS may not be confluent even if the unconditional TRS is. Strict equality and semi-equational equality are stable. For a confluent rewriting system semi-equational equality is equivalent to join equality, it just allows more reductions.</p>
<p>As another example, consider a nondeterministic term <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b;</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">c</span></code>. <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">a</span></code> reduces to both <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">==</span> <span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">==</span> <span class="pre">c</span></code>. With semi-equational equality, <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">==</span> <span class="pre">c</span></code> is actually true, so <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">a</span></code> only reduces to true. Hence <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">|</span> <span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">...</span></code> would not reduce <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">a</span></code>. With strict equality <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">a</span></code> reduces to both true and false, hence reducing <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">a</span></code> would reduce <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">b</span> <span class="pre">c</span></code>. Semi-equational equality seems to have the wrong behavior here because it equates all reducts of a nondeterministic term. Strict equality seems easier to understand in the context of nondeterminism.</p>
<p>Overall, strict equality is the most conservative, the choice used in traditional programming languages, and the one whose behavior seems easiest to understand. It does reduce the laziness of the language a bit but even Haskell’s equality is strict.</p>
<ul class="simple">
<li><p>convergent (confluent and terminating) - These include typed systems such as the simply typed lambda calculus. For these, the result is the same no matter how they are reduced. So the focus is on do the reduction efficiently, compiling to fast assembly via a state machine and data format analysis and/or doing optimal reduction to reduce in the smallest number of steps.</p></li>
</ul>
<section id="confluence">
<h3>Confluence<a class="headerlink" href="#confluence" title="Permalink to this heading"></a></h3>
<p>Confluence has gotten a lot of attention as well and has automated provers. Confluence implies UN→; it is equivalent if the TRS is weakly normalizing. And there is an extension theorem:  Similarly a system can be shown to be UN= by presenting an extension of it that is confluent. <span id="id10">[<a class="reference internal" href="../zzreferences.html#id85" title="Jan Willem Klop and Roel de Vrijer. Extended term rewriting systems. In S. Kaplan and M. Okada, editors, Conditional and Typed Rewriting Systems, Lecture Notes in Computer Science, 26–50. Berlin, Heidelberg, 1991. Springer. doi:10.1007/3-540-54317-1_79.">KdeVrijer91</a>]</span> So a UN= program is just a partially specified system. UN→ is a little more complex though. And the equivalence classes of terms are uncomputable in general so the extension is as well.</p>
<p>Confluence avoids situations where a system may branch into two distinct diverging states. It makes finding a normalizing strategy much easier as the strategy only has to avoid getting stuck evaluating a term infinitely (using the same rule infinitely often), as opposed to UN→ where the strategy must avoid using the wrong reduction rule at every step.</p>
<p>The Knuth-Bendix algorithm produces a confluent system from a set of non-oriented equations, but the rules in programs are oriented, so using this would be confusing. Not to mention that the algorithm fails often. So that’s out.</p>
<p>A necessary condition for confluence is weak/local confluence, i.e. each critical pair is convergent. But this is not sufficient. Newman’s lemma is that a terminating locally confluent TRS is confluent. But termination is quite strong. A generalization is a critical pair system <span id="id11">[<a class="reference internal" href="../zzreferences.html#id63" title="Nao Hirokawa and Aart Middeldorp. Decreasing Diagrams and Relative Termination. arXiv:0910.2853 [cs], October 2009. Comment: v3: missing references added. URL: http://arxiv.org/abs/0910.2853 (visited on 2021-09-14), arXiv:0910.2853.">HM09</a>]</span> (also called decreasingly confluent): the system must be left-linear, locally confluent, and its critical pair steps must be <em>relatively terminating</em>, i.e. the relation ‘arbitrary steps followed by a critical pair step followed by arbitrary steps’ is terminating. Trivial critical pair steps can be excluded, hence this includes weakly orthogonal TRSs. For a terminating TRS the TRS syntactic equality notion is equivalent to strict equality, hence the system is left linear in the CTRS sense, hence why this includes Newman’s lemma.</p>
<p>We say → has random descent (RD), if for each R:a ↔∗b with b in normal form, all maximal reductions from a have length d(R) and end in b. Systems with random descent are confluent.</p>
</section>
<section id="normalization">
<h3>Normalization<a class="headerlink" href="#normalization" title="Permalink to this heading"></a></h3>
<p>A hypernormalizing strategy is a strategy that is normalizing even if arbitrary reduction steps are taken before and after steps of the strategy. This allows the compiler to make optimizations without changing the behavior of the program. A hypernormalizing strategy allows aggressive optimizations and program transforms.</p>
<p>Leftmost outermost reduction is the basis of lazy evaluation and is hypernormalizing for the lambda calculus. But for TRSs LO is only normalizing for left-normal TRSs, where variables do not precede function symbols in the left-hand sides of the rewrite rule. A better strategy is outermost fair (ensuring each outermost redex will eventually be evaluated - the simplest example is parallel outermost) - it’s hypernormalizing for critical pair TRSs (decreasingly confluent TRSs), in particular weakly orthogonal TRSs. <span id="id12">[<a class="reference internal" href="../zzreferences.html#id64" title="Nao Hirokawa and Aart Middeldorp. Strategies for Decreasingly Confluent Rewrite Systems. Reduction Strategies in Rewriting and Programming, pages 23, 2011.">HM11</a>]</span></p>
<p>There are also stronger properties than normalization. A Church-Rosser strategy is one with common reducts, i.e. there exist m and n, such that <span class="math notranslate nohighlight">\(F^m(t)=F^n(u)\)</span> for every t and u equal via forward/backward evaluation. A normalizing strategy is Church-Rosser if the system is confluent and weakly normalizing (i.e. all objects have a normal form). In general a many-step CR strategy exists for effective ARS’s, i.e. countable (in a computable fashion) and with a computable reduction relation. But the strategy is quite hard to compute, as it has to synchronize reducing subterms so that all components are reduced the same amount. And it’s not clear that this synchronization offers anything to the programmer.</p>
<p>Cofinal strategies are weaker than Church-Rosser but stronger than normalizing: for every term a, if a reduces in a finite number of steps to b, then there is an object c obtained by applying the strategy some number of times to a such that b reduces to c. For critical pair TRSs any “fair” strategy that ensures every redex is eventually contracted is cofinal. The cofinal property provides slick proofs - it ensures every redex not part of a cycle is contracted. But at runtime non-normalizing terms have indistinguishable behavior (infinite loop), hence this means the cofinal strategy is doing unnecessary work.</p>
<p>There are also termination properties like strong convergence that ensure that for every term, there exists some number of reduction steps after which the head cannot be rewritten.
To ensure that term rewriting halts we probably also want a property like strong convergence, but this is a property of the rewriting strategy, not the TRS proper.</p>
<p>A perpetual strategy is the opposite of normalizing - if any strategy diverges, then perpetual strategy diverges. Leftmost-innermost is close to the strategies commonly used in strict languages and is perpetual. With a perpetual strategy inlining etc. hold only if reduction of the expression terminates, i.e. one must keep track of termination properties. A perpetual strategy gives the wrong behavior for if-then-else and short-circuit functions, so strict languages special-case these to ensure they don’t cause nontermination. Perpetual strategies are antagonistic, “I’ll crash your program if I can”.</p>
</section>
</section>
<section id="modularity">
<h2>Modularity<a class="headerlink" href="#modularity" title="Permalink to this heading"></a></h2>
<p>A property is modular if the disjoint union of two systems with the property has the property.</p>
<p>Left linearity, confluence, weak normalization, unique normal forms (w.r.t. equivalence), and consistency (w.r.t. equivalence) are modular for first-order systems. Modularity of left linearity, confluence, and unique normal forms extend to semi-equational CTRSs. Confluence also extends to join CTRSs. In fact if the disjoint union is confluent then the component systems must be confluent. Confluence is not modular for higher-order TRSs but confluence plus left linearity is.</p>
<p>Weak termination, weak innermost termination, and strong innermost termination are modular for CTRSs in combination with confluence or the property that there are no extra variables in the conditions.</p>
<p>NF, unique normal forms with respect to reduction, and consistency with respect to reduction are modular in combination with left linearity. Consistency w.r.t. reduction means that there is no term reducing to two distinct variables; it is implied by the unique normal form property w.r.t. reduction as variables are normal forms.</p>
<p>Strong normalization plus consistency w.r.t. reduction plus left linearity is modular. This likely holds for CTRSs without extra variables as well.</p>
</section>
<section id="hors">
<h2>HORS<a class="headerlink" href="#hors" title="Permalink to this heading"></a></h2>
<p>A HORS is orthogonal if:</p>
<p>A1 the substitution calculus is complete
A2 the substitution calculus is only needed for gluing
A4 the substitution calculus is a descendant rewriting system
A5 the substitution calculus is parametric and rules are head-defined
A7 the substitution calculus is naturally closed under substitution</p>
<p>A3 parallel rewrite steps can be serialised
A6 left-hand sides of rules are linear
A8 every set of redexes is pairwise simultaneous</p>
</section>
<section id="concrete-strategies">
<h2>Concrete strategies<a class="headerlink" href="#concrete-strategies" title="Permalink to this heading"></a></h2>
<p>So: strategy must normalizing. Now, which strategy?</p>
<p>For terminating programs, all strategies are normalizing. Hence we want to infer termination and use this to optimize the strategy - leftmost innermost ensures “complete development”, i.e. a subterm is reduced completely before the outer term, hence we can store the subterm using an optimized representation of the normal form.
But strongly normalizing implies not Turing complete, hence the typechecker that ensures termination will cause problems for complex programs. We need a fallback for non-terminating programs.</p>
<p>The simplest fallback is outermost-fair, it’s a reasonable default and terminates on critical pair TRSs. But there are hand-written examples where it fails.</p>
<p>We could do user-specified strategies like Stratego, but then how would we know that they’re normalizing.</p>
<p>The optimal reduction stuff is defined for match sequential TRSs.</p>
<p>non-strict strategies:
* Lenient evaluation - computation rule [Traub, FPCA 89], where all redexes are evaluated in parallel except inside the arms of conditionals and inside lambdas.
* extra memory overhead for parameter passing (inefficient)
* strictness analysis to optimize to eager (which has identical semantics to lazy 99% of the time)</p>
<p>Now, one can argue about which computational strategy is better (time, space, parallelism, …)
Stroscot: be accepting of programs, ensure a normalizing strategy. But after that aim for most efficient in time/space for strict programs.</p>
<p>Q: can normalizing be as efficient as strict
profiling, other optimization tricks</p>
<p>A list List[Nat]. In a strict language ADTs are finite. In lazy, we might accept infinite lists (generators). We want precise types: the finite data structure and its infinite counterpart ARE DIFFERENT DATATYPES. Only discardable (weakenable) boxes can contain infinite structures, so uList. (Nat + !w List) is an infinite list, while uList. (Nat + List) is a strict list. Extends to more complicated data structures. With subtyping you can use a finite list with an infinite list transformer.</p>
<p>UNIX pipes. “yes fred | less” works fine, but “yes fred | sort | less” is an infinite loop, because yes fred is infinite and sort is strict. For finite streams the simple semantics of pipes, namely
1) First program generates output
2) This output is sent to next program
….
n) This output is sent to next program
n+1) This output is sent to terminal
suffices.
Most programs have finite output on finite input and block gracefully. Thus for MOST programs you need not worry about whether the execution of pipes is interleaved or not. The interleaving matters for long outputs because it saves memory (=time w/gc) and improves performance dramatically.
That interleaving works with certain infinite streams is just a natural generalization. The slow behavior of sort is also visible with long lists.
Laziness means you can implement interleaving once in the language (as the evaluation strategy) as opposed to piecemeal for each program.</p>
<p>Condensing acyclic rewriting systems gives back the same system. Orthogonal higher-order TRSs that are weakly head normalizing are acyclic, per <span id="id13">[<a class="reference internal" href="../zzreferences.html#id81" title="Jeroen Ketema, Jan Willem Klop, and Vincent van Oostrom. Vicious Circles in Rewriting Systems. In 5th International Workshop on Reduction Strategies in Rewriting and Programming, 20. Nara, Japan, April 2005. URL: https://www.dicosmo.org/WRS05/proceedings/jeroen.pdf.">KKvanOostrom05</a>]</span>.</p>
<p>So The way we handle cycles in the rewrite engine is something like:</p>
<ul class="simple">
<li><p>detect cyclic term via rule cycle detection or presence of AC operator</p></li>
<li><p>use specialized matching (eg AC matching or Tarjan SCC + memo hash table) to identify all reductions out of SCC</p></li>
<li><p>end with condensed normal form if no reduction out of SCC</p></li>
<li><p>otherwise, pick a reduction out of the SCC</p></li>
</ul>
<p>Then this infinite term is computed in chunks and fed to the surrounding context on demand (laziness), ensuring that a finite normal form is reached if possible and otherwise implementing an infinite stream of commands.</p>
<section id="higher-order-matching">
<h3>Higher-order matching<a class="headerlink" href="#higher-order-matching" title="Permalink to this heading"></a></h3>
<p>If the substitution calculus is convergent, then terms can be represented by preterms in normal form.</p>
<p>Handling lambdas in RHSs is fairly straightforward, just beta-reduce as much as possible when they are encountered. But in higher-order term rewriting systems the lambdas can show up on the left hand side, in the pattern. The rewriting system is then defined modulo lambda reduction. Executing a rule <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code> on a term <code class="docutils literal notranslate"><span class="pre">t</span></code> solves the equation <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">C[lθ]</span></code> and replaces it with <code class="docutils literal notranslate"><span class="pre">C[rθ]</span></code>.</p>
<p>Finding the contexts <code class="docutils literal notranslate"><span class="pre">C</span></code> is fairly straightforward, just enumerate all the subterms of <code class="docutils literal notranslate"><span class="pre">t</span></code>. But solving the equation <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">lθ</span></code> is an instance of higher-order unification (specifically higher-order matching).  The λ-superposition calculus relies on complete sets of unifiers (CSUs). The
CSU for s and t, with respect to a set of variables V , denoted by CSUV (s, t), is a
set of unifiers such that for any unifier % of s and t, there exists a σ ∈ CSUV (s, t)
and θ such that %(X) = (σ◦θ)(X) for all X ∈ V . The set X is used to distinguish
between important and auxiliary variables. We can normally leave it implicit</p>
<p>Higher order matching is decidable for the simply typed lambda calculus. But the proof is of the form “the minimal solution is of size at most 2^2^2^2…, the number of 2’s proportional to the size of the problem”. There are 3 transformations presented in the proof which reduce a larger solution to a smaller solution. These might be usable to prune the search tree. But at the end of the day it’s mostly brute-force.</p>
<p>The proof relies on some properties of the STLC, namely normalization and that terms have a defined eta long form (canonical form).</p>
<p>It is not clear if there is a way to do untyped higher order matching for general lambda patterns.</p>
<p>As a consequence of confluence each rewrite step is composed of an expansion in the substitution calculus, a replacement by applying some rule, and a reduction in the substitution calculus, so it is M &lt;&lt;- C[l] and C[r] -&gt;&gt; N</p>
<p>If reduction does not end in a condensed normal form, then the sequence of terms must be infinitely expanding in the sense that for every size s there is a point in the reduction where terms are always at least size s. Otherwise, assuming a finite number of term symbols, there are only finitely many terms of size &lt; s, so there would be a cycle in the reduction and reduction would end in a condensed normal form.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Syntax.html" class="btn btn-neutral float-left" title="Syntax" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Time.html" class="btn btn-neutral float-right" title="Time API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>