<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Logic programming &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=db2ac877" />

  
    <link rel="shortcut icon" href="../../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=7f41d439"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Macros" href="Macros.html" />
    <link rel="prev" title="Logic" href="Logic.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Commentary</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Language specification</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="Aspects.html">Aspects</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l3"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l3"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l3"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l3"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l3"><a class="reference internal" href="FunctionalLogic.html">Functional logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Logic programming</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#motivation">Motivation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#semantics">Semantics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#modes">Modes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sources">Sources</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l3"><a class="reference internal" href="Memory.html">Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="OpPrims.html">Operational primitives</a></li>
<li class="toctree-l3"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l3"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l3"><a class="reference internal" href="Security.html">Security</a></li>
<li class="toctree-l3"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l3"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="Values.html">Values</a></li>
<li class="toctree-l3"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Implementation/index.html">Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Libraries/index.html">Libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Meta/index.html">Meta</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Commentary</a></li>
          <li class="breadcrumb-item"><a href="index.html">Language specification</a></li>
      <li class="breadcrumb-item active">Logic programming</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Language/LogicProgramming.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="logic-programming">
<h1>Logic programming<a class="headerlink" href="#logic-programming" title="Link to this heading"></a></h1>
<p>logic programming: express goals in a declarative form and solve problems using automated reasoning.</p>
<section id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Link to this heading"></a></h2>
<p>Misquoting <span id="id1">[<a class="reference internal" href="../../zzreferences.html#id125" title="Kenneth E. Iverson. Notation as a tool of thought. Communications of the ACM, 23(8):444–465, August 1980. URL: https://doi.org/10.1145/358896.358899 (visited on 2022-07-18), doi:10.1145/358896.358899.">Ive80</a>]</span>:</p>
<blockquote>
<div><p>Users of computers and programming languages are often concerned primarily with the efficiency of execution of algorithms, and might, therefore, summarily dismiss [logic programming]. Such dismissal would be short-sighted since a clear statement […] can usually be used as a basis from which one may easily derive a more efficient algorithm.</p>
<p>[…]</p>
<p>The practice of first developing a clear and precise definition […] without regard to efficiency, and then using it as a guide and a test in exploring equivalent processes possessing other characteristics, such as greater efficiency, is very common in mathematics. It is a very fruitful practice which should not be blighted by premature emphasis on efficiency in computer execution.</p>
<p>[…]</p>
<p>Finally, overemphasis of efficiency leads to an unfortunate circularity in design: for reasons of efficiency early programming languages reflected the characteristics of the early computers, and each generation of computers reflects the needs of the programming languages of the preceding generation.</p>
</div></blockquote>
<p>Practically, logic programming is a great tool for naturally expressing computational tasks that use logical constraints. Large programs generally run into one or two of these tasks. Without logic programming these tasks must be solved in an ad-hoc and verbose way. Compare <a class="reference external" href="https://www.metalevel.at/sudoku/">Sudoku with Prolog</a> vs <a class="reference external" href="https://norvig.com/sudopy.shtml">Norvig’s Sudoku solution</a>. Other examples include parsers, typecheckers, and database queries. Specifically:</p>
<ul class="simple">
<li><p>Prolog’s Definite Clause Grammars, and library <a class="reference external" href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/pio.pl">pio</a>, are a great parsing DSL. Furthermore the relation <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">parses_to</span> <span class="pre">Y</span></code> can be flipped to get <code class="docutils literal notranslate"><span class="pre">Y</span> <span class="pre">prints_to</span> <span class="pre">X</span></code>, automatically generating serializers from deserializers.</p></li>
<li><p>With typecheckers you can just directly translate the rules to Horn clauses and it runs. Similarly language interpreters are a direct translation of their operational semantics.</p></li>
<li><p>Incomplete data structures are great. <code class="docutils literal notranslate"><span class="pre">date(2018,</span> <span class="pre">month,</span> <span class="pre">14)</span></code> describes every 14th day in this year, and the month can be constrained or the set of dates extracted. Furthermore with constraint logic programming sets of dates can be manipulated.</p></li>
<li><p>Database queries are naturally expressed as logical operations on relations. For example pyDatalog and SQL can be called relational languages.</p></li>
</ul>
</section>
<section id="semantics">
<h2>Semantics<a class="headerlink" href="#semantics" title="Link to this heading"></a></h2>
<section id="relational">
<h3>Relational<a class="headerlink" href="#relational" title="Link to this heading"></a></h3>
<p>Logic programs over classical true, false, not, ∧, ∨, ⊃, ∀, and ∃ have what <span id="id2">[<a class="reference internal" href="../../zzreferences.html#id47" title="William E. Byrd. Relational Programming in Minikanren: Techniques, Applications, and Implementations. PhD thesis, Indiana University, August 2009. URL: https://scholarworks.iu.edu/dspace/handle/2022/8777 (visited on 2022-07-14).">Byr09</a>]</span> terms “relational” semantics (to be confused with relational databases). A state is a map from some set of nominal variables to their substitution, a set of ground terms. A goal is a logical predicate over some variables - applying it to a state that defines the relevant variables gives true or false. Running a program consists of computing the set of satisifable states, which may be empty or infinite.</p>
<p>Practically the execution engine does not return a set, but rather a finite or infinite stream of satisfying meta-states. Meta-states are states that include unbound variables representing any term, and (in constraint logic programming) constraints for these unbound variables. Ideally the stream would be a minimal completely-covering set of meta-states in some arbitrary order, but in practice implementations can return identical or overlapping results.</p>
<p>miniKanren uses an “interleaving” search from <span id="id3">[<a class="reference internal" href="../../zzreferences.html#id151" title="Oleg Kiselyov, Chung-chieh Shan, Daniel P. Friedman, and Amr Sabry. Backtracking, interleaving, and terminating monad transformers: (functional pearl). In Proceedings of the Tenth ACM SIGPLAN International Conference on Functional Programming - ICFP '05, 192. Tallinn, Estonia, 2005. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1086365.1086390 (visited on 2022-07-15), doi:10.1145/1086365.1086390.">KSFS05</a>]</span>, which is “complete” in the sense that it explores all branches fairly and will find all answers eventually. Generally the search strategy is irrelevant so long as it is fair, so there are many other choices; we can optimize the search, or dump the problem into an SMT solver and use its search strategy. CDCL with optimizations should be the fastest.</p>
</section>
<section id="imperative">
<h3>Imperative<a class="headerlink" href="#imperative" title="Link to this heading"></a></h3>
<p>Prolog has extended the execution engine with predicates that expose details of the underlying implementation:</p>
<ul class="simple">
<li><p>Cut (!) which commits to choices made since the parent goal was unified with the left-hand side of the clause containing the cut. miniKanren similarly includes operators conda (soft-cut) and condu (committed choice). Concurrent logic programming also has committed choice which prunes off all other branches once it is known that a clause’s guard goals all succeed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">var/1</span></code> which checks if the variable is unbound</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">copy_term/2</span></code> which can duplicate unbound variables to fresh ones</p></li>
<li><p>Side-effectful operations which execute even if the operation fails</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is</span></code> which - as a side effect - computes an arithmetic expression and binds a variable</p></li>
<li><p>unfair search so that <code class="docutils literal notranslate"><span class="pre">ancestor_of(A,</span> <span class="pre">P)</span> <span class="pre">:-</span> <span class="pre">ancestor_of(A,</span> <span class="pre">Parent),</span> <span class="pre">parent_of(Parent,</span> <span class="pre">P).</span> <span class="pre">:-</span> <span class="pre">ancestor_of(x,y)</span></code> diverges e switching the order of the goals does not</p></li>
<li><p>Meta-programming which allows querying or modifying clauses at run time, such as nth_clause, assert, retract</p></li>
</ul>
<p>In particular these features expose Prolog’s search strategy. Prolog uses a simple depth-first search strategy, “SLD resolution”, to explore clauses. This means the denotational semantics of programs must include the search strategy’s implementation and any goal side effects. SLD resolution is inefficient and biased compared to more modern logic search strategies such as DPLL or CDCL. But SLD’s simplicity is the main reason imperative Prolog execution is comprehensible.</p>
<p>Programs that heavily use imperative features and SLD resolution are best understood using an imperative execution model with embedded backtracking commands that can re-execute side-effectful operations. The imperative “Byrd Box” execution model was first described in “Understanding the control flow of Prolog programs” by Lawrence Byrd. This paper is not available online but the idea is described in many other places, e.g. <a class="reference external" href="https://www.amzi.com/articles/prolog_under_the_hood.htm">Merritt</a>, and is visible in Prolog debuggers. It goes as follows. A goal is of type <code class="docutils literal notranslate"><span class="pre">Goal</span> <span class="pre">=</span> <span class="pre">{call</span> <span class="pre">:</span> <span class="pre">Entry,</span> <span class="pre">redo</span> <span class="pre">:</span> <span class="pre">Entry</span> <span class="pre">};</span> <span class="pre">Entry</span> <span class="pre">=</span> <span class="pre">{exit:</span> <span class="pre">Entry,</span> <span class="pre">fail</span> <span class="pre">:</span> <span class="pre">Entry}</span> <span class="pre">-&gt;</span> <span class="pre">Exit;</span> <span class="pre">Exit</span> <span class="pre">=</span> <span class="pre">IO</span> <span class="pre">()</span></code>. The composition <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">,</span> <span class="pre">B</span></code> of two goals is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">comp</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Goal</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">exit</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">redo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">exit</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">A</span><span class="o">.</span><span class="n">call</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">f</span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">B</span><span class="o">.</span><span class="n">call</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">e</span>
<span class="w">  </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">exit</span>
<span class="w">  </span><span class="n">d</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">B</span><span class="o">.</span><span class="n">redo</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">e</span>
<span class="w">  </span><span class="n">e</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">A</span><span class="o">.</span><span class="n">redo</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">f</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fail</span>
</pre></div>
</div>
<p>Various examples of goals:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">write</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="n">print</span><span class="w"> </span><span class="kt">X</span><span class="p">;</span><span class="w"> </span><span class="n">exit</span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">redo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="p">}</span>
<span class="nf">fail</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">redo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="p">}</span>
<span class="nf">cut</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">exit</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">redo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">abort_goal</span><span class="w"> </span><span class="p">}</span>
<span class="nf">unify</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="kt">Y</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newGoalId</span><span class="p">;</span>
<span class="w">  </span><span class="n">tryNext</span><span class="w"> </span><span class="ow">=</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">pop</span><span class="w"> </span><span class="n">unifiers</span><span class="p">)</span>
<span class="w">      </span><span class="n">pushChoicePoint</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="n">unifiers</span><span class="p">)</span>
<span class="w">      </span><span class="n">unify</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="n">u</span>
<span class="w">      </span><span class="n">exit</span>
<span class="w">    </span><span class="kr">else</span>
<span class="w">      </span><span class="n">fail</span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="ow">=</span>
<span class="w">      </span><span class="p">(</span><span class="kt">X</span><span class="p">,</span><span class="w"> </span><span class="kt">Y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lookupOrAllocVars</span><span class="w"> </span><span class="p">(</span><span class="kt">X</span><span class="p">,</span><span class="kt">Y</span><span class="p">)</span>
<span class="w">      </span><span class="n">unifiers</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">unificationAlgo</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="kt">Y</span>
<span class="w">      </span><span class="n">pushChoicePoint</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">unifiers</span>
<span class="w">      </span><span class="n">tryNext</span>
<span class="w">    </span><span class="n">redo</span><span class="w"> </span><span class="ow">=</span>
<span class="w">      </span><span class="n">unifiers</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">popChoicePoint</span><span class="w"> </span><span class="n">r</span>
<span class="w">      </span><span class="n">tryNext</span>
<span class="w">  </span><span class="p">}</span>

<span class="nf">predicate</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newGoalId</span>
<span class="w">  </span><span class="n">tryNext</span><span class="w"> </span><span class="ow">=</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">pop</span><span class="w"> </span><span class="n">unifiers</span><span class="p">)</span>
<span class="w">      </span><span class="n">pushChoicePoint</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="n">unifiers</span><span class="p">)</span>
<span class="w">      </span><span class="n">unify</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="n">u</span>
<span class="w">      </span><span class="n">exit</span>
<span class="w">    </span><span class="kr">else</span>
<span class="w">      </span><span class="n">fail</span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="ow">=</span>
<span class="w">      </span><span class="n">unifiers</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">findClauses</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">findUnifiers</span>
<span class="w">      </span><span class="n">pushChoicePoint</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">unifiers</span>
<span class="w">      </span><span class="n">tryNext</span>
<span class="w">    </span><span class="n">redo</span><span class="w"> </span><span class="ow">=</span>
<span class="w">      </span><span class="n">unifiers</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">popChoicePoint</span><span class="w"> </span><span class="n">r</span>
<span class="w">      </span><span class="n">tryNext</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>The general advice is to use imperative features <a class="reference external" href="http://www.cse.unsw.edu.au/~billw/dictionaries/prolog/cut.html">sparingly</a> and only if you can justify the need based on performance. <span id="id4">[<a class="reference internal" href="../../zzreferences.html#id47" title="William E. Byrd. Relational Programming in Minikanren: Techniques, Applications, and Implementations. PhD thesis, Indiana University, August 2009. URL: https://scholarworks.iu.edu/dspace/handle/2022/8777 (visited on 2022-07-14).">Byr09</a>]</span> shows that, for a sample program, these features can be completely avoided. Cut can almost always be replaced with a tagging scheme that makes the matching clause unambiguous, or more expressive constraints. Byrd says there is no complete method for avoiding copy-term, but in his example it can be replaced by using templates with unique names and substituting these with logic variables.</p>
<p>Overall it seems that imperative features are antipatterns: band-aid implementation hacks that can be avoided by making the compiler smarter or the constraint language more expressive. Mercury has eliminated these features in favor of a state-token I/O system. <span id="id5">[<a class="reference internal" href="../../zzreferences.html#id114" title="Fergus Henderson, Zoltan Somogyi, and Thomas Conway. Determinism analysis in the Mercury compiler. In In Proceedings of the Australian Computer Science Conference, 337–346. 1996. URL: https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.17.3967&amp;rep=rep1&amp;type=pdf.">HSC96</a>]</span></p>
<ul class="simple">
<li><p>XSB: <a class="reference external" href="http://xsb.sourceforge.net/manual1/manual1.pdf">http://xsb.sourceforge.net/manual1/manual1.pdf</a></p></li>
</ul>
</section>
<section id="proof-search">
<h3>Proof-search<a class="headerlink" href="#proof-search" title="Link to this heading"></a></h3>
<p>A more general paradigm is sequent proof search, which allows all the connectives of linear logic and extensions such as infinite proof trees. A logic program consists of some list of program clauses (proof sequents) ∆ which can be seen as assumptions or axioms. There is then a goal sequent !∆, C −→ G representing a search state in which formulas ∆ are assumed, resources C are provided, and the goal is G. The logic engine then searches for proof trees which prove this sequent. Via the Curry-Howard correspondence, these proof trees correspond to programs of the type described by the sequent. As with relational programming a finite or infinite stream of satisfying programs is returned.</p>
<p>Since programs such as <code class="docutils literal notranslate"><span class="pre">undefined</span></code> trivially satisfy all goals, restrictions must be made to the space of proofs to obtain useful results. The standard restriction is to finite “cut free” proofs, which by the cut elimination theorem can prove all sequents with finite proofs. Uniform proofs are cut-free sequent proofs P such that every subproof of P is uniform and also for every non-atomic formula occurrence B in the right-hand side of the end-sequent of P, there is a proof P0 equal to P up to permutation of inference rules such that P0’s last inference rule is the right introduction rule for the top-level logical connective occurring in B. The existence of uniform proofs allow a goal-directed search which starts by logically decomposing goals. It is only when the goal formula is atomic that other proof methods are used (“backchaining”). An abstract logic programming language is a system of goals, formulas, and rules such that a sequent has a proof if and only if it has a uniform proof.</p>
<p>Uniformity seems mainly useful for classical logic. In linear logic the dynamics of cut-free proof search can be described via Andreoli’s focused proofs which alternate between “unfocused”/goal-reduction decomposition of all asynchronous formulas and “focused”/backchaining decomposition of some synchronous formula by using introduction rules for its top-level connective and all synchronous subformulas that might arise.</p>
</section>
<section id="answer-set">
<h3>Answer set<a class="headerlink" href="#answer-set" title="Link to this heading"></a></h3>
<p>Answer-set programming (ASP) rebases the solving process onto SMT/SAT-style propositional solvers. ASP is based on “stable-model semantics”, which competes with “program completion” and the “well-founded semantics” to define the meaning of negation. Program completion <span id="id6">[<a class="reference internal" href="../../zzreferences.html#id53" title="Keith L. Clark. Negation as Failure. In Hervé Gallaire and Jack Minker, editors, Logic and Data Bases, pages 293–322. Springer US, Boston, MA, 1978. URL: http://www.doc.ic.ac.uk/~klc/NegAsFailure.pdf (visited on 2022-07-15), doi:10.1007/978-1-4684-3384-5_11.">Cla78</a>]</span> interprets as a clause <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">:-</span> <span class="pre">q,</span> <span class="pre">not</span> <span class="pre">r</span></code> as “p if and only if q and not r”. A stable model is a mapping <code class="docutils literal notranslate"><span class="pre">Prop</span> <span class="pre">-&gt;</span> <span class="pre">{T,F}</span></code> such that for each clause <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">:-</span> <span class="pre">B1,</span> <span class="pre">…,</span> <span class="pre">Bm</span> <span class="pre">,</span> <span class="pre">not</span> <span class="pre">C1,</span> <span class="pre">…,</span> <span class="pre">not</span> <span class="pre">Cn</span></code> either some proposition <code class="docutils literal notranslate"><span class="pre">Ci</span></code> is true or the negation-free sequent <code class="docutils literal notranslate"><span class="pre">B1,</span> <span class="pre">…,</span> <span class="pre">Bm</span> <span class="pre">|-</span> <span class="pre">A</span></code> holds.</p>
<p>Although the semantics of ASP is conventional first-order logic, existing practical tools for ASP only implement propositional solvers, not first-order logic - they work by first “grounding” the first-order formulae to a propositional representation, and then solving them. Compared to SLDNF this can cause blow-up or speed-up but under a finite domain assumption it gives the same results.</p>
</section>
</section>
<section id="modes">
<h2>Modes<a class="headerlink" href="#modes" title="Link to this heading"></a></h2>
<p>Mercury has <a class="reference external" href="https://www.mercurylang.org/information/doc-latest/mercury_ref/Modes.html#Modes">modes</a>. An instantiation state is either “free”, a unbound variable “distinct” in that it does not appear anywhere else, or “bound”, a mapping from possible function symbols to instantiation states of the symbols’ arguments. A mode is a mapping from initial instantiation states to final instantiation states, with the constraint that no node is transformed from bound to free. The two standard modes are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">==</span> <span class="pre">ground</span> <span class="pre">&gt;&gt;</span> <span class="pre">ground.</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">==</span> <span class="pre">free</span> <span class="pre">&gt;&gt;</span> <span class="pre">ground.</span></code></p></li>
</ul>
<p>There are other states, e.g. <code class="docutils literal notranslate"><span class="pre">X</span></code> in the term <code class="docutils literal notranslate"><span class="pre">[X,X]</span></code> is neither free nor bound, hence Mercury’s mode system is incomplete.  I think this deficiency can be fixed by allowing constrained modes, at the expense of making the definition of modes even more complicated.</p>
<p>Mercury also categorises each mode of a predicate according to how many times it can succeed:</p>
<ul class="simple">
<li><p>deterministic: exactly one solution</p></li>
<li><p>semideterministic: no solutions or one solution</p></li>
<li><p>multisolution: at least one solution</p></li>
<li><p>nondeterministic: zero, one, or more solutions</p></li>
<li><p>failure/erroneous: no solution, always fails/errors</p></li>
</ul>
<p>For example append can work in several modes:</p>
<ul class="simple">
<li><p>predicate (in, in, in), semideterministic: <code class="docutils literal notranslate"><span class="pre">append</span> <span class="pre">[a,b]</span> <span class="pre">[c]</span> <span class="pre">[a,b,c]</span> <span class="pre">--&gt;</span> <span class="pre">yes</span></code></p></li>
<li><p>function (in, in, out), deterministic: <code class="docutils literal notranslate"><span class="pre">append</span> <span class="pre">[a,b]</span> <span class="pre">[c]</span> <span class="pre">Z</span> <span class="pre">--&gt;</span> <span class="pre">Z</span> <span class="pre">=</span> <span class="pre">[a,b,c]</span></code></p></li>
<li><p>match left (out, in, in), semideterministic: <code class="docutils literal notranslate"><span class="pre">append</span> <span class="pre">X</span> <span class="pre">[c]</span> <span class="pre">[a,b,c]</span> <span class="pre">--&gt;</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">[a,b]</span></code></p></li>
<li><p>match both (out, out, in), nondeterministic: <code class="docutils literal notranslate"><span class="pre">append</span> <span class="pre">X</span> <span class="pre">Y</span> <span class="pre">[a,b,c]</span> <span class="pre">--&gt;</span> <span class="pre">X=[],Y=[a,b,c];X=[a],Y=[b,c];X=[a,b],Y=[c],X=[a,b,c],Y=[]</span></code></p></li>
<li><p>match all (out, out, out), nondeterministic: <code class="docutils literal notranslate"><span class="pre">append</span> <span class="pre">X</span> <span class="pre">Y</span> <span class="pre">Z</span> <span class="pre">--&gt;</span> <span class="pre">X=[],Y=[],Z=[];...</span></code></p></li>
</ul>
<p>Each mode is a function from inputs to a set of outputs (or output / Maybe, in the deterministic/semideterministic case). So, characterizing all uses of predicates with mode declarations, predicates can be thought of as a collection of ad-hoc overloaded functions. Except it’s not ad-hoc, because they all represent the same logical relation. Anyways, we can embed functional programming into logic programming, by a mode declaration <code class="docutils literal notranslate"><span class="pre">(in,</span> <span class="pre">out),</span> <span class="pre">deterministic</span></code> for each function. Similarly we can embed term rewriting, by a mode declaration <code class="docutils literal notranslate"><span class="pre">(in,</span> <span class="pre">out),</span> <span class="pre">nondeterministic</span></code> for the rewrite relation. The reverse is not possible - we cannot get from the behavior on a specific mode to the overall behavior of the predicate. To support logic programming in an integrated manner everything must be interpretable as a logic program.</p>
<p>Logic programming allows writing very concise code, although it can be unusably inefficient in some cases. For this, we can allow writing optimized imperative code, and asserting that this implements a specific mode of a predicate. Then the predicate becomes optimized. But with a smart compiler, the imperative code can be avoided most of the time, saving the need for duplication - just tune the hot cases. Similarly writing imperative code in the first place avoids the issue altogether, although it precludes most of the benefits of logic programming.</p>
</section>
<section id="sources">
<h2>Sources<a class="headerlink" href="#sources" title="Link to this heading"></a></h2>
<p>Based on:
* <a class="reference external" href="https://stackoverflow.com/questions/28467011/what-are-the-main-technical-differences-between-prolog-and-minikanren-with-resp">Byrd</a>, author of miniKanren
* <a class="reference external" href="https://www.reddit.com/r/ProgrammingLanguages/comments/9kb9z5/logic_programming_languages/">Reddit thread</a>, particularly Paul Bone who did his PhD “Automatic Parallelism in Mercury”)
* <a class="reference external" href="https://news.ycombinator.com/item?id=14439137">HN thread</a></p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Logic.html" class="btn btn-neutral float-left" title="Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Macros.html" class="btn btn-neutral float-right" title="Macros" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>