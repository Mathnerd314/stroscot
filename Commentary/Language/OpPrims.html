<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Operational primitives &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=db2ac877" />

  
    <link rel="shortcut icon" href="../../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=7f41d439"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Posets" href="Posets.html" />
    <link rel="prev" title="Objects" href="Objects.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Commentary</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Language specification</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="Aspects.html">Aspects</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l3"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l3"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l3"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l3"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l3"><a class="reference internal" href="FunctionalLogic.html">Functional logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l3"><a class="reference internal" href="Memory.html">Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Operational primitives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#assembly">Assembly</a></li>
<li class="toctree-l4"><a class="reference internal" href="#abstracted-assembly">Abstracted assembly</a></li>
<li class="toctree-l4"><a class="reference internal" href="#runtime-and-os-calls">Runtime and OS calls</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ffi-calls">FFI calls</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l3"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l3"><a class="reference internal" href="Security.html">Security</a></li>
<li class="toctree-l3"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l3"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="Values.html">Values</a></li>
<li class="toctree-l3"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Implementation/index.html">Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Libraries/index.html">Libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Meta/index.html">Meta</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Commentary</a></li>
          <li class="breadcrumb-item"><a href="index.html">Language specification</a></li>
      <li class="breadcrumb-item active">Operational primitives</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Language/OpPrims.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="operational-primitives">
<h1>Operational primitives<a class="headerlink" href="#operational-primitives" title="Link to this heading"></a></h1>
<p>8A. There shall be a few low level input-output operations that send and receive control information to and from physical channels and devices. The low level operations shall be chosen to insure that all user level input-output operations can be defined within the language.</p>
<p>As used in Stroscot, operational primitives refer to the stateful operations that form the building blocks of imperative programs. Examples include memory operations (read, write), foreign function calls, compiler intrinsics, and OS system calls. It would also be possible to call them “primitive operations”, but this term is less precise and could be read as including elements of the runtime such as lambda reduction and term rewriting.</p>
<p>There is an operational interpretation of every expression in Stroscot. For example, the operational interpretation of a value is returning that value. The operational interpretation of addition on two machine integers consists of storing the integers to memory or fixed registers, executing the <code class="docutils literal notranslate"><span class="pre">add</span></code> assembly instruction, appropriately handling any error conditions or traps, packaging up the result as a value, and returning it. And so on. Generally, a program may be viewed as assembly instruction sequences interleaved together with higher-level “glue” code. During optimization, one goal is to convert and reduce as much of this “glue” code as possible into assembly. Each switch into “glue” code corresponds to a jump back into the interpreter, with associated overhead.</p>
<p>Steelman 1G says “There shall be a facility for defining those portions of programs that are dependent on the object machine configuration and for conditionally compiling programs depending on the actual configuration.” Stroscot follows this fully, exposing the full machine configuration at runtime and allowing code to use this information in conditions or other control structures.</p>
<p>11C. To aid conditional compilation, it shall be possible to interrogate properties that are known during translation including characteristics of the object configuration, of function and procedure calling environments, and of actual parameters. For example, it shall be possible to determine whether the caller has suppressed a given exception, the callers optimization criteria, whether an actual parameter is a translation time expression, the type of actual generic parameters, and the values of constraints characterizing the subtype of actual parameters.</p>
<p>11D. The object system configuration must be explicitly specified in each separately translated unit. Such specifications must include the object machine model, the operating system if present, peripheral equipment, and the device configuration, and may include special hardware options and memory size. The translator will use such specifications when generating object code. [Note that programs that depend on the specific characteristics of the object machine, may be made more portable by enclosing those portions in branches of conditionals on the object machine configuration.]</p>
<section id="assembly">
<h2>Assembly<a class="headerlink" href="#assembly" title="Link to this heading"></a></h2>
<p>Operational primitives are naturally represented as assembly instruction sequences or templates. After all, the CPU cannot execute anything else. So with a built-in assembler, we have a complete set of operational primitives. By the nature of the definition, these are hardware and platform specific.</p>
<p>Ideally we would model primitives as deterministic functions from input machine state to output machine state. We can use a <a class="reference external" href="https://criu.org/Images">CRIU image</a> to model the machine state (at least on Linux - Windows is left as an exercise). This allows more control than a traditional ELF image + exit code, as it captures the complete state of a process in the middle of its execution, like a debugger would. But the behavior of almost all assembly instructions can be affected by unpredictable external factors. Therefore we model primitives as functions that take an input CRIU state and an additional “recording” of external factors and produces an output CRIU state. Examples of recorded factors:</p>
<ul class="simple">
<li><p>signal interrupts (any interruptible instruction)</p></li>
<li><p>memory order (for any instruction reading/writing shared memory)</p></li>
<li><p>system call results (for syscalls)</p></li>
<li><p>spurious failures (for load-linked/store-conditional)</p></li>
<li><p>CPU cycle count (rdtsc)</p></li>
<li><p>random numbers (rdrand)</p></li>
<li><p>current CPU / core id (cpuid)</p></li>
<li><p>FPU state (floating-point)</p></li>
<li><p>chip ID (if the instruction outputs undefined or “reserved for future definition” registers)</p></li>
</ul>
<p>Generally speaking, all assembly instructions are deterministic after recording and controlling these factors - otherwise, programs would not execute reliably. For most instructions there is a “default” recording that can be assumed (no signals, no memory interactions, etc.), so it would be possible to formulate these instructions without a recording, but as rdrand etc. are also instructions it is easier to formalize all instructions and instruction sequences as taking a recording.</p>
<p>Recordings are not just theoretical; there are programs that implement record/replay. They use various techniques, such as ptrace/breakpoints (rr - single threaded), intercepting DLL calls (Replay.io - mainly for JS), dynamic instrumentation (PinPlay, Undo.io - multithreaded), and machine virtualization (research-level; a bit problematic as it requires emulating a whole system).</p>
<p>When we are optimizing, we often want to replace one instruction sequence with another. For example, we may want to redo the register allocation, or replace an instruction sequence with a faster one. So we need a semantics for these instruction sequences that allows us to determine if two instruction sequences are equivalent, and then we can define operational primitives as equivalence classes of instruction sequences. In general, an instruction sequence may have arbitrary effects, and may be a complete program. So it is easier to think about comparing programs, and then we can define instruction sequences as equivalent if they have the same behavior when embedded in appropriate programs. Conceptually, comparing programs is simple: run the programs and see if they do the same thing. But programs on modern systems have a lot of parts.</p>
</section>
<section id="abstracted-assembly">
<h2>Abstracted assembly<a class="headerlink" href="#abstracted-assembly" title="Link to this heading"></a></h2>
<p>The nature of assembly is that it is a bit messy; we have to deal with register allocation and recordings and so forth. It is more convenient if we assume a fixed calling convention, say that all data for the operation (including the recording or decision to record de novo) is stored and returned in memory. Since all registers/flags/etc. can be stored/loaded to memory, and record/replay can be implemented on an instruction level, this does not lose any expressiveness - it merely adds significant overhead to executing the instruction. But in return it means operations work on immutable bitstrings rather than machine states. Generally these bitstrings are of a fixed, known width, such as 1, 8, 16, 32, 64, 80, 128, 256, 512, etc. (for flags, segment registers, general-purpose registers, FPU registers, MMX/SSE/AVX).</p>
<p>Operations are exposed in Stroscot as intrinsic functions. This allows using Stroscot’s typical syntax. For example the operations corresponding to x86-64 DIV, ADD, and ADC with 64-bit operands look like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">divide</span><span class="w"> </span><span class="p">(</span><span class="n">src</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">B64</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">high</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">B64</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">B64</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">divisor</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">src</span>
<span class="w">  </span><span class="n">dividend</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">low</span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="n">divisor</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="n">fault</span><span class="w"> </span><span class="kt">DE</span>
<span class="w">  </span><span class="kr">else</span>
<span class="w">    </span><span class="n">quotient</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">src2</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">src1</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="n">quotient</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="o">^</span><span class="mi">64</span>
<span class="w">      </span><span class="n">fault</span><span class="w"> </span><span class="kt">DE</span>
<span class="w">    </span><span class="kr">else</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="n">quotient</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">quotient</span><span class="p">,</span><span class="w"> </span><span class="n">remainder</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">src2</span><span class="w"> </span><span class="n">mod</span><span class="w"> </span><span class="n">src1</span><span class="w"> </span><span class="p">}</span>

<span class="nf">add</span><span class="w"> </span><span class="p">(</span><span class="n">src1</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">B64</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">src2</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">B64</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">dest</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">src1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">src2</span>
<span class="w">  </span><span class="o">...</span><span class="w"> </span><span class="n">compute</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">...</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="kt">OF</span><span class="p">,</span><span class="w"> </span><span class="kt">SF</span><span class="p">,</span><span class="w"> </span><span class="kt">ZF</span><span class="p">,</span><span class="w"> </span><span class="kt">AF</span><span class="p">,</span><span class="w"> </span><span class="kt">CF</span><span class="p">,</span><span class="w"> </span><span class="kt">PF</span><span class="w"> </span><span class="p">}</span>

<span class="nf">adc</span><span class="w"> </span><span class="p">(</span><span class="n">src1</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">B64</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">src2</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">B64</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">cf</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">B1</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">dest</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">src1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">src2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cf</span>
<span class="w">  </span><span class="o">...</span><span class="w"> </span><span class="n">compute</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">...</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="kt">OF</span><span class="p">,</span><span class="w"> </span><span class="kt">SF</span><span class="p">,</span><span class="w"> </span><span class="kt">ZF</span><span class="p">,</span><span class="w"> </span><span class="kt">AF</span><span class="p">,</span><span class="w"> </span><span class="kt">CF</span><span class="p">,</span><span class="w"> </span><span class="kt">PF</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Accessing memory is handled by a separate operation - but in the ISA x86 has combined read-add instructions:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">read</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Addr</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="kt">B64</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">B32</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">B16</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">B8</span><span class="p">}</span>
<span class="nf">read</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span>
<span class="kr">if</span><span class="w"> </span><span class="n">noncanonical</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="c1">-- https://stackoverflow.com/questions/25852367/x86-64-canonical-address</span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="n">referencesSSsegment</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="n">fault</span><span class="w"> </span><span class="kt">SS</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="kr">else</span>
<span class="w">    </span><span class="n">fault</span><span class="w"> </span><span class="kt">GP</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kr">else</span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="n">unaligned</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">enabled</span><span class="w"> </span><span class="n">alignment_checking</span>
<span class="w">    </span><span class="n">fault</span><span class="w"> </span><span class="kt">AC</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">not_in_physical_memory</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="n">fault</span><span class="w"> </span><span class="kt">PF</span><span class="p">(</span><span class="n">fault</span><span class="o">-</span><span class="n">code</span><span class="p">)</span>
<span class="w">  </span><span class="kr">else</span>
<span class="w">    </span><span class="n">memory</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="runtime-and-os-calls">
<h2>Runtime and OS calls<a class="headerlink" href="#runtime-and-os-calls" title="Link to this heading"></a></h2>
<p>The concept of a runtime depends on whether the program is compiled or interpreted. A compiler outputs native machine code that requires a specific library called a “runtime”. The runtime is a library that’s part of every program that can be either statically or dynamically linked. Meanwhile, an interpreter is an executable that includes a runtime. For example Java compiles to bytecode with javac, but the “runtime” or interpreter is the separate program “java” (JRE). The JRE implements concurrency and memory management.</p>
<p>For Stroscot the plan is for the compiled runtime to be minimal since many things can be implemented by linking in part of the standard library and it’s always nice to have small executable sizes. For example Zig claims to have <a class="reference external" href="https://ziglang.org/documentation/master/#Memory">“no runtime”</a>. Really this just means no default memory allocator - in practice, compared to assembly, Zig <a class="reference external" href="https://drewdevault.com/2020/01/04/Slow.html">still has</a> 2-3 KiB overhead (30%) for printing error messages.</p>
<p>libc is the C runtime for compiled programs. Go and Zig have a link_libc flag/no-libc mode that allows choosing to not link it, but in practice a lot of programs end up depending on libc anyway. Specifically, libc wraps all the syscalls, so on various systems (<a class="reference external" href="https://utcc.utoronto.ca/~cks/space/blog/programming/Go116OpenBSDUsesLibc">OpenBSD</a>, Illumos, Solaris) avoiding libc isn’t possible because system calls must be made through the system libc. And Windows/Mac require libc indirectly because you have to link to DLLs that depend on libc. Only on Linux is it possible to avoid libc by using direct syscalls. This can cause <a class="reference external" href="https://marcan.st/2017/12/debugging-an-evil-go-runtime-bug">evil bugs</a>. If the implementation follows Go’s or Zig’s closely this probably isn’t an issue because they’ve worked out all the bugs. And it should be faster / less register pressure to do syscalls in assembly than to set up a C stack and call into libc.</p>
<p>Even on Linux, many programs still need libc for compatibility. They interface with C by calling C libraries. Facilities such as malloc and errno can be avoided / reimplemented but in general the only way to get a working program is to use the C runtime. In particular Go’s net package depends on system C APIs everywhere except Linux, where they went to some effort to implement a no-libc version.</p>
<p>So overall it seems that self-contained executables on Linux are the only libc-free possibility. But these kinds of programs are what people use for comparisons on system programming, so it still seems to be worth implementing. There’s that “cool factor” of one less dependency.</p>
<p>The syscalls themselves take / modify C structs. So regardless of whether we link with libc, we still need a C parser / ABI to get anywhere.</p>
</section>
<section id="ffi-calls">
<h2>FFI calls<a class="headerlink" href="#ffi-calls" title="Link to this heading"></a></h2>
<p>Stroscot should work well with existing code written in other languages, either through natively importing and using that code or through easy-to-use bridges or interfaces.</p>
<p>The semantics of a call are inherently system/ABI dependent, to the point of not being captured in a target triple. The semantics thus have to be described at the call site. But the data format doesn’t really matter as the call instruction will most likely be wrapped / generated. Maybe libffi can help.</p>
<p>basic FFI types: <code class="docutils literal notranslate"><span class="pre">()</span></code>, <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">int8</span></code>, <code class="docutils literal notranslate"><span class="pre">int16</span></code>, <code class="docutils literal notranslate"><span class="pre">int32</span></code>, <code class="docutils literal notranslate"><span class="pre">int64</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">double</span></code>, <code class="docutils literal notranslate"><span class="pre">pointer</span></code>
Process C/C++ headers with clang, or inspect LLVM bitcode, to identify FFI types</p>
<p>symbols can be statically or dynamically linked</p>
<p>you can also just enclose foreign code in <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">C</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>.
this goes through clang to identify its FFI signature</p>
<p>Use C/C++ in the same address space - requires bindings with LLVM or SWIG, or compiling to the LLVM / GCC backend. Linking C requires an understanding of the calling conventions for all languages concerned, as well as concern for stack limits when calling C or C++.</p>
<section id="linux-syscalls">
<h3>Linux syscalls<a class="headerlink" href="#linux-syscalls" title="Link to this heading"></a></h3>
<p>Parsing all the syscalls requires either manually writing them out / copying them from <a class="reference external" href="https://filippo.io/linux-syscall-table/">somewhere</a> or doing a lot of kernel source spelunking. Go has some stuff <a class="reference external" href="https://pkg.go.dev/golang.org/x/sys/unix?utm_source=godoc">here</a> (<a class="reference external" href="https://cs.opensource.google/go/x/sys/+/master:unix/linux/mkall.go">script</a>): it generates syscall numbers and constants / <a class="reference external" href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoCGoCompatibleStructs">struct definitions</a> from the headers.</p>
<p>The only place the syscall arguments are defined is in individual files with macros from the family <a class="reference external" href="https://lwn.net/Articles/604287/">SYSCALL_DEFINEx</a> (e.g. <a class="reference external" href="https://github.com/torvalds/linux/blob/141415d7379a02f0a75b1a7611d6b50928b3c46d/fs/io_uring.c#L9737">io_uring_setup</a>). We have to run the preprocessor for true correctness; the best option seems to be hooking the macro to print out the arguments with <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Pragmas.html#Diagnostic-Pragmas">diagnostic pragmas</a>. Although scraping the files directly with grep + parentheses matching seems like it would work alright.</p>
<p>The actual convention is documented <a class="reference external" href="https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-and-user-space-f/2538212#2538212">here</a> and <a class="reference external" href="https://manpages.debian.org/unstable/manpages-dev/syscall.2.en.html">here</a>. The syscall number is expected in rax, return values in rax and rdx. otherwise all registers, segments and eflags are saved. Arguments left to right are rdi, rsi, rdx, r10, r8, r9.</p>
<p>Signed range of -4096 &lt; eax &lt; 0 is an error code, anything else may be a normal return value. (“A.2 AMD64 Linux Kernel Conventions” of <a class="reference external" href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs">System V Application Binary Interface AMD64 Architecture Processor Supplement</a>)</p>
</section>
<section id="abi">
<h3>ABI<a class="headerlink" href="#abi" title="Link to this heading"></a></h3>
<p>Swift 5 has a stable ABI, which has been <a class="reference external" href="https://gankra.github.io/blah/swift-abi/">praised</a>. This allows dynamic linking to system-wide libraries. Dynamic linking means that the ABI (method signatures) is provided at compile time but the actual methods are only available at runtime via the system dynamic linker.</p>
<p>An ABI consists of the names of some symbols together with their calling convention, which specifies the layout of types and return values. It is a property of the platform and toolchain. Linux C uses the Itanium ABI, Windows has MSVC (supported by LLVM) and also gcc can use Itanium. There are split conventions for 64-bit vs 32-bit.</p>
<p>C++ templated and Rust generic functions <code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;typename</span> <span class="pre">T&gt;</span> <span class="pre">bool</span> <span class="pre">process(T</span> <span class="pre">value)</span></code> generate symbols for each type (monomorphization) but have no direct ABI.</p>
<p>ABI should follow API, nothing can save API-breaking changes. Annotations optimize the ABI, at the cost of adding more ways to break compatibility. Swift made adding some annotations backwards-compatible. Example annotations are frozen (non-resilient) layout, exhaustively matchable, inlineable, non-subclassable, non-escaping.</p>
<p>Example: we change <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">path</span> <span class="pre">:</span> <span class="pre">ptr</span> <span class="pre">char</span> <span class="pre">}</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">{size</span> <span class="pre">:</span> <span class="pre">int64_t}</span></code> to <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">path</span> <span class="pre">:</span> <span class="pre">ptr</span> <span class="pre">char</span> <span class="pre">}</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">{last_modified_time</span> <span class="pre">:</span> <span class="pre">int64_t,</span> <span class="pre">size</span> <span class="pre">:</span> <span class="pre">int64_t}</span></code>. In Swift this only breaks ABI if the <code class="docutils literal notranslate"><span class="pre">frozen</span></code> annotation is present. By default types are resilient, meaning they are passed by reference and the size, alignment, stride, and extra inhabitants of types are looked up from the type’s witness table at runtime. But this is only outside the ABI boundary, inside the dynamic library it can assume the representation. And pointers have uniform layout hence don’t need the witness table. Swift compiles polymorphic APIs to a generic ABI, rather than monomorphizing. Also fields of resilient types are only exposed as getters and setters, so can be computed instead of being stored fields.</p>
<p>Re-abstraction thunks wrap closures with the wrong ABI.</p>
<p>ownership is part of the calling convention:</p>
<ul class="simple">
<li><p>function stores value and will release it</p></li>
<li><p>functions borrows value and does not keep it</p></li>
</ul>
<p>exceptions use a special calling convention with the error type boxed in a register. The caller initializes the “swift error” register to 0, and if there’s an exception the callee sets that register to hold the boxed error’s pointer. This makes error propagation really fast.</p>
<p>binary compatibility - changes will not break memory-safety or type-safety. Observable behavior may change, and preconditions, postconditions, and invariants may break. If a value is inlined, the old value will be used in existing compiled objects. Removing functionality has the expectation that the functionality is unused - if a client attempts to use the removed functionality it will get an error.</p>
<p>“fragile” or “frozen” describes C structs, which have very strict binary compatibility rules. Swift has “resilient” structs which store a witness table with metadata on their interpretation.</p>
<p>The following changes are binary compatible:</p>
<ul class="simple">
<li><p>Changing the body/value/initial value of a function, constant, or variable</p></li>
<li><p>Adding, changing, or removing a default argument</p></li>
<li><p>Changing a variable to a constant or vice versa</p></li>
<li><p>Adding, reordering, or removing members of resilient structs.</p></li>
<li><p>Adding, reordering, or removing cases of a resilient enum.</p></li>
<li><p>Changing parsing rules</p></li>
</ul>
</section>
<section id="c-c">
<h3>C/C++<a class="headerlink" href="#c-c" title="Link to this heading"></a></h3>
<p>Interop with C/C++ is a good target feature. There are varying approaches (in increasing order of ease of use):</p>
<ul class="simple">
<li><p>libffi just implements basic assembly stubs for setting registers. It doesn’t handle function signatures, memory layout or anything else - calling is all manual.</p></li>
<li><p><a class="reference external" href="https://github.com/rust-lang/rust-bindgen">rust-bindgen</a> parses headers with clang and generates FFI struct descriptions and function prototypes in Rust. It requires a separate build step. It doesn’t handle many features properly, such as macros, inline methods, templates, inheritance, destructors, exceptions and non-trivial calling conventions.</p></li>
<li><p><a class="reference external" href="https://github.com/rpav/c2ffi">c2ffi</a> parses headers with clang and generates JSON. There is hacked in support for some preprocessor macros and templates, but it is otherwise similar to rust-bindgen.</p></li>
<li><p><a class="reference external" href="https://github.com/aguinet/dragonffi">dragonffi</a> again uses clang but it works by compiling code snippets. This allows the full range of C/C++ to be used.</p></li>
</ul>
<p>I think the dragonffi approach is the best, since it’s the most powerful and least error prone. There is some effort to analyze the result of the compilation and integrate it with the rest of Stroscot, but deep integration with an existing C/C++ compiler seems better than trying to write one from scratch.</p>
<hr class="docutils" />
<p>Usually these are modeled using primitive operations, e.g. file descriptors are allocated with the open syscall rather than declaratively as <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">fd1</span> <span class="pre">=</span> <span class="pre">inode</span> <span class="pre">1234</span> <span class="pre">}</span></code>. But the more state we model as state, the more powerful our debugging tools get. A traditional debugger has no way to undo closing a file. However, a filestate-aware debugger can reopen the file. The less we view the program as an I/O machine the easier it is to use high-bandwidth interfaces such as io_uring to perform bulk state changes - describing what rather than how is the hallmark of a high-level language. Of course, in most cases the program will use state in a single-threaded manner and it will simply be compiled to the primitive operation API by the automatic destructive update optimization.</p>
<blockquote>
<div><p>operational primitive as a function from input machine state to output machine state. This is actually a function because we can always set up the machine to a given state and see what it does.</p>
<p>Generally speaking the machine can be simulated deterministically as a function from machine state to machine state - otherwise programs would not execute reliably. We can examine emulator projects such as QEMU or a formal ISA semantics to get a good idea of what each instruction does. Due to out-of-order execution the execution time of each instruction is nondeterministic; this is not modeled.</p>
</div></blockquote>
<p>Yes, there are projects and tools that focus on ensuring reproducible execution, particularly by controlling and managing different aspects of the execution process. Some of these projects include:</p>
<ol class="arabic simple">
<li><p><strong>rr (Record and Replay Debugger)</strong>: rr is a lightweight tool that enables the recording and deterministic replaying of execution traces of multi-threaded programs. It allows for the precise replication of program execution, helping in the identification and debugging of complex issues.</p></li>
<li><p><strong>Pernosco</strong>: Pernosco provides a cloud-based collaborative debugging platform that allows developers to record, replay, and analyze the execution of complex software systems. It enables teams to collaboratively investigate and debug issues in a reproducible manner.</p></li>
<li><p><strong>Pin Play</strong>: Pin Play is an extension of the Pin dynamic binary instrumentation framework that enables the record and replay of the execution of parallel programs. It allows for the deterministic reproduction of thread schedules and memory accesses, aiding in debugging and analysis.</p></li>
<li><p><strong>Deterministic Parallel Java (DPJ)</strong>: DPJ is a programming model and runtime system that emphasizes determinism in parallel and concurrent Java programs. It provides constructs and mechanisms for controlling the execution of parallel threads, ensuring predictable and reproducible outcomes.</p></li>
<li><p><strong>Chaos Engineering Tools</strong>: While not specifically focused on reproducibility, Chaos Engineering tools such as Chaos Monkey, developed by Netflix, and similar tools aim to test the resiliency of systems by inducing controlled failures. These tools can help uncover non-deterministic behaviors in distributed systems, leading to improved reliability and predictability.</p></li>
</ol>
<p>These projects contribute to ensuring reproducible execution by providing tools and mechanisms to control and manage the concurrent execution of threads, handle I/O operations, and manage random number generation, thereby enabling the deterministic and consistent behavior of programs across different runs and environments.</p>
</section>
<section id="store-state">
<h3>Store state<a class="headerlink" href="#store-state" title="Link to this heading"></a></h3>
<p>Most papers limit themselves to keeping the values of mutable variables in the store. But conceptually the state of a program could include the state of the computer, the stock market, quantum fluctuations, etc. - all information within the chronological past of a program. But practically we are limited to state that we can read and write deterministically. In particular the read operation must satisfy the associative array definition:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">read</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="n">write</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kt">D</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kt">D</span>
<span class="nf">read</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">emptyStore</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MissingValue</span>
</pre></div>
</div>
<p>So one constraint to be a variable is that the state must be accessible. So for example the kernel limits us - we do not have full control over peripheral devices or processes not related to ours. We can represent this by shadowing access-controlled variables and returning <code class="docutils literal notranslate"><span class="pre">WriteFailed</span></code> for inaccessible variables.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Objects.html" class="btn btn-neutral float-left" title="Objects" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Posets.html" class="btn btn-neutral float-right" title="Posets" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>