<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Objects &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Package manager" href="PackageManager.html" />
    <link rel="prev" title="Modules" href="Modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler-Library.html">Compiler library</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Intrinsics.html">Intrinsics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#definition">Definition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">Objects</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#no-autoboxing">No autoboxing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#no-object-identity">No object identity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#no-implicit-synchronization-lock">No implicit synchronization lock</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#more-chatgpt-definitions">More ChatGPT definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#encapsulation">Encapsulation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#no-constructors">No constructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#all-or-nothing-field-access">All-or-nothing field access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#inheritance">Inheritance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#multiple-inheritance">Multiple inheritance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#patterns-of-inheritance">Patterns of inheritance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inheritance-is-not-subtyping">Inheritance is not subtyping</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#virtual-methods">Virtual methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#multimethods">Multimethods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#minimal-oo">Minimal OO</a></li>
<li class="toctree-l4"><a class="reference internal" href="#beta">BETA</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fragile-base-classes-interfaces">Fragile base classes (Interfaces)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dissolving-interfaces-into-multimethods">Dissolving interfaces into multimethods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiple-implementations">Multiple implementations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#resources">Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#metrics">Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#methods">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#action">Action</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#caches">Caches</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard-Library.html">Standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Objects</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Objects.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="objects">
<h1>Objects<a class="headerlink" href="#objects" title="Permalink to this heading"></a></h1>
<p>Many people like to use the word “object”, as in “object-oriented programming”. Stroscot aims to support all the paradigms, so being able to claim that Stroscot is OOP would be a great feature. But our analysis is stymied before it begins: per the C2 wiki, <a class="reference external" href="https://wiki.c2.com/?NobodyAgreesOnWhatOoIs">nobody agrees on what OO is</a> and there are <a class="reference external" href="https://wiki.c2.com/?DefinitionsForOo">many definitions for OO</a>. For that reason the word “object” is not used in the rest of the documentation.</p>
<section id="definition">
<h2>Definition<a class="headerlink" href="#definition" title="Permalink to this heading"></a></h2>
<p>Fortunately, it is 2023, so we can use ChatGPT to cut the Gordian knot. It has analyzed many discussions of OOP and distilled the common themes. ChatGPT does not actually give a consistent definition either, but we can distill the common parts of 10 ChatGPT definitions:</p>
<ul class="simple">
<li><p>OOP uses objects to represent and manipulate data. An object contains properties and methods, which group related data and behavior.</p></li>
<li><p>The core principles of OOP are encapsulation, inheritance, and polymorphism.</p></li>
</ul>
<p>There are some other statements included in some definitions but not others. Since we want only what is agreed on, it is clear that these should be ignored, but I will also justify why they can be ignored:</p>
<ul class="simple">
<li><p>Objects are instances of classes (8/10) - prototypes instead of classes is a common twist on OO, e.g. as done in Self, and <span id="id1">[]</span> argues that prototype-based inheritance is simpler than class-based.</p></li>
<li><p>It is widely used / popular in software development (6/10) - this doesn’t really matter in an argument on whether Stroscot is OO.</p></li>
<li><p>Abstraction is a fourth core principle (4/10) - arguably this is included in the “use objects to represent and manipulate data” bullet point.</p></li>
</ul>
<p>Getting back to the definition, the second part is just the <a class="reference external" href="https://wiki.c2.com/?PolymorphismEncapsulationInheritance">PolymorphismEncapsulationInheritance</a> definition found on C2. We thus see that this is the “correct” definition. Notably, this definition is one of the few definitions on C2 not associated with a particular pundit, and it is listed second, pretty close to the top. It is similar to <a class="reference external" href="http://paulgraham.com/reesoo.html">Rees’s</a>  “conventional Simula 67-like pattern” of encapsulation, ad hoc polymorphism, inheritance = subtyping, and sum-of-product-of-function pattern, which he states “many people take as a definition of OO”. C2 does list caveats:</p>
<ul class="simple">
<li><p>It is C++ centric - ChatGPT vehemently disagrees with this, and says the principles also apply to Java, Python, and Ruby.</p></li>
<li><p>The words “encapsulation”, “inheritance”, “polymorphism” only express so much, and are ambiguous out of context. There is a large amount of convention and code constructs associated with expressing these principles. - Each ChatGPT definition devotes a sentence or two to each of these words expressing the intended meaning, so doing the same common theme distillation, there is much less ambiguity. And we can always follow up by asking ChatGPT what it means by these various words. In 4/10 definitions it thought encapsulation referred to the idea of bundling data and methods into a single entity. But it should be clear that this is the basic definition of “object”, rather than a principle of OOP. In 8/10 definitions, it said more reasonably that (2 definitions had both bundling and hiding) This hiding ensures that the object’s internal data can only be accessed through a public interface provided by the object, which can prevent unintended changes to an object’s state, and makes it easier to maintain and modify code over time.</p></li>
</ul>
</section>
<section id="id2">
<h2>Objects<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h2>
<p>For the first part of OO, we must define objects, and explain how they can contain properties and methods. For the most part I agree with <a class="reference external" href="https://wiki.c2.com/?ObjectsAreDictionaries">ObjectsAreDictionaries</a>, i.e. objects are a mapping from strings to values. But I want one fewer concept in the core language so I will instead define objects to be modules, in the ML sense: a module is a list of definitions, and these definitions collectively define a mapping from expressions to values. The expression evaluated in the context of an object/module will usually be an identifier, corresponding to a dictionary lookup, but this definition lets us define values for function calls and other bits of syntax as well, so we can write DSLs more easily.</p>
<p>We want to create and manipulate objects. So we have some operations on modules:</p>
<ul class="simple">
<li><p>literal syntax</p></li>
<li><p>evaluate an expression in the context of the module</p></li>
<li><p>inspect/replace/remove a definition</p></li>
<li><p>list all definitions</p></li>
<li><p>change module imports/exports</p></li>
</ul>
<p>Per some cursory reading, these include all the object creation and manipulation idioms of <a class="reference external" href="https://handbook.selflanguage.org/SelfHandbook2017.1.pdf">Self</a> and <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects">Javascript</a>.</p>
<section id="no-autoboxing">
<h3>No autoboxing<a class="headerlink" href="#no-autoboxing" title="Permalink to this heading"></a></h3>
<p>Stroscot does not subscribe to Smalltalk’s notion that “everything is an object”. Rather, in Stroscot, “everything is a value”, and booleans, integers, and objects (modules) are different types of values.  This is a little similar to Java’s notion of “primitive types”, but unlike Java, Stroscot does not make objects reference types - objects have value semantics, and are part of the universal type. Stroscot’s notion of object is more similar to the notion of “pure object” in <span id="id3">[]</span>, where an object is an immutable record of functions that themselves take and return immutable objects and primitive values. To express the Java notion of mutable object, you would use Stroscot’s mutable variables, in particular a Java object could be represented as a variable containing an object whose methods/functions took mutable variable references pointing to more objects.</p>
<p>Java and C# have implemented a feature called “autoboxing” where primitive types are automatically converted to “wrapped primitive” objects like Boolean or Integer. This allows using primitives in places where an object is required. But this is a leaky abstraction; autoboxing actually changes behavior. For example in Java <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Integer(0)</span> <span class="pre">!=</span> <span class="pre">new</span> <span class="pre">Integer(0)</span></code>, you have to do <code class="docutils literal notranslate"><span class="pre">Integer.valueOf(0)</span> <span class="pre">==</span> <span class="pre">Integer.valueOf(0)</span></code> or use <code class="docutils literal notranslate"><span class="pre">.equals</span></code>. In JS <code class="docutils literal notranslate"><span class="pre">false</span></code> is falsy but <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Boolean(false)</span></code> is truthy. Properly speaking, primitives are distinct from objects, in that they do not support key object operations such as looking up identifiers. Ultimately, discarding the “wrapping primitive” notion and simply representing primitive values directly is the most logical. Supporting a universal type that can contain both primitives and objects does complicate code generation, but it’s not that bad.</p>
</section>
<section id="no-object-identity">
<h3>No object identity<a class="headerlink" href="#no-object-identity" title="Permalink to this heading"></a></h3>
<p>In Java, objects have an identity. For example, <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Object()</span> <span class="pre">==</span> <span class="pre">new</span> <span class="pre">Object()</span></code> returns false because two different object references are constructed and their addresses are different. But when you try to do <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Object()</span> <span class="pre">&lt;</span>&#160; <span class="pre">new</span> <span class="pre">Object()</span></code> it’s disallowed because the address is an implementation detail. So just for consistency’s sake <code class="docutils literal notranslate"><span class="pre">==</span></code> shouldn’t work either - if the address is an implementation detail, then don’t expose anything about it! But apparently the desire for a fast pointer equality hack won out over the desire to avoid exposing implementation details of the language. As <span id="id4">[]</span> says, “primitive equality exposes representation and prevents simulation of one object by another.”</p>
<p>In Stroscot, objects are values, so they don’t have identity. Syntactically identical objects will always compare equal. However, mutable variables have identity - their value is the address, and allocating a new mutable variable creates a new address hence a new identity.. So in the emulation of Java objects as mutable variables containing objects, we can compare ref-to-object for address equality, and also dereference the refs and compare the object values. Hence the Java notion naturally decomposes into the combination of two concepts. Immutable objects work much better with the functional programming paradigm. Furthermore JSON cannot easily represent the notion of object identity, whereas object values are easily written.</p>
</section>
<section id="no-implicit-synchronization-lock">
<h3>No implicit synchronization lock<a class="headerlink" href="#no-implicit-synchronization-lock" title="Permalink to this heading"></a></h3>
<p>Another (mis)feature of Java is the ability to write <code class="docutils literal notranslate"><span class="pre">synchronize</span> <span class="pre">(random_object)</span></code> and use any object as a lock. This adds some bytes of header to every object allocation. It has been acknowledged by <a class="reference external" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html">the Java tutorial</a> that the ability to use any object was overly broad and it is better to use specific lock objects. <a class="reference external" href="https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/#_horror_circus_kinda_works_but_horrifying">This post</a> points out that you can synchronize on primitives (actually the corresponding autoboxed objects) and on strings. Although it works for small examples due to interning caches, it will fail if your program uses too many primitives/strings as locks. This sort of tomfoolery seems pretty stupid, and there is an easy fix: if you want a mutex you should have to create a value of the <code class="docutils literal notranslate"><span class="pre">Mutex</span></code> type.</p>
</section>
</section>
<section id="more-chatgpt-definitions">
<h2>More ChatGPT definitions<a class="headerlink" href="#more-chatgpt-definitions" title="Permalink to this heading"></a></h2>
<p>Polymorphism refers to the ability of objects to take on different forms, depending on the context in which they are used.
Polymorphism allows different objects to be used interchangeably, even if they have different implementations or behaviors, which can make code more flexible and extensible.
Polymorphism - allowing objects to take on different forms or behaviors depending on the context in which they are used.
Polymorphism allows objects to take on multiple forms, depending on their context.
polymorphism, which allows objects to be treated as instances of their parent classes, or as instances of their own specific class.
Polymorphism allows objects of different classes to be treated as if they were of the same class, by providing a common interface that can be used to interact with them.
Polymorphism allows objects of different classes to be used interchangeably, as long as they share a common interface.
polymorphism, which refers to the ability of objects to take on different forms or behaviors depending on the context in which they are used.
Polymorphism: the ability of an object to take on different forms, depending on the context in which it is used.
polymorphism allows objects to take on multiple forms and behave in different ways depending on the context in which they are used.</p>
<p>Abstraction - representing complex systems or processes through simpler, more generalized concepts.
Abstraction is the practice of defining interfaces without specifying implementation details, allowing for flexibility in how the interface is implemented.
Abstraction: the ability to represent complex real-world objects in simplified form, by focusing on the essential features and ignoring the non-essential details.
abstraction involves defining simplified interfaces for objects that hide their implementation details.</p>
</section>
<section id="encapsulation">
<h2>Encapsulation<a class="headerlink" href="#encapsulation" title="Permalink to this heading"></a></h2>
<p>According to 8/10 ChatGPT definitions, encapsulation refers to hiding the internal workings of an object from the outside world. The object’s data can only be accessed or modified through a well-defined interface. Typically this interface is defined by marking certain methods and fields as “public”, meaning they can be accessed by the outside world, while others are marked “private”, meaning they can only be accessed by the object itself.</p>
<p><span id="id5">[<a class="reference internal" href="../zzreferences.html#id150" title="Alan Snyder. Encapsulation and inheritance in object-oriented programming languages. ACM SIGPLAN Notices, 21(11):38–45, November 1986. URL: https://dl.acm.org/doi/10.1145/960112.28702 (visited on 2022-12-26), doi:10.1145/960112.28702.">Sny86</a>]</span> says this controlled interface serves as a contract between the object and its clients. So long as this contract is maintained, the object can be reimplemented without affecting any clients. To maximize the advantages of encapsulation, the contract should avoid including implementation details. For example, it should be possible to rename instance variables without affecting clients. Encapsulation provides a way to protect an object’s integrity, ensuring a consistent and valid internal state. Encapsulation promotes modular software evolution and maintenance.</p>
<p><span id="id6">[]</span> argues that encapsulation is really a property of
ML modules, because only ML modules provide sophisticated sharing mechanisms that allow multiple implementations and uses of multiple abstractions to coexist. ML of course allow the basic hiding feature, by not exporting the representation of a type. Unlike Smalltalk, which disallows <code class="docutils literal notranslate"><span class="pre">this.foo</span> <span class="pre">==</span> <span class="pre">b.foo</span></code> even if <code class="docutils literal notranslate"><span class="pre">b</span></code> is an instance of the current class, ML modules allow inspecting the representation of more than one value at the same time. ML modules also allow defining multiple abstract data types in the same module, so that a complex internal representation may be defined and manipulated without recourse to C++’s “friend” qualifier. The only feature missing from ML modules is mixing values of two different implementations - this is solved in Stroscot by allowing functions to use duck typing, so that two values may be mixed if they both conform to the proper interface. Since Stroscot defines objects to be ML modules, all the benefits of encapsulation are provided.</p>
<p>Cook goes on to state that “any programming model that allows inspection of the representation of more than one abstraction at a time is not object-oriented.” So by his definition C++ and Java are not object-oriented - bleh. In fact this is just a limitation of ML - ML cannot inspect/pattern match on functions; they are opaque. In Stroscot, it is possible to match on the lambdas in Cook’s Figure 8 and determine if an ISet was constructed via the Empty, Insert, or Union implementations. We might as well have written <code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">ISet</span> <span class="pre">=</span> <span class="pre">Empty</span> <span class="pre">|</span> <span class="pre">Insert</span> <span class="pre">int</span> <span class="pre">ISet</span> <span class="pre">|</span> <span class="pre">Union</span> <span class="pre">ISet</span> <span class="pre">ISet</span></code> as in the ADT implementation, except that the lambda presentation is an open data type that allows adding more cases. In Stroscot, we use multimethods to solve the expression problem, so it is just defining symbols and adding more dispatch cases to the relevant multimethods.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>interface ISet = {
  isEmpty : bool,
  contains : int → bool,
  insert : int → ISet,
  union : ISet → ISet
}
</pre></div>
</div>
<p>Stroscot has modules, which provide encapsulation. We can create a type and not export its constructor symbols, so that the type becomes an abstract data type: only functions defined in the module can access the concrete representation of the type, and functions outside the module can only use the public interface. This indeed allows renaming fields of the data type without affecting external clients.</p>
<section id="no-constructors">
<h3>No constructors<a class="headerlink" href="#no-constructors" title="Permalink to this heading"></a></h3>
<p>A Java constructor has many limitations compared to a factory function: it must allocate new memory, it cannot return a subclass, and it has to be called with a noisy “new” syntax and a fixed name.</p>
<p>For example, consider a boxed primitive boolean. It only needs two values: a factory function can construct one true and one false and then return those from then on. But using a constructor forces the program to produce millions of distinct trues and falses, creating significant overhead.</p>
<p>Another difference is that a factory function computes the field values first and then can use an allocate-and-initialize primitive. The primitive can ensure that its allocation is private, hence appears atomic for concurrency. In contrast a constructor allocates memory initialized to a default value and then overwrites each field. This implicit memory writing means that concurrency and constructors interact poorly because you can access partially-constructed objects. <a class="reference external" href="https://counterexamples.org/under-construction.html">This page</a> describes several bugs in real-world systems.</p>
<p>Deserialization bypasses defined constructors and directly creates objects via the runtime - it is an implicit public constructor. In fact this deserialization constructor is exactly the allocate-and-initialize primitive that a factory function needs.</p>
<p>One use of constructors is to enforce invariants (validity checking); for example a time constructor that ensures <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">minutes</span> <span class="pre">&lt;</span> <span class="pre">60</span></code>. In Stroscot, invariants like these are defined in types, and checked on use, rather than on construction. It is often very helpful to be able to talk about about an object whose fields are unnormalized, which the constructor pattern prevents. And when you need the invariants, the types establish object integrity. Whereas in Java you must reason about all mutating methods to identify the possible states of an object, in Stroscot only the type needs to be examined.</p>
<p>A minor downside of doing away with constructors is that factory functions are not automatically marked in the documentation, so can be harder to find. Organizing the source code and documentation to group factory methods is not hard, the hard part is enforcing that such a convention is followed consistently. But it’s not even clear that grouping factory functions together is the best organization.</p>
</section>
<section id="all-or-nothing-field-access">
<h3>All-or-nothing field access<a class="headerlink" href="#all-or-nothing-field-access" title="Permalink to this heading"></a></h3>
<p>Inheritance should respect encapsulation, so that inheriting classes do not get any more access. Thus we see that Java’s protected keyword is a hack. Allowing non-public instance variables to be accessed by subclasses breaks encapsulation. Instance variables should either be public and accessible to everyone, or private and not accessible to anything outside a module.</p>
<p>In Stroscot, if you can access the term’s constructor symbol, you have full data access to all fields and can destruct and create values with that constructor. But, you can avoid exporting a constructor symbol from a module - that means a user will have to use the defined factory functions and accessors, or else deliberately import the <code class="docutils literal notranslate"><span class="pre">._internal</span></code> module.</p>
</section>
</section>
<section id="inheritance">
<h2>Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this heading"></a></h2>
<p>Inheritance allows objects to inherit properties and methods from a parent class, making it possible to create specialized subclasses with additional functionality.
Inheritance allows objects to inherit properties and behaviors from other objects, which can be useful for creating related objects with similar functionality.
Inheritance - allowing classes to inherit properties and methods from other classes, forming a hierarchy of related objects.
inheritance allows classes to inherit properties and methods from other classes.
inheritance, which allows classes to inherit properties and methods from other classes
Inheritance allows new objects to be based on existing objects, inheriting their attributes and behaviors.
Inheritance is the ability of a class to inherit properties and behaviors from a parent class.
Classes can inherit properties and behaviors from parent classes, allowing for code reuse and the creation of hierarchies of objects. Inheritance allows classes to inherit properties and behaviors from parent classes
Inheritance: the ability of one class to inherit properties and methods from another class.
Inheritance allows classes to derive attributes and behaviors from parent classes</p>
<p>Inheritance originated from Simula where per <span id="id7">[<a class="reference internal" href="../zzreferences.html#id120" title="Kristen Nygaard and Ole-Johan Dahl. The development of the SIMULA languages. In History of Programming Languages, pages 439–480. Association for Computing Machinery, New York, NY, USA, June 1978. URL: https://doi.org/10.1145/800025.1198392 (visited on 2022-12-20).">ND78</a>]</span> they were trying to model a toll booth on a bridge, with a queue of cars which were either trucks or buses. The queue was modeled with a “circular list” structure, consisting of a “set head” and a variable number of “links”, each with a predecessor and successor reference. The trucks and buses are modeled as collections of static properties according to a schema. Inheritance thus appeared as a “concatenation” or “prefixing” mechanism for “gluing” each of the various vehicles (trucks, buses) together with a “link” for an intrusive list to make one record instance. As <a class="reference external" href="https://catern.com/inheritance.html">this post</a> argues, inheritance was invented as a performance hack.</p>
<p>We can implement the basic “concatenation” pattern in Stroscot as a library, <a class="reference external" href="https://github.com/Mathnerd314/stroscot/blob/master/library/inheritance.txt">here</a>. It doesn’t seem to require any weird tricks besides polymorphism, so it could easily be in the standard library somewhere. I chose <code class="docutils literal notranslate"><span class="pre">+</span></code> to represent the inheritance operator that plays a key role. Per Simula lookup is asymmetric (right-biased); for example <code class="docutils literal notranslate"><span class="pre">Record</span> <span class="pre">{</span> <span class="pre">a</span> <span class="pre">:</span> <span class="pre">integer</span> <span class="pre">}</span> <span class="pre">+</span> <span class="pre">Record</span> <span class="pre">{</span> <span class="pre">a</span> <span class="pre">:</span> <span class="pre">real</span> <span class="pre">}</span></code> gives something like <code class="docutils literal notranslate"><span class="pre">Record</span> <span class="pre">{</span> <span class="pre">shadowed_a</span> <span class="pre">:</span> <span class="pre">integer,</span> <span class="pre">a</span> <span class="pre">:</span> <span class="pre">real</span> <span class="pre">}</span></code>, renaming the field on the left when it collides with the right. So we have a lookup operator for that. We also have a more specialized “qualified lookup” operator for accessing shadowed prefix attributes. There are other choices for how to deal with duplicate field names, e.g. removing the superclass field. But shadowing allows us to always lift operations on <code class="docutils literal notranslate"><span class="pre">A</span></code> or <code class="docutils literal notranslate"><span class="pre">B</span></code> to <code class="docutils literal notranslate"><span class="pre">A+B</span></code>. We will want to use these lifting operations to be able to apply <code class="docutils literal notranslate"><span class="pre">in</span></code> on <code class="docutils literal notranslate"><span class="pre">truck_link</span></code>, for example.</p>
<p><span id="id8">[<a class="reference internal" href="../zzreferences.html#id158" title="Antero Taivalsaari. On the notion of inheritance. ACM Computing Surveys, 28(3):438–479, September 1996. URL: https://doi.org/10.1145/243439.243441 (visited on 2022-12-14), doi:10.1145/243439.243441.">Tai96</a>]</span> also mentions “defeating” or “cancelling” a property. This involves the subclass containing a “whiteout” entry so that looking up that property returns a not found exception rather than a value. It really is an extension of the lookup algorithm and doesn’t affect much of the design.</p>
<section id="multiple-inheritance">
<h3>Multiple inheritance<a class="headerlink" href="#multiple-inheritance" title="Permalink to this heading"></a></h3>
<p>Multiple inheritance makes things more complicated. There is diamond inheritance: if D extends B and C, and B and C each extend A, then are there two copies of the fields of A, or only one copy? Most languages with MI pick one or the other, but C++ seems to be unique in allowing each superclass to be declared either non-virtual or virtual. Each virtual superclass appears only once in the composite object, while non-virtual superclasses appear once for each non-virtual path. This means that the hierarchy is no longer simple aggregation but also has a dictionary mapping from virtual class names to virtual class pieces.</p>
<p>There is no convenient “subclass takes precedence” rule when properties conflict between superclasses, so we must accept that such cases are ambiguous errors, and rely more often on specialized lookup syntaxes that makes clear which part of the composite object we are referring to. For example C++ uses syntax like <code class="docutils literal notranslate"><span class="pre">p-&gt;A::next</span></code> or <code class="docutils literal notranslate"><span class="pre">((A)</span> <span class="pre">p)-&gt;next</span></code>, as well as class casts, to allow access to ambiguous properties.</p>
<p>Non-virtual inheritance makes specifying properties even more complicated because we have to specify the full path of the superclass and not just its name. C++ forbids direct duplication of base classes like <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">extends</span> <span class="pre">(B,</span> <span class="pre">B)</span></code>, so can always specify a path unambiguously using class names - basically, instead of directly duplicating <code class="docutils literal notranslate"><span class="pre">B</span></code>, you do <code class="docutils literal notranslate"><span class="pre">B1</span> <span class="pre">extends</span> <span class="pre">B,</span> <span class="pre">B2</span> <span class="pre">extends</span> <span class="pre">B,</span> <span class="pre">A</span> <span class="pre">extends</span> <span class="pre">(B1,</span> <span class="pre">B2)</span></code>, and then <code class="docutils literal notranslate"><span class="pre">B1,B2</span></code> are unique and can specify a path. For now I’ll ignore this detail and specify paths by number.</p>
</section>
<section id="patterns-of-inheritance">
<h3>Patterns of inheritance<a class="headerlink" href="#patterns-of-inheritance" title="Permalink to this heading"></a></h3>
<p>Having defined inheritance, and implemented it as a library, we are still not finished with inheritance in Stroscot. We must also examine the common patterns of inheritance to see if there are any other libraries hiding in the dark. If we had a definitive study showing “Inheritance makes systems more complex and bug-ridden and thus unmaintainable” then we could stop on the grounds of inheritance being a footgun. Certainly there are suggestive blog posts like “Inheritance is evil and must be destroyed” (<a class="reference external" href="https://blog.berniesumption.com/software/inheritance-is-evil-and-must-be-destroyed/index.html">1</a>). But <span id="id9">[<a class="reference internal" href="../zzreferences.html#id53" title="K. El Emam, S. Benlarbi, N. Goel, and S.N. Rai. The confounding effect of class size on the validity of object-oriented metrics. IEEE Transactions on Software Engineering, 27(7):630–650, July 2001. URL: http://ieeexplore.ieee.org/document/935855/ (visited on 2023-02-24), doi:10.1109/32.935855.">EEBGR01</a>]</span> lists several cases where a promising study found that inheritance caused difficulties, but follow up studies/replications have found the opposite conclusion. And their subsequent regression model invalidates all of the tested inheritance metrics (DIT, NOC, NMO, NMA, SIX) as having no statistical relationship after controlling for lines of code. It is still possible that inheritance may make programs more difficult to understand, but nobody has created a metric and done a study with enough statistical power to confirm or deny that conclusion definitively. TODO: Maybe Jan Vitek (co-author of some large scale Github studies) would be interested.</p>
<p><span id="id10">[<a class="reference internal" href="../zzreferences.html#id159" title="Ewan Tempero, Hong Yul Yang, and James Noble. What Programmers Do with Inheritance in Java. In David Hutchison, Takeo Kanade, Josef Kittler, Jon M. Kleinberg, Friedemann Mattern, John C. Mitchell, Moni Naor, Oscar Nierstrasz, C. Pandu Rangan, Bernhard Steffen, Madhu Sudan, Demetri Terzopoulos, Doug Tygar, Moshe Y. Vardi, Gerhard Weikum, and Giuseppe Castagna, editors, ECOOP 2013 – Object-Oriented Programming, volume 7920, pages 577–601. Springer Berlin Heidelberg, Berlin, Heidelberg, 2013. URL: http://link.springer.com/10.1007/978-3-642-39038-8_24 (visited on 2022-08-31), doi:10.1007/978-3-642-39038-8_24.">TYN13</a>]</span> found that in Java, on average, 3 out of 4 types were defined using some form of inheritance, and that &gt;99% of inheritance in Java can be classified as subtyping or reuse. Specifically (S a subclass of T):</p>
<ul>
<li><p>Subtyping is where an object of type S is supplied where an object of type T is expected. This can be done by assigning an object of type S to a variable declared to be type T, passing an actual parameter of type S to a formal parameter of type T, returning an object of type S when the formal return type is T, or casting an expression of type S to type T. 76% (range 11% - 100%) of class-class relationships had a subtype usage somewhere in the code. Meyer describes several patterns of subtyping inheritance (assuming B inherits from A):</p>
<ul class="simple">
<li><p>Subtype inheritance - A is partitioned into several disjoint subsets B1, B2, B3.</p></li>
<li><p>Restriction inheritance - B is the subset of A that satisfies a certain constraint, enforced by the constructor and public interface of B. New features should directly follow from the added constraint.</p></li>
<li><p>Reification inheritance - subtype inheritance but specialized to data structures</p></li>
<li><p>Structure inheritance - restriction inheritance but specialized to structures</p></li>
<li><p>View inheritance - A is split into several types B1, B2 where each subtype represents a way of viewing a certain value space. For example 2d_Coordinates is split into Cartesian_Coordinates and Polar_Coordinates, or List is split into ArrayList and LinkedList.</p></li>
</ul>
<p>Stroscot’s expressive type system allows expressing all of these patterns directly, without using inheritance. And the <code class="docutils literal notranslate"><span class="pre">or_subclass</span></code> predicate allows expressing the subtyping inherent to inheritance.</p>
</li>
<li><p>Reuse is when a method not in T, either in S (internal) or not in S (external), invokes a method m() or accesses a field f on an object constructed from type S, and m() or f is declared in T. 22% (4%-88%) of CC edges were external reuse and did not have a subtype usage, while 2% (0.5% - 30%) of CC edges had internal reuse but no subtype use or external reuse. So together these accounted for 24% of edges. Meyer describes a few patterns that seem to fall into this category:</p>
<ul class="simple">
<li><p>Extension inheritance - B introduces attributes not present in A and features not applicable to direct instances of A. This changes the set of values. Myers tries to argue that open records give a subtyping relation, but this is flawed because a self type can appear in both covariant and contravariant positions, so in general B is neither a subtype nor supertype of A.</p></li>
<li><p>Variation inheritance, uneffecting inheritance - B redefines some features of A and does not introduce new attributes or features.</p></li>
<li><p>Implementation inheritance - we want to write a new version of the class with most of the methods shared, but not actually duplicate the file</p></li>
</ul>
<p>These forms of inheritance seem suited for the inheritance library described before. Java-style inheritance actually seems less useful because it imposes a rigid class structure on reuse. And also, since these patterns are reuse, we could implement them without inheritance, by calling the method directly.</p>
</li>
</ul>
<p><span id="id11">[<a class="reference internal" href="../zzreferences.html#id159" title="Ewan Tempero, Hong Yul Yang, and James Noble. What Programmers Do with Inheritance in Java. In David Hutchison, Takeo Kanade, Josef Kittler, Jon M. Kleinberg, Friedemann Mattern, John C. Mitchell, Moni Naor, Oscar Nierstrasz, C. Pandu Rangan, Bernhard Steffen, Madhu Sudan, Demetri Terzopoulos, Doug Tygar, Moshe Y. Vardi, Gerhard Weikum, and Giuseppe Castagna, editors, ECOOP 2013 – Object-Oriented Programming, volume 7920, pages 577–601. Springer Berlin Heidelberg, Berlin, Heidelberg, 2013. URL: http://link.springer.com/10.1007/978-3-642-39038-8_24 (visited on 2022-08-31), doi:10.1007/978-3-642-39038-8_24.">TYN13</a>]</span> also did some analysis on the remaining &lt;0.1% of other relationships. The “constants class” was where a class or interface of only static final constants was inherited from to gain access to the constants. Meyers calls this “facility inheritance”. This accounted for 1% of CC edges in some systems but most had no constant classes. A wildcard import seems a lot more straightforward. One system used a lot of “super” calls in the constructor, but for no discernible reason. Probably not worth emulating. Some “framework” relationships used third party types and could not be analyzed fully due to lack of source code. “Generic” containers cast to Object and back so impeded subtyping analysis - again Stroscot’s type system seems sufficient here. And still other inheritance relationships were just there and no amount of inspection by the authors could discern a useful purpose.</p>
</section>
<section id="inheritance-is-not-subtyping">
<h3>Inheritance is not subtyping<a class="headerlink" href="#inheritance-is-not-subtyping" title="Permalink to this heading"></a></h3>
<p>This is the title of <span id="id12">[<a class="reference internal" href="../zzreferences.html#id34" title="William R. Cook, Walter Hill, and Peter S. Canning. Inheritance is not subtyping. In Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL '90, 125–135. New York, NY, USA, December 1989. Association for Computing Machinery. URL: https://doi.org/10.1145/96709.96721 (visited on 2022-12-15), doi:10.1145/96709.96721.">CHC89</a>]</span>, and their argument seems correct. The existence of <code class="docutils literal notranslate"><span class="pre">Lens</span> <span class="pre">(a+b)</span> <span class="pre">(a'+b)</span> <span class="pre">a</span> <span class="pre">a'</span></code> does not imply a subtype relation - <code class="docutils literal notranslate"><span class="pre">A</span></code> is not a subtype or supertype of <code class="docutils literal notranslate"><span class="pre">A+B</span></code>. Rather <code class="docutils literal notranslate"><span class="pre">A</span></code> is related to <code class="docutils literal notranslate"><span class="pre">A+B</span></code> by a separate “is subcomponent of” relation, as formalized in the Lens type. For example, in <span id="id13">[<a class="reference internal" href="../zzreferences.html#id34" title="William R. Cook, Walter Hill, and Peter S. Canning. Inheritance is not subtyping. In Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL '90, 125–135. New York, NY, USA, December 1989. Association for Computing Machinery. URL: https://doi.org/10.1145/96709.96721 (visited on 2022-12-15), doi:10.1145/96709.96721.">CHC89</a>]</span> section 3.2 page 129 we have a parent constructor <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">self</span> <span class="pre">super</span> <span class="pre">thislvl</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">5,</span> <span class="pre">id</span> <span class="pre">=</span> <span class="pre">self,</span> <span class="pre">eq</span> <span class="pre">=</span> <span class="pre">\o</span> <span class="pre">-&gt;</span> <span class="pre">self.i</span> <span class="pre">==</span> <span class="pre">o.i</span> <span class="pre">}</span></code> and a child constructor <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">self</span> <span class="pre">_</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">true,</span> <span class="pre">eq</span>&#160; <span class="pre">=</span> <span class="pre">\o</span> <span class="pre">-&gt;</span> <span class="pre">o.i</span> <span class="pre">==</span> <span class="pre">self.i</span> <span class="pre">&amp;&amp;</span> <span class="pre">o.b</span> <span class="pre">==</span> <span class="pre">self.b</span> <span class="pre">}</span></code>. We can work out some types: <code class="docutils literal notranslate"><span class="pre">mkObject</span> <span class="pre">[P]</span> <span class="pre">:</span> <span class="pre">mu</span> <span class="pre">self.</span> <span class="pre">{</span> <span class="pre">i</span> <span class="pre">:</span> <span class="pre">int,</span> <span class="pre">id</span> <span class="pre">:</span> <span class="pre">self,</span> <span class="pre">eq</span> <span class="pre">:</span> <span class="pre">{i</span> <span class="pre">:</span> <span class="pre">int}_open</span> <span class="pre">-&gt;</span> <span class="pre">bool</span> <span class="pre">}</span></code> and <code class="docutils literal notranslate"><span class="pre">mkObject</span> <span class="pre">[C,P]</span> <span class="pre">:</span> <span class="pre">mu</span> <span class="pre">self.</span> <span class="pre">{</span> <span class="pre">i</span> <span class="pre">:</span> <span class="pre">int,</span> <span class="pre">id</span> <span class="pre">:</span> <span class="pre">self,</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">bool,</span> <span class="pre">eq</span> <span class="pre">:</span> <span class="pre">{i</span> <span class="pre">:</span> <span class="pre">int,</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">}_open</span> <span class="pre">-&gt;</span> <span class="pre">bool</span> <span class="pre">}</span></code>. The second has more fields than the first, so with closed records they are unrelated types. We might think (as Meyers does) that with open record types we could say that the second (child) type is a subtype of the first. But looking at <code class="docutils literal notranslate"><span class="pre">eq</span></code>, since <code class="docutils literal notranslate"><span class="pre">{i</span> <span class="pre">:</span> <span class="pre">int,</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">}_open</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">{i</span> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">}_open</span></code>, by contravariance the first <code class="docutils literal notranslate"><span class="pre">eq</span></code> type is actually a subtype of the second. So even relaxing our record subtyping definition these are unrelated types.</p>
<p>More generally, all combinations of subtyping and inheritance are possible:</p>
<ul class="simple">
<li><p>S is neither a subtype nor a child type of T - independent types, Boolean and Float</p></li>
<li><p>S is a subtype but is not a child type of T - Int32 and Int64, subset but unrelated by inheritance</p></li>
<li><p>S is not a subtype but is a child type of T - S child of T, S -&gt; S is not a subtype of T -&gt; T</p></li>
<li><p>S is both a subtype and a child type of  - when all inherited fields and methods of the derived type have types which are subtypes of the corresponding fields and methods from the inherited type, and the type is an “open record”</p></li>
</ul>
<p>Note that subtype + derived type is only possible with open records - with closed records no derived type is a proper subtype. <span id="id14">[<a class="reference internal" href="../zzreferences.html#id2" title="Moez AbdelGawad and Robert Cartwright. NOOP: A Domain-Theoretic Model of Nominally-Typed OOP. January 2018. Comment: 23 pages. URL: http://arxiv.org/abs/1801.06793 (visited on 2022-12-27), arXiv:1801.06793.">AC18</a>]</span> formalizes this notion and shows that in Java and other nominally-typed OOP languages, “inheritance is subtyping”. More specifically, “a class B is a subtype
of a class A iff B inherits from A.” But this property is obtained by placing restrictions on inheritance - in Java, a method only overrides its parent method if its type matches the parent method, and methods cannot be removed. <span id="id15">[<a class="reference internal" href="../zzreferences.html#id158" title="Antero Taivalsaari. On the notion of inheritance. ACM Computing Surveys, 28(3):438–479, September 1996. URL: https://doi.org/10.1145/243439.243441 (visited on 2022-12-14), doi:10.1145/243439.243441.">Tai96</a>]</span> calls this “strict inheritance”. Strict inheritance is a pretty weird semantics from a unityped perspective - for example in Smalltalk we can override a field and change its value from an int to a string. So this “inheritance is subtyping” property is a form of type discipline, rather than a free property.</p>
<p>Inheritance-as-subtyping is easy to misuse and the Java platform libraries made numerous mistakes: Stack extends Vector, Properties extends Hashtable - in both cases, not using inheritance and thus avoiding the accompanying subtyping constraint would have been preferable. For example, with Properties (<a class="reference external" href="https://codeblog.jonskeet.uk/2006/03/04/inheritancetax/">1</a>), <code class="docutils literal notranslate"><span class="pre">(Properties)</span> <span class="pre">p.getProperty(key)</span></code> takes defaults into account, while <code class="docutils literal notranslate"><span class="pre">p.get(key)</span></code> which is inherited from Hashtable does not, and direct access to the underlying Hashtable allows adding non-String objects, when the designers intended that Properties should only be Strings. Once this invariant is violated, it is no longer possible to use other parts of the Properties API (load and store). Without inheritance-as-subtyping, <code class="docutils literal notranslate"><span class="pre">get</span></code> could have been overridden to be a subtype, and the other Hashtable methods deleted.</p>
<p>Inheritance as subtyping breaks encapsulation, because superclass methods that expect to receive themselves may receive a subclass instance that doesn’t support an expected contract. In particular, a call to self.b in A.a may resolve to an inherited implementation B.b, and this B.b may violate a contract that A.b satisfies. Even adding a method in the subclass can be unsafe, because the superclass can later add the same method and then you are unintentionally overriding it. For this reason languages have added the override annotation so that unintentional overriding generates a warning.</p>
<p>When separating inheritance from type classification, one question is how many different language mechanisms are needed. Meyers says that 10 would be needed and implies this is too many, but his list of types of inheritance is duplicative, so he overestimates it. Also, even 10 is not that many, e.g. C has 10 control structures - ternary operator, if, if-else, while, do-while, for, switch, break, continue, and goto. It probably is true that deciding between <code class="docutils literal notranslate"><span class="pre">for</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span></code> wastes some time as Meyer says, but nobody has argued for removing <code class="docutils literal notranslate"><span class="pre">for</span></code> or <code class="docutils literal notranslate"><span class="pre">while</span></code> - although the constructs overlap, they are used in different situations and help to express the intent of the programmer, enhancing readability. Structured programming argues that one should have various loop constructs, even though goto can express any loop. Similarly, even if inheritance can express all the patterns of interest, it is still better to have separate syntax for each pattern of inheritance. Meyer says he has seen no compelling argument, but papers like “Inheritance is not subtyping” seem pretty compelling to me.</p>
<p>After separating inheritance from subtyping, what does it mean to have an abstract method in an interface, <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">:</span> <span class="pre">T1</span></code>? Declaring <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">foo</span> <span class="pre">:</span> <span class="pre">T1</span> <span class="pre">}</span> <span class="pre">+</span> <span class="pre">{</span> <span class="pre">foo</span> <span class="pre">:</span> <span class="pre">...</span> <span class="pre">}</span></code> is meaningless (assuming we never use <code class="docutils literal notranslate"><span class="pre">super.foo</span></code>) because only the type of <code class="docutils literal notranslate"><span class="pre">foo</span></code> on the right matters. So we see that the declaration is an assertion about the result of lookup, that <code class="docutils literal notranslate"><span class="pre">lookup</span> <span class="pre">foo</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">T1</span></code>. Then an interface of abstract methods is the intersection of these types, <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">x</span> <span class="pre">|</span> <span class="pre">foo</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">T1</span> <span class="pre">}</span> <span class="pre">intersect</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">|</span> <span class="pre">bar</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">T2</span> <span class="pre">}</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">|</span> <span class="pre">(foo</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">T1)</span> <span class="pre">&amp;&amp;</span> <span class="pre">(bar</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">T2)</span> <span class="pre">}</span></code>.</p>
</section>
</section>
<section id="virtual-methods">
<h2>Virtual methods<a class="headerlink" href="#virtual-methods" title="Permalink to this heading"></a></h2>
<p>The other part of Simula’s subclass mechanism was the concept of virtual attributes. For example in <span id="id16">[<a class="reference internal" href="../zzreferences.html#id39" title="Ole-Johan Dahl, Bjørn Myhrhaug, and Kristen Nygaard. Common Base Language. October 1970. URL: https://www.ics.uci.edu/~jajones/INF102-S18/readings/10_Simula.pdf (visited on 2022-12-20).">DMN70</a>]</span> page 25 they present two hashing functions for strings: the base class does a standard hash, while the subclass skips underscore characters. The hash function is a “replaceable part” that allows access to subclass behavior from superclasses. This complicates the semantics of inheritance quite a bit, because now the superclass takes a reference to the subclass, and constructing the object requires tying up a recursive knot. Simula’s semantics are somewhat restrictive so I instead chose to copy Nixpkgs’s <code class="docutils literal notranslate"><span class="pre">extends</span></code> function, which overrides methods in a manner similar to Smalltalk’s inheritance model. In my library there is a function <code class="docutils literal notranslate"><span class="pre">mkObject</span></code> to capture the usage pattern of <code class="docutils literal notranslate"><span class="pre">extends</span></code> in Nixpkgs. Each “constructor” function in the list passed to <code class="docutils literal notranslate"><span class="pre">mkObject</span></code> takes three arguments, <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">super</span></code>, and <code class="docutils literal notranslate"><span class="pre">thislvl</span></code>, and returns an attribute set.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> is the final resulting attribute set / object. It may refer to itself recursively but conceptually all of this recursion is unrolled. This allows late/virtual binding to an overridden method in the subclass.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">super</span></code> is the unmodified attribute set returned from the parent constructor function. This allows statically binding to the parent.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">thislvl</span></code> represents the return value of the current constructor. This allows statically binding to the current level. This argument is not present in Nixpkgs, but can be modeled by using <code class="docutils literal notranslate"><span class="pre">rec</span> <span class="pre">{</span> <span class="pre">}</span></code> for the attribute set.</p></li>
</ul>
<p>With these three parameters we can choose for each self-call how it is bound, and arbitrarily mix binding levels. It is thus the most expressive. In Ecstasy in contrast, access is restricted so only the parent method can be called.</p>
<p><code class="docutils literal notranslate"><span class="pre">mkObject</span></code> implements what might be termed “value-level” inheritance. We don’t have any types, just agglomerations of records. Specifying the type of <code class="docutils literal notranslate"><span class="pre">mkObject</span></code> is tricky. Since the subclass fields can vary, the type of the subclass reference <code class="docutils literal notranslate"><span class="pre">self</span></code> also varies, hence specifying the type of <code class="docutils literal notranslate"><span class="pre">mkObject</span></code> requires dependent types and heterogenous lists.</p>
<section id="multimethods">
<h3>Multimethods<a class="headerlink" href="#multimethods" title="Permalink to this heading"></a></h3>
<p>We can also implement virtual methods via Stroscot’s multimethods, assigning everything the same priority to use the specificity mechanism to implement overriding, and using module definition recursion to do the knot tying. This separates data from behavior which is a more functional style. Careful use of single arguments and lambdas allow mimicking single dispatch, matching Smalltalk’s virtual method semantics. Smalltalk also allows accessing the parent method like <code class="docutils literal notranslate"><span class="pre">super.method1</span></code>; in Stroscot this rather is done with <code class="docutils literal notranslate"><span class="pre">next_method</span></code> when in <code class="docutils literal notranslate"><span class="pre">C.method1</span></code>. Outside <code class="docutils literal notranslate"><span class="pre">C.method1</span></code>, we can call <code class="docutils literal notranslate"><span class="pre">P.method1</span></code> with something like <code class="docutils literal notranslate"><span class="pre">(lookup_clause</span> <span class="pre">method1</span> <span class="pre">(self</span> <span class="pre">:</span> <span class="pre">C</span> <span class="pre">or_subclass)).next_method</span></code>; we have to use this convoluted mechanism if we want to mimic calling <code class="docutils literal notranslate"><span class="pre">super.method2</span></code>. So similar to Ecstasy, we have a restricted <code class="docutils literal notranslate"><span class="pre">super</span></code> call for the most part. Similarly doing <code class="docutils literal notranslate"><span class="pre">(lookup_clause</span> <span class="pre">method1</span> <span class="pre">(self</span> <span class="pre">:</span> <span class="pre">C</span> <span class="pre">or_subclass))</span></code> without the <code class="docutils literal notranslate"><span class="pre">next_method</span></code>, we can access <code class="docutils literal notranslate"><span class="pre">thislvl</span></code>. Again it is more convoluted than a keyword, although a macro could fix this.</p>
<p>If we code the arguments naturally using multiple dispatch then of course we get multiple dispatch. E.g. I implemented equality on ColorPoints and Points, the only non-degenerate one per <a class="reference external" href="https://www.artima.com/articles/how-to-write-an-equality-method-in-java">Artima</a>. I would argue that the multimethods are a clear win here over Artima’s implementation as we can just write the clauses - the <code class="docutils literal notranslate"><span class="pre">instanceof</span></code> is implicit in the specificity matching, and there is no separate <code class="docutils literal notranslate"><span class="pre">canEqual</span></code> method. And if we removed <code class="docutils literal notranslate"><span class="pre">or_subclass</span></code> then we would not be overriding at all and the <code class="docutils literal notranslate"><span class="pre">false</span></code> clauses and priority equalization would not be needed - Points and ColorPoints would simply be treated as disjoint types and comparison between them would not be defined.</p>
<p>The biggest issue with multimethods is per <span id="id17">[<a class="reference internal" href="../zzreferences.html#id158" title="Antero Taivalsaari. On the notion of inheritance. ACM Computing Surveys, 28(3):438–479, September 1996. URL: https://doi.org/10.1145/243439.243441 (visited on 2022-12-14), doi:10.1145/243439.243441.">Tai96</a>]</span> pg. 473 they “do not feel object-oriented”. Because the operations are not logically “contained” in the object, but rather live in a separate “method dispatch” namespace, e.g. using the traditional function syntax <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span></code> rather than the infix <code class="docutils literal notranslate"><span class="pre">a.f(b)</span></code>, there is no clear boundary for the internal vs. external methods of an object. We can define such a boundary using module encapsulation, but it is not as tidy as the methods-fields package offered by traditional OO.</p>
</section>
<section id="minimal-oo">
<h3>Minimal OO<a class="headerlink" href="#minimal-oo" title="Permalink to this heading"></a></h3>
<p>Uncle Bob <a class="reference external" href="https://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html">defines</a> OO by distinguishing <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">o</span></code> from <code class="docutils literal notranslate"><span class="pre">o.f()</span></code>. With Uniform Function Call Syntax there is no difference. But, he argues, in an OO language <code class="docutils literal notranslate"><span class="pre">o.f()</span></code> is overloaded - it does dynamic dispatch based on the type of <code class="docutils literal notranslate"><span class="pre">o</span></code>. Whereas with <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">o</span></code> there is usually only one group of clauses for <code class="docutils literal notranslate"><span class="pre">f</span></code>. Bob also wants to exclude implementations of dynamic dispatch that work by modifying <code class="docutils literal notranslate"><span class="pre">f</span></code> to use switch statements or long if/else chains. So he excludes dynamic dispatch that creates a source code dependency from <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">o</span></code> to <code class="docutils literal notranslate"><span class="pre">f</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">o</span></code> “knows” <code class="docutils literal notranslate"><span class="pre">f</span></code>. Instead there must be several clauses for <code class="docutils literal notranslate"><span class="pre">f</span></code> which may be called. Concretely, Bob says, one should be able to write <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">o</span></code> in source file A and an implementation of <code class="docutils literal notranslate"><span class="pre">f</span></code> in source file B and there should be no use/require/import declaration from A to B.</p>
<p>Stroscot has predicate dispatch and multimethods. So all functions can be overloaded and do dynamic dispatch. Stroscot solves the expression problem, so there is no boilerplate needed when extending <code class="docutils literal notranslate"><span class="pre">f</span></code>. Furthermore, Stroscot uses a recursive knot so definitions are properly in scope. So Stroscot’s multimethods are enough to make it OO in Bob’s minimalist sense.</p>
</section>
<section id="beta">
<h3>BETA<a class="headerlink" href="#beta" title="Permalink to this heading"></a></h3>
<p>Per <a class="reference external" href="https://journal.stuffwithstuff.com/2012/12/19/the-impoliteness-of-overriding-methods/">this</a>, BETA inverts the dispatch order. It is the least derived class in the chain that is called first, that then can call <code class="docutils literal notranslate"><span class="pre">inner()</span></code> to dispatch to a subclass. We can implement this kind of inheritance using a prefix-biased lookup method and a similarly reversed <code class="docutils literal notranslate"><span class="pre">extends</span></code> method. <span id="id18">[<a class="reference internal" href="../zzreferences.html#id158" title="Antero Taivalsaari. On the notion of inheritance. ACM Computing Surveys, 28(3):438–479, September 1996. URL: https://doi.org/10.1145/243439.243441 (visited on 2022-12-14), doi:10.1145/243439.243441.">Tai96</a>]</span> pg. 463 mentions that although BETA’s method order looks completely different from the Smalltalk order, they can in fact simulate each other by systematically placing explicit calls to super/inner in the right places.</p>
</section>
<section id="fragile-base-classes-interfaces">
<h3>Fragile base classes (Interfaces)<a class="headerlink" href="#fragile-base-classes-interfaces" title="Permalink to this heading"></a></h3>
<p>The “fragile base class” problem is that a subclass may break if its parent changes its self-use of methods, even though the subclass’s code has not been touched. Every downcall generates a code coupling that must be documented and maintained. For example in <span id="id19">[<a class="reference internal" href="../zzreferences.html#id12" title="Artima - Java Design Issues. URL: https://www.artima.com/articles/java-design-issues (visited on 2022-12-13).">Art</a>]</span>, there is mentioned the situation where a List class has add and addAll methods and one wants to write a CountingList class that overrides add and addAll to count the total number of elements added. This cannot be done properly without knowing whether List.addAll does a downcall to List.add.</p>
<p>One solution is to remove downcalls: if <code class="docutils literal notranslate"><span class="pre">self</span></code> is not an argument to the constructor passed to <code class="docutils literal notranslate"><span class="pre">mkObject</span></code>, and only <code class="docutils literal notranslate"><span class="pre">thislvl</span></code> is used, then there is no encapsulation issue. Unfortunately <span id="id20">[<a class="reference internal" href="../zzreferences.html#id159" title="Ewan Tempero, Hong Yul Yang, and James Noble. What Programmers Do with Inheritance in Java. In David Hutchison, Takeo Kanade, Josef Kittler, Jon M. Kleinberg, Friedemann Mattern, John C. Mitchell, Moni Naor, Oscar Nierstrasz, C. Pandu Rangan, Bernhard Steffen, Madhu Sudan, Demetri Terzopoulos, Doug Tygar, Moshe Y. Vardi, Gerhard Weikum, and Giuseppe Castagna, editors, ECOOP 2013 – Object-Oriented Programming, volume 7920, pages 577–601. Springer Berlin Heidelberg, Berlin, Heidelberg, 2013. URL: http://link.springer.com/10.1007/978-3-642-39038-8_24 (visited on 2022-08-31), doi:10.1007/978-3-642-39038-8_24.">TYN13</a>]</span> measured that 0-86% (median 34%) of inheritance relationships have a downcall. Although some projects are at 0, suggesting it is possible to avoid downcalls, the prevalance of this practice suggests they cannot be removed categorically and some form of downcalling must be supported.</p>
<p>A less restrictive solution is to ensure that for every downcall, the downcalled method is abstract in the current class. That way the code coupling is self-documenting. So what is prohibited is “implementation inheritance”, i.e. the situation where there is a concrete method A.a being overridden by a concrete method B.a and a method in A calls A.a. Rust, Julia, Go, and Swift have all adopted this style of programming, under various names such as trait, interface, or prototype-oriented programming. Even Java 8 added default methods and static methods to interfaces. There is an associated nomenclature change. Now a concrete method is referred to as “a default implementation of a required method”, and the most-derived class is given the normal name “class” while the other classes in the chain are given a more unusual name like interfaces or traits and are not allowed to be directly instantiated. This terminology makes the special role of the final class in the inheritance chain clear. And of course there is multiple inheritance, with a nice solution to the problem of multiple definitions, namely “error if there is no most-specific definition, which you can fix by defining it in the most-derived class”.</p>
<p>But actually, these languages have not “solved” the issue at all in a technical sense. Although most of the time the method is left abstract and implemented in the most-derived class, so the fragile base class problem is avoided, implementation inheritance is still there: you can override an interface and replace one of its default methods. The difference is rather a culture change: overridable methods in interfaces are all marked as default, so it is clear that they are expected to be overridden. And in Swift, non-overridable (final) methods are the default, so you have to jump through several hoops to actually implement the “bad” implementation inheritance pattern.</p>
</section>
<section id="dissolving-interfaces-into-multimethods">
<h3>Dissolving interfaces into multimethods<a class="headerlink" href="#dissolving-interfaces-into-multimethods" title="Permalink to this heading"></a></h3>
<p>Interfaces, traits, etc. are a morass of complexity. Generally these declare one, two, three, four functions or more. But it’s not particularly clear how to structure that: How many interfaces do you have? Do you have one interface per function, one interface with all the functions, or something in between? There’s no clear guidance. And it’s an important decision because you can’t remove a method from an interface later on without breaking lots of code. The safest decision is zero or one functions per interface, and never more, because that way you’ll never need to remove a function from an interface.</p>
<p>Obviously though this will require a lot more interfaces. There is already a naming problem where you don’t know which interface a method is coming from, and this will make it worse. Who is going to remember that <code class="docutils literal notranslate"><span class="pre">summarize</span></code> comes from the <code class="docutils literal notranslate"><span class="pre">Summary</span></code> interface rather than <code class="docutils literal notranslate"><span class="pre">Summarizer</span></code>, or that <code class="docutils literal notranslate"><span class="pre">next</span></code> comes from <code class="docutils literal notranslate"><span class="pre">Iterator</span></code>?  The solution is to once again introduce some order into the chaos, this time by mandating a uniform naming scheme based on the method name. For example we could call each interface <code class="docutils literal notranslate"><span class="pre">&lt;method_name&gt;_interface</span></code>. It’s not going to win any writing awards, but it works.</p>
<p>At this point though developers will start complaining about how tedious it is. We’ve taken all the fun out of using interfaces, and it is just tedious boilerplate now:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">interface</span><span class="w"> </span><span class="n">lookup_protocol</span>
<span class="w">  </span><span class="n">lookup</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">T1</span>

<span class="kr">class</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="n">implements</span><span class="w"> </span><span class="n">lookup_protocol</span>
<span class="w">  </span><span class="n">lookup</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">T1</span>
<span class="w">  </span><span class="n">lookup</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span>
</pre></div>
</div>
<p>Fortunately in Stroscot we don’t need this boilerplate, we can just use multimethods:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lookup_protocol</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">lookup</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="p">}</span>

<span class="nf">lookup</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">A</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span>

<span class="nf">assert</span><span class="w"> </span><span class="p">(</span><span class="n">lookup_protocol</span><span class="w"> </span><span class="kt">A</span><span class="p">)</span>
</pre></div>
</div>
<p>tl;dr interfaces are just a verbose chaotic version of multimethods. As a corollary of this, Stroscot has no methods defined “inside” a type - you write <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">=</span> <span class="pre">...;</span> <span class="pre">method</span> <span class="pre">=</span> <span class="pre">...</span></code> rather than <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">...;</span> <span class="pre">method</span> <span class="pre">;</span> <span class="pre">...</span> <span class="pre">}</span></code>. They are all “free functions” or “extension methods”.</p>
</section>
<section id="multiple-implementations">
<h3>Multiple implementations<a class="headerlink" href="#multiple-implementations" title="Permalink to this heading"></a></h3>
<p>In a lot of languages there’s a restriction that interfaces can be implemented only once for a given type. This is Stroscot’s restriction too: because of how overloading works, a function can be implemented only once in a module. There are ways to work around this. Java has the adapter pattern, and similarly Idris allows <a class="reference external" href="https://docs.idris-lang.org/en/latest/tutorial/interfaces.html#named-implementations">named implementations</a>. In Stroscot, we can just write <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">{</span> <span class="pre">method1</span> <span class="pre">=</span> <span class="pre">...,</span> <span class="pre">method2</span> <span class="pre">=</span> <span class="pre">...</span> <span class="pre">}</span></code> and override the methods using implicit parameters.</p>
<p>Now with multiple implementations floating around we often want to use these as a value. There’s no issue with this in Stroscot. For example, sets and maps need a comparison operator, and this has to be consistent so that you don’t insert with comparison A and removing with comparison B. To avoid inconsistent comparisons the map or set can store the comparison operator as a parameter on creation - it is simply a function after all.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Modules.html" class="btn btn-neutral float-left" title="Modules" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="PackageManager.html" class="btn btn-neutral float-right" title="Package manager" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>