<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Objects &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Package manager" href="PackageManager.html" />
    <link rel="prev" title="Modules" href="Modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler-Library.html">Compiler library</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Intrinsics.html">Intrinsics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#definition">Definition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">Objects</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#no-autoboxing">No autoboxing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#no-object-identity">No object identity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#no-implicit-synchronization-lock">No implicit synchronization lock</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#encapsulation">Encapsulation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#no-constructors">No constructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#all-or-nothing-internal-access">All-or-nothing internal access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#inheritance">Inheritance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usage-patterns">Usage patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inheritance-is-not-subtyping">Inheritance is not subtyping</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#polymorphism">Polymorphism</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#minimal-oo">Minimal OO</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interfaces">Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multimethods">Multimethods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiple-implementations">Multiple implementations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#design-patterns">Design patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Security.html">Security</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard-Library.html">Standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Objects</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Objects.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="objects">
<h1>Objects<a class="headerlink" href="#objects" title="Permalink to this heading"></a></h1>
<p>Many people like to use the word “object”, as in “object-oriented programming”. Stroscot aims to support all the paradigms, so being able to claim that Stroscot is OOP would be a great feature. But our analysis is stymied before it begins: per the C2 wiki, <a class="reference external" href="https://wiki.c2.com/?NobodyAgreesOnWhatOoIs">nobody agrees on what OO is</a> and there are <a class="reference external" href="https://wiki.c2.com/?DefinitionsForOo">many definitions for OO</a>. For that reason the word “object” is not used in the rest of the documentation. But here we try to figure out what OO is how to make Stroscot support OO.</p>
<section id="definition">
<h2>Definition<a class="headerlink" href="#definition" title="Permalink to this heading"></a></h2>
<p>It is 2023, so we can use ChatGPT to cut the Gordian knot of defining OO. It has analyzed many discussions of OOP and distilled the common themes. ChatGPT does not actually give a consistent definition either, changing when you re-generate, but we can distill the common parts of 10 ChatGPT definitions:</p>
<ul class="simple">
<li><p>OOP uses objects to represent and manipulate data. An object contains properties and methods, which group related data and behavior.</p></li>
<li><p>The core principles of OOP are encapsulation, inheritance, and polymorphism.</p></li>
</ul>
<p>ChatGPT list more aspects of OOP, but inconsistently, including them only sometimes. Similarly <a href="#id36"><span class="problematic" id="id37">`ISO-IEC-2382 Mhttps://www.iso.org/obp/ui/#iso:std:iso-iec:2382:ed-1:v2:en&gt;`__</span></a> lists extra concepts. Since we want only what is agreed on, it is clear that these should be ignored, but I will also justify why they can be ignored:</p>
<ul class="simple">
<li><p>Objects are instances of classes (8/10, IEC-2382) - prototypes instead of classes is a common twist on OO, e.g. as done in Self, and <span id="id1">[]</span> argues that prototype-based inheritance is simpler than class-based.</p></li>
<li><p>It is widely used / popular in software development (6/10) - We could just copy the OO systems of popular languages like Java. Python, or C++. But copying without understanding is pointless. The goal is rather to deconstruct OO, identify each use case, and cover those use cases. If Stroscot is popular enough it should define OO, just like these languages.</p></li>
<li><p>Abstraction as a third or fourth core principle (4/10) - arguably this is included in the “OOP uses objects to represent and manipulate data” bullet point. In 3/4 appearances it just meant encapsulation, “hiding implementation details”, while in the other one it was “representing complex systems or processes through simpler, more generalized concepts.” In <span id="id2">[]</span>, Stroustrup used abstraction instead of encapsulation, so the variation is probably due to that source. In a more recent <a class="reference external" href="https://youtu.be/xcpSLRpOMJM?t=37">2015 talk</a>, Stroustrup used “encapsulation” instead of “abstraction”.</p></li>
<li><p>Message passing (IEC-2382) - this is included in Alan Kay’s definition of Smalltalk, but C++/Java do not use message passing, so it is an inaccurate definition of OOP.</p></li>
<li><p>Dynamic binding (IEC-2382) - this is just an implementation technique for polymorphism</p></li>
</ul>
<p>Getting back to the definition. It is essentially Bjarne Stroustrup’s definition: in <span id="id3">[]</span> he similarly requires three principles, abstraction, inheritance, and run-time polymorphism. But it’s evolved a bit. I think the ChatGPT version is influenced by the wording of C2, <a class="reference external" href="https://wiki.c2.com/?PolymorphismEncapsulationInheritance">PolymorphismEncapsulationInheritance</a>. I also think the ChatGPT definition is a bit clearer because it separates out “providing objects” from the 3 principles. But given the similarities and that Stroustrup calls his definition the “traditional” one, I think ChatGPT has converged to a reliable definition. Notably, this definition is listed second on C2, pretty close to the top. It is similar to <a class="reference external" href="http://paulgraham.com/reesoo.html">Rees’s</a>  “conventional Simula 67-like pattern” of encapsulation, ad hoc polymorphism, inheritance = subtyping, and sum-of-product-of-function pattern, which he states “many people take as a definition of OO”. C2 does list caveats:</p>
<ul class="simple">
<li><p>It is C++ centric - ChatGPT vehemently disagrees with this, and says the principles also apply to Java, Python, and Ruby. It is true though that the author of C++ coined it, so it is a more pragmatic definition than others.</p></li>
<li><p>The words “encapsulation”, “inheritance”, “polymorphism” only express so much, and are ambiguous out of context. There is a large amount of convention and code constructs associated with expressing these principles. In fact though, ChatGPT understands these principles quite well and we can just follow up by asking ChatGPT what it means by these various words.</p></li>
</ul>
<p>There is also the first definition on C2, associated with the BETA language <span id="id4">[]</span>. Per <span id="id5">[]</span> this was first published in <span id="id6">[]</span>. This defines OOP as a language where “a program execution is regarded as a physical model, simulating the behavior of either a real or imaginary part of the world.” C2 states “many consider this to be the definitive definition.” But I don’t like this definition. The “physical” in physical model refers to physics. There are many approaches to physics, but in modern physics we decompose the system into a state, noting the position and velocity of each atom, and the laws, specifying the evolution of the state over time. Similarly, we can decompose a program execution as a state (composed of bits) and a transition rule between states. At this point we are back to the functional view of programming, as we can express the full program execution as a function of the initial state. Objects only appear as an abstraction for manipulating subsets of state, and it is just ChatGPT’s definition of objects as collections of properties (attributes) and methods (actions). Indeed, it is not even clear that object “actions” in this framework are well-defined; actions operate on the entire state and may affect multiple objects or state that has not been identified as an object. So this definition raises more questions than it answers, although as far as I can tell Stroscot’s continuation approach to I/O fits perfectly into this definition of the OO paradigm.</p>
<p>There is also Alan Kay’s “definition”. As most sources are careful to note, it is not a definition of OOP at all - it is a definition of Smalltalk. I have looked and it is not clear at all that Smalltalk is a particularly OOP language. Certainly, the Smalltalk manual describes a concept of “object”, but the word “object” was common at the time, for binary files and database records, so Kay coining it for his notion is not a big stretch. Kay has <a class="reference external" href="http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html">said</a> that if he could go back in time he would rename object to something else. He uses “modules” in that email but I think following Erlang a better term might be actor. Does module-oriented programming or actor-oriented programming sound like it is related to OOP? I think not. As of August 2023, Wikipedia has a “citation needed” tag for Alan Kay being the father of OOP - it has been in the article (unsourced) since <a class="reference external" href="https://en.wikipedia.org/w/index.php?diff=29999">2002</a>.</p>
<p>Briefly looking at the other definitions on C2:</p>
<ul>
<li><p>William Cook: Once you get past the terminology, this defines an object as a record of data and functions. Pretty similar to the “properties and methods” of ChatGPT, but with more of a mathematical flavor.</p></li>
<li><p>Theory of Objects book: An object is a reference to a record of attributes. Similar but with the reference included.</p></li>
<li><p>ObjectsAreDictionaries - Cook’s definition, basically.</p></li>
<li><p>Everything is a behavior - no? Even BETA <span id="id7">[]</span> acknowledges that for example addition is not a behavior <code class="docutils literal notranslate"><span class="pre">.plus</span></code>, it is just an operation</p></li>
<li><p>The “natural extension” of programmer-defined types - there are other forms of types, e.g. ADTs and refinement types, which seem more natural.</p></li>
<li><p>No polymorphism - a weird thing to exclude. I could see excluding inheritance, focusing on encapsulation, but just allowing functions to be included in the record means you get virtual dispatch and polymorphism.</p></li>
<li><p>Generic functions (multimethods) - This misses out on the objects as records. But certainly some of the aspects of OO polymorphism are covered.</p></li>
<li><p>DavidMoon - C++ and Java are not OO? What?</p></li>
<li><p><a class="reference external" href="http://paulgraham.com/reesoo.html">Jonathan Rees</a> - he has 9 concepts. Grouping them by ChatGPT’s principles, they are: objects (sum-of-product-of-function pattern - 9), encapsulation (encapsulation - 1 and protection - 2), inheritance (specification inheritance/subtyping - 7, implementation inheritance/reuse - 8), and polymorphism (ad hoc polymorphism - 3, parametric polymorphism - 4). Then he has “everything is an object” (EIAO) (5) and “all you can do is send a message” (AYCDISAM, 6). Then he considers the following propositions:</p>
<ul class="simple">
<li><p>Lisp is OO - it has polymorphism, EIAO, and subtyping.</p></li>
<li><p>Simula 67 is OO - it has encapsulation, specification  inheritance, and objects</p></li>
<li><p>Java is OO - it has encapsulation, polymorphism, inheritance, and objects</p></li>
<li><p>E is OO - it has encapsulation, polymorphism, specification inheritance, and objects</p></li>
</ul>
<p>Applying the ChatGPT definition, it is clear here that, as considered by Rees, Lisp is not OO because it doesn’t have object values. But actually there are Lisp libraries with <code class="docutils literal notranslate"><span class="pre">defclass</span></code> that allow making object-like dictionaries - if you use those, Lisp is OO. And all the other languages are clearly OO, at least if specification inheritance is considered sufficient. The principles are essentially the same as ChatGPT except for EIAO (see <span id="id8">[]</span> again, not an OO principle), and AYCDISAM which is more like Kay’s actor-oriented programming. Also sub-type polymorphism, the form of polymorphism most associated with OOP, is missing from Rees’s list.</p>
<p>Another argument against EIAO comes from its <a class="reference external" href="https://crystal-lang.org/reference/1.9/syntax_and_semantics/everything_is_an_object.html">definition in Crystal</a> - a value is an object if it can “respond to some methods”. But with multimethods, for any value we can write a function which operates on that value, so EIAO trivially holds.</p>
</li>
<li><p>Chris Date “An object is essentially just a value (if immutable) or a variable (otherwise).” - certainly a good property, but I think the dictionary definitions capture much more of the intuition</p></li>
<li><p>Binding Behavior to References - unless “binding behavior” means dictionaries, it’s missing a key component of OO, the field and method names</p></li>
</ul>
</section>
<section id="id9">
<h2>Objects<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h2>
<p>For the first part of OO, we must define objects, and explain how they can contain properties and methods. For the most part I agree with <a class="reference external" href="https://wiki.c2.com/?ObjectsAreDictionaries">ObjectsAreDictionaries</a>, i.e. objects are a mapping from strings to values. But I want one fewer concept in the core language so I will instead define objects to be modules, in the ML sense: a module is a list of definitions, and these definitions collectively define a mapping from expressions to values. The expression evaluated in the context of an object/module will usually be an identifier, corresponding to a dictionary lookup, but this definition lets us define values for function calls and other bits of syntax as well, so we can write DSLs more easily.</p>
<p>We want to create and manipulate objects. So we have some operations on modules:</p>
<ul class="simple">
<li><p>literal syntax</p></li>
<li><p>evaluate an expression in the context of the module</p></li>
<li><p>inspect/replace/remove a definition</p></li>
<li><p>list all definitions</p></li>
<li><p>change module imports/exports</p></li>
</ul>
<p>Per some cursory reading, these include all the object creation and manipulation idioms of <a class="reference external" href="https://handbook.selflanguage.org/SelfHandbook2017.1.pdf">Self</a> and <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects">Javascript</a>.</p>
<section id="no-autoboxing">
<h3>No autoboxing<a class="headerlink" href="#no-autoboxing" title="Permalink to this heading"></a></h3>
<p>Stroscot does not subscribe to Smalltalk’s notion that “everything is an object”. Rather, in Stroscot, “everything is a value”, and booleans, integers, and objects (modules) are different types of values.  This is a little similar to Java’s notion of “primitive types”, but unlike Java, Stroscot does not make objects reference types - objects have value semantics, and are part of the universal type. Stroscot’s notion of object is more similar to the notion of “pure object” in <span id="id10">[]</span>, where an object is an immutable record of functions that themselves take and return immutable objects and primitive values. To express the Java notion of mutable object, you would use Stroscot’s mutable variables, in particular a Java object could be represented as a variable containing an object whose methods/functions took mutable variable references pointing to more objects, and whose data fields are mutable variables.</p>
<p>Java and C# have implemented a feature called “autoboxing” where primitive types are automatically converted to “wrapped primitive” objects like Boolean or Integer. This allows using primitives in places where an object is required. But this is a leaky abstraction; autoboxing actually changes behavior. For example in Java <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Integer(0)</span> <span class="pre">!=</span> <span class="pre">new</span> <span class="pre">Integer(0)</span></code>, you have to do <code class="docutils literal notranslate"><span class="pre">Integer.valueOf(0)</span> <span class="pre">==</span> <span class="pre">Integer.valueOf(0)</span></code> or use <code class="docutils literal notranslate"><span class="pre">.equals</span></code>. In JS <code class="docutils literal notranslate"><span class="pre">false</span></code> is falsy but <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Boolean(false)</span></code> is truthy. Properly speaking, primitives are distinct from objects, in that they do not support key object operations such as looking up identifiers. Ultimately, discarding the “wrapping primitive” notion and simply representing primitive values directly is the most logical. Supporting a universal type that can contain both primitives and objects does complicate code generation, but it’s not that bad.</p>
</section>
<section id="no-object-identity">
<h3>No object identity<a class="headerlink" href="#no-object-identity" title="Permalink to this heading"></a></h3>
<p>In Java, objects have an identity. For example, <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Object()</span> <span class="pre">==</span> <span class="pre">new</span> <span class="pre">Object()</span></code> returns false because two different object references are constructed and their addresses are different. But when you try to do <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Object()</span> <span class="pre">&lt;</span>&#160; <span class="pre">new</span> <span class="pre">Object()</span></code> it’s disallowed because the address is an implementation detail. So just for consistency’s sake <code class="docutils literal notranslate"><span class="pre">==</span></code> shouldn’t work either - if the address is an implementation detail, then don’t expose anything about it! But apparently the desire for a fast pointer equality hack won out over the desire to avoid exposing implementation details of the language. As <span id="id11">[]</span> says, “primitive equality exposes representation and prevents simulation of one object by another.”</p>
<p>In Stroscot, objects are values, so they don’t have identity. Syntactically identical objects will always compare equal. However, mutable variables have identity - their value is the address, and allocating a new mutable variable creates a new address hence a new identity.. So in the emulation of Java objects as mutable variables containing objects, we can compare ref-to-object for address equality, and also dereference the refs and compare the object values. Hence the Java notion naturally decomposes into the combination of two concepts. Immutable objects work much better with the functional programming paradigm. Furthermore JSON cannot easily represent the notion of object identity, whereas object values are easily written.</p>
</section>
<section id="no-implicit-synchronization-lock">
<h3>No implicit synchronization lock<a class="headerlink" href="#no-implicit-synchronization-lock" title="Permalink to this heading"></a></h3>
<p>Another (mis)feature of Java is the ability to write <code class="docutils literal notranslate"><span class="pre">synchronize</span> <span class="pre">(random_object)</span></code> and use any object as a lock. This adds some bytes of header to every object allocation. It has been acknowledged by <a class="reference external" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html">the Java tutorial</a> that the ability to use any object was overly broad and it is better to use specific lock objects. <a class="reference external" href="https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/#_horror_circus_kinda_works_but_horrifying">This post</a> points out that you can synchronize on primitives (actually the corresponding autoboxed objects) and on strings. Although it works for small examples due to interning caches, it will fail if your program uses too many primitives/strings as locks. This sort of tomfoolery seems pretty stupid, and there is an easy fix: if you want a mutex you should have to create a value of the <code class="docutils literal notranslate"><span class="pre">Mutex</span></code> type.</p>
</section>
</section>
<section id="encapsulation">
<h2>Encapsulation<a class="headerlink" href="#encapsulation" title="Permalink to this heading"></a></h2>
<p>According to 8/10 ChatGPT definitions, encapsulation refers to hiding the internal workings of an object from the outside world. The object’s data can only be accessed or modified through a well-defined interface. Typically this interface is defined by marking certain methods and fields as “public”, meaning they can be accessed by the outside world, while others are marked “private”, meaning they can only be accessed by the object itself.</p>
<p>In 4/10 definitions ChatGPT thought encapsulation referred to the idea of bundling data and methods into a single entity. But it should be clear that this is the basic definition of “object”, rather than a principle of OOP. (The numbers for bundling and hiding sum to 12/10 because 2 definitions had both bundling and hiding)</p>
<p><span id="id12">[<a class="reference internal" href="../zzreferences.html#id151" title="Alan Snyder. Encapsulation and inheritance in object-oriented programming languages. ACM SIGPLAN Notices, 21(11):38–45, November 1986. URL: https://dl.acm.org/doi/10.1145/960112.28702 (visited on 2022-12-26), doi:10.1145/960112.28702.">Sny86</a>]</span> says this controlled interface serves as a contract between the object and its clients. So long as this contract is maintained, the object can be reimplemented without affecting any clients. To maximize the advantages of encapsulation, the contract should avoid including implementation details. For example, it should be possible to rename instance variables without affecting clients. Encapsulation provides a way to protect an object’s integrity, ensuring a consistent and valid internal state. Encapsulation promotes modular software evolution and maintenance.</p>
<p><span id="id13">[]</span> argues that encapsulation is really a property of
ML modules, because only ML modules provide sophisticated sharing mechanisms that allow multiple implementations and uses of multiple abstractions to coexist. ML of course allow the basic hiding feature, by not exporting the representation of a type. Unlike Smalltalk, which disallows <code class="docutils literal notranslate"><span class="pre">this.foo</span> <span class="pre">==</span> <span class="pre">b.foo</span></code> even if <code class="docutils literal notranslate"><span class="pre">b</span></code> is an instance of the current class, ML modules allow inspecting the representation of more than one value at the same time. ML modules also allow defining multiple abstract data types in the same module, so that a complex internal representation may be defined and manipulated without recourse to C++’s “friend” qualifier. The only feature missing from ML modules is mixing values of two different implementations - this is solved in Stroscot by allowing functions to use duck typing, so that two values may be mixed if they both conform to the proper interface. Since Stroscot defines objects to be ML modules, all the benefits of encapsulation are provided.</p>
<p>Cook goes on to state that “any programming model that allows inspection of the representation of more than one abstraction at a time is not object-oriented.” So by his definition C++ and Java are not object-oriented - bleh. In fact this is just a limitation of ML - ML cannot inspect/pattern match on functions; they are opaque. In Stroscot, it is possible to match on the lambdas in Cook’s Figure 8 and determine if an ISet was constructed via the Empty, Insert, or Union implementations. We might as well have written <code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">ISet</span> <span class="pre">=</span> <span class="pre">Empty</span> <span class="pre">|</span> <span class="pre">Insert</span> <span class="pre">int</span> <span class="pre">ISet</span> <span class="pre">|</span> <span class="pre">Union</span> <span class="pre">ISet</span> <span class="pre">ISet</span></code> as in the ADT implementation, except that the lambda presentation is an open data type that allows adding more cases. In Stroscot, we use multimethods to solve the expression problem, so it is just defining symbols and adding more dispatch cases to the relevant multimethods.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>interface ISet = {
  isEmpty : bool,
  contains : int → bool,
  insert : int → ISet,
  union : ISet → ISet
}
</pre></div>
</div>
<p>Stroscot has modules, which provide encapsulation. We can create a type and not export its constructor symbols, so that the type becomes an abstract data type: only functions defined in the module can access the concrete representation of the type, and functions outside the module can only use the public interface. This indeed allows renaming fields of the data type without affecting external clients.</p>
<section id="no-constructors">
<h3>No constructors<a class="headerlink" href="#no-constructors" title="Permalink to this heading"></a></h3>
<p>A Java constructor has many limitations compared to a factory function: it must allocate new memory, it cannot return a subclass, and it has to be called with a noisy “new” syntax and a fixed name.</p>
<p>For example, consider a boxed primitive boolean. It only needs two values: a factory function can construct one true and one false and then return those from then on. But using a constructor forces the program to produce millions of distinct trues and falses, creating significant overhead.</p>
<p>Another difference is that a factory function computes the field values first and then can use an allocate-and-initialize primitive. The primitive can ensure that its allocation is private, hence appears atomic for concurrency. In contrast a constructor allocates memory initialized to a default value and then overwrites each field. This implicit memory writing means that concurrency and constructors interact poorly because you can access partially-constructed objects. <a class="reference external" href="https://counterexamples.org/under-construction.html">This page</a> describes several bugs in real-world systems.</p>
<p>Deserialization bypasses defined constructors and directly creates objects via the runtime - it is an implicit public constructor. In fact this deserialization constructor is exactly the allocate-and-initialize primitive that a factory function needs.</p>
<p>One use of constructors is to enforce invariants (validity checking); for example a time constructor that ensures <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">minutes</span> <span class="pre">&lt;</span> <span class="pre">60</span></code>. In Stroscot, invariants like these are defined in types, and checked on use, rather than on construction. It is often very helpful to be able to talk about about an object whose fields are unnormalized, which the constructor pattern prevents. And when you need the invariants, the types establish object integrity. Whereas in Java you must reason about all mutating methods to identify the possible states of an object, in Stroscot only the type needs to be examined.</p>
<p>A minor downside of doing away with constructors is that factory functions are not automatically marked in the documentation, so can be harder to find. Organizing the source code and documentation to group factory methods is not hard, the hard part is enforcing that such a convention is followed consistently. But it’s not even clear that grouping factory functions together is the best organization.</p>
</section>
<section id="all-or-nothing-internal-access">
<h3>All-or-nothing internal access<a class="headerlink" href="#all-or-nothing-internal-access" title="Permalink to this heading"></a></h3>
<p>Inheritance should respect encapsulation, so that inheriting classes do not get any more access. Thus we see that Java’s protected keyword is a hack. Allowing non-public instance variables to be accessed by subclasses breaks encapsulation. Instance variables should either be public and accessible to everyone, or private and not accessible to anything outside a module.</p>
<p>In Stroscot, if you can access the term’s constructor symbol, you have full data access to all fields and can destruct and create values with that constructor. But, you can avoid exporting a constructor symbol from a module - that means a user will have to use the defined factory functions and accessors, or else deliberately import the <code class="docutils literal notranslate"><span class="pre">._internal</span></code> module.</p>
</section>
</section>
<section id="inheritance">
<h2>Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this heading"></a></h2>
<p>Per 10/10 ChatGPT definitions, and Wikipedia, inheritance allows objects to inherit properties and methods from a parent class (class-based inheritance, 8/10) or other objects (prototype-based inheritance, 2/10). This allows for code reuse (3/10) and forms a hierarchy of objects (2/10).</p>
<p>Inheritance originated from Simula where per <span id="id14">[<a class="reference internal" href="../zzreferences.html#id121" title="Kristen Nygaard and Ole-Johan Dahl. The development of the SIMULA languages. In History of Programming Languages, pages 439–480. Association for Computing Machinery, New York, NY, USA, June 1978. URL: https://doi.org/10.1145/800025.1198392 (visited on 2022-12-20).">ND78</a>]</span> they were trying to model a toll booth on a bridge, with a queue of cars which were either trucks or buses. The queue was modeled with a “circular list” structure, consisting of a “set head” and a variable number of “links”, each with a predecessor and successor reference. The trucks and buses are modeled as collections of static properties according to a schema. Inheritance thus appeared as a “concatenation” or “prefixing” mechanism for “gluing” each of the various vehicles (trucks, buses) together with a “link” for an intrusive list to make one record instance. As <a class="reference external" href="https://catern.com/inheritance.html">this post</a> argues, inheritance was invented as a performance hack.</p>
<p>Bjarne Stroustrup has explored <a class="reference external" href="https://www.youtube.com/watch?v=xcpSLRpOMJM">OO without inheritance</a>, and similarly <span id="id15">[]</span> states “[inheritance] is neither necessary for, nor specific to, object-oriented programming.” If we had a definitive study showing that inheritance makes systems more complex, bug-ridden, and unmaintainable, then we could just leave inheritance out on the grounds of it being a footgun. Certainly there are suggestive blog posts like “Inheritance is evil and must be destroyed” (<a class="reference external" href="https://blog.berniesumption.com/software/inheritance-is-evil-and-must-be-destroyed/index.html">1</a>). But <span id="id16">[<a class="reference internal" href="../zzreferences.html#id54" title="K. El Emam, S. Benlarbi, N. Goel, and S.N. Rai. The confounding effect of class size on the validity of object-oriented metrics. IEEE Transactions on Software Engineering, 27(7):630–650, July 2001. URL: http://ieeexplore.ieee.org/document/935855/ (visited on 2023-02-24), doi:10.1109/32.935855.">EEBGR01</a>]</span> lists several cases where a promising study found that inheritance caused difficulties, but follow up studies/replications have found the opposite conclusion. And the regression model in that paper invalidates all of the tested inheritance metrics (DIT, NOC, NMO, NMA, SIX) as having no statistical relationship after controlling for lines of code. It is still possible that inheritance may make programs more difficult to understand, but nobody has created a metric and done a study with enough statistical power to confirm or deny that conclusion definitively. TODO: Maybe Jan Vitek (co-author of some large scale Github studies) would be interested.</p>
<p>Since there is little evidence, and it is customary to include inheritance in OOP, it is better to err on the side of inclusion. Following <span id="id17">[]</span> we shall see we can implement pretty much all the common patterns of inheritance as library functions.</p>
<section id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this heading"></a></h3>
<p>Combining records is a basic operation. There are a few choices for handling conflicting definitions, like <code class="docutils literal notranslate"><span class="pre">combine</span> <span class="pre">{a</span> <span class="pre">=</span> <span class="pre">1}</span> <span class="pre">{a</span> <span class="pre">=</span> <span class="pre">2}</span></code>: we can error (<code class="docutils literal notranslate"><span class="pre">combine_bot</span></code>), we can be right-biased like Simula (<code class="docutils literal notranslate"><span class="pre">combine_r</span></code>), <code class="docutils literal notranslate"><span class="pre">{a</span> <span class="pre">=</span> <span class="pre">2}</span></code>, or we can be left-biased ((<code class="docutils literal notranslate"><span class="pre">combine_l</span></code>, as in <span id="id18">[]</span>). But most OO languages also support a “qualified lookup” mechanism that allows specifically accessing shadowed attributes, so really combining in the context of inheritance stores both fields, like <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">parent:</span> <span class="pre">{a</span> <span class="pre">=</span> <span class="pre">1},</span> <span class="pre">main:</span> <span class="pre">{a</span> <span class="pre">=</span> <span class="pre">2}</span> <span class="pre">}</span></code> or <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">parent:</span> <span class="pre">1,</span> <span class="pre">main:</span> <span class="pre">2}</span> <span class="pre">}</span></code>. It is just convenient to omit this extra structure when no names are shadowed and unqualified lookup suffices. <span id="id19">[<a class="reference internal" href="../zzreferences.html#id159" title="Antero Taivalsaari. On the notion of inheritance. ACM Computing Surveys, 28(3):438–479, September 1996. URL: https://doi.org/10.1145/243439.243441 (visited on 2022-12-14), doi:10.1145/243439.243441.">Tai96</a>]</span> also mentions “defeating” or “cancelling” a property. This involves the subclass’s record containing a “whiteout” entry so that looking up that property returns a not found exception rather than a value. It really is an extension of the combination algorithm and doesn’t affect much of the design.</p>
<p>The difficulty in inheritance lies in that inheritance allows self-reference, for example method calls in Java can refer to <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">super</span></code>. This means constructing the object requires tying up a recursive knot, so that the methods refer to the parts properly. <span id="id20">[]</span> models the inheritance process as follows: you have a “generator” parent function (a function whose fixed point is an object), and a “wrapper” child function (that takes self and super parameters representing the final object and the superstructure). Cook lists several variants:</p>
<ul class="simple">
<li><p>wrapping with distributive application, <code class="docutils literal notranslate"><span class="pre">extends_app</span> <span class="pre">w</span> <span class="pre">g</span> <span class="pre">=</span> <span class="pre">\self.</span> <span class="pre">w</span> <span class="pre">self</span> <span class="pre">(g</span> <span class="pre">self)</span></code>. This allows full control of the result by the wrapper function.</p></li>
<li><p>wrapper application with combination, <code class="docutils literal notranslate"><span class="pre">extends_combine</span> <span class="pre">w</span> <span class="pre">g</span> <span class="pre">=</span> <span class="pre">\self.</span> <span class="pre">combine</span> <span class="pre">(g</span> <span class="pre">self)</span> <span class="pre">(w</span> <span class="pre">self</span> <span class="pre">(g</span> <span class="pre">self))</span></code>. This is equivalent to the previous with <code class="docutils literal notranslate"><span class="pre">w'</span> <span class="pre">w</span> <span class="pre">=</span> <span class="pre">\self</span> <span class="pre">super.</span> <span class="pre">combine</span> <span class="pre">super</span> <span class="pre">(w</span> <span class="pre">self</span> <span class="pre">super)</span></code>. This is the more practical operator in most cases. For example it is used in <a class="reference external" href="https://github.com/NixOS/nixpkgs/blob/d44a67c4ba1a01614f236213b3f64e17bb107879/lib/fixed-points.nix#L91">Nixpkgs</a>.</p></li>
<li><p>Selective inheritance, <code class="docutils literal notranslate"><span class="pre">extends_select</span> <span class="pre">w</span> <span class="pre">g</span> <span class="pre">=</span> <span class="pre">\self.</span> <span class="pre">combine_compose</span> <span class="pre">(w</span> <span class="pre">self)</span> <span class="pre">(g</span> <span class="pre">self)</span></code> where <code class="docutils literal notranslate"><span class="pre">combine_compose</span> <span class="pre">m</span> <span class="pre">p</span> <span class="pre">s</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">s</span> <span class="pre">.</span> <span class="pre">p</span> <span class="pre">s</span></code>.</p></li>
<li><p>Multiple inheritance. This can apply to all the previous; the distributive application is easiest, the single generator <code class="docutils literal notranslate"><span class="pre">g</span></code> is replaced with a list <code class="docutils literal notranslate"><span class="pre">gs</span></code>: <code class="docutils literal notranslate"><span class="pre">extends_app_mi</span> <span class="pre">w</span> <span class="pre">gs</span> <span class="pre">=</span> <span class="pre">\self.</span> <span class="pre">w</span> <span class="pre">self</span> <span class="pre">(map</span> <span class="pre">gs</span> <span class="pre">self)</span></code>. Similarly combination-based multiple inheritance is <code class="docutils literal notranslate"><span class="pre">extends_combine_mi</span> <span class="pre">w</span> <span class="pre">gs</span> <span class="pre">=</span> <span class="pre">\self.</span> <span class="pre">combine</span> <span class="pre">(reduce</span> <span class="pre">combine_bot</span> <span class="pre">(map</span> <span class="pre">gs</span> <span class="pre">self))</span> <span class="pre">(w</span> <span class="pre">self</span> <span class="pre">(map</span> <span class="pre">gs</span> <span class="pre">self))</span></code>.</p></li>
</ul>
<p>Looking at the multiple inheritance variants, it is clear that composing wrappers and generators in a one-by-one fashion is getting unwieldy. For example, it is unclear how to represent C++’s virtual inheritance, where not only is there a list of direct parents but also a map of “virtual” parents. A lot of the intermediate stages of composition are not relevant; they are abstract, uninstantiable classes. For example mixins cannot be instantiated at all; how do we prevent attempting to <code class="docutils literal notranslate"><span class="pre">fix</span></code> them? I think a more flexible and expressive model is a function <code class="docutils literal notranslate"><span class="pre">mkObject</span></code> - rather than writing <code class="docutils literal notranslate"><span class="pre">fix</span> <span class="pre">(extends</span> <span class="pre">f</span> <span class="pre">(extends</span> <span class="pre">g</span> <span class="pre">base))</span></code>, we write <code class="docutils literal notranslate"><span class="pre">mkObject</span> <span class="pre">[f,g,base]</span></code>. This captures the usage pattern more clearly. Although, as Cook hints at in the comparison with Kamin’s semantics (11.2), <code class="docutils literal notranslate"><span class="pre">extends</span></code> is a little bit more compositional because it assigns a meaning to the partially constructed classes, it is not clear that this has much more meaning that applying <code class="docutils literal notranslate"><span class="pre">mkObject</span></code> to a partial list of classes. Also, with <code class="docutils literal notranslate"><span class="pre">mkObject</span></code>, it becomes clear that we can replace the list of class generators with other data structures, like a tree for multiple inheritance and an auxiliary map structure for C++’s pattern of named virtual superclasses. Similarly, with <code class="docutils literal notranslate"><span class="pre">static</span></code>, the structure becomes further complicated because we must distinguish class and instance variables and methods. Due to the recursive knot, and the variance of the type of the subclass reference <code class="docutils literal notranslate"><span class="pre">self</span></code>, specifying the type of <code class="docutils literal notranslate"><span class="pre">mkObject</span></code> is tricky - it requires dependent types and heterogenous lists. You can see the full implementation in Stroscot <a class="reference external" href="https://github.com/Mathnerd314/stroscot/blob/master/library/inheritance.txt">here</a>. Perhaps this is another reason why Cook uses <code class="docutils literal notranslate"><span class="pre">extends</span></code>, it at least has a relatively simple type.</p>
<p>There is definitely a lot of choice in how to implement inheritance and its semantics. For example, in Ecstasy, <code class="docutils literal notranslate"><span class="pre">super</span></code> refers only to the parent method, and other methods of the superclass cannot be called. In my implementation, I went the other direction, preserving the ability of <code class="docutils literal notranslate"><span class="pre">super</span></code> to access the full parent object, and adding a <code class="docutils literal notranslate"><span class="pre">thislvl</span></code> keyword to represent the current level of the constructed object, in case a descendant object shadows a variable/method. Cook goes through inheritance in Simula, Smalltalk, Beta, and Flavors and shows how they can be modeled with the “fixed point of composition of wrappers” model and translation into records and functions. It is not exhaustive, but I would say that most likely, users will be able to write a <code class="docutils literal notranslate"><span class="pre">mkObject</span></code> or <code class="docutils literal notranslate"><span class="pre">extends</span></code> variant that satisfies pretty much all of their inheritance needs, and then wrap it up in nice syntax with a macro. But to be safe, I would also say that an auxiliary lookup function (like an overloaded <code class="docutils literal notranslate"><span class="pre">.</span></code> operator) to handle shadowing must be provided as well.</p>
<p>BETA is one example of strange inheritance - per <a class="reference external" href="https://journal.stuffwithstuff.com/2012/12/19/the-impoliteness-of-overriding-methods/">this</a>, it inverts the dispatch order. It is the least derived class in the chain that is called first, that then can call <code class="docutils literal notranslate"><span class="pre">inner()</span></code> to dispatch to a subclass. We can implement this kind of inheritance using a prefix-biased lookup method and a similarly reversed <code class="docutils literal notranslate"><span class="pre">extends</span></code> method. <span id="id21">[<a class="reference internal" href="../zzreferences.html#id159" title="Antero Taivalsaari. On the notion of inheritance. ACM Computing Surveys, 28(3):438–479, September 1996. URL: https://doi.org/10.1145/243439.243441 (visited on 2022-12-14), doi:10.1145/243439.243441.">Tai96</a>]</span> pg. 463 mentions that although BETA’s method order looks completely different from the Smalltalk order, they can in fact simulate each other by systematically placing explicit calls to super/inner in the right places.</p>
</section>
<section id="usage-patterns">
<h3>Usage patterns<a class="headerlink" href="#usage-patterns" title="Permalink to this heading"></a></h3>
<p>Having defined inheritance, and implemented several variants as a library, we are still not finished with inheritance in Stroscot. We must also examine the common patterns of inheritance to see if there are any other amazing operations hiding in the dark.</p>
<p><span id="id22">[<a class="reference internal" href="../zzreferences.html#id160" title="Ewan Tempero, Hong Yul Yang, and James Noble. What Programmers Do with Inheritance in Java. In David Hutchison, Takeo Kanade, Josef Kittler, Jon M. Kleinberg, Friedemann Mattern, John C. Mitchell, Moni Naor, Oscar Nierstrasz, C. Pandu Rangan, Bernhard Steffen, Madhu Sudan, Demetri Terzopoulos, Doug Tygar, Moshe Y. Vardi, Gerhard Weikum, and Giuseppe Castagna, editors, ECOOP 2013 – Object-Oriented Programming, volume 7920, pages 577–601. Springer Berlin Heidelberg, Berlin, Heidelberg, 2013. URL: http://link.springer.com/10.1007/978-3-642-39038-8_24 (visited on 2022-08-31), doi:10.1007/978-3-642-39038-8_24.">TYN13</a>]</span> found that in Java, on average, 3 out of 4 types were defined using some form of inheritance, and that &gt;99% of inheritance in Java can be classified as subtyping or reuse. Specifically (S a subclass of T):</p>
<ul>
<li><p>Subtyping is where an object of type S is supplied where an object of type T is expected. This can be done by assigning an object of type S to a variable declared to be type T, passing an actual parameter of type S to a formal parameter of type T, returning an object of type S when the formal return type is T, or casting an expression of type S to type T. 76% (range 11% - 100%) of class-class relationships had a subtype usage somewhere in the code. Meyer describes several patterns of subtyping inheritance (assuming B inherits from A):</p>
<ul class="simple">
<li><p>Subtype inheritance - A is partitioned into several disjoint subsets B1, B2, B3.</p></li>
<li><p>Restriction inheritance - B is the subset of A that satisfies a certain constraint, enforced by the constructor and public interface of B. New features should directly follow from the added constraint.</p></li>
<li><p>Reification inheritance - subtype inheritance but specialized to data structures</p></li>
<li><p>Structure inheritance - restriction inheritance but specialized to structures</p></li>
<li><p>View inheritance - A is split into several types B1, B2 where each subtype represents a way of viewing a certain value space. For example 2d_Coordinates is split into Cartesian_Coordinates and Polar_Coordinates, or List is split into ArrayList and LinkedList.</p></li>
</ul>
<p>Stroscot’s expressive type system allows expressing all of these patterns directly, without using inheritance. And the <code class="docutils literal notranslate"><span class="pre">or_subclass</span></code> predicate allows expressing the subtyping inherent to inheritance.</p>
</li>
<li><p>Reuse is when a method not in T, either in S (internal) or not in S (external), invokes a method m() or accesses a field f on an object constructed from type S, and m() or f is declared in T. 22% (4%-88%) of CC edges were external reuse and did not have a subtype usage, while 2% (0.5% - 30%) of CC edges had internal reuse but no subtype use or external reuse. So together these accounted for 24% of edges. Meyer describes a few patterns that seem to fall into this category:</p>
<ul class="simple">
<li><p>Extension inheritance - B introduces attributes not present in A and features not applicable to direct instances of A. This changes the set of values. Myers tries to argue that open records give a subtyping relation, but this is flawed because a self type can appear in both covariant and contravariant positions, so in general B is neither a subtype nor supertype of A.</p></li>
<li><p>Variation inheritance, uneffecting inheritance - B redefines some features of A and does not introduce new attributes or features.</p></li>
<li><p>Implementation inheritance - we want to write a new version of the class with most of the methods shared, but not actually duplicate the file</p></li>
</ul>
<p>These forms of inheritance seem suited for the inheritance library described before. Java-style inheritance actually seems less useful for these cases because it imposes a rigid class structure on reuse. And also, since these patterns are reuse, we could implement them without inheritance, by constructing the objects directly.</p>
</li>
</ul>
<p><span id="id23">[<a class="reference internal" href="../zzreferences.html#id160" title="Ewan Tempero, Hong Yul Yang, and James Noble. What Programmers Do with Inheritance in Java. In David Hutchison, Takeo Kanade, Josef Kittler, Jon M. Kleinberg, Friedemann Mattern, John C. Mitchell, Moni Naor, Oscar Nierstrasz, C. Pandu Rangan, Bernhard Steffen, Madhu Sudan, Demetri Terzopoulos, Doug Tygar, Moshe Y. Vardi, Gerhard Weikum, and Giuseppe Castagna, editors, ECOOP 2013 – Object-Oriented Programming, volume 7920, pages 577–601. Springer Berlin Heidelberg, Berlin, Heidelberg, 2013. URL: http://link.springer.com/10.1007/978-3-642-39038-8_24 (visited on 2022-08-31), doi:10.1007/978-3-642-39038-8_24.">TYN13</a>]</span> also did some analysis on the remaining &lt;0.1% of other relationships. The “constants class” was where a class or interface of only static final constants was inherited from to gain access to the constants. Meyers calls this “facility inheritance”. This accounted for 1% of CC edges in some systems but most had no constant classes. A wildcard import seems a lot more straightforward. One system used a lot of “super” calls in the constructor, but for no discernible reason. Probably not worth emulating. Some “framework” relationships used third party types and could not be analyzed fully due to lack of source code. “Generic” containers cast to Object and back so impeded subtyping analysis - again Stroscot’s type system seems sufficient here. And still other inheritance relationships were just there and no amount of inspection by the authors could discern a useful purpose.</p>
<p>So the conclusion is that no, inheritance is not a silver bullet and the usage patterns are much covered in Stroscot.</p>
</section>
<section id="inheritance-is-not-subtyping">
<h3>Inheritance is not subtyping<a class="headerlink" href="#inheritance-is-not-subtyping" title="Permalink to this heading"></a></h3>
<p>This is the title of <span id="id24">[<a class="reference internal" href="../zzreferences.html#id35" title="William R. Cook, Walter Hill, and Peter S. Canning. Inheritance is not subtyping. In Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL '90, 125–135. New York, NY, USA, December 1989. Association for Computing Machinery. URL: https://doi.org/10.1145/96709.96721 (visited on 2022-12-15), doi:10.1145/96709.96721.">CHC89</a>]</span>, and their argument seems correct. The existence of <code class="docutils literal notranslate"><span class="pre">Lens'</span> <span class="pre">(a+b)</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">view</span> <span class="pre">:</span> <span class="pre">(a+b)</span> <span class="pre">-&gt;</span> <span class="pre">a,</span> <span class="pre">over</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">(a+b)</span> <span class="pre">-&gt;</span> <span class="pre">(a+b)</span> <span class="pre">}</span></code> does not imply a subtype relation - <code class="docutils literal notranslate"><span class="pre">A</span></code> is not a subtype or supertype of <code class="docutils literal notranslate"><span class="pre">A+B</span></code>. Rather <code class="docutils literal notranslate"><span class="pre">A</span></code> is related to <code class="docutils literal notranslate"><span class="pre">A+B</span></code> by a separate “is subcomponent of” relation, as formalized in the Lens type. For example, in <span id="id25">[<a class="reference internal" href="../zzreferences.html#id35" title="William R. Cook, Walter Hill, and Peter S. Canning. Inheritance is not subtyping. In Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL '90, 125–135. New York, NY, USA, December 1989. Association for Computing Machinery. URL: https://doi.org/10.1145/96709.96721 (visited on 2022-12-15), doi:10.1145/96709.96721.">CHC89</a>]</span> section 3.2 page 129 we have a parent constructor <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">self</span> <span class="pre">super</span> <span class="pre">thislvl</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">5,</span> <span class="pre">id</span> <span class="pre">=</span> <span class="pre">self,</span> <span class="pre">eq</span> <span class="pre">=</span> <span class="pre">\o</span> <span class="pre">-&gt;</span> <span class="pre">self.i</span> <span class="pre">==</span> <span class="pre">o.i</span> <span class="pre">}</span></code> and a child constructor <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">self</span> <span class="pre">_</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">true,</span> <span class="pre">eq</span>&#160; <span class="pre">=</span> <span class="pre">\o</span> <span class="pre">-&gt;</span> <span class="pre">o.i</span> <span class="pre">==</span> <span class="pre">self.i</span> <span class="pre">&amp;&amp;</span> <span class="pre">o.b</span> <span class="pre">==</span> <span class="pre">self.b</span> <span class="pre">}</span></code>. We can work out some types: <code class="docutils literal notranslate"><span class="pre">mkObject</span> <span class="pre">[P]</span> <span class="pre">:</span> <span class="pre">mu</span> <span class="pre">self.</span> <span class="pre">{</span> <span class="pre">i</span> <span class="pre">:</span> <span class="pre">int,</span> <span class="pre">id</span> <span class="pre">:</span> <span class="pre">self,</span> <span class="pre">eq</span> <span class="pre">:</span> <span class="pre">{i</span> <span class="pre">:</span> <span class="pre">int}_open</span> <span class="pre">-&gt;</span> <span class="pre">bool</span> <span class="pre">}</span></code> and <code class="docutils literal notranslate"><span class="pre">mkObject</span> <span class="pre">[C,P]</span> <span class="pre">:</span> <span class="pre">mu</span> <span class="pre">self.</span> <span class="pre">{</span> <span class="pre">i</span> <span class="pre">:</span> <span class="pre">int,</span> <span class="pre">id</span> <span class="pre">:</span> <span class="pre">self,</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">bool,</span> <span class="pre">eq</span> <span class="pre">:</span> <span class="pre">{i</span> <span class="pre">:</span> <span class="pre">int,</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">}_open</span> <span class="pre">-&gt;</span> <span class="pre">bool</span> <span class="pre">}</span></code>. The second has more fields than the first, so with closed records they are unrelated types. We might think (as Meyers does) that with open record types we could say that the second (child) type is a subtype of the first. But looking at <code class="docutils literal notranslate"><span class="pre">eq</span></code>, since <code class="docutils literal notranslate"><span class="pre">{i</span> <span class="pre">:</span> <span class="pre">int,</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">}_open</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">{i</span> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">}_open</span></code>, by contravariance the first <code class="docutils literal notranslate"><span class="pre">eq</span></code> type is actually a subtype of the second. So even relaxing our record subtyping definition these are unrelated types.</p>
<p>More generally, all combinations of subtyping and inheritance are possible:</p>
<ul class="simple">
<li><p>S is neither a subtype nor a child type of T - independent types, Boolean and Float</p></li>
<li><p>S is a subtype but is not a child type of T - Int32 and Int64, subset but unrelated by inheritance</p></li>
<li><p>S is not a subtype but is a child type of T - S child of T, S -&gt; S is not a subtype of T -&gt; T</p></li>
<li><p>S is both a subtype and a child type of T - when all inherited fields and methods of the derived type have types which are subtypes of the corresponding fields and methods from the inherited type, and the type is an “open record”</p></li>
</ul>
<p>Note that subtype + derived type is only possible with open records - with closed records no derived type is a proper subtype. <span id="id26">[<a class="reference internal" href="../zzreferences.html#id2" title="Moez AbdelGawad and Robert Cartwright. NOOP: A Domain-Theoretic Model of Nominally-Typed OOP. January 2018. Comment: 23 pages. URL: http://arxiv.org/abs/1801.06793 (visited on 2022-12-27), arXiv:1801.06793.">AC18</a>]</span> formalizes this notion of open records and shows that in Java and other nominally-typed OOP languages, “inheritance is subtyping”. More specifically, “a class B is a subtype
of a class A, in the open record sense, iff B inherits from A.” But this property is obtained by placing restrictions on inheritance - in Java, a method only overrides its parent method if its type matches the parent method, and methods cannot be removed. <span id="id27">[<a class="reference internal" href="../zzreferences.html#id159" title="Antero Taivalsaari. On the notion of inheritance. ACM Computing Surveys, 28(3):438–479, September 1996. URL: https://doi.org/10.1145/243439.243441 (visited on 2022-12-14), doi:10.1145/243439.243441.">Tai96</a>]</span> calls this “strict inheritance”. Strict inheritance is a pretty weird restriction from a unityped perspective - for example in Smalltalk we can override a field and change its value from an int to a string. So this “inheritance is subtyping” property is a form of type discipline, rather than a free property.</p>
<p>Inheritance-as-subtyping is easy to misuse and the Java platform libraries made numerous mistakes: Stack extends Vector, Properties extends Hashtable - in both cases, not using inheritance and thus avoiding the accompanying field/property inclusion would have been preferable. For example, with Properties (<a class="reference external" href="https://codeblog.jonskeet.uk/2006/03/04/inheritancetax/">1</a>), <code class="docutils literal notranslate"><span class="pre">(Properties)</span> <span class="pre">p.getProperty(key)</span></code> takes defaults into account, while <code class="docutils literal notranslate"><span class="pre">p.get(key)</span></code> which is inherited from Hashtable does not, and direct access to the underlying Hashtable allows adding non-String objects, when the designers intended that Properties should only be Strings. Once this invariant is violated, it is no longer possible to use other parts of the Properties API (load and store). Without inheritance-as-subtyping, <code class="docutils literal notranslate"><span class="pre">get</span></code> could have been overridden to be a subtype, and the other Hashtable methods deleted.</p>
<p>Inheritance as subtyping breaks encapsulation, because superclass methods that expect to receive themselves may receive a subclass instance that doesn’t support an expected contract. In particular, a call to self.b in A.a may resolve to an inherited implementation B.b, and this B.b may violate a contract that A.b satisfies. Even adding a method in the subclass can be unsafe, because the superclass can later add the same method and then you are unintentionally overriding it. For this reason languages have added the override annotation so that unintentional overriding generates a warning.</p>
<p>When separating inheritance from type classification, one question is how many different language mechanisms are needed. Bertrand Meyer says that 10 would be needed and implies this is too many, but his list of types of inheritance is duplicative, so he overestimates it. Also, even 10 is not that many, e.g. C has 10 control structures - ternary operator, if, if-else, while, do-while, for, switch, break, continue, and goto. It probably is true that deciding between <code class="docutils literal notranslate"><span class="pre">for</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span></code> wastes some time as Meyer says, but nobody has argued for removing <code class="docutils literal notranslate"><span class="pre">for</span></code> or <code class="docutils literal notranslate"><span class="pre">while</span></code> - although the constructs overlap, they are used in different situations and help to express the intent of the programmer, enhancing readability. Structured programming argues that one should have various loop constructs, even though goto can express any loop. Similarly, even if inheritance can express all the patterns of interest, it is still better to have separate syntax for each pattern of inheritance. Meyer says he has seen no compelling argument, but papers like “Inheritance is not subtyping” seem pretty compelling to me.</p>
<p>After separating inheritance from subtyping, what does it mean to have an abstract method in an interface, <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">:</span> <span class="pre">T1</span></code>? Declaring <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">foo</span> <span class="pre">:</span> <span class="pre">T1</span> <span class="pre">}</span> <span class="pre">+</span> <span class="pre">{</span> <span class="pre">foo</span> <span class="pre">:</span> <span class="pre">...</span> <span class="pre">}</span></code> is meaningless (assuming we never use <code class="docutils literal notranslate"><span class="pre">super.foo</span></code>) because only the type of <code class="docutils literal notranslate"><span class="pre">foo</span></code> on the right matters. So we see that the declaration is an assertion about the result of lookup, that <code class="docutils literal notranslate"><span class="pre">lookup</span> <span class="pre">foo</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">T1</span></code>. Then an interface of abstract methods is the intersection of these types, <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">x</span> <span class="pre">|</span> <span class="pre">foo</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">T1</span> <span class="pre">}</span> <span class="pre">intersect</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">|</span> <span class="pre">bar</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">T2</span> <span class="pre">}</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">|</span> <span class="pre">(foo</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">T1)</span> <span class="pre">&amp;&amp;</span> <span class="pre">(bar</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">T2)</span> <span class="pre">}</span></code>.</p>
</section>
</section>
<section id="polymorphism">
<h2>Polymorphism<a class="headerlink" href="#polymorphism" title="Permalink to this heading"></a></h2>
<p>Polymorphism is a pretty confusing concept. ChatGPT’s definition was (6/10) “the ability of objects to take on different forms, depending on the context in which they are used”, which honestly makes little sense. The object’s methods and properties do not change based on context. Rather, it is (per 2/10 ChatGPT definitions) that a procedure (context) is able to interchangeably handle objects with differing properties and methods.
Specifically, there are three forms of polymorphism. (Per ChatGPT there is no standard “fourth” type of polymorphism in the realm of object-oriented programming.) In order of most common to least in OOP, they are:</p>
<ul class="simple">
<li><p>subtype/interface polymorphism or method overriding. Per <a class="reference external" href="https://en.wikipedia.org/w/index.php?diff=580604701">old Wikipedia</a>  and 2/10 ChatGPT definitions this is what “polymorphism” unqualified generally refers to, and per <a class="reference external" href="https://wiki.c2.com/?PolymorphismEncapsulationInheritance">C2</a> is also the main sense intended for OOP. In this form, a procedure declares itself as taking a parameter typed as some parent class or interface, and then any subclass or instance of that interface may be passed to that procedure. Method overriding may be further classified into “implementation inheritance” or “standard method overriding”, where the method being overridden has a concrete implementation in the superclass, and “interface inheritance” or “interface method implementation”, where the method is abstract in the superclass. This form originated from Simula basically simultaneously with inheritance, for example in <span id="id28">[<a class="reference internal" href="../zzreferences.html#id40" title="Ole-Johan Dahl, Bjørn Myhrhaug, and Kristen Nygaard. Common Base Language. October 1970. URL: https://www.ics.uci.edu/~jajones/INF102-S18/readings/10_Simula.pdf (visited on 2022-12-20).">DMN70</a>]</span> page 25 they present an example of overriding a string hashing function with a subclass method that skips underscore characters.</p></li>
<li><p>parametric polymorphism (Java generics/C++ templates). The procedure declares a type parameter and constraints and then may be used with any type satisfying those constraints. The same code is used for multiple types.</p></li>
<li><p>ad-hoc polymorphism or method overloading. Multiple procedure implementations are declared with the same name but different types, and the appropriate procedure is called based on the arguments passed. It is not supported in Python; the most recent definition of a name overwrites any previous ones.</p></li>
</ul>
<section id="minimal-oo">
<h3>Minimal OO<a class="headerlink" href="#minimal-oo" title="Permalink to this heading"></a></h3>
<p>Uncle Bob <a class="reference external" href="https://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html">defines</a> OO by distinguishing <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">o</span></code> from <code class="docutils literal notranslate"><span class="pre">o.f()</span></code>. With Uniform Function Call Syntax there is no difference. But, he argues, in an OO language <code class="docutils literal notranslate"><span class="pre">o.f()</span></code> is overloaded - it does dynamic dispatch based on the type of <code class="docutils literal notranslate"><span class="pre">o</span></code>. Whereas with <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">o</span></code> there is usually only one group of clauses for <code class="docutils literal notranslate"><span class="pre">f</span></code>. Bob also wants to exclude implementations of dynamic dispatch that work by modifying <code class="docutils literal notranslate"><span class="pre">f</span></code> to use switch statements or long if/else chains. So he excludes dynamic dispatch that creates a source code dependency from <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">o</span></code> to <code class="docutils literal notranslate"><span class="pre">f</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">o</span></code> “knows” <code class="docutils literal notranslate"><span class="pre">f</span></code>. Instead there must be several clauses for <code class="docutils literal notranslate"><span class="pre">f</span></code> which may be called. Concretely, Bob says, one should be able to write <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">o</span></code> in source file A and an implementation of <code class="docutils literal notranslate"><span class="pre">f</span></code> in source file B and there should be no use/require/import declaration from A to B.</p>
<p>Stroscot has predicate dispatch and multimethods. So all functions can be overloaded and do dynamic dispatch. Stroscot solves the expression problem, so there is no boilerplate needed when extending <code class="docutils literal notranslate"><span class="pre">f</span></code>. Furthermore, Stroscot uses a recursive knot so definitions are properly in scope. So Stroscot’s multimethods are enough to make it OO in Bob’s minimalist sense.</p>
</section>
<section id="interfaces">
<h3>Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this heading"></a></h3>
<p>The “fragile base class” problem is that a subclass may break if its parent changes its self-use of methods, even though the subclass’s code has not been touched. Every downcall generates a code coupling that must be documented and maintained. For example in <span id="id29">[<a class="reference internal" href="../zzreferences.html#id12" title="Artima - Java Design Issues. URL: https://www.artima.com/articles/java-design-issues (visited on 2022-12-13).">Art</a>]</span>, there is mentioned the situation where a List class has add and addAll methods and one wants to write a CountingList class that overrides add and addAll to count the total number of elements added. This cannot be done properly without knowing whether List.addAll does a downcall to List.add.</p>
<p>One solution is to remove downcalls: if <code class="docutils literal notranslate"><span class="pre">self</span></code> is not an argument to the constructor passed to <code class="docutils literal notranslate"><span class="pre">mkObject</span></code>, and only <code class="docutils literal notranslate"><span class="pre">thislvl</span></code> is used, then there is no encapsulation issue. Unfortunately <span id="id30">[<a class="reference internal" href="../zzreferences.html#id160" title="Ewan Tempero, Hong Yul Yang, and James Noble. What Programmers Do with Inheritance in Java. In David Hutchison, Takeo Kanade, Josef Kittler, Jon M. Kleinberg, Friedemann Mattern, John C. Mitchell, Moni Naor, Oscar Nierstrasz, C. Pandu Rangan, Bernhard Steffen, Madhu Sudan, Demetri Terzopoulos, Doug Tygar, Moshe Y. Vardi, Gerhard Weikum, and Giuseppe Castagna, editors, ECOOP 2013 – Object-Oriented Programming, volume 7920, pages 577–601. Springer Berlin Heidelberg, Berlin, Heidelberg, 2013. URL: http://link.springer.com/10.1007/978-3-642-39038-8_24 (visited on 2022-08-31), doi:10.1007/978-3-642-39038-8_24.">TYN13</a>]</span> measured that 0-86% (median 34%) of inheritance relationships have a downcall. Although some projects are at 0, suggesting it is possible to avoid downcalls, the prevalance of this practice suggests they cannot be removed categorically and some form of downcalling must be supported. But it certainly makes senser to give downcalls more verbose syntax rather than the simple syntax <code class="docutils literal notranslate"><span class="pre">this.method()</span></code>.</p>
<p>A less restrictive solution is to ensure that for every downcall, the downcalled method is abstract in the current class. That way the code coupling is self-documenting - the developer can just check the class definition to see what is a downcall. So what is prohibited is “implementation inheritance”, i.e. the situation where there is a concrete method <code class="docutils literal notranslate"><span class="pre">A.a</span></code> being overridden by a concrete method <code class="docutils literal notranslate"><span class="pre">B.a</span></code> and a method in A calls <code class="docutils literal notranslate"><span class="pre">A.a</span></code>. Rust, Julia, Go, and Swift have all adopted this style of programming, under various names such as trait, interface, or prototype-oriented programming. Even Java 8 added default methods and static methods to interfaces. There is an associated nomenclature change. Now a concrete method is referred to (in Swift) as “a default implementation of a required method”, and the most-derived class is given the normal name “class” while the other classes in the chain are given a more unusual name like interfaces, mixins, or traits, and are not allowed to be directly instantiated. This terminology makes the special role of the final class in the inheritance chain clear. And multiple inheritance works better - conflicting definitions can simply error if there is no most-specific definition, and the developer can solve such issues by defining the method in the most-derived class.</p>
<p>But actually, these languages have not “solved” the issue at all in a technical sense. Although most of the time the method is left abstract and implemented in the most-derived class, so the fragile base class problem is avoided, implementation inheritance is still there: you can override an interface and replace one of its default methods. The difference is rather a culture change: overridable methods in interfaces are all marked as default, so it is clear that they are expected to be overridden. And in Swift, non-overridable (final) methods are the default, so you have to jump through several hoops to actually implement the “bad” implementation inheritance pattern.</p>
</section>
<section id="multimethods">
<h3>Multimethods<a class="headerlink" href="#multimethods" title="Permalink to this heading"></a></h3>
<p>Interfaces etc. are a morass of complexity. Generally these declare one, two, three, four functions or more. But it’s not particularly clear how to structure that: How many interfaces do you have? Do you have one interface per function, one interface with all the functions, or something in between? There’s no clear guidance. And it’s an important decision because you can’t remove a method from an interface later on without breaking lots of code. The safest decision is one function per interface, and never more or less, because that way you’ll never need to remove a function from an interface, and a zero-function marker interface is trivial and mostly useless.</p>
<p>Obviously though this will require a lot more interfaces. There is already a naming problem where you don’t know which interface a method is coming from, and this will make it worse. Who is going to remember that <code class="docutils literal notranslate"><span class="pre">summarize</span></code> comes from the <code class="docutils literal notranslate"><span class="pre">Summary</span></code> interface rather than <code class="docutils literal notranslate"><span class="pre">Summarizer</span></code>, or that <code class="docutils literal notranslate"><span class="pre">next</span></code> comes from <code class="docutils literal notranslate"><span class="pre">Iterator</span></code>?  The solution is to once again introduce some order into the chaos, this time by mandating a uniform naming scheme based on the method name. For example we could call each interface <code class="docutils literal notranslate"><span class="pre">&lt;method_name&gt;_interface</span></code>. It’s not going to win any writing awards, but it works.</p>
<p>At this point though developers will start complaining about how tedious it is. We’ve taken all the fun out of using interfaces, and it is just tedious boilerplate now:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">interface</span><span class="w"> </span><span class="n">lookup_protocol</span>
<span class="w">  </span><span class="n">lookup</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">T1</span>

<span class="kr">class</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="n">implements</span><span class="w"> </span><span class="n">lookup_protocol</span>
<span class="w">  </span><span class="n">lookup</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">T1</span>
<span class="w">  </span><span class="n">lookup</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span>
</pre></div>
</div>
<p>Fortunately in Stroscot we don’t need this boilerplate, we can just use multimethods:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lookup_protocol</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">lookup</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T1</span><span class="w"> </span><span class="p">}</span>

<span class="nf">lookup</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">A</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span>

<span class="nf">assert</span><span class="w"> </span><span class="p">(</span><span class="n">lookup_protocol</span><span class="w"> </span><span class="kt">A</span><span class="p">)</span>
</pre></div>
</div>
<p>tl;dr interfaces are just a verbose chaotic version of multimethods. As a corollary of this, Stroscot has no methods defined “inside” a type - you write <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">=</span> <span class="pre">...;</span> <span class="pre">method</span> <span class="pre">=</span> <span class="pre">...</span></code> rather than <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">...;</span> <span class="pre">method</span> <span class="pre">;</span> <span class="pre">...</span> <span class="pre">}</span></code>. They are all “free functions” or “extension methods”.</p>
<p>We can also implement virtual methods via Stroscot’s multimethods, assigning everything the same priority to use the specificity mechanism to implement overriding, and using module definition recursion to do the knot tying. This separates data from behavior which is a more functional style. Careful use of single arguments and lambdas allow mimicking single dispatch, matching Smalltalk’s virtual method semantics. Smalltalk also allows accessing the parent method like <code class="docutils literal notranslate"><span class="pre">super.method1</span></code>; in Stroscot this rather is done with <code class="docutils literal notranslate"><span class="pre">next_method</span></code> when in <code class="docutils literal notranslate"><span class="pre">C.method1</span></code>. Outside <code class="docutils literal notranslate"><span class="pre">C.method1</span></code>, we can call <code class="docutils literal notranslate"><span class="pre">P.method1</span></code> with something like <code class="docutils literal notranslate"><span class="pre">(lookup_clause</span> <span class="pre">method1</span> <span class="pre">(self</span> <span class="pre">:</span> <span class="pre">C</span> <span class="pre">or_subclass)).next_method</span></code>; we have to use this convoluted mechanism if we want to mimic calling <code class="docutils literal notranslate"><span class="pre">super.method2</span></code>. So similar to Ecstasy, we have a restricted <code class="docutils literal notranslate"><span class="pre">super</span></code> call for the most part. Similarly doing <code class="docutils literal notranslate"><span class="pre">(lookup_clause</span> <span class="pre">method1</span> <span class="pre">(self</span> <span class="pre">:</span> <span class="pre">C</span> <span class="pre">or_subclass))</span></code> without the <code class="docutils literal notranslate"><span class="pre">next_method</span></code>, we can access <code class="docutils literal notranslate"><span class="pre">thislvl</span></code>. Again it is more convoluted than a keyword, although a macro could fix this.</p>
<p>If we code the arguments naturally using multiple dispatch then of course we get multiple dispatch. E.g. I implemented equality on ColorPoints and Points, the only non-degenerate one per <a class="reference external" href="https://www.artima.com/articles/how-to-write-an-equality-method-in-java">Artima</a>. I would argue that the multimethods are a clear win here over Artima’s implementation as we can just write the clauses - the <code class="docutils literal notranslate"><span class="pre">instanceof</span></code> is implicit in the specificity matching, and there is no separate <code class="docutils literal notranslate"><span class="pre">canEqual</span></code> method. And if we removed <code class="docutils literal notranslate"><span class="pre">or_subclass</span></code> then we would not be overriding at all and the <code class="docutils literal notranslate"><span class="pre">false</span></code> clauses and priority equalization would not be needed - Points and ColorPoints would simply be treated as disjoint types and comparison between them would not be defined.</p>
<p>The biggest issue with multimethods is per <span id="id31">[<a class="reference internal" href="../zzreferences.html#id159" title="Antero Taivalsaari. On the notion of inheritance. ACM Computing Surveys, 28(3):438–479, September 1996. URL: https://doi.org/10.1145/243439.243441 (visited on 2022-12-14), doi:10.1145/243439.243441.">Tai96</a>]</span> pg. 473 they “do not feel object-oriented”. Because the operations are not logically “contained” in the object, but rather live in a separate “method dispatch” namespace, e.g. using the traditional function syntax <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span></code> rather than the infix <code class="docutils literal notranslate"><span class="pre">a.f(b)</span></code>, there is no clear boundary for the internal vs. external methods of an object. We can define such a boundary using module encapsulation, but it is not as tidy as the methods-fields package offered by traditional OO. It is not clear that such a boundary is useful, though.</p>
</section>
<section id="multiple-implementations">
<h3>Multiple implementations<a class="headerlink" href="#multiple-implementations" title="Permalink to this heading"></a></h3>
<p>In a lot of languages there’s a restriction that interfaces can be implemented only once for a given type. This is Stroscot’s restriction too: because of how overloading works, a function can be implemented only once in a module. There are ways to work around this. Java has the adapter pattern, and similarly Idris allows <a class="reference external" href="https://docs.idris-lang.org/en/latest/tutorial/interfaces.html#named-implementations">named implementations</a>. In Stroscot, we can just write <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">{</span> <span class="pre">method1</span> <span class="pre">=</span> <span class="pre">...,</span> <span class="pre">method2</span> <span class="pre">=</span> <span class="pre">...</span> <span class="pre">}</span></code> and override the methods using implicit parameters.</p>
<p>Now with multiple implementations floating around we often want to use these as a value. There’s no issue with this in Stroscot. For example, sets and maps need a comparison operator, and this has to be consistent so that you don’t insert with comparison A and removing with comparison B. To avoid inconsistent comparisons the map or set can store the comparison operator as a parameter on creation - it is simply a function after all.</p>
</section>
</section>
<section id="design-patterns">
<h2>Design patterns<a class="headerlink" href="#design-patterns" title="Permalink to this heading"></a></h2>
<p>Design patterns are not really OO, but <span id="id32">[]</span> is subtitled “reusable object-oriented software”, and the naming patterns of extremely long Java class names like <code class="docutils literal notranslate"><span class="pre">AbstractVisitorManagerFactoryProvider</span></code> originated from that book, so there’s not really a better place to discuss it. Essentially, the “Gang of Four” described 23 patterns of structuring objects. Since then, the patterns have held up pretty well - per <span id="id33">[]</span> the authors did a session in 2005, and the only changes they wanted to make would be dropping Singleton, combining Abstract Factory and Factory Method to Factory, and adding Null Object, Type Object, Dependency Injection, and Extension Object from Pattern Languages of Program Design 3. They would also redo the categories, but those aren’t essential. Similarly, besides the Gang of Four patterns, Wikipedia has only added 14 “other” patterns to its “Software design patterns” infobox. But Wikipedia also lists new categories of “concurrency”, “network architecture”, and “functional” patterns.</p>
<p>As many have observed, e.g. as cited on <a class="reference external" href="https://en.wikipedia.org/wiki/Software_design_pattern#Criticism">Wikipedia</a> and <a class="reference external" href="https://wiki.c2.com/?DesignPatternsAreMissingLanguageFeatures">C2</a>, design patterns are really missing language features. The point of examining these patterns is to ensure that Stroscot can easily express each pattern with minimal boilerplate, rather than to hold them up as examples of great program design. To use <span id="id34">[]</span>’s words, the patterns should be “invisible”, so much a part of the language that you don’t notice using them.</p>
<ul class="simple">
<li><p>Active object</p></li>
<li><p>Active record</p></li>
<li><p>Actor</p></li>
<li><p>Adapter - this is just writing a module that imports another module and wraps its functionality.</p></li>
<li><p>ADR</p></li>
<li><p>Applicative</p></li>
<li><p>Balking</p></li>
<li><p>Barrier</p></li>
<li><p>Binding properties</p></li>
<li><p>Blackboard</p></li>
<li><p>Bridge - this is done by passing in a parameter to the module or function, and overloading on its value.</p></li>
<li><p>Broker</p></li>
<li><p>Builder - in Stroscot, macros make it easy to parse an AST and return a value. The AST does not need to be valid Stroscot code at all (the typical verbose <code class="docutils literal notranslate"><span class="pre">buildX</span></code>, <code class="docutils literal notranslate"><span class="pre">buildY</span></code> chain of statements), giving the flexibility of using a DSL such as JSON or XML to specify the data in a more compact manner. Furthermore, it is easy to define an intermediate representation and convert the data to that, rather than directly returning an object, allowing multiple forms of “building” such as the size counting example.</p></li>
<li><p>Business delegate</p></li>
<li><p>CBD</p></li>
<li><p>Chain of responsibility</p></li>
<li><p>Circuit Breaker</p></li>
<li><p>Client–server</p></li>
<li><p>Closure</p></li>
<li><p>Command</p></li>
<li><p>Comonad</p></li>
<li><p>Compensating Transaction</p></li>
<li><p>Composite - this is represented using the tree structure of symbols, or as a graph of references. Since Stroscot is unityped there is no need for inheritance.</p></li>
<li><p>Composite entity</p></li>
<li><p>Compute kernel</p></li>
<li><p>Coroutine</p></li>
<li><p>CQRS</p></li>
<li><p>Currying</p></li>
<li><p>Data access object (DAO)</p></li>
<li><p>Data transfer object (DTO)</p></li>
<li><p>DDD</p></li>
<li><p>Decorator - In a unityped language, this is just defining a wrapper around another value. Hard to distinguish from the adapter or facade patterns.</p></li>
<li><p>Delegation - this is overloading each method to also work on the wrapper. Maybe can be automated with a macro.</p></li>
<li><p>Dependency injection</p></li>
<li><p>Double-checked locking - The goal of this is lazy initialization, it is really the implementation of that pattern.</p></li>
<li><p>ECB</p></li>
<li><p>ECS</p></li>
<li><p>EDA</p></li>
<li><p>Event-based asynchronous</p></li>
<li><p>Facade - this is writing a record with multiple fields and an operation on those fields. not particularly complex.</p></li>
<li><p>Factory</p>
<ul>
<li><p>Abstract factory - In Stroscot, if there is a need for a cross-platform or pluggable interface, then overloading can be used to seamlessly combine multiple implementations into one interface. Each implementation can guard that a configuration option is a specific value. This option can be specified as an implicit parameter, rather than as an option on a singleton. As in the book’s Smalltalk example, the creation methods themselves can be redefined using implicit parameters to use specialized behavior for a specific type of object creation.</p></li>
<li><p>Factory method - As discussed in the section “No constructors” above, in Stroscot, every “constructor” is simply an ordinary unrestricted function and has the power of a factory method to return multiple types of concrete objects and hide these behind an abstract type signature.</p></li>
</ul>
</li>
<li><p>Fiber</p></li>
<li><p>Filters</p></li>
<li><p>Flyweight - this is just using a shared reference, and I think Stroscot will hash cons shared immutable data automatically or at least use optimal reduction to avoid duplicating data too much</p></li>
<li><p>Free monad</p></li>
<li><p>Front controller - This is using a handler function or three and an overloaded controller function. Seems straightforward.</p></li>
<li><p>Function composition</p></li>
<li><p>Functor</p></li>
<li><p>Futex</p></li>
<li><p>Futures and promises</p></li>
<li><p>Generator</p></li>
<li><p>Guarded suspension</p></li>
<li><p>HOF</p></li>
<li><p>Identity map</p></li>
<li><p>Immutable object</p></li>
<li><p>Implicit invocation</p></li>
<li><p>Index Table</p></li>
<li><p>Intercepting filter</p></li>
<li><p>Interceptor</p></li>
<li><p>Interpreter</p></li>
<li><p>Inversion of control</p></li>
<li><p>Iterator</p></li>
<li><p>Join</p></li>
<li><p>Lazy initialization - memoization of computing the value of a variable. Computations without side effects are automatically delayed to their point of use and evaluated exactly once if it will improve performance, but I guess Stroscot should have a <code class="docutils literal notranslate"><span class="pre">compute_once</span></code> function for imperative actions that works through the combination of lazy evaluation and unsafePerformIO. It should use a race-free version of double-checked locking.</p></li>
<li><p>Lazy loading</p></li>
<li><p>Leader Election</p></li>
<li><p>Leaders/followers</p></li>
<li><p>Lock</p></li>
<li><p>Mangler</p></li>
<li><p>MapReduce</p></li>
<li><p>Marker interface - in Stroscot we just use a set, like <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">Market</span> <span class="pre">default</span> <span class="pre">empty;</span> <span class="pre">FooClass</span> <span class="pre">subset</span> <span class="pre">Marker</span></code></p></li>
<li><p>Materialized View</p></li>
<li><p>Mediator</p></li>
<li><p>Memento</p></li>
<li><p>Messaging</p></li>
<li><p>Method chaining</p></li>
<li><p>Microservices</p></li>
<li><p>Mock object</p></li>
<li><p>Model 2</p></li>
<li><p>Module - Stroscot directly supports modules</p></li>
<li><p>MOM</p></li>
<li><p>Monad</p></li>
<li><p>Monitor</p></li>
<li><p>Monoid</p></li>
<li><p>Monolithic</p></li>
<li><p>Multitier (n-tier)</p></li>
<li><p>Multiton - per <span id="id35">[]</span> pg. 341, a multiton is “any type with a restricted set of values”. Taking this literally, this is simply a refinement type - for example we can make an enumeration of cases and get an ADT.</p></li>
<li><p>MVA</p></li>
<li><p>MVC</p></li>
<li><p>MVC</p></li>
<li><p>MVP</p></li>
<li><p>MVVM</p></li>
<li><p>Naked objects</p></li>
<li><p>Nuclear</p></li>
<li><p>Null object</p></li>
<li><p>Object pool - this is a memory/resource management technique, combined with the factory method pattern</p></li>
<li><p>Observer</p></li>
<li><p>ORB</p></li>
<li><p>P2P</p></li>
<li><p>PAC</p></li>
<li><p>Pipes</p></li>
<li><p>Proactor</p></li>
<li><p>Prototype - objects are just data, so modifying an object always creates a new object, without the need for an explicit clone operation</p></li>
<li><p>Proxy - just another name for writing wrappers, like the delegation pattern</p></li>
<li><p>Publish–subscribe</p></li>
<li><p>Publisher-Subscriber</p></li>
<li><p>RAII - this is implemented in Stroscot with finalizers, which generalize RAII to heap usage</p></li>
<li><p>Reactor</p></li>
<li><p>Read write lock</p></li>
<li><p>Resource acquisition is initialization</p></li>
<li><p>REST</p></li>
<li><p>SBA</p></li>
<li><p>Scheduled-task pattern</p></li>
<li><p>Scheduler</p></li>
<li><p>Servant</p></li>
<li><p>Service locator</p></li>
<li><p>Sharding</p></li>
<li><p>Singleton - this is essentially a global variable, and is now considered an antipattern. Stroscot instead has implicit variables, which are passed down from the program start to its site of usage.</p></li>
<li><p>SN</p></li>
<li><p>SOA</p></li>
<li><p>Specification</p></li>
<li><p>State</p></li>
<li><p>STM</p></li>
<li><p>Strategy</p></li>
<li><p>Template method</p></li>
<li><p>Thread pool</p></li>
<li><p>Thread-local storage</p></li>
<li><p>Throttling</p></li>
<li><p>Twin - this seems like implementing multiple inheritance manually</p></li>
<li><p>Type tunnel</p></li>
<li><p>Visitor</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Modules.html" class="btn btn-neutral float-left" title="Modules" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="PackageManager.html" class="btn btn-neutral float-right" title="Package manager" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>