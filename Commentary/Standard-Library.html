<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Standard library &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=7f41d439"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Stateful programming" href="State.html" />
    <link rel="prev" title="Sets" href="Sets.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Aspects.html">Aspects</a></li>
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler-Library.html">Compiler library</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="FunctionalLogic.html">Functional logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="OpPrims.html">Operational primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Security.html">Security</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Standard library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#library-checklist">Library checklist</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scope">Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="#evolution">Evolution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stability">Stability</a></li>
<li class="toctree-l3"><a class="reference internal" href="#processes">Processes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#blessed-prelude">Blessed prelude</a></li>
<li class="toctree-l3"><a class="reference internal" href="#security">Security</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Symbolic.html">Symbolic computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Values.html">Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Standard library</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Standard-Library.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="standard-library">
<h1>Standard library<a class="headerlink" href="#standard-library" title="Link to this heading"></a></h1>
<p>What is a good standard library? Well, in Stroscot, the goal of the standard library is to simplify the question “For this task, how do I use a 3rd party library?”. Obviously, writing your own code is fun and all. But life is short, and reinventing the wheel is a waste of man‑hours that can be better spent elsewhere.
Still, there is a lot of due diligence necessary to use a 3rd party library. The standard library is the “opinionated and supported path” to build programs. (<a class="reference external" href="https://engineering.atspotify.com/2020/08/how-we-use-golden-paths-to-solve-fragmentation-in-our-software-ecosystem/">Spotify</a>) The library team has already done the due diligence, identified the “golden path”, and any caveats will be noted in the documentation.</p>
<p>Of course, sometimes the solution you want is not in the standard library, but that’s where continuously expanding the standard library can help. In an ideal world, the standard library would offer a common set of abstractions used by all programs that covers all use cases. Eventually, even if a user needs an unusual data structure like a Y-fast trie, they should be able to find it in the standard library.</p>
<section id="library-checklist">
<h2>Library checklist<a class="headerlink" href="#library-checklist" title="Link to this heading"></a></h2>
<p>The standard library is essentially a shortcut for using 3rd party libraries in general. So let’s look at that process for <a class="reference external" href="https://chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party.md">Chromium</a>:</p>
<ul class="simple">
<li><p>Identify a necessary piece of functionality.</p></li>
<li><p>Find various implementations (e.g. by trawling through Google, Github, or Bitbucket search results)</p></li>
<li><p>Filter to ones with acceptable licenses (e.g., no closed source components, MIT/X11/BSD/Apache 2.0/GPL/LGPL/MPL)</p></li>
<li><p>Determine subjective quality: Is there an issue tracker? If so, how many bugs are reported and how quickly are they resolved? Is the API easy to use? What do users report the performance / memory usage is like?</p></li>
<li><p>Determine objective quality: Is the code readable? Does it have good documentation?  Has the code been profiled and optimized?</p></li>
<li><p>Determine stability: How long has the project been around? What have the recent releases been called (patches, betas, etc.), and is there a promised support schedule? Do release notes frequently describe breaking changes? Is there a test suite and release checklist for ensuring quality?</p></li>
<li><p>Determine size: How large is the source code? How long does it take to build? What is the increase in binary size for a typical project?</p></li>
<li><p>Determine maintenance: Who will maintain the library? (Existing maintainer, standard library team)</p></li>
<li><p>Determine compatibility: What platforms are supported? Does it use the FFI and link with code written in another programming language?</p></li>
<li><p>Choose the best choices among the alternatives, and make a pro/con matrix so it is easy to understand which library should be used where.</p></li>
<li><p>Fork the code and mirror the history into a Git repo. This makes it easy to maintain the code, particularly time-sensitive security patches, segregates the code so it is easy to track license/credit/necessary attributions, and avoids any issues with hosting going down.</p></li>
<li><p>Add metadata:</p>
<ul>
<li><p>Name: Descriptive name of the package</p></li>
<li><p>Description: A short description of what the package is and is used for.</p></li>
<li><p>Version: (OPTIONAL) A version number for the package. Otherwise, the Git revision hash is used.</p></li>
<li><p>Local Modifications: Enumerate any changes that have been made locally to the package from the upstream version. (Note that e.g. Apache-2 also requires notice in each modified file)</p></li>
<li><p>License: The license under which the package is distributed. Probably best to use SPDX identifiers.</p></li>
<li><p>License File: File that contains a copy of the package’s license or credits.</p></li>
<li><p>Security Critical: A package is security-critical if it accepts untrustworthy inputs from the internet, parses or interprets complex input formats sends data to internet servers, collects new data, or influences or sets security-related policy (including the user experience)</p></li>
<li><p>Identifiers: (OPTIONAL) A dictionary of identifiers which represent the upstream package, e.g. short name, upstream URL/repo (for detecting new versions), and ‘common platform enumerations’ (<a class="reference external" href="https://nvd.nist.gov/products/cpe/search">https://nvd.nist.gov/products/cpe/search</a>), which allow automated detection and reporting of known vulnerabilities.</p></li>
<li><p>Hashes: technically this is in the git revisions, or git tags, but GPG signatures and SHA hashes should be recorded</p></li>
<li><p>Owners: at least two people on the standard library team, who have the responsibility to keep the library updated with upstream and any security packages. Of course most updates are automated, so it is really just fixing broken stuff.</p></li>
</ul>
</li>
<li><p>Security review by the security team</p></li>
<li><p>File-by-file license review by script or person</p></li>
<li><p>Refactor other libraries to use the chosen library, so that there is not duplicate code</p></li>
</ul>
<p>Pretty much all these steps seem suitable as requirements to evaluate something for inclusion in the standard library.</p>
</section>
<section id="scope">
<h2>Scope<a class="headerlink" href="#scope" title="Link to this heading"></a></h2>
<p>Currently, since the language is unimplemented, the standard library doesn’t exist. Although it would be nice if we had a standard library ready-made, the lack of a standard library is honestly not a bad state of affairs, compared to having a bad standard library. C’s standard library is so small and old that barely anyone knows it is there, and C++ has a standard library but it has so many forks and unused areas that it’s not really a standard. Of course, for implementing the language, it is necessary to have some basic functions; these are termed the “compiler library” and discussed in a separate document. In the near term, Stroscot’s compiler library will grow, and it will also be encouraged that everyone develops their own competing non-standard libraries. Then, as the good and the bad parts of each library becomes clear, the “standard” library will emerge following an evolutionary process.</p>
<p>Generally speaking, non-standard libraries should be in active development. The main advantage of being outside the standard library is rapid iteration: there’s less pressure to maintain compatibility, and development can focus on achieving a good design. Once a library is stable, in the sense of “no major API changes”, it might as well go through the standards process and become available to import without the extra installation step. The few kilobytes overhead of additional code is pretty small. The standard library provides discoverability and maintenance benefits over isolated libraries. For example incorporation solves the <a class="reference external" href="https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/">left-pad</a> issue where key libraries are maintained by solo developers with no oversight. Since it’s all FLOSS, licensing should not be an issue, and presumably most developers will be happy to share maintainershup and join the team, or relinquish maintainance entirely.</p>
<p>The main goal of standardization is to solve fragmentation. With no effort to standardize, over time, sharing code becomes problematic because pieces of code become tied to one or another mutually incompatible libraries, and there are endless flamewars and newcomers get turned off by decision paralysis. Example: <a class="reference external" href="https://github.com/fosskers/scalaz-and-cats">scalaz vs cats</a> was an issue with Scala for a long time, before <a class="reference external" href="https://www.reddit.com/r/scala/comments/afor0h/scalaz_8_timeline/">it became clear</a> that Scalaz 8 would never be released and scalaz was effectively dead, thus making cats the go-to choice. There is a possibility that standardizing a solution in the standard library will crowd out other solutions, but discussing trade-offs and linking alternative libraries in the standard library documentation is probably sufficient, as after all the discussion process will presumably have created some intelligent reasoning behind choosing one library as standard. It doesn’t really matter if the wrong decision is made because a robust evolution process means it can always be changed later, and in the short term 50% standardized is better than 0% standardized even if there is a (not-at-all obvious) 60% option. What is problematic is letting a split continue to fester without a clear path forward.</p>
<p>The language itself can also suffer from ecosystem fragmentation, where programs end up being written in different “dialects” (specifically, the old and new versions, e.g. we are considering C++11 and C++14 as different dialects). So, we cannot prohibit fragmentation; it will happen regardless, unless we bury our hands in the sand and freeze everything entirely. But if we do that, then a new, completely incompatible language will arise and take over.</p>
</section>
<section id="evolution">
<h2>Evolution<a class="headerlink" href="#evolution" title="Link to this heading"></a></h2>
<p>Try as we might, no design is perfect. Languages and libraries inevitably change and extend their semantics over time. Most changes are simply the addition of new features or libraries, but sometimes the changes break compatibility. According to <a class="reference external" href="https://youtu.be/fJvPBHErF2U?t=4827">Herb Sutter</a>, if you make a breaking change and don’t provide a migration path beyond “modify your codebase wholesale”, you can expect the old version to stick around for approximately 11-12 years, and maybe even beyond (Python had ~10% still using 2.x even after 12 years).</p>
<p>Perl 6 trap - why did it end up Raku?</p>
<p>Making breaking changes is hard. Just like merging was hard, before Git. It’s a similar sort of situation: updating libaries and compilers is generally considered to be something really quite painful and hard in most programming languages. They’re generally planned in advance for weeks, because they’re a big deal, an all-or-nothing situation. That kind of planning wasn’t acceptable to Linus Torvalds, because he did tens of merges a day. Similarly, a large, active library community could easily achieve 10 library updates a day. It shouldn’t be acceptable for Stroscot to delay these updates. In fact, library updates should be instant: the change gets approved, it gets pushed to the servers, every system downloads it on the next build, and it’s applied automatically. There should be zero human involvement in the actual update process. If updating to the new version requires changes, the changes should be automated as well. And it is unacceptable for the automation to fail - everyone has to update, and if the automatic update doesn’t work, then people will make different workarounds for the update and everyone’s source trees will go out of sync. As Guido van Rossum discusses, Python’s 2to3 tool covered 95% of the rewrites needed, but that last 5% prevented anyone from taking 2to3 seriously. Projects ended up simply avoiding the API that the tool didn’t handle and wrote in “Python 2 intersect 3”, the least common denominator. If the change can’t be automated then it should be handled by adding a new independent API, separate from the old one, creating “Python 2 union 3”, rewriting what can be rewritten automatically and warning on what cannot, and then deprecating the old API and eventually removing it. This pattern happened for example with Java’s <code class="docutils literal notranslate"><span class="pre">nio</span></code> (“new I/O”) package, minus the removal part.</p>
<p>If updating to the new version requires changes, the changes should be automated as well. And it is unacceptable for the automation to fail - everyone has to update, and if it isn’t automated then people will make different workarounds for the update and everyone’s source trees will go out of sync.</p>
<p>If you’re worried about security, improve the approval process - more reviewers, mandated waiting and comment periods, maybe add some cryptographic signatures. It’s not like anyone actually looks at the list of thousands of downloaded/updated libraries when they do <code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">update</span></code>.</p>
<p>How do we test these changes? Semver doesn’t help - some newbie developer changes the defaults, and they’re like “I didn’t change the API” so they just bump the patch level. It’s easy to miss API incompatibilities and no amount of manual review is going to catch everything. So update testing has to be automated as well - verify that the new version passes all the tests, and because the tests are incomplete, verify that the new version has identical behavior to the old version using bisimulation.</p>
</section>
<section id="stability">
<h2>Stability<a class="headerlink" href="#stability" title="Link to this heading"></a></h2>
<p>We can aim to minimize the disruption of the evolutionary process to existing code. In particular, by discretizing evolution into units of “features” and “versions”, we can provide a compatibility promise that the source code of existing programs written for an old version can be automatically migrated to a new version.</p>
<p>Furthermore, the versioning process aims to determine a standardized, stable set of features, so by encouraging the use of approved versions of the language, the overall community can avoid fragmentation, even if there are several dialects of the language in use at any one time.</p>
<p>A feature is a distinct chunk of functionality, such as a change to the semantics of the language, a compiler plugin, an external tool integration, or a new or updated standard library module. A feature can be alpha, beta, or stable.</p>
<p>Alpha features are experimental features with little formal testing, released to get feedback. They may be documented informally or on an “alpha features” page. Alpha features have no compatibility guarantee and may be changed freely. Alpha features are kept behind feature toggles, which allow conditioning code on a feature. This allows testing features and integrating them on the main branch while isolating them from other tests and software releases. Alpha features will be removed from the compiler if they have not made any progress towards beta over the course of a year.</p>
<p>Beta features are implemented features that may change further. They must have a reasonable test suite and be documented in the commentary / reference in full detail, describing edge cases. They must also have a how-to if the feature’s usage is not obvious. Fundamental new features may affect the tutorial as well, although generally new features are too advanced. Beta features cannot be toggled off but have automigration functionality for old code that is enabled by specifying the language version. Automigration is distinct from a toggle because it is a source-to-source rewrite of the code. Beta features may still have significant bugs, such as the inability to migrate old code correctly, but these bugs should generate readable error messages mentioning the feature name rather than crashing the compiler or silently failing.</p>
<p>Stable features are frozen features - further changes will be done as new features. They are considered to have reached a level of stability sufficient for long-term use. There is no visible difference in the implementation code between beta features and stable features and the distinction is mainly for marketing purposes.</p>
<p>The list of features is centralized in the code to <a class="reference external" href="https://github.com/Mathnerd314/stroscot/blob/master/src/features.txt">this specific file</a>, to make finding them easier and to standardize handling. The scope of a feature may be identified by grep’ing the code for its identifier.</p>
<p>Moving a feature from alpha to beta should have a PR with documentation links and test case links. The PR should:</p>
<ul class="simple">
<li><p>change the feature list to set the feature’s status to beta released on the current date. This enables old code warnings, automigration, and compiler bootstrap workarounds.</p></li>
<li><p>implement automigration code if not already present</p></li>
<li><p>remove all uses of the feature toggle in the code by modifying to the case where the feature is present (avoiding toggle debt).</p></li>
</ul>
<p>A (language) version is determined annually through some process. I don’t have a good idea of this process, but here is a sketch: First, a survey is sent out where people describe features they use and don’t use, and which ones break code or don’t break code. Then, the committee goes through each feature, and select the ones the people like and the ones that don’t break code.</p>
</section>
<section id="processes">
<h2>Processes<a class="headerlink" href="#processes" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>It should be easy to add code to the standard library, and the standard library should always be trying to expand. Taking more than a year to add a new API is just too slow; a 6 month process from “let’s add this” to being available in the most-unstable release branch seems about right. Obviously, if there is a single popular third-party library that has become the “go-to” library for some task, the process is straightforward: it should just be incorporated after it has been proven to be sufficiently stable. If there are multiple popular third-party libraries that do similar things but are incompatible, there are several strategies to deal with this:</p>
<ul>
<li><p>Analyze the pros and cons and choose one library to make standard</p></li>
<li><p>Create a new library that combines all the pros and none of the cons of the existing libraries</p></li>
<li><p>Create a wrapper interface that provides the least common denominator among libraries, but allows importing specific libraries for more functionality</p></li>
</ul>
</li>
<li><p>It should also be easy to remove code from the standard library. Some APIs inevitably become obsolete as others are added and become more popular. Similarly it should be easy to fix names, implementation details, and API design, as conventions change. This is accomplished as an add-remove pair. But people need time to migrate, so there should be a 2-year deprecation process. There should be some amount of forward stability so that if code compiles with an old standard library, it will continue to do so with a new standard library. This means deprecated API isn’t actually removed, it instead goes to a “compatibility graveyard” and stays around for old projects while being invisible to new ones.</p></li>
<li><p>RFC Process: It should not be hard for people to make forks / small patches to the language / library as experimental language extensions. But making such changes standard is more involved. Per <a class="reference external" href="https://youtu.be/f3rP3JRq7Mw?t=102">Robert Virding</a>, it is often hard to see the whole picture. An RFC process for language changes helps to flesh out details and establish what the full impact of a change will be. Making a very simple change can affect many other things, indirectly causing a lot of problems and a lot of strange behavior. Once the change is formalized, it has to be evaluated against the principles of the language and goals of the standard library. Although Stroscot aims to be a universal language, hence making everything possible, some things are just too weird to really be of use, or can be easily implemented in terms of the existing standard library. When you’re firm on your no’s, and explain the reasoning behind your decisions, eventually the users will go away and work around the decision, and, assuming your reasoning is sound, make a better solution than what they originally planned.</p></li>
<li><p>The most important aspect is finding a group of people willing to maintain the code and keep up with patches / bug reports - a lot of code does just fine by itself and doesn’t need much effort, but when there is a response needed, it should be a high-quality response. Third-party library maintainers should live up to the standards set by the standard library team, rather than the other way around.</p></li>
</ul>
</section>
<section id="blessed-prelude">
<h2>Blessed prelude<a class="headerlink" href="#blessed-prelude" title="Link to this heading"></a></h2>
<p>The standard library is blessed in that its prelude module is imported by default into every module. Other than this there is no special support from the compiler for the standard library. Furthermore there is a compiler option to override the prelude import to import no prelude or a different prelude module.</p>
<p>Since the standard prelude is imported by default it should be small, so that no name conflicts arise. The definition of small varies but we’ll just take the community consensus. A truly minimal prelude would just have the import statement, which would also have some advantages.</p>
</section>
<section id="security">
<h2>Security<a class="headerlink" href="#security" title="Link to this heading"></a></h2>
<p>The first defense is security through obscurity - who is going to check the library for issues besides the maintainers? But of course, the more popular the library is, the more attention must be paid to security, and the standard library is probably the most popular of all. But, code is generally not vulnerable if it uses the library the intended way. Also, most security issues are due to unsafe semantics, such as unchecked memory access or manipulation of raw strings instead of structured data, which can be addressed through good language and library design. Still, it is worth having a security review for each new library, and a bounty program once sufficient funding is available. It seems from examining bounties that most standard library bugs are actually not too valuable, around $500.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Sets.html" class="btn btn-neutral float-left" title="Sets" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="State.html" class="btn btn-neutral float-right" title="Stateful programming" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>