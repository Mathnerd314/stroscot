<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Resource management &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Sets" href="Sets.html" />
    <link rel="prev" title="Reduction example" href="Reduction-Example.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler-Library.html">Compiler library</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Intrinsics.html">Intrinsics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#resources">Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#metrics">Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#methods">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#action">Action</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Resource management</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#manual-approach">Manual approach</a></li>
<li class="toctree-l3"><a class="reference internal" href="#try-finally">try-finally</a></li>
<li class="toctree-l3"><a class="reference internal" href="#try-with-resources">try-with-resources</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bracket">Bracket</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scope-guard">Scope guard</a></li>
<li class="toctree-l3"><a class="reference internal" href="#goto-cleanup">Goto cleanup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#garbage-collection">Garbage collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#raii">RAII</a></li>
<li class="toctree-l3"><a class="reference internal" href="#finalizers">Finalizers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exceptions-in-finalizers">Exceptions in finalizers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exception-safety">Exception safety</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#poisoning">Poisoning</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard-Library.html">Standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Resource management</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Resource-Management.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="resource-management">
<h1>Resource management<a class="headerlink" href="#resource-management" title="Permalink to this heading"></a></h1>
<p>Resources are things that can be acquired and released, and are available in limited quantities due to OS or physical limitations. Examples include memory allocations, file handles, internet sockets, mutexes/locks, process table entries, and process identifiers (PIDs). A resource leak happens if the program does not promptly release a resource it has acquired after the program is finished with the resource. A resource management technique prevents resource leaks by releasing resources promptly.</p>
<p>It is possible to manage resources by hand, but it is quite error-prone and tedious. Automatic resource management aims to provide a concise and safe replacement.</p>
<section id="manual-approach">
<h2>Manual approach<a class="headerlink" href="#manual-approach" title="Permalink to this heading"></a></h2>
<p>The manual approach is to release sequentially after acquiring, for example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">open</span><span class="w"> </span><span class="s">&quot;file.txt&quot;</span>
<span class="nf">f2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">open</span><span class="w"> </span><span class="s">&quot;file2.txt&quot;</span>
<span class="nf">do_something</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="n">f2</span>
<span class="nf">close</span><span class="w"> </span><span class="n">f1</span>
<span class="nf">do_something_2</span><span class="w"> </span><span class="n">f2</span>
<span class="nf">close</span><span class="w"> </span><span class="n">f2</span>
</pre></div>
</div>
<p>There are several issues:</p>
<ul class="simple">
<li><p>Early exit leak: There is a resource leak if do_something contains a return, exception, goto, break, or continue out of the do_something block. <a class="reference external" href="https://web.archive.org/web/20201017213150/https://devblogs.microsoft.com/oldnewthing/?p=36783">Raymond Chen</a> complains about C++ macros hiding return and goto statements in the function body.</p></li>
<li><p>Failed acquire: if open fails, do_something and close will be called on an invalid value. But with automatic exception propagation this will be fine since <code class="docutils literal notranslate"><span class="pre">close</span> <span class="pre">InvalidHandle</span> <span class="pre">=</span> <span class="pre">InvalidHandle</span></code>.</p></li>
<li><p>Adjacency: If do_something is long, the release is far from the acquisition, so manual inspection cannot easily identify if the corresponding release function is actually called.</p></li>
<li><p>Encapsulation: the release requirement exposes a detail of the value, namely that it is a resource. This means it cannot be stored in a data structure or returned from a function without special care to call release later.</p></li>
<li><p>Interleaving: Not a problem here, but many solutions impose the requirement that f2 is freed before f1, a LIFO nesting.</p></li>
</ul>
</section>
<section id="try-finally">
<h2>try-finally<a class="headerlink" href="#try-finally" title="Permalink to this heading"></a></h2>
<p>The try-finally modifies the basic approach by marking the do_something and release blocks explicitly. There are two patterns in Java 6, <a class="reference external" href="http://www.javapractices.com/topic/TopicAction.do?Id=25">standard pattern</a> and open-in-try (<a class="reference external" href="https://stackoverflow.com/questions/2699209/java-io-ugly-try-finally-block">here</a>):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">open</span><span class="w"> </span><span class="s">&quot;file.txt&quot;</span>
<span class="nf">try</span><span class="kt">:</span>
<span class="w">    </span><span class="n">do_something</span><span class="w"> </span><span class="n">f</span>
<span class="nf">finally</span><span class="kt">:</span>
<span class="w">    </span><span class="n">close</span><span class="w"> </span><span class="n">f</span>

<span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="kt">InvalidHandle</span>
<span class="nf">try</span><span class="kt">:</span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">open</span><span class="w"> </span><span class="s">&quot;file.txt&quot;</span>
<span class="w">    </span><span class="n">do_something</span><span class="w"> </span><span class="n">f</span>
<span class="nf">finally</span><span class="kt">:</span>
<span class="w">  </span><span class="kr">if</span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">InvalidHandle</span><span class="p">)</span>
<span class="w">    </span><span class="n">close</span><span class="w"> </span><span class="n">f</span>
</pre></div>
</div>
<p>The unwinding protection solves the early exit leak. The failed acquire again doesn’t really matter. This pattern does not solve adjacency, encapsulation, or interleaving, meaning that it is still awkward and verbose. For adjacency, throws act as go-downs and you have to scan down almost the whole function to the finally block to see what cleanups are waiting and if an allocation has a matching clean-up. Also there is an indentation pyramid with nested try-finally.</p>
</section>
<section id="try-with-resources">
<h2>try-with-resources<a class="headerlink" href="#try-with-resources" title="Permalink to this heading"></a></h2>
<p>The try-with-resources solves adjacency by making <code class="docutils literal notranslate"><span class="pre">close</span></code> a Java built-in interface, but it still can’t do encapsulation or interleaving:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">try</span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">open</span><span class="w"> </span><span class="s">&quot;file.txt&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="n">do_something</span><span class="w"> </span><span class="n">f</span>
</pre></div>
</div>
<p>In particular <a class="reference external" href="https://stackoverflow.com/questions/12552863/correct-idiom-for-managing-multiple-chained-resources-in-try-with-resources-bloc">chained resources</a> are awkward.</p>
<p>C# has a similar <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">(f</span> <span class="pre">=</span> <span class="pre">newThing)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> syntax, and Python has <code class="docutils literal notranslate"><span class="pre">with</span></code>.</p>
</section>
<section id="bracket">
<h2>Bracket<a class="headerlink" href="#bracket" title="Permalink to this heading"></a></h2>
<p>Haskell has a <code class="docutils literal notranslate"><span class="pre">bracket</span> <span class="pre">acquire</span> <span class="pre">release</span> <span class="pre">action</span></code> combinator which functions similarly to try-with-resources. It similarly doesn’t support interleaving or encapsulation.</p>
<p>The <a class="reference external" href="https://vimeo.com/97329153">D guy</a> claims you need an even larger combinator than bracket, which goes as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span><span class="w"> </span><span class="n">acquire</span><span class="w"> </span><span class="kr">then</span>
<span class="w">  </span><span class="n">when</span><span class="w"> </span><span class="o">!</span><span class="n">next</span>
<span class="w">    </span><span class="n">rollback</span>
<span class="w">  </span><span class="n">release</span>
</pre></div>
</div>
<p>With masking this looks like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">generalBracket</span><span class="w"> </span><span class="n">acquire</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="n">rollback</span><span class="w"> </span><span class="n">release</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">mask</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">unmasked</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span>
<span class="w">    </span><span class="n">resource</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">acquire</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">unmasked</span><span class="w"> </span><span class="p">(</span><span class="n">next</span><span class="w"> </span><span class="n">resource</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="n">catch</span><span class="p">`</span><span class="w"> </span><span class="nf">\</span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span>
<span class="w">      </span><span class="kr">_</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">rollback</span><span class="w"> </span><span class="n">resource</span>
<span class="w">      </span><span class="kr">_</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">release</span><span class="w"> </span><span class="n">resource</span>
<span class="w">      </span><span class="n">throw</span><span class="w"> </span><span class="n">e</span>
<span class="w">    </span><span class="n">c</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">release</span><span class="w"> </span><span class="n">resource</span>
<span class="w">    </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>acquire has to be masked because there could be an async exception between the action and running next.</p>
</section>
<section id="scope-guard">
<h2>Scope guard<a class="headerlink" href="#scope-guard" title="Permalink to this heading"></a></h2>
<p>This approach involves a “deferred release”, which is called when the scope is exited. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">open</span><span class="w"> </span><span class="s">&quot;file.txt&quot;</span>
<span class="nf">defer</span><span class="w"> </span><span class="p">(</span><span class="n">close</span><span class="w"> </span><span class="n">f</span><span class="p">)</span>
<span class="nf">do_something</span><span class="w"> </span><span class="n">f</span>
</pre></div>
</div>
<p>It is available in C++ as the ScopeGuard class, in Go and Zig as the defer statement, and in D via the <a class="reference external" href="http://ddili.org/ders/d.en/scope.html">scope</a> keyword, where there are <code class="docutils literal notranslate"><span class="pre">scope(exit)</span></code>, <code class="docutils literal notranslate"><span class="pre">scope(success)</span></code>, and <code class="docutils literal notranslate"><span class="pre">scope(failure)</span></code> (referring to exiting the scope unconditionally as with <code class="docutils literal notranslate"><span class="pre">defer</span></code>, without exception, or by exception respectively).</p>
<p>It does solve early exit.</p>
<p>The pattern nests in the sense that <code class="docutils literal notranslate"><span class="pre">defer</span></code>-ed statements are run latest-defined to earliest-defined on exit, but again doesn’t allow interleaving.</p>
<p>It solves adjacency by putting the cleanup before the code that uses the resource, right after the code that’s being cleaned up after. It’s easy to verify that allocations match up with their nearby cleanups, but the clean-up is delayed to the scope’s exit. The syntax is very compact, just specify a cleanup function, but is a statement rather than an expression, meaning that the acquire must also be a statement.</p>
<p><code class="docutils literal notranslate"><span class="pre">defer</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> do not allow returning a resource from a function and skipping the cleanup. They also introduce memory allocation questions since the deferred expressions can capture local variables. So no encapsulation.</p>
</section>
<section id="goto-cleanup">
<h2>Goto cleanup<a class="headerlink" href="#goto-cleanup" title="Permalink to this heading"></a></h2>
<p>C has this pattern:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">open</span><span class="w"> </span><span class="s">&quot;file&quot;</span>
<span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">InvalidHandle</span><span class="p">)</span>
<span class="w">  </span><span class="n">return</span>
<span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="n">isException</span><span class="w"> </span><span class="p">(</span><span class="n">do_something</span><span class="w"> </span><span class="n">f</span><span class="p">))</span>
<span class="w">  </span><span class="n">goto</span><span class="w"> </span><span class="n">cleanup</span>
<span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="n">isException</span><span class="w"> </span><span class="p">(</span><span class="n">do_something_2</span><span class="w"> </span><span class="n">f</span><span class="p">))</span>
<span class="w">  </span><span class="n">goto</span><span class="w"> </span><span class="n">cleanup</span>
<span class="nf">cleanup</span><span class="kt">:</span>
<span class="w">  </span><span class="n">close</span><span class="w"> </span><span class="n">f</span>
</pre></div>
</div>
<p>This suffers from early return but addresses adjacency in that the cleanup label is present and can handle interleaving with conditionals. It is not encapsulated though and it is easy to mess up handling a failed acquire.</p>
</section>
<section id="garbage-collection">
<h2>Garbage collection<a class="headerlink" href="#garbage-collection" title="Permalink to this heading"></a></h2>
<p>GC almost solves the problem by making closing automatic. It looks like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">open</span><span class="w"> </span><span class="s">&quot;file.txt&quot;</span>
<span class="nf">do_something</span><span class="w"> </span><span class="n">f</span>
</pre></div>
</div>
<p>It solves all the issues of early exit, adjacency (implicit in the open), and encapsulation (the GC is based on global program flow). Unfortunately GC does not guarantee it will promptly call the finalizer, so in practice the semantics are not usable.</p>
</section>
<section id="raii">
<h2>RAII<a class="headerlink" href="#raii" title="Permalink to this heading"></a></h2>
<p>C++ uses RAII, which looks like GC, but uses deterministic memory management, such as stack allocation or reference counting. It ensures you cannot insert any failure points between the allocation and the start of the cleanup’s scope. A resource can even be allocated with its corresponding cleanup in the middle of an expression. But defining a new class for every cleanup operation is tedious - fortunately in C++0x it is possible to define one “RAII lambda” class and be done. C++’s semantics define lambda memory handling so there is no allocation issue.</p>
<p>With C++17 it is apparently possible to copy/move RAII types and store them in a data structure or return them from a function, but it seems fragile. In case of a complicated object graph, such as multiple objects sharing a resource, RAII falls down because the available strategies for deterministic memory management are insufficient.</p>
</section>
<section id="finalizers">
<h2>Finalizers<a class="headerlink" href="#finalizers" title="Permalink to this heading"></a></h2>
<p>Stroscot’s finalizers are inspired by RAII and GC but free resources “promptly” as opposed to the “eventually” of GC or the stack or reference counting discipline of RAII. Similarly to <code class="docutils literal notranslate"><span class="pre">defer</span></code> the cleanup is placed near the acquire but similarly to <code class="docutils literal notranslate"><span class="pre">finally</span></code> there can be a marker for the end of the scope. The pattern is <code class="docutils literal notranslate"><span class="pre">newFinalizer</span> <span class="pre">f;</span> <span class="pre">...</span> <span class="pre">;</span> <span class="pre">use</span> <span class="pre">f;</span> <span class="pre">...;</span> <span class="pre">use</span> <span class="pre">f</span></code>. The finalizer will run after the last <code class="docutils literal notranslate"><span class="pre">use</span></code> if code flows normally and soon after raising an exception otherwise. Finalizers allow nesting, in the natural way <code class="docutils literal notranslate"><span class="pre">newFinalizer</span> <span class="pre">a;</span> <span class="pre">newFinalizer</span> <span class="pre">b;</span> <span class="pre">...;</span> <span class="pre">use</span> <span class="pre">b;</span> <span class="pre">use</span> <span class="pre">a</span></code>, and interleaving, by reordering to <code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">a;</span> <span class="pre">use</span> <span class="pre">b</span></code>. But the execution order on an exception is latest-defined-first-run. Finalizers also support encapsulation such as returning the allocated resource. It is also possible to embed the finalizer in a resource handle and use RAII style programming - each operation calls <code class="docutils literal notranslate"><span class="pre">use</span></code> and extends the finalizer’s life.</p>
<p>Finalizers directly implement D’s <code class="docutils literal notranslate"><span class="pre">scope(exit)</span></code>, and with an extra flag variable they can implement <code class="docutils literal notranslate"><span class="pre">scope(success)</span></code> and <code class="docutils literal notranslate"><span class="pre">scope(failure)</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">scope_failure</span><span class="w"> </span><span class="n">rollback</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">flag</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mut</span><span class="w"> </span><span class="n">true</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newFinalizer</span><span class="w"> </span><span class="p">(</span><span class="kr">if</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">rollback</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="p">{})</span>
<span class="w">  </span><span class="kt">ScopeFailure</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">f</span>

<span class="nf">use</span><span class="w"> </span><span class="p">(</span><span class="kt">ScopeFailure</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span>
<span class="w">   </span><span class="n">flag</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">false</span>
<span class="w">   </span><span class="n">use</span><span class="w"> </span><span class="n">f</span>


<span class="nf">s</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">scope_failure</span><span class="w"> </span><span class="n">rollback</span>
<span class="nf">code</span>
<span class="nf">use</span><span class="w"> </span><span class="n">s</span>
</pre></div>
</div>
<p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4152.pdf">Herb Sutter</a> claims that the extra <code class="docutils literal notranslate"><span class="pre">use</span></code> is “tedious and fragile” and forces the programmer to think about the placement of failure determination. One can define a proper <code class="docutils literal notranslate"><span class="pre">scope_failure</span> <span class="pre">rollback</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> block structure, and even redefine return/continue/break to not run the rollback. But personally I think the finalizers are more powerful because they allow interleaving scopes. The combinators only allow nesting which isn’t as expressive. In Haskell land Snoyman created <a class="reference external" href="https://hackage.haskell.org/package/resourcet">ResourceT</a> even though there was <code class="docutils literal notranslate"><span class="pre">bracket</span></code>, exactly because of this.</p>
</section>
<section id="exceptions-in-finalizers">
<h2>Exceptions in finalizers<a class="headerlink" href="#exceptions-in-finalizers" title="Permalink to this heading"></a></h2>
<p>What to do when throwing an exception from a finalizer? Say we have</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newFinalizer</span><span class="w"> </span><span class="p">(</span><span class="n">throw</span><span class="w"> </span><span class="kt">Bar</span><span class="p">)</span>
<span class="w">  </span><span class="n">throw</span><span class="w"> </span><span class="kt">Foo</span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">f</span>

<span class="nf">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">catch</span><span class="w"> </span><span class="nf">\</span><span class="kr">case</span>
<span class="w">        </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="s">&quot;foo&quot;</span>
<span class="w">        </span><span class="kt">Bar</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="s">&quot;bar&quot;</span>
</pre></div>
</div>
<p>Per Stroscot’s semantics, the finalizer runs as soon as it is known that <code class="docutils literal notranslate"><span class="pre">use</span></code> will not be called - i.e. immediately after constructing the finalizer, before the <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">Foo</span></code> (because <code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">f</span></code> is unreachable). So <code class="docutils literal notranslate"><span class="pre">x</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">Bar;</span> <span class="pre">throw</span> <span class="pre">Foo</span></code>. Then per normal exception semantics <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">Bar</span></code> wins since it is first and <code class="docutils literal notranslate"><span class="pre">y</span></code> outputs <code class="docutils literal notranslate"><span class="pre">bar</span></code>.</p>
<p>If we had an I/O operation <code class="docutils literal notranslate"><span class="pre">writeOrThrow</span></code> instead of <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">Foo</span></code>, then <code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">f</span></code> is reachable. So then we have two cases:</p>
<ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">writeOrThrow</span></code> throws, then it is known that <code class="docutils literal notranslate"><span class="pre">use</span></code> will not be called. The finalizer will be delayed until just before the first I/O operation executed after the <code class="docutils literal notranslate"><span class="pre">writeOrThrow</span></code>, in this case <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;foo&quot;</span></code>. So <code class="docutils literal notranslate"><span class="pre">y</span></code> will exit with a <code class="docutils literal notranslate"><span class="pre">Bar</span></code> error without printing anything.</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">writeOrThrow</span></code> doesn’t throw, then the finalizer will execute after the last <code class="docutils literal notranslate"><span class="pre">use</span></code>. Again <code class="docutils literal notranslate"><span class="pre">y</span></code> will exit with a <code class="docutils literal notranslate"><span class="pre">Bar</span></code> error without printing anything.</p></li>
</ul>
<p>As far as I can tell this is a logical choice. C++ instead decided to terminate the program on the <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">Bar</span></code> in the destructor. The justification seems to be that it slightly simplified the implementation of unwinding, and that the C++ STL wanted to “arbitrarily require that [destructors] may not throw.” (<a class="reference external" href="https://ptgmedia.pearsoncmg.com/imprint_downloads/informit/aw/meyerscddemo/DEMO/MAGAZINE/SUTTER.HTM">Herb Sutter</a>, also Item 16 “Destructors That Throw and Why They’re Evil” of his 1999 book Exceptional C++) <a class="reference external" href="http://web.archive.org/web/20130728131646/cpp-next.com/archive/2012/08/evil-or-just-misunderstood/">John Kalb and David Abraham</a> say “The reason we can’t have throwing destructors is that nobody worked out how to deal with multiple exceptions wanting to propagate through the same set of stack frames. […] we think termination is a bit draconian. Frankly, we don’t think it’s so hard to nail down the final details of how this should work.”</p>
<p>Kalb proposes to “drop the second [destructor] exception on the floor and propagate the original one”, but this is a bad idea. Since (per Sutter’s convention) destructors generally don’t fail, an exception during a destructor is going to be fairly serious, such as an OOM. Ignoring this exception in favor of a trivial logic exception is the wrong approach.</p>
</section>
<section id="exception-safety">
<h2>Exception safety<a class="headerlink" href="#exception-safety" title="Permalink to this heading"></a></h2>
<p>Exception safe code is code that works correctly even when exceptions are thrown. The basic issue is in Rust/C++ almost everything is a resource. In Stroscot almost everything is a value, inert data - copy/clone is built into the language and can’t fail. Taking away explicit memory management makes it much easier to ensure exception safety. Reasoning about invariants with pure values is straightforward, and fail-fast coding styles mean that the program doesn’t live long. And when writing cleanups the programmer is already thinking about exception safety and restoring invariants, so will write an exception-safe cleanup.</p>
<p>Still, what about exception safety for a mutable data structure? C++ has <a class="reference external" href="https://en.wikipedia.org/wiki/Exception_safety">levels of safety</a> for stateful functions based on what invariants are preserved.</p>
<ul class="simple">
<li><p>no-throw means forward progress is guaranteed. It’s nice when you can give this, but most functions can fail due to insufficient memory.</p></li>
<li><p>Strong safety means that state transitions happen atomically and a failure will return to the old state. To ensure this one needs basic safety and to copy the relevant data beforehand and write it back afterwards.  This is infeasible for even simple data structures in C++ due to overloaded assignment and copy operators being able to throw.</p></li>
<li><p>Basic safety means that the final state will be valid, i.e. all invariants hold. You need to safeguard against each function call throwing. This requires adding handling code to each call and trusting the documentation for the list of thrown exceptions (or using no-throw).</p></li>
</ul>
<p>These levels only work for stateful data structures that call a small and easily auditable set of other functions.</p>
<p>In Stroscot there are two steps to making code exception-safe:</p>
<ul class="simple">
<li><p>identify invariants. These can be written as assertions using the pure read operations on stores. With this the static verification will identify the function and the exceptional control flow that breaks the invariant.</p></li>
<li><p>place exception cleanup handlers to restore broken invariants</p></li>
</ul>
<blockquote>
<div><p>This code in Rust or C++ is not exception safe: (based on <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1995/N0623.asc">this code</a> and <a class="reference external" href="https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md#background-what-is-exception-safety-in-rust">this code</a>)</p>
</div></blockquote>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">push_ten_more</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Vec</span><span class="w"> </span><span class="kt">T</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Op</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Vec</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="o">|</span><span class="n">uninitialized</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="nf">push_ten_more</span><span class="w"> </span><span class="p">(</span><span class="n">this</span><span class="o">@</span><span class="p">(</span><span class="n">readRef</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Vector</span><span class="w"> </span><span class="n">arr</span><span class="p">))</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">new_arr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">alloc</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
<span class="w">  </span><span class="n">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">indexes</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span>
<span class="w">    </span><span class="n">copy</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">new_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="w">    </span><span class="n">delete</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="w">  </span><span class="n">this</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="kt">Vector</span><span class="w"> </span><span class="n">new_arr</span>

<span class="w">  </span><span class="n">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">t</span><span class="o">.</span><span class="n">clone</span><span class="nb">()</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The update to the Vector happens when the next 10 elements are uninitialized, and <code class="docutils literal notranslate"><span class="pre">Vec</span></code> has an internal invariant that its elements are safe to deallocate. So if <cite>t.clone</cite> throws then the initialization will not be called. Vec’s destructor that assumes the invariant will then free uninitialized memory.</p>
<p>In this code the Rust/C++ semantics require calling a destructor <code class="docutils literal notranslate"><span class="pre">delete</span></code> on each element of a <code class="docutils literal notranslate"><span class="pre">vec</span></code>, and copying values with <code class="docutils literal notranslate"><span class="pre">copy_to_</span></code> and <code class="docutils literal notranslate"><span class="pre">clone</span></code> operations that can fail -  Similarly we wouldn’t necessarily call any finalizers (<code class="docutils literal notranslate"><span class="pre">delete</span></code>) - the finalizer is called after the last use, and likely there are other copies and this is not the last use. Even if the Stroscot code was written to call an operation <code class="docutils literal notranslate"><span class="pre">clone</span></code> that could throw exceptions, the rest of the elements will be deallocated if needed, but otherwise not. In all cases memory is safe due to the finalizer semantics.</p>
<p>Another issue is the uninitialized array. This means the array may be filled with <code class="docutils literal notranslate"><span class="pre">uninitialized</span></code> values (exceptions). The result type reflects this possibility. With careful rewriting, the code can provide the strong guarantee that the resulting vector only contains values of type T. This can be done by extending the array one element at a time or by saving the exception(s) thrown in a separate list and rethrowing at the end as an exception group.</p>
<p>A simple example is <code class="docutils literal notranslate"><span class="pre">TwoList</span></code>, which maintains two mutable linked lists with the invariant that they are the same. What does adding an element look like?</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">List</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">head</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">l</span>
<span class="w">  </span><span class="n">l</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">head</span>

<span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">TwoLists</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="n">l2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">l1</span>
<span class="w">  </span><span class="n">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">l2</span>
</pre></div>
</div>
<p>But this is not exception safe for the invariant, because an async exception between the two adds may add a to l1 but not l2.</p>
<p>If add is no-throw we can fix this just by adding uninterruptibleMask. But add allocates so can throw out of memory. But remove is no-throw so we can use remove:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">TwoLists</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="n">l2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">mask_</span><span class="w"> </span><span class="o">$</span>
<span class="w">    </span><span class="kr">case</span><span class="w"> </span><span class="n">try</span><span class="w"> </span><span class="p">(</span><span class="n">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">l1</span><span class="p">)</span><span class="w"> </span><span class="kr">of</span>
<span class="w">      </span><span class="kt">Err</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="n">e</span>
<span class="w">      </span><span class="kt">Ok</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">        </span><span class="kr">case</span><span class="w"> </span><span class="n">try</span><span class="w"> </span><span class="p">(</span><span class="n">allowInterrupt</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">l2</span><span class="p">)</span><span class="w"> </span><span class="kr">of</span>
<span class="w">          </span><span class="kt">Ok</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">return</span>
<span class="w">          </span><span class="kt">Err</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">uninterruptibleMask</span><span class="w"> </span><span class="p">(</span><span class="n">remove</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">l1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="n">e</span>
</pre></div>
</div>
<p>Here add should have strong safety, i.e. it restores the state if an exception is thrown during the add.</p>
<section id="poisoning">
<h3>Poisoning<a class="headerlink" href="#poisoning" title="Permalink to this heading"></a></h3>
<p>Rust has “poisoning” for taking locks, which is a safeguard against trying to use data that was corrupted due to an exception, e.g. a concurrent heap that doesn’t have the heap property anymore. Poisoned data will tear down all connected threads.</p>
<p>Essentially it uses the scope_failure cleanup to poison the lock on failure:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">getGuard</span><span class="w"> </span><span class="n">mutex</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">acquireLock</span><span class="w"> </span><span class="n">mutex</span>
<span class="w">  </span><span class="n">flag</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mut</span><span class="w"> </span><span class="n">true</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newFinalizer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="kr">then</span>
<span class="w">      </span><span class="n">poisonLock</span><span class="w"> </span><span class="n">mutex</span>
<span class="w">    </span><span class="n">releaseLock</span><span class="w"> </span><span class="n">mutex</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="kt">Guard</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">f</span>

<span class="nf">finishGuard</span><span class="w"> </span><span class="p">(</span><span class="kt">Guard</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">flag</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">false</span>
<span class="w">  </span><span class="n">use</span><span class="w"> </span><span class="n">f</span>
</pre></div>
</div>
<p>Once the lock is poisoned then locking the mutex will throw an exception.</p>
<p>However, the invariant checking approach to exception safety discussed above will throw an exception anyway when trying to use a data structure operation on a corrupted data structure. It also covers the single-threaded case where no mutex is used but the recovery from an exception is incomplete. So poisoning isn’t really that useful. But a PoisoningMutex can at least be in the standard library for those who want the functionality.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Reduction-Example.html" class="btn btn-neutral float-left" title="Reduction example" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Sets.html" class="btn btn-neutral float-right" title="Sets" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>