<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reduction &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=db2ac877" />

  
    <link rel="shortcut icon" href="../../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=7f41d439"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Reduction example" href="Reduction-Example.html" />
    <link rel="prev" title="Profiling" href="Profiling.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../Language/index.html">Language specification</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Implementation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l3"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l3"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l3"><a class="reference internal" href="Implementation.html">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="Memory.html">Memory model</a></li>
<li class="toctree-l3"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Reduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#def-use">Def/use</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hashing">Hashing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#primitives">Primitives</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linear-logic">Linear logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l3"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l3"><a class="reference internal" href="Tools.html">Tools</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Libraries/index.html">Libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Meta/index.html">Meta</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Commentary</a></li>
          <li class="breadcrumb-item"><a href="index.html">Implementation</a></li>
      <li class="breadcrumb-item active">Reduction</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Implementation/Reduction.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="reduction">
<h1>Reduction<a class="headerlink" href="#reduction" title="Link to this heading"></a></h1>
<p>In graph reduction, a graph node identifies a closed expression, and can be referenced by many other nodes. This sharing allows reduction in a more efficient manner, only computing the expression’s reduction once rather than repeatedly for each occurrence. But this sharing is relative to the initial term - if there are duplicated expressions in the initial program, or identical expressions arise from distinct reduction paths, graph reduction will not merge them.  But this labelling is only preserved under weak reduction, reduction not inside lambdas.</p>
<p>An extension of graph reduction is optimal reduction.  In optimal reduction, terms with the same family / Levy-label are identified as one node, and strong reduction is valid, i.e. reducing any redex. Levy-labelling is again relative to the initial expression (each sub-term annotated with a unique label) and the reduction history from that expression to the current. There is then the implementation task of representing the shared redexes efficiently so that they may be reduced together.</p>
<p>Although BOHM and Lambdascope have created interaction net machines where a Levy family beta-reduction is an atomic operation, it does not seem that these interaction net machines are actually that efficient. In <span id="id1">[<a class="reference internal" href="../../zzreferences.html#id108" title="Stefano Guerrini and Marco Solieri. Is the optimal implementation inefficient? Elementarily not. In 2nd International Conference on Formal Structures for Computation and Deduction, 16 pages. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik GmbH, Wadern/Saarbruecken, Germany, September 2017. \subsection Other  Sharing graphs are a local and asynchronous implementation of lambda-calculus beta-reduction (or linear logic proof-net cut-elimination) that avoids useless duplications. Empirical benchmarks suggest that they are one of the most efficient machineries, when one wants to fully exploit the higher-order features of lambda-calculus. However, we still lack confirming grounds with theoretical solidity to dispel uncertainties about the adoption of sharing graphs. Aiming at analysing in detail the worst-case overhead cost of sharing operators, we restrict to the case of elementary and light linear logic, two subsystems with bounded computational complexity of multiplicative exponential linear logic. In these two cases, the bookkeeping component is unnecessary, and sharing graphs are simplified to the so-called &quot;abstract algorithm&quot;. By a modular cost comparison over a syntactical simulation, we prove that the overhead of shared reductions is quadratically bounded to cost of the naive implementation, i.e. proof-net reduction. This result generalises and strengthens a previous complexity result, and implies that the price of sharing is negligible, if compared to the obtainable benefits on reductions requiring a large amount of duplication. URL: http://drops.dagstuhl.de/opus/volltexte/2017/7733/ (visited on 2021-09-06), doi:10.4230/LIPICS.FSCD.2017.17.">GS17</a>]</span> they find a quadratic slowdown of the fan-fan swap interactions, relative to normal order reduction on lambdas. Furthermore in <span id="id2">[<a class="reference internal" href="../../zzreferences.html#id19" title="Andrea Asperti and Harry G. Mairson. Parallel beta reduction is not elementary recursive. Information and Computation, 170(1):49–80, October 2001. URL: https://linkinghub.elsevier.com/retrieve/pii/S089054010192869X (visited on 2020-06-15), doi:10.1006/inco.2001.2869.">AM01</a>]</span> they find that a Levy family beta-reduction step can take time that is not elementary recursive. It seems like an easier path to optimal reduction is to track the families directly and perform family reductions individually using an efficient non-sharing algorithm such as <span id="id3">[<a class="reference internal" href="../../zzreferences.html#id230" title="Olin Shivers and Mitchell Wand. Bottom-up β-reduction: uplinks and λ-DAGs (extended version). Technical Report, Citeseer, 2004.">SW04</a>]</span> or a limited-sharing algorithm such as graph reduction. Such an approach gives up the exponential speedups of sharing contexts, but has a much more understandable cost model. It is still “optimal” in the sense that outermost family reduction performs the minimal number of family reductions, and the overall reduction follows this strategy, hence the only inefficiency is the need to evaluate some unnecessary individual reductions as part of the family. Potentially, there is the possibility to use the homogeneity of the redexes within a family to speed up within-family reduction, but most likely not.</p>
<p>Since reduction is confluent, it does not change anything to reduce in non-normal order for a time. The reduction will still terminate when going back to normal order. So terminating reductions can always be performed and even non-terminating reductions can be reduced somewhat. Hence during compilation we want to reduce the program as much as possible - ideally the compiled core should be cut-free. We can detect diverging terms and replace them with error terms. But we can’t eliminate cuts involving complex recursion, so have to create a heap or a stack allocation. For example the Fibonacci list <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">fibs</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">::</span> <span class="pre">1</span> <span class="pre">::</span> <span class="pre">zipWith</span> <span class="pre">(+)</span> <span class="pre">fibs</span> <span class="pre">(tail</span> <span class="pre">fibs)</span> <span class="pre">in</span> <span class="pre">{</span> <span class="pre">repeat</span> <span class="pre">forever</span> <span class="pre">{</span> <span class="pre">n</span> <span class="pre">&lt;-</span> <span class="pre">readInt;</span> <span class="pre">print</span> <span class="pre">(fibs</span> <span class="pre">!!</span> <span class="pre">n)</span> <span class="pre">}</span> <span class="pre">}</span></code>, this needs some kind of reduction graph or memo stack involved.</p>
<section id="def-use">
<h2>Def/use<a class="headerlink" href="#def-use" title="Link to this heading"></a></h2>
<p>Graph reduction using def/use is not hard - assign each definition node a static integer identifier. Then the root is a distinguished definition, which is mutable, while everything else is copied into the root graph when reduction goes past its use point. Assuming the definition data is stored on disk and paged in/out as needed, we can minimize runtime memory use in a compiler pass by introducing as many use-def indirections as possible, one for every sequent in the derivation. This also makes the connections between rules uniform. But having lots of indirections is inefficient so a later pass would remove indirections that will be immediately used (chunkification).</p>
<p>The optimal fixedpoint algorithm outlined in <span id="id4">[<a class="reference internal" href="../../zzreferences.html#id225" title="Adi Shamir. The Fixedpoints of Recursive Definitions. PhD thesis, Weizmann Institute of Science, Rehovot, October 1976. URL: https://weizmann.primo.exlibrisgroup.com/permalink/972WIS_INST/1d4esio/alma990002185270203596.">Sha76</a>]</span> (10.18, PDF pages 240-242) is a variation of Tarjan’s strongly connected component algorithm. Cuts between two definitions <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> are memoized in a list, and if the SCC algorithm finds a component <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">let</span> <span class="pre">g</span> <span class="pre">=</span> <span class="pre">...</span> <span class="pre">in</span> <span class="pre">g</span> <span class="pre">(f</span> <span class="pre">x)</span></code> then this component is solved. If it has a unique solution then that’s the answer, otherwise <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> diverges and is replaced with a <code class="docutils literal notranslate"><span class="pre">RecursionError</span></code> or <code class="docutils literal notranslate"><span class="pre">AmbiguousError</span></code>. We assume the solver allows uninterpreted “holes”, so that the SCC can be solved before its sub-computations.</p>
<p>For comparison, to compute the least fixed point we would maintain a “working graph” and incrementally unfold the definition when encountered. But with the optimal fixed point we first reduce the definition to a value while copying other definitions in.</p>
<p>The solver is an SMT solver on the predicate <code class="docutils literal notranslate"><span class="pre">SAT(y</span> <span class="pre">==</span> <span class="pre">g</span> <span class="pre">y)</span></code>, and for uniqueness <code class="docutils literal notranslate"><span class="pre">UNSAT(y</span> <span class="pre">==</span> <span class="pre">g</span> <span class="pre">y</span> <span class="pre">&amp;&amp;</span> <span class="pre">y</span> <span class="pre">!=</span> <span class="pre">y0)</span></code> where <code class="docutils literal notranslate"><span class="pre">y0</span></code> is the first solution found. We exclude error values as possible solutions since the recursion error will be more informative.</p>
<p>The posets the paper uses appear to be pointed directed-complete partial orders <a class="reference external" href="https://en.wikipedia.org/wiki/Complete_partial_order">(cppo’s)</a>.</p>
</section>
<section id="hashing">
<h2>Hashing<a class="headerlink" href="#hashing" title="Link to this heading"></a></h2>
<p>To hash the graphs we can use the tree structure of the sequent derivations. Each upward slot in a node is hashed with a fixed value and each downward slot is hashed with a value corresponding to the path through the derivation tree followed by the label of the upward slot. It is written as a single DFS traversal with the leaves as base case that stores the hashed subtree and a map from edge name to partial path.</p>
<p>Hashing infinite graphs is harder, we have to hash each SCC as a unit. See <span id="id5">[<a class="reference internal" href="../../zzreferences.html#id173" title="Laurent Mauborgne. An incremental unique representation for regular trees. Nordic Journal of Computing, 7(4):290–311, December 2000.">Mau00</a>]</span>.</p>
</section>
<section id="primitives">
<h2>Primitives<a class="headerlink" href="#primitives" title="Link to this heading"></a></h2>
<p>Primitives (integers) can be handled by hacking special cases into Cut; we add primitive functions of type PiR that use the arguments provided by PiL during a cut, and also literals, special values of type SigmaR. Alternately we can use a specialized proof trees: 64-bit integers are represented as a sigma type with 2^64 possibilities. So addition is represented as a case expression, where each case contains another case expression, and then each case constructs the integer corresponding to the addition. There is a lot of fan-out at each step, which would require 2^128 values to represent, clearly infeasible. So although this is the conceptual representation, the actual representation has no fan-out for the cases - instead the case nodes create symbolic variables <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, and the constructed value has the tag <code class="docutils literal notranslate"><span class="pre">a+b</span></code>.</p>
</section>
<section id="linear-logic">
<h2>Linear logic<a class="headerlink" href="#linear-logic" title="Link to this heading"></a></h2>
<p>Linear logic has boxes, The difference is not observable if we do not use duplication. e.g. <code class="docutils literal notranslate"><span class="pre">(\x.print(x+1))</span> <span class="pre">{print(&quot;x&quot;);</span> <span class="pre">2}</span></code> can only print <code class="docutils literal notranslate"><span class="pre">x3</span></code>. But if we change <code class="docutils literal notranslate"><span class="pre">x+1</span></code> to <code class="docutils literal notranslate"><span class="pre">x+x</span></code> then CBV/optimal/lazy is <code class="docutils literal notranslate"><span class="pre">x4</span></code> while CBN is <code class="docutils literal notranslate"><span class="pre">xx4</span></code>.</p>
<p>So how do we specify the difference between the two, in linear logic?</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">s</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">dup</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="n">print</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="p">)</span>
<span class="nf">s</span><span class="w"> </span><span class="p">(</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">);</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Boxes do have some performance cost, so how can they be avoided? There are cases where boxes are not necessary:</p>
<p>1. When the term is linear or affine and does not need to duplicate anything.
3. Inlining, when the duplication is carried out, resulting in two terms.
4. More complex cases enforced by a typing system, such as Elementary Affine Logic.</p>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Link to this heading"></a></h2>
<p>Reduction is fairly simple to implement without duplication, as it is just pairs of constructors and destructors annihilating and joining their wires, or, for <code class="docutils literal notranslate"><span class="pre">case</span></code>, joining some eraser nodes. But what about duplication?</p>
<p>Stroscot takes its general inspiration from the delimiter system found in Lambdascope. However, instead of having levels Stroscot keeps explicit track of “environments” or “scopes”. In particular a delimiter has an inside scope and an outside scope. Initially, all delimiters look like opening/closing delimiters where the outside scope is the default/root scope <code class="docutils literal notranslate"><span class="pre">0</span></code> and the inside scope is the scope of the multiplexer involved. When two delimiters meet, the touching outer scopes are compared for equality (they should always be equal) and one inner scope remains the inner scope while the other inner scope become the new delimiter’s outer scope.</p>
<p>To determine which scope becomes the outer scope, delimiters are also marked as “head”, “full”, or “empty” depending on whether they represent a reference to the result of a duplication, the target of a duplication, or a path that crosses the scope but doesn’t duplicate. Interactions are allowed only between head delimiters and other delimiter; the head delimiter’s scope stays on the inside.</p>
<p>For multiplexers the situation is a little more complicated. A multiplexer also has two scopes, an inner “label”/identity-like scope and an outer “ambient” scope. When a multiplexer crosses a delimiter, from outside to inside, its “ambient” scope is changed to the delimiter’s inside scope. Meanwhile the delimiter’s scope is split into a new set of scopes, and this is indexed by the label scope. In the Stroscot code these are referred to as “variant” scopes. In particular, multiplexers with the same label scope must split other scopes into the same set of variant scopes at each interaction. This is not too hard to keep track of, just give each scope a map <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">scope</span> <span class="pre">-&gt;</span> <span class="pre">variant</span> <span class="pre">scope</span> <span class="pre">set</span></code> that’s lazily created.</p>
<p>For efficient graph reduction we want to reduce a term completely, if we are able to. The top-level instruction evaluation loop can be written strictly, using a code pointer for conditional nodes.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Profiling.html" class="btn btn-neutral float-left" title="Profiling" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Reduction-Example.html" class="btn btn-neutral float-right" title="Reduction example" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>