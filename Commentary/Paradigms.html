<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Comparison &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Exemplary programs" href="Programs.html" />
    <link rel="prev" title="Package manager" href="PackageManager.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Comparison</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#paradigms">Paradigms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#graph-of-paradigms">Graph of paradigms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#other-programming-languages">Other programming languages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Commentary</a> &raquo;</li>
      <li>Comparison</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Paradigms.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="comparison">
<h1>Comparison<a class="headerlink" href="#comparison" title="Permalink to this heading"></a></h1>
<p>This page has two sections:</p>
<ul class="simple">
<li><p>a graph of paradigms, showing which language embed into which others</p></li>
<li><p>a brief summary of interesting features of popular programming languages</p></li>
</ul>
<section id="paradigms">
<h2>Paradigms<a class="headerlink" href="#paradigms" title="Permalink to this heading"></a></h2>
<p>In linguistics, a paradigm is “a set of linguistic items that form mutually exclusive choices in particular syntactic roles,” specifically “a table of all the inflected forms of a particular verb, noun, or adjective.” This seems to be a usable definition of a PL paradigm - you have all related versions of a semantic entity.</p>
<p>Unfortunately people seem to use paradigms as labels of entire languages, rather than classifications of their features. Stroscot, like every other language, is “multi-paradigm” - even assembly is multi-paradigm since it is imperative (syscalls) and structured (conditional jump). So the adjectives “object-oriented”, “functional”, etc. are best avoided in favor of discussing whether a language has specific semantic constructs, since “functional object-oriented language” sounds weird. Still, it’s good to have a map of which paradigms embed into which other paradigms. This list is based on Wikipedia’s list of paradigms:</p>
<ul class="simple">
<li><p>Action: <a class="reference external" href="https://en.wikipedia.org/wiki/Action_language">action descriptions</a> are given by the state trajectory relation</p></li>
<li><p>Array-oriented functions are still functions</p></li>
<li><p>Automata-based:</p>
<ul>
<li><p>Nondeterministic automata are given by the transition relation</p></li>
<li><p>Deterministic automata are given by the transition function</p></li>
</ul>
</li>
<li><p>concurrency operations decompose into OS calls which are I/O operations</p>
<ul>
<li><p>agents/actors/flow-based processes are threads with a dispatch loop</p></li>
</ul>
</li>
<li><p>data-driven programming is a main loop over condition-action pairs</p></li>
<li><p>declarative is a logical relation or a function</p>
<ul>
<li><p>functional</p>
<ul>
<li><p>lambas are anonymous functions</p></li>
<li><p>functions are total functional binary relations</p></li>
</ul>
</li>
<li><p>logic</p>
<ul>
<li><p>a relation is a set of tuples</p></li>
<li><p>boolean operations are logical constraints</p></li>
</ul>
</li>
<li><p>constraint: constraints are 0-1 loss functions in an optimization problem</p></li>
<li><p>dataflow is a block in single static assignment form</p></li>
<li><p>a reactive or incremental program is a state value plus a state update function or command</p></li>
<li><p>a query is a function that takes a database and produces a list of results</p></li>
</ul>
</li>
<li><p>differentiable: the <a class="reference external" href="https://en.wikipedia.org/wiki/Fr%C3%A9chet_derivative">derivative</a> is a function mapping a function <span class="math notranslate nohighlight">\(f\)</span> to a linear operator <span class="math notranslate nohighlight">\(A\)</span> such that <span class="math notranslate nohighlight">\(\lim _{\|h\|\to 0}{\frac {\|f(x+h)-f(x)-Ah\|}{\|h\|}}=0\)</span>.</p></li>
<li><p>dynamic: eval is a function from strings to values (and optionally with an environment)</p></li>
<li><p>event driven: an ED program is some event handler functions, data binding event handlers to events, and a main loop function (provided by a library) that repeatedly checks for events and calls the matching event handler</p></li>
<li><p>generic functions are just functions</p></li>
<li><p>imperative programing:</p>
<ul>
<li><p>commands can be represented as a tag (payload) plus a callback function returning another command</p></li>
<li><p>mutable variables are using read and write functions on an implicitly passed/returned store.</p></li>
<li><p>procedures are functions from arguments to commands</p></li>
</ul>
</li>
<li><p>Metaprogramming:</p>
<ul>
<li><p>Attribute-oriented: attributes are a function from symbols to metadata</p></li>
<li><p>Macros: macros are functions that take an AST and a lexical environment</p></li>
</ul>
</li>
<li><p>Nondeterministic: a nondeterministic function is a relation</p></li>
<li><p>Parallel: a block in single static assignment form can be easily parallelized using a concurrent worker pool</p></li>
<li><p>Process-oriented programs can be represented using concurrent operations</p></li>
<li><p>probabilistic programs are functions from parameters to a log probability</p></li>
<li><p>Quantum:</p>
<ul>
<li><p>quantum logic gates are functions, in particular unitary operators on states of qubits</p></li>
<li><p>a quantum program is a block, consisting of gate applications and discarding information (Qunity)</p></li>
</ul>
</li>
<li><p>Set-theoretic: set membership is a boolean predicate function</p></li>
<li><p>Stack-based: a stack-oriented program is a function on stacks, a.k.a. lists</p></li>
<li><p>structured:</p>
<ul>
<li><p>loops are recursive functions</p></li>
<li><p>conditionals are lazy functions</p></li>
<li><p>Block-structured: block sequencing is Kleisli arrow composition, a function</p></li>
<li><p>Object-oriented: objects are mutable variables containing records of mutable variables and functions</p></li>
<li><p>Class-based: classes are types</p></li>
<li><p>recursion is syntax for applying a fixpoint function</p></li>
</ul>
</li>
<li><p>Symbolic: an AST is a value</p></li>
<li><p>Value-level: types are sets</p></li>
</ul>
<p>In addition there are some other paradigms:</p>
<ul class="simple">
<li><p>term rewriting systems are given by the rewriting relation</p></li>
<li><p>optimization problems are relations based on on objective functions</p></li>
<li><p>optimization solvers are functions from objective functions to a list of solutions</p></li>
</ul>
<section id="graph-of-paradigms">
<h3>Graph of paradigms<a class="headerlink" href="#graph-of-paradigms" title="Permalink to this heading"></a></h3>
<div class="graphviz"><object data="../_images/graphviz-9b0c9e1656cc4b742d191ec51445dac6e280cda3.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph paradigms {
  action -&gt; relation
  array -&gt; function
  &quot;nondet automata&quot; -&gt; relation
  &quot;det automata&quot; -&gt; function
  concurrency -&gt; command
  actor -&gt; concurrency
  agent -&gt; concurrency
  flow -&gt; concurrency
  actor -&gt; loop
  agent -&gt; loop
  flow -&gt; loop
  &quot;data-driven&quot; -&gt; loop
  &quot;data-driven&quot; -&gt; condition
  &quot;data-driven&quot; -&gt; function
  &quot;data-driven&quot; -&gt; command
  declarative -&gt; relation
  declarative -&gt; function
  lambda -&gt; function
  function -&gt; relation
  relation -&gt; set
  boolean -&gt; constraint
  constraint -&gt; optimization
  dataflow -&gt; block
  reactive -&gt; function
  reactive -&gt; command
  query -&gt; function
  differentiable -&gt; function
  dynamic -&gt; function
  event -&gt; function
  event -&gt; loop
  generic -&gt; function
  command -&gt; function
  &quot;mutable variable&quot; -&gt; function
  procedure -&gt; function
  attribute -&gt; function
  macro -&gt; function
  nondeterministic -&gt; relation
  parallel -&gt; block
  parallel -&gt; concurrency
  process -&gt; concurrency
  probabilistic -&gt; function
  quantum -&gt; function
  quantum -&gt; block
  set -&gt; boolean
  stack -&gt; function
  loop -&gt; function
  loop -&gt; recursion
  conditional -&gt; function
  block -&gt; function
  object -&gt; &quot;mutable variable&quot;
  class -&gt; type
  recursion -&gt; function
  type -&gt; set
  &quot;term rewriting&quot; -&gt; relation
  optimization -&gt; relation
  optimization -&gt; function
}</p></object></div>
<p>Graphviz has chosen “function” as the root paradigm. This agrees well with experience. Quoting <a class="reference external" href="https://www.google.com/books/edition/Calculus/7JKVu_9InRUC?hl=en&amp;gbpv=1&amp;bsq=central%20objects">Spivak</a>, “the most important concept in all of mathematics is that of a function - in almost every branch of modern mathematics functions turn out to be the central objects of investigation.” Looking closer, function is part of an SCC <code class="docutils literal notranslate"><span class="pre">function,</span> <span class="pre">relation,</span> <span class="pre">set,</span> <span class="pre">boolean,</span> <span class="pre">constraint,</span> <span class="pre">optimization</span></code>. The mathematical notion of function is broad; a functional relation cannot be expressed naturally using lambdas, but lambdas naturally express functions. So we need constraint logic programming as well to get full expressiveness of our functions.</p>
</section>
</section>
<section id="other-programming-languages">
<h2>Other programming languages<a class="headerlink" href="#other-programming-languages" title="Permalink to this heading"></a></h2>
<p>There are many existing programming languages to learn from. All of them have had effort put into their design so their features should be considered. But the disadvantages to a feature are not obvious and generally can only be found by examining complexities in large software projects in the language. The trick is to isolate the use case and cut the Gordian knot in a surgical manner.</p>
<p>Inspiring projects:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/cheery/lever/">Lever</a></p></li>
<li><p><a class="reference external" href="https://github.com/BSVino/JaiPrimer/blob/4a2d14f3e1c8e82a4ba68b81d3fd7d8d438e955c/JaiPrimer.md">Jai</a></p></li>
<li><p><a class="reference external" href="https://pinafore.info/">Pinafore</a></p></li>
<li><p><a class="reference external" href="http://github.com/codedot/lambda">Macro Lambda Calculus</a></p></li>
<li><p><a class="reference external" href="https://github.com/manuel/wat-js">Wat</a></p></li>
<li><p><a class="reference external" href="https://github.com/vito/atomo">Atomo</a> / <a class="reference external" href="https://github.com/vito/atomy">Atomy</a></p></li>
</ul>
<p>Languages in TIOBE index order:</p>
<p>Python</p>
<ul class="simple">
<li><p>Most popular on TIOBE index, said to be “easy to learn for beginners”, “simple and elegant syntax” “similar to English”.</p></li>
<li><p>brevity, readability, developer-friendliness make it 5-10x more productive than Java</p></li>
<li><p>“Batteries included” standard libraries, such as lists and dictionaries, numpy (BLAS wrapper) and scipy</p></li>
<li><p>Twisted web framework</p></li>
<li><p>Mixed reference counting / tracing GC memory management</p></li>
<li><p>Significant indentation - still a point of contention, e.g. whether it makes copy pasting code harder</p></li>
<li><p>C++ interpreter CPython, slow performance. PyPy exists but has’t been widely adopted due to incompatibility.</p></li>
</ul>
<p>C</p>
<ul class="simple">
<li><p>old and widespread language. Language of most OS’s, hence runs just about everywhere (portable).</p></li>
<li><p>statically compiled, compilers are very efficient.</p></li>
<li><p>unsafe pointers, common to see memory corruption and security vulnerabilities. valgrind, smart fuzzing, and static analysis have allowed catching these. Also there is the Boehm GC, used by many people who don’t want to deal with memory management.</p></li>
<li><p>header files slow down compilation as they have to be read many times during compilation</p></li>
</ul>
<p>Java</p>
<ul class="simple">
<li><p>Baroque type system, many types of class-like thing (interfaces, enumerations, anonymous adapters), with generics on top</p></li>
<li><p>Compromises between performance and expressiveness such as covariant arrays</p></li>
<li><p>The OO mantra has led to design patterns, which are a reference point for features support with explicit syntax. The class-based syntax for the patterns is not worth emulating.</p></li>
<li><p>try-finally and checked exceptions have wasted the time of many programmers.</p></li>
<li><p>Keyword soup for declarations, such as “public static void main”.</p></li>
<li><p>Lack of operator overloading such as <code class="docutils literal notranslate"><span class="pre">+</span></code> for <code class="docutils literal notranslate"><span class="pre">BigInteger</span></code></p></li>
<li><p>Every object has a 4-byte header and identity using <code class="docutils literal notranslate"><span class="pre">==</span></code>. No value types besides primitives.</p></li>
<li><p>Requirement that the class name must match the directory name.  When moving functionality around this implies a lot of changes inside source files. Led to IDEs with extensive support for refactoring.</p></li>
<li><p>Static methods. Scoped to a class, but not related to objects. Can be very confusing.</p></li>
<li><p>JIT is probably best in the world for throughput. Startup is slow but throughput matches C performance in many cases.</p></li>
<li><p>Garbage collector takes big chunks of CPU time at irregular intervals. Low-pause GCs trade this for continuous overhead. Still not solved, around 15% overhead on wall clock time . <span id="id1">[<a class="reference internal" href="../zzreferences.html#id23" title="Zixian Cai, Stephen M Blackburn, Michael D Bond, and Martin Maas. Distilling the Real Cost of Production Garbage Collectors. IEEE International Symposium on Performance Analysis of Systems and Software, pages 12, 2022.">CBBM22</a>]</span></p></li>
</ul>
<p>C++</p>
<ul class="simple">
<li><p>many features, which interact in messy/complex ways making C++ take a long time to learn</p></li>
<li><p>fast, efficient standard libraries similar to hand-tuned code (but missing many features, see also Boost)</p></li>
<li><p>templates, efficient at runtime but slow at compile time</p></li>
<li><p>memory unsafe like C, although smart pointers make this a little better.</p></li>
</ul>
<p>C#</p>
<ul class="simple">
<li><p>best designed C-style syntax - e.g. introduced async/await</p></li>
<li><p>wide usage - desktop software (Windows), games (MonoGame, Unity), web development (ASP.NET Core), mobile (Xamarin)</p></li>
</ul>
<p>Visual Basic</p>
<ul class="simple">
<li><p>“mentally mutilates” programmers (according to Dijkstra)</p></li>
<li><p>runs on .NET, so very similar to C# in semantics</p></li>
</ul>
<p>JavaScript</p>
<ul class="simple">
<li><p>second-best JIT, optimized for startup time - fast bytecode interpreters</p></li>
<li><p>many strange features such as implicit type conversion, <code class="docutils literal notranslate"><span class="pre">with</span></code> statement, and <code class="docutils literal notranslate"><span class="pre">eval</span></code></p></li>
</ul>
<p>Swift</p>
<ul class="simple">
<li><p>Automatic reference counting, interesting but not something I want to copy</p></li>
<li><p>syntax for exception handling, if let/guard let</p></li>
<li><p><a class="reference external" href="https://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html">exponentially slow</a> type inference for numeric expressions, with bad heuristics</p></li>
</ul>
<p>Delphi / Object Pascal</p>
<ul class="simple">
<li><p>still kicking</p></li>
<li><p>proprietary, so not worth looking at too closely</p></li>
</ul>
<p>PHP</p>
<ul class="simple">
<li><p>Initial design was hacked together quickly, inconsistent API design. Could be fixed but backwards compatibility is more important.</p></li>
<li><p>Several features with huge security or performance impact: eval, weak typing</p></li>
</ul>
<p>Objective C</p>
<ul class="simple">
<li><p>deprecated by Apple in favor of Swift, but a good comparison against C++</p></li>
</ul>
<p>Go</p>
<ul class="simple">
<li><p>opinionated design, touts meaningless features such as “strong typing”</p></li>
<li><p>goroutines, killer feature</p></li>
<li><p>finally added generics after a long time</p></li>
<li><p>supposedly a Python replacement, but TensorFlow is mainly in Python and the Go binding <a class="reference external" href="https://github.com/tensorflow/build/tree/master/golang_install_guide">isn’t officially supported</a></p></li>
</ul>
<p>R</p>
<ul class="simple">
<li><p>numerous libraries for statistics and data analysis</p></li>
<li><p>lazy evaluation</p></li>
</ul>
<p>Perl</p>
<ul class="simple">
<li><p>A mess with the Raku split</p></li>
<li><p>Various libraries on CPAN are good</p></li>
<li><p>Contexts and sigils, terrible syntax IMO</p></li>
</ul>
<p>Lua</p>
<ul class="simple">
<li><p>Use of “tables” for everything is interesting</p></li>
<li><p>LuaJIT was fast but the main developer left. Storscot needs to avoid the same fate.</p></li>
</ul>
<p>Ruby</p>
<ul class="simple">
<li><p>weird syntax, e.g. expression by itself is return value - causes mistakes.</p></li>
<li><p>Rails is <a class="reference external" href="https://www.jetbrains.com/lp/devecosystem-2021/ruby/#Ruby_what-web-development-tools-and-or-frameworks-do-you-regularly-use-if-any">(still)</a> the most popular framework</p></li>
<li><p>slow, <a class="reference external" href="https://github.com/ruby/ruby/blob/master/doc/yjit/yjit.md">YJIT</a> added in 3.1</p></li>
</ul>
<p>Prolog</p>
<ul class="simple">
<li><p>The inference algorithm (SLD resolution) is inefficient and should be replaced with DPLL or CDCL. But SLD’s simplicity is the main reason Prolog execution is comprehensible.</p></li>
<li><p>Teyjus / λProlog rely on higher order pattern unification. It is possible to use Huet’s semi-algorithm for higher order unification, though the lack of most general unifiers complicates things.</p></li>
</ul>
<p>Rust</p>
<ul class="simple">
<li><p>good standard library design and documentation, probably worth copying</p></li>
<li><p>voted “most loved” by StackOverflow</p></li>
<li><p>borrow checker, can’t even write linked lists without <a class="reference external" href="https://rcoh.me/posts/rust-linked-list-basically-impossible/">endless pain</a>. They <a class="reference external" href="https://rust-unofficial.github.io/too-many-lists/third-layout.html">end up</a>  using reference counting as a substitute for GC to ensure memory safety</p></li>
<li><p>concurrency safe, but async suffers from “borrow checker”-itis and uses atomic reference counting</p></li>
</ul>
<p>Julia</p>
<ul class="simple">
<li><p>good support for concurrency/parallelism</p></li>
<li><p>C+Fortran+Python FFIs and syntax</p></li>
<li><p>JIT design assumes trampolines, performance barrier</p></li>
</ul>
<p>Kotlin</p>
<ul class="simple">
<li><p>JVM languages with improved features compared to Java</p></li>
<li><p>val keyword instead of final, null safety, extension methods, first-class type parameters</p></li>
<li><p>coroutines</p></li>
</ul>
<p>D</p>
<ul class="simple">
<li><p>C/C++ style but different. Never really took off AFAICT.</p></li>
<li><p>many features that have been incorporated into C++, others that haven’t like scope guards</p></li>
</ul>
<p>Scala</p>
<ul class="simple">
<li><p>Type inference, allows avoiding repetition of Java such as <code class="docutils literal notranslate"><span class="pre">SomeModule.MyClass</span> <span class="pre">v</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">SomeModule.MyClass();</span></code></p></li>
<li><p>complex type system: implicit conversions, subtyping</p></li>
</ul>
<p>TypeScript</p>
<ul class="simple">
<li><p><a class="reference external" href="https://stackoverflow.com/questions/29918324/is-typescript-really-a-superset-of-javascript">near superset</a> of JavaScript with an unsound type system</p></li>
<li><p>doesn’t really add anything besides the types, so only useful for ideas on gradual typing</p></li>
</ul>
<p>Haskell</p>
<ul class="simple">
<li><p>“finest imperative programming language”</p></li>
<li><p>small community, few core/maintenance developers (mainly SPJ) compared to size of codebase</p></li>
<li><p>good in benchmarks and scripting but GC is still not usable in production</p></li>
<li><p>poor library design, e.g. verbose naming conventions</p></li>
</ul>
<p>Clojure</p>
<ul class="simple">
<li><p>one of few languages to use software transactional memory, custom implementation “MVCC”</p></li>
<li><p><a class="reference external" href="https://github.com/matthiasn/talk-transcripts/tree/master/Hickey_Rich">interesting talks</a> on functional programming and language design</p></li>
<li><p>runs well on JVM</p></li>
</ul>
<p>Elm</p>
<ul class="simple">
<li><p>small ecosystem</p></li>
<li><p>derivative of OCaml</p></li>
<li><p>no substantial commits in main repo since 2019</p></li>
<li><p>BDFL doing “exploratory work” closed-repo, most recently described in a 2021 <a class="reference external" href="https://discourse.elm-lang.org/t/status-update-3-nov-2021/7870">status update</a></p></li>
</ul>
<p>Erlang</p>
<ul class="simple">
<li><p>has a well-tested distributed, fault-tolerant, reliable, soft real-time, concurrent database</p></li>
<li><p>designed to be crash-only, restart tolerant</p></li>
<li><p>not used much outside Ericsson</p></li>
</ul>
<p>Elixir</p>
<ul class="simple">
<li><p>based on Erlang, new and supposedly great syntax</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="PackageManager.html" class="btn btn-neutral float-left" title="Package manager" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Programs.html" class="btn btn-neutral float-right" title="Exemplary programs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>