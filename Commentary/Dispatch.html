<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dispatch &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Evaluation strategy" href="Evaluation-Strategy.html" />
    <link rel="prev" title="Core syntax" href="CoreSyntax.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Dispatch</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#priorities">Priorities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#clos-method-dispatch">CLOS method dispatch</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#overloading">Overloading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#default-arguments">Default arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#return-type-overloading">Return type overloading</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#defaulting">Defaulting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#signatures">Signatures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inference">Inference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Paradigms.html">Comparison</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Commentary</a> &raquo;</li>
      <li>Dispatch</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Dispatch.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="dispatch">
<h1>Dispatch<a class="headerlink" href="#dispatch" title="Permalink to this heading"></a></h1>
<section id="priorities">
<h2>Priorities<a class="headerlink" href="#priorities" title="Permalink to this heading"></a></h2>
<p>Priority is novel AFAIK but powerful, and generalizes the CLOS dispatch system. I thought about making all clauses the same priority by default, but concluded that specificity was likely going to be confusing hence is better off opt-in. Specificity is found in predicate dispatch and Zarf’s rule based programming, but both are far off from practical languages.</p>
<section id="clos-method-dispatch">
<h3>CLOS method dispatch<a class="headerlink" href="#clos-method-dispatch" title="Permalink to this heading"></a></h3>
<p>CLOS has method qualifiers <code class="docutils literal notranslate"><span class="pre">before</span></code>, <code class="docutils literal notranslate"><span class="pre">after</span></code>, and <code class="docutils literal notranslate"><span class="pre">around</span></code>. The basic idea of method combination can be seen here:</p>
<img alt="../_images/Method-combination.png" src="../_images/Method-combination.png" />
<p>But it turns out these can simply be implemented with priorities <code class="docutils literal notranslate"><span class="pre">around_clause</span> <span class="pre">&gt;</span> <span class="pre">before_clause</span> <span class="pre">&gt;</span> <span class="pre">after_clause</span> <span class="pre">&gt;</span> <span class="pre">prioHigh</span></code> and next-method. <code class="docutils literal notranslate"><span class="pre">before</span></code> and <code class="docutils literal notranslate"><span class="pre">after</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">before</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">around</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span><span class="n">next</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="nf">after</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">around</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">next</span><span class="o">-</span><span class="n">method</span><span class="p">;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Guards are handled by calling next-method on failure:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">around</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">next</span><span class="o">-</span><span class="n">method</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="overloading">
<h2>Overloading<a class="headerlink" href="#overloading" title="Permalink to this heading"></a></h2>
<p><a class="reference external" href="https://go.dev/doc/faq#overloading">The Go FAQ</a> says Go deliberately does not support overloading, but then it admits overloading is “occasionally useful”. Actually, Go does support a limited form of overloading, in the form of interfaces - you can write <code class="docutils literal notranslate"><span class="pre">a.area()</span></code> and <code class="docutils literal notranslate"><span class="pre">b.area()</span></code> and these refer to different methods. But it’s limited to dispatching on the self parameter’s type.</p>
<p>The Go FAQ says overloading is confusing and fragile. Life is confusing and fragile, but this does not mean eliminating all life is the solution.</p>
<p>The Go FAQ says naming separate functions leads to a clearer API. While separate functions can be clearer, supporting overloading does not prevent creating separate functions. And suppose you are trying to wrap a Java library that makes heavy use of overloading. Name mangling using simple rules will give relatively long names like <code class="docutils literal notranslate"><span class="pre">divide_int_int</span></code>. More complicated rules will give shorter name like <code class="docutils literal notranslate"><span class="pre">div_ii</span></code>, but the names will be hard to remember. Either way, overloading means no mangling is needed at all, a strictly better alternative.</p>
<p>The Go FAQ says leaving overloading out simplifies the type system and method dispatch. Overloading doesn’t complicate a dynamic type system at all. It does complicate method dispatch, but in exchange overloading enables generic functions and solves the expression problem, so it’s worth it.</p>
<p>So the verdict here is that the Go developers were just too lazy to implement overloading.</p>
</section>
<section id="default-arguments">
<h2>Default arguments<a class="headerlink" href="#default-arguments" title="Permalink to this heading"></a></h2>
<p>Default arguments are very similar in expressiveness to overloading, so as one might expect <a class="reference external" href="https://talks.golang.org/2012/splash.article">Rob Pike</a> says Go deliberately does not support default arguments. Supposedly adding default arguments to a function results in interactions among arguments that are difficult to understand.</p>
<p>Pike admits that it is really easy to patch API design flaws by adding a default argument. Expanding on this, it seems default arguments have a good place in the lifecycle of an API parameter:</p>
<ol class="arabic simple">
<li><p>A new parameter can be added to a function, just give it a default value such that the function behavior is unchanged.</p></li>
<li><p>The whole argument can be deprecated and removed on a major release, hard-coding the default value</p></li>
<li><p>The default value can be deprecated and then removed on a major release, forcing the value to be specified.</p></li>
<li><p>An existing parameter can be given a default value without breaking compatibility</p></li>
</ol>
<div class="graphviz"><object data="../_images/graphviz-f5df746232bb87f68aa9c40b9d520f54204a1d7c.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
rankdir=LR
Missing -&gt; Defaulted [label=&quot;1&quot;]
Defaulted -&gt; Missing [label=&quot;2&quot;, color=&quot;blue&quot;]
Defaulted -&gt; Present [label=&quot;3&quot;, color=&quot;blue&quot;]
Present -&gt; Defaulted [label=&quot;4&quot;]
}</p></object></div>
<p>One side effect of this lifecycle is it gravitates towards default parameters, because those don’t break compatibility. So programs accumulate many default parameters that should be made into required parameters or removed. This is probably why developers say default parameters are a code smell (nonwithstanding the internet’s main opinion, which comes from C#’s implementation breaking ABI compatibility in a way that can be fixed by using regular overloading). But regular pruning should be possible, just do occasional surveys as to remove/make mandatory/leave alone. And, without default parameters, adding or removing a parameter immediately breaks the API without a deprecation window, so it is effectively impossible - you have to make a new method name. This is why Linux has the unimaginatively named syscalls <code class="docutils literal notranslate"><span class="pre">dup</span></code>, <code class="docutils literal notranslate"><span class="pre">dup2</span></code> and <code class="docutils literal notranslate"><span class="pre">dup3</span></code>. IMO having deprecated parameters is better than trying to come up with a new name or having version numbers in names.</p>
<p>A <a class="reference external" href="https://github.com/wartremover/wartremover/issues/116">wartremover issue</a> provides 4 potentially problematic cases for default arguments. Going through them:</p>
<ul class="simple">
<li><p>Automatically allocated resource arg - this is deallocated by the finalizer system in Stroscot, hence no resource management problem. To avoid statefulness, the pattern is to default to a special value like <code class="docutils literal notranslate"><span class="pre">AutoAllocate</span></code> and do the allocation in the method body.</p></li>
<li><p>Config - a big win convenience-wise for default arguments, only specify the parameters you care about.</p></li>
<li><p>Delegated parameter: this is nicely handled in Stroscot by implicit parameters. Hence a pattern like <code class="docutils literal notranslate"><span class="pre">ingest</span> <span class="pre">{compressor</span> <span class="pre">=</span> <span class="pre">None}</span> <span class="pre">=</span> <span class="pre">...;</span> <span class="pre">doIngestion</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">log;</span> <span class="pre">ingest</span> <span class="pre">};</span> <span class="pre">executeIngest</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">prepare;</span> <span class="pre">doIngestion</span> <span class="pre">};</span> <span class="pre">parseAndExec</span> <span class="pre">cmdline</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">compressor</span> <span class="pre">=</span> <span class="pre">parse</span> <span class="pre">cmdline;</span> <span class="pre">executeIngest</span> <span class="pre">}</span></code> is possible. Once you realize the compressor is important you can remove the default and make it a keyword parameter - the default can still be provided as a definition in an importable module, and you get an unset argument error if no implicit parameter is set.</p></li>
<li><p>Faux overloading like <code class="docutils literal notranslate"><span class="pre">foo(i,</span> <span class="pre">name</span> <span class="pre">=</span> <span class="pre">&quot;s&quot;)</span></code> - useful just like overloading.</p></li>
</ul>
<p>The verdict here is that defaulting is a power vs predictability tradeoff. The obvious choice given Stroscot’s principles is power. There are no easy solutions for adding new behavior to a function besides adding a default argument flag to modifying an API in a backwards-compatible way, so default arguments are necessary. And default arguments have been used in creative ways to make fluent interfaces, giving programmers the enjoyment of complex interface design. The added implementation complexity is small. Security concerns are on the level of misreading the API docs, which is possible in any case. Adding a warning that a default argument has not been specified, forcing supplying all parameters to every method, seems sufficient.</p>
</section>
<section id="return-type-overloading">
<h2>Return type overloading<a class="headerlink" href="#return-type-overloading" title="Permalink to this heading"></a></h2>
<p>In Haskell, typeclasses can cause ambiguity errors. For example <code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">(read</span> <span class="pre">&quot;1&quot;)</span></code> gives “Ambiguous type variable ‘a0’ arising from ‘show’ and ‘read’ prevents the constraint ‘(Show a0, Read a0)’ from being solved.”</p>
<p>Following <span id="id1">[<a class="reference internal" href="../zzreferences.html#id102" title="Martin Odersky, Philip Wadler, and Martin Wehr. A second look at overloading. In Proceedings of the Seventh International Conference on Functional Programming Languages and Computer Architecture - FPCA '95, 135–146. La Jolla, California, United States, 1995. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=224164.224195 (visited on 2022-06-07), doi:10.1145/224164.224195.">OWW95</a>]</span> the ambiguity can be further attributed to <code class="docutils literal notranslate"><span class="pre">read</span></code>. The function <code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">::</span> <span class="pre">Show</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code> takes a value of type <code class="docutils literal notranslate"><span class="pre">a</span></code>, so dynamic dispatch can deduce the type <code class="docutils literal notranslate"><span class="pre">a</span></code> and there is no ambiguity. In contrast <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">&quot;1&quot;</span></code> produces a type out of nowhere and could be of type <code class="docutils literal notranslate"><span class="pre">Integer</span></code> or <code class="docutils literal notranslate"><span class="pre">Double</span></code>. Since <code class="docutils literal notranslate"><span class="pre">read</span></code> has a constraint <code class="docutils literal notranslate"><span class="pre">Read</span> <span class="pre">a</span></code> and does not take a value of type <code class="docutils literal notranslate"><span class="pre">a</span></code> as argument it is said to be return type overloaded (RTOed).</p>
<p>A brief categorization of some RTO functions in GHC’s base libraries:</p>
<ul class="simple">
<li><p>Conversion functions, functions that extract a value: <code class="docutils literal notranslate"><span class="pre">toEnum</span> <span class="pre">::</span> <span class="pre">Enum</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">fromInteger</span> <span class="pre">::</span> <span class="pre">Num</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Integer</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">fromRational</span> <span class="pre">::</span> <span class="pre">Fractional</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Rational</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">encodeFloat</span> <span class="pre">::</span> <span class="pre">RealFloat</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Integer</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">indexByteArray#</span> <span class="pre">::</span> <span class="pre">Prim</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">ByteArray#</span> <span class="pre">-&gt;</span> <span class="pre">Int#</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code></p></li>
<li><p>Overloaded constants: <code class="docutils literal notranslate"><span class="pre">maxBound</span> <span class="pre">::</span> <span class="pre">Bounded</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">mempty</span> <span class="pre">::</span> <span class="pre">Monoid</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">::</span> <span class="pre">Default</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code></p></li>
<li><p>Monadically-overloaded operations: <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">::</span> <span class="pre">Applicative</span> <span class="pre">f</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">getLine</span> <span class="pre">::</span> <span class="pre">Interactive</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">String</span></code>, <code class="docutils literal notranslate"><span class="pre">fail</span> <span class="pre">::</span> <span class="pre">MonadFail</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">ask</span> <span class="pre">::</span> <span class="pre">MonadReader</span> <span class="pre">r</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">r</span></code> <code class="docutils literal notranslate"><span class="pre">parsec</span> <span class="pre">::</span> <span class="pre">(Parsec</span> <span class="pre">a,</span> <span class="pre">CabalParsing</span> <span class="pre">m)</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code></p></li>
<li><p>Type-indexed constant: <code class="docutils literal notranslate"><span class="pre">get</span> <span class="pre">::</span> <span class="pre">Binary</span> <span class="pre">t</span> <span class="pre">=&gt;</span> <span class="pre">Get</span> <span class="pre">t</span></code>, <code class="docutils literal notranslate"><span class="pre">readsPrec</span> <span class="pre">::</span> <span class="pre">(Read</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">ReadS</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">buildInfo</span> <span class="pre">::</span> <span class="pre">HasBuildInfo</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Lens'</span> <span class="pre">a</span> <span class="pre">BuildInfo</span></code>, <code class="docutils literal notranslate"><span class="pre">garbitrary</span> <span class="pre">::</span> <span class="pre">GArbitrary</span> <span class="pre">f</span> <span class="pre">=&gt;</span> <span class="pre">Gen</span> <span class="pre">(f</span> <span class="pre">())</span></code></p></li>
<li><p>GADT faffing: <code class="docutils literal notranslate"><span class="pre">iodataMode</span> <span class="pre">::</span> <span class="pre">KnownIODataMode</span> <span class="pre">mode</span> <span class="pre">=&gt;</span> <span class="pre">IODataMode</span> <span class="pre">mode</span></code>, <code class="docutils literal notranslate"><span class="pre">hGetIODataContents</span> <span class="pre">::</span> <span class="pre">KnownIODataMode</span> <span class="pre">mode</span> <span class="pre">=&gt;</span> <span class="pre">System.IO.Handle</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">mode</span></code></p></li>
<li><p>Creating arrays of type: <code class="docutils literal notranslate"><span class="pre">newArray</span> <span class="pre">::</span> <span class="pre">(MArray</span> <span class="pre">a</span> <span class="pre">e</span> <span class="pre">m</span> <span class="pre">,</span> <span class="pre">Ix</span> <span class="pre">i)</span> <span class="pre">=&gt;</span> <span class="pre">(i,i)</span> <span class="pre">-&gt;</span> <span class="pre">e</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">(a</span> <span class="pre">i</span> <span class="pre">e)</span></code>, <code class="docutils literal notranslate"><span class="pre">basicUnsafeNew</span> <span class="pre">::</span> <span class="pre">PrimMonad</span> <span class="pre">m,</span> <span class="pre">MVector</span> <span class="pre">v</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">(v</span> <span class="pre">(PrimState</span> <span class="pre">m)</span> <span class="pre">a)</span></code></p></li>
<li><p>Representable functors: <code class="docutils literal notranslate"><span class="pre">tabulate</span> <span class="pre">::</span> <span class="pre">Representable</span> <span class="pre">f</span> <span class="pre">=&gt;</span> <span class="pre">(Rep</span> <span class="pre">f</span> <span class="pre">-&gt;</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">unmodel</span> <span class="pre">::</span> <span class="pre">TestData</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Model</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, where <code class="docutils literal notranslate"><span class="pre">Rep</span></code> and <code class="docutils literal notranslate"><span class="pre">Model</span></code> are type synonym families of their respective classes</p></li>
</ul>
<p>GHC has several ways to resolve an RTOed expression:</p>
<section id="defaulting">
<h3>Defaulting<a class="headerlink" href="#defaulting" title="Permalink to this heading"></a></h3>
<p>Defaulting is considered by <a class="reference external" href="https://web.archive.org/web/20200107071106/https://prime.haskell.org/wiki/Defaulting">Haskell Prime Proposal 4</a> to be a wart of the language. <a class="reference external" href="https://www.reddit.com/r/haskell/comments/mprk2e/generalized_named_and_exportable_default/gubpfbn/">clinton84</a> want a switch NoDefaulting to remove it entirely. But GHC plans to move in the opposite direction, expanding its use by allowing more and more classes to be defaulted, and recently allowing defaulting rules to be exported. <a class="reference external" href="https://ghc-proposals.readthedocs.io/en/latest/proposals/0409-exportable-named-default.html">ref</a></p>
<p>In Haskell 98 defaulting is limited to numeric types, where it allows numerical calculations such as <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">^</span> <span class="pre">2</span></code> - <code class="docutils literal notranslate"><span class="pre">^</span></code> is generic in the 2 so must be defaulted. This usage can be replaced with using a single arbitrary-precision type for all literals that can accurately hold both <code class="docutils literal notranslate"><span class="pre">Integer</span></code> and <code class="docutils literal notranslate"><span class="pre">Double</span></code>, and then Julia’s conversion/promotion mechanism in operations.</p>
<p>With -XOverloadedStrings every string literal is wrapped in a call to <code class="docutils literal notranslate"><span class="pre">fromString</span> <span class="pre">:</span> <span class="pre">IsString</span> <span class="pre">s</span> <span class="pre">=&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">s</span></code>. The usage is that Haskell has several text types, such as <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> and <code class="docutils literal notranslate"><span class="pre">Text</span></code>, and also some people define newtypes over them. The defaulting to <code class="docutils literal notranslate"><span class="pre">IsString</span> <span class="pre">String</span></code> seems to mainly be added for compatibility with existing source code. Probably Julia’s conversion/promotion mechanism is sufficient for this as well. The corresponding <code class="docutils literal notranslate"><span class="pre">IsList</span></code> class for -XOverloadedLists has no defaulting rules, and nobody is complaining.</p>
<p>ExtendedDefaultRules for the Show, Eq, Ord, Foldable and Traversable classes is simply a hack for Curry-style type system oddities in GHCi - since the involved classes have no RTOed functions, it is unnecessary in an untyped setting. For instance, <code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">[]</span></code> is unambiguous in a dynamically typed language - it matches a rule <code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">[]</span> <span class="pre">=</span> <span class="pre">...</span></code>. In Haskell it has a polymorphic type <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">[a]</span></code> and no principal <code class="docutils literal notranslate"><span class="pre">Show</span></code> instance because GHC does not allow polymorphic type class instances. GHCi defaulting to <code class="docutils literal notranslate"><span class="pre">[Void]</span></code> instead of <code class="docutils literal notranslate"><span class="pre">[()]</span></code> would make this clear, but <code class="docutils literal notranslate"><span class="pre">Void</span></code> was only recently added to the base library so GHCi uses <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
<p>GHC also supports defaulting plugins, <a class="reference external" href="https://github.com/hasktorch/hasktorch/issues/514">supposedly</a> to specify default device types and numeric types for tensors in haskell-torch. The defaulting can likely be solved by using default or implicit parameters. And Haskell-torch is a port of PyTorch so everything can be solved by using dynamic types. AFAICT there are no working defaulting plugins currently available.</p>
</section>
<section id="signatures">
<h3>Signatures<a class="headerlink" href="#signatures" title="Permalink to this heading"></a></h3>
<p>The most direct way to resolve RTO in Haskell is to specify the type. There is an inline signature <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">x</span> <span class="pre">::</span> <span class="pre">Float</span></code>, defining a helper <code class="docutils literal notranslate"><span class="pre">readFloat</span> <span class="pre">::</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">Float;</span> <span class="pre">readFloat</span> <span class="pre">=</span> <span class="pre">read</span></code>, or using type application <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">&#64;Float</span></code>. Rust traits are similar, the turbofish specifies the type explicitly, like <code class="docutils literal notranslate"><span class="pre">iterator.collect::&lt;Vec&lt;i32&gt;&gt;</span></code>, and the type inference for defaulting is local rather than global. Ada similarly can disambiguate by return type because the type of the LHS is specified.</p>
<p>Inline signatures and type application can be replaced in a dynamic language by passing the type explicitly as a parameter, <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">Double</span></code> or <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">Float</span></code>, using normal overloading. Sometimes it can be shortened by making the type itself the function, <code class="docutils literal notranslate"><span class="pre">Vec</span> <span class="pre">i32</span> <span class="pre">iterator</span></code> or <code class="docutils literal notranslate"><span class="pre">Vec</span> <span class="pre">iterator</span></code> instead of <code class="docutils literal notranslate"><span class="pre">collect</span> <span class="pre">(Vec</span> <span class="pre">i32)</span> <span class="pre">iterator</span></code>. Either way, the resulting syntax is uniform, and more standard and simple than the observed Haskell / Rust syntax.</p>
<p>Multiple parameters can be handled in the obvious way, <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">A</span> <span class="pre">B</span></code>, or we can pack them in a term <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">(term</span> <span class="pre">A</span> <span class="pre">B)</span></code>.</p>
<section id="return-types-signatures">
<h4>Return types signatures<a class="headerlink" href="#return-types-signatures" title="Permalink to this heading"></a></h4>
<p>Julia essentially uses the same syntax I’m planning, <code class="docutils literal notranslate"><span class="pre">zeros(Float64,0)</span></code>, with strict matching on the type <code class="docutils literal notranslate"><span class="pre">Float64</span></code>. Contrariwise Martin Holters, a professor in Germany researching audio processing (i.e. not a language designer), filed a <a class="reference external" href="https://github.com/JuliaLang/julia/issues/19206">Julia issue</a> to introduce more complex syntax <code class="docutils literal notranslate"><span class="pre">foo(x,y,z)::Type</span></code> that specifies the return type. The issue generated no substantial discussion for 5 years so could be ignored, but let’s go through it.</p>
<p>Martin says a dedicated syntax would be clearer than the “return type as first argument” convention because the type passed is used inconsistently. He gives a list of function calls using <code class="docutils literal notranslate"><span class="pre">Float64</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">map(Float64,</span> <span class="pre">1)</span> <span class="pre">=</span> <span class="pre">1.0</span></code>: this applies <code class="docutils literal notranslate"><span class="pre">Float64</span></code> to 1. IMO this should error because <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">:</span> <span class="pre">Int</span></code> is not a collection type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">map(Float64,</span> <span class="pre">(1,</span> <span class="pre">2))</span> <span class="pre">=</span> <span class="pre">(1.0,2.0)</span></code>: good, so long as the overloading of types as conversions is remembered. It would be clearer to write <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">(convert</span> <span class="pre">Float64)</span> <span class="pre">(1,</span> <span class="pre">2)</span> <span class="pre">=</span> <span class="pre">(1.0,2.0)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rand(Float64)</span> <span class="pre">=</span> <span class="pre">0.16908130360440443</span></code>: <code class="docutils literal notranslate"><span class="pre">Float64</span></code> is the return type, good.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rand(Float64,</span> <span class="pre">1)</span> <span class="pre">=</span> <span class="pre">Vector{Float64}</span> <span class="pre">[0.1455494388391413]</span></code>: returning a vector is a bit inconsistent with the previous. It would be better to have a separate function <code class="docutils literal notranslate"><span class="pre">randvec</span></code> that takes a varargs list of dimensions, so <code class="docutils literal notranslate"><span class="pre">randvec(Float64)</span></code> would return a 0-dimensional array. With this using interpreting the parameter as the element type is fine.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zeros(Float64)</span> <span class="pre">=</span> <span class="pre">Array{Float64,</span> <span class="pre">0}</span> <span class="pre">[0.0]</span></code>: This always returns an array and interprets as the element type, like the proposed <code class="docutils literal notranslate"><span class="pre">randvec</span></code>. Good.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zeros(Float64,</span> <span class="pre">1)</span> <span class="pre">=</span> <span class="pre">Vector{Float64}</span> <span class="pre">[0.0]</span></code>; Writing the full return type like <code class="docutils literal notranslate"><span class="pre">zeros(1)::Vector{Float64}</span></code> is verbose, and you would inconsistently write <code class="docutils literal notranslate"><span class="pre">zeros(1,1)::Matrix{Float64}</span></code> or <code class="docutils literal notranslate"><span class="pre">zeros(1,1)::Array{Float64,</span> <span class="pre">2}</span></code> for a 2D array, compared to <code class="docutils literal notranslate"><span class="pre">fill</span></code> which has no types involved in calling it and is length invariant.</p></li>
</ul>
<p>So the inconsistencies he points out are due to standard library oddities, rather than the syntax, and in the practical cases of <code class="docutils literal notranslate"><span class="pre">zeros</span></code> / <code class="docutils literal notranslate"><span class="pre">randvec</span></code> Martin’s syntax would be worse IMO.</p>
<p>Martin also says <code class="docutils literal notranslate"><span class="pre">foo()::T</span></code> should invoke the method <code class="docutils literal notranslate"><span class="pre">foo()::S</span></code> such that <code class="docutils literal notranslate"><span class="pre">S</span></code> is the largest type with <code class="docutils literal notranslate"><span class="pre">S&lt;:T</span></code>. It’s not clear why - he just says it “seems logical” but admits it doesn’t “translate into any real benefits”. Practically, one has to write the return type out, and writing the exact type used in the dispatch clause is simpler than picking out a supertype. For a trivial example, writing <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">{None}</span></code> instead of <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">{None,1,2}</span></code> makes it clearer that <code class="docutils literal notranslate"><span class="pre">None</span></code> will be used as the default. Furthermore it avoids conflicts like for <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">(Int|{None})</span></code> if there were two rules <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">Int</span> <span class="pre">=</span> <span class="pre">0;</span> <span class="pre">default</span> <span class="pre">{None}</span> <span class="pre">=</span> <span class="pre">None</span></code></p>
</section>
</section>
<section id="inference">
<h3>Inference<a class="headerlink" href="#inference" title="Permalink to this heading"></a></h3>
<p>The case where dynamic typing falls down is when the type is not specified directly on the function but rather is inferred. For example <code class="docutils literal notranslate"><span class="pre">(fromInteger</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">fromInteger</span> <span class="pre">2)</span> <span class="pre">::</span> <span class="pre">Int</span></code>, the type is pushed down so that <code class="docutils literal notranslate"><span class="pre">fromInteger</span> <span class="pre">1</span> <span class="pre">::</span> <span class="pre">Int</span></code>. If we went with giving the type as a parameter we would have to write <code class="docutils literal notranslate"><span class="pre">fromInteger</span> <span class="pre">Int</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">fromInteger</span> <span class="pre">Int</span> <span class="pre">2</span></code>, duplicating the type. With a function expression of fixed type <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">id</span> <span class="pre">::</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">in</span> <span class="pre">show</span> <span class="pre">(f</span> <span class="pre">$</span> <span class="pre">read</span> <span class="pre">&quot;1&quot;)</span></code> or case statement <code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">(case</span> <span class="pre">read</span> <span class="pre">&quot;1&quot;</span> <span class="pre">of</span> <span class="pre">(1</span> <span class="pre">::</span> <span class="pre">Int)</span> <span class="pre">-&gt;</span> <span class="pre">&quot;x&quot;)</span></code> the type is far removed from the ambiguous <code class="docutils literal notranslate"><span class="pre">read</span></code>.</p>
<p>It is arguable whether inference is desirable. The programmer has to perform the same type inference in their head to follow the path the compiler is taken, which can make code tricky to understand. The meaning of an expression is context-dependent. But the original typeclasses paper <span id="id2">[<a class="reference internal" href="../zzreferences.html#id141" title="P. Wadler and S. Blott. How to make ad-hoc polymorphism less ad hoc. In Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages - POPL '89, 60–76. Austin, Texas, United States, 1989. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=75277.75283 (visited on 2022-06-07), doi:10.1145/75277.75283.">WB89</a>]</span> mentions resolving overloaded constants based on the context as a feature. So this section discusses possible ways of implementing the context resolution.</p>
<p>One approach is similar to <a class="reference external" href="https://artificial-mind.net/blog/2020/10/10/return-type-overloading">this C++ thing</a>. We create a “blob” type that represents an RTO value of unknown type as a function from type to value. Then we overload operations on the blob to return blobs, delaying resolution until the full type can be inferred. Furthermore the blob can store its type in a mutable reference and use <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code> to ensure that it resolves to the same type if it is used multiple times. Or it can be safe and evaluate at multiple types. This requires overloading every function to support the blob, so can be some boilerplate.</p>
<p>A little simpler approach is to use a term, so e.g. <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">&quot;x&quot;</span></code> is a normal form. Then you overload functions to deal with these terms. This works well for nullary symbols like <code class="docutils literal notranslate"><span class="pre">maxBound</span></code> - you implement conversion <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">maxBound</span> <span class="pre">Float</span> <span class="pre">=</span> <span class="pre">float</span> <span class="pre">Infinity</span></code> and promotion will take care of the rest. The issue is that an expression like <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">&quot;1&quot;</span> <span class="pre">+</span> <span class="pre">read</span> <span class="pre">&quot;2&quot;</span></code> will not resolve the return type, and returning <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">&quot;3&quot;</span></code> is inefficient. I think the best solution is to return a blob. So this ends up being the blob solution but with readable literals for the first level of return value.</p>
<p>Another approach is to add type inference, but as a macro transformation. All it has to do is infer the types using Hindley Milner or similar and insert explicit type parameters for the RTOed functions. But this is really the opposite of what Stroscot aims for. Stroscot avoided static typing to begin with because there are no principal types if you have union types. For example a value of type <code class="docutils literal notranslate"><span class="pre">A</span></code> may take on the type <code class="docutils literal notranslate"><span class="pre">(A|B)</span></code> or <code class="docutils literal notranslate"><span class="pre">(A|C)</span></code> depending on context. The inserted types would have to be principal, negating the advantage of dynamic typing. Furthermore you’d have to use more macros to specify type instances and types of functions.</p>
<p>My original idea is to use nondeterminism: an overloaded function <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">Something</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code> is interpreted as <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">A)</span> <span class="pre">amb</span> <span class="pre">(f</span> <span class="pre">B)</span> <span class="pre">amb</span> <span class="pre">...</span></code>, combining all the typeclass instances. Disambiguating types using annotations is then replaced with disambiguating the result using assertion failures. This actually preserves the semantics of the static typeclass resolution AFAICT. In the discussion <a class="reference external" href="https://www.reddit.com/r/ProgrammingLanguages/comments/uynw2i/return_type_overloading_for_dynamic_languages/">on Reddit</a>, it was brought up that if there are a lot of overloadings or the overloadings are recursive, it would be slow, exponential in the number of function calls. That’s for a quite naive implementation; I think the compiler could do a type analysis and give good performance for most cases. HM also has exponential blowup on pathological cases. Overall I think this approach is the best, but it is not clear if it is actually helpful because features like automatic promotion will make many programs ambiguous.</p>
</section>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this heading"></a></h2>
<p>The full dispatch mechanism is as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">dispatch</span><span class="w"> </span><span class="n">clauses</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">warnIfAnyPrioEqual</span><span class="w"> </span><span class="n">clauses</span><span class="w"></span>
<span class="w">  </span><span class="n">starting_clauses</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">find_no_predecessors</span><span class="w"> </span><span class="n">clauses</span><span class="w"></span>
<span class="w">  </span><span class="n">callParallel</span><span class="w"> </span><span class="n">starting_clauses</span><span class="w"></span>
<span class="w">   </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">callParallel</span><span class="w"> </span><span class="n">clauses</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lubAll</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">clauses</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="n">clause</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">clause</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">next</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">callParallel</span><span class="w"> </span><span class="p">(</span><span class="n">find_covering</span><span class="w"> </span><span class="n">methods</span><span class="w"> </span><span class="n">clause</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">lubAll</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fold</span><span class="w"> </span><span class="n">lub</span><span class="w"> </span><span class="kt">DispatchError</span><span class="w"></span>
</pre></div>
</div>
<p>This depends on the <code class="docutils literal notranslate"><span class="pre">lub</span></code> primitive defined in <a class="reference external" href="http://conal.net/blog/posts/merging-partial-values">Conal’s post</a>. Since strict evaluation of <code class="docutils literal notranslate"><span class="pre">(1,undefined)</span></code> gives <code class="docutils literal notranslate"><span class="pre">undefined</span></code>, <code class="docutils literal notranslate"><span class="pre">lub</span></code> instead works on expressions. Expressions with little information content are in the set Bottom or ⊥, such as predicate failure, failed assertions, exceptions, and nontermination. Values are normal forms excluding bottoms, <code class="docutils literal notranslate"><span class="pre">NF</span> <span class="pre">\</span> <span class="pre">Bottom</span></code>. Aggregate expressions can be partially evaluated and hence neither bottoms nor values, such as the aforementioned <code class="docutils literal notranslate"><span class="pre">(1,undefined)</span></code>.</p>
<p>One of the clever ideas of the theory of semantic domains (“domain theory”) is to place a partial ordering on values (domain members), based on information content. Values can not only be equal and unequal, they can also have more or less information content than each other.</p>
<p>Structured types are not flat. For instance, the meaning of (i.e., the domain corresponding to) the Haskell type (Bool,Integer) contains five different kinds of values, as shown in the figure. Each arrow leads from a less-defined (less informative) value to a more-defined value.</p>
<p>Define an operation <code class="docutils literal notranslate"><span class="pre">lub</span> <span class="pre">::</span> <span class="pre">HasLub</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>.</p>
<p>If the arguments are consistent, i.e. have a common upper bound, then that is the result.
Otherwise the context is used, <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(a</span> <span class="pre">`lub`</span> <span class="pre">b)</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">`lub`</span> <span class="pre">f</span> <span class="pre">b</span></code></p>
<p>The dispatch semantics is that all methods are run in parallel using the .  Furthermore <code class="docutils literal notranslate"><span class="pre">lub</span></code> is an oracle, analyzing the whole program - we want return type overloading, return values that are not accepted by the surrounding context are discarded.</p>
<p>This falls out naturally from doing the analysis on the CPS-transformed version of the program.</p>
<p>The way Stroscot optimizes dispatch is:
* eliminate all the statically impossible cases (cases that fail)
* use profiling data to identify the hot paths
* build a hot-biased dispatch tree
* use conditionals for small numbers of branches, tables for large/uniform branches (like switch statements)</p>
<p>The standard vtable implementation of Java/C++ is out. TODO: check out pattern dispatch paper</p>
<p>Karnaugh map with profiling data</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="CoreSyntax.html" class="btn btn-neutral float-left" title="Core syntax" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Evaluation-Strategy.html" class="btn btn-neutral float-right" title="Evaluation strategy" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>