<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dispatch &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=7f41d439"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Errors" href="Errors.html" />
    <link rel="prev" title="Core syntax" href="CoreSyntax.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Aspects.html">Aspects</a></li>
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler-Library.html">Compiler library</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Dispatch</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#priorities">Priorities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#clos-method-dispatch">CLOS method dispatch</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#overloading">Overloading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#return-type-overloading">Return type overloading</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#defaulting">Defaulting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#signatures">Signatures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inference">Inference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#default-arguments">Default arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#currying">Currying</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#variadic-arguments">Variadic arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#optional-arguments">Optional arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#keyword-arguments">Keyword arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="FunctionalLogic.html">Functional logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="OpPrims.html">Operational primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Security.html">Security</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard-Library.html">Standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Symbolic.html">Symbolic computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Values.html">Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Dispatch</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Dispatch.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="dispatch">
<h1>Dispatch<a class="headerlink" href="#dispatch" title="Link to this heading"></a></h1>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading"></a></h2>
<p>A function is a pattern <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span> <span class="pre">=</span> <span class="pre">body</span></code> that matches some parameters <code class="docutils literal notranslate"><span class="pre">a,b,c</span></code> and transforms it to the body, an expression possibly referring to the parameters.</p>
<p>The parameters can either be bound positionally, meaning the syntactic position at the call site determines what formal parameter an argument is bound to, or with a keyword associating the argument with the formal parameter. Keywords allows reordering parameters. Also keyword parameters can have a default value (optional parameter).</p>
<p>The arity of a function is how many positional parameters it has. A function with arity 0 is nullary, arity 1 is unary, arity 2 is binary, arity 3 is ternary, and in general arity n is n-ary. Functions with no fixed arity are called variadic functions.</p>
<p>Functions are usually named with a function symbol identifying the function. There are also anonymous (nameless) lambda functions, which have somewhat restricted syntax compared to named functions.</p>
<p>Functions that have functions as parameters or results are called higher-order functions. Functions that don’t are called first-order functions.</p>
</section>
<section id="priorities">
<h2>Priorities<a class="headerlink" href="#priorities" title="Link to this heading"></a></h2>
<p>Priority is novel AFAIK but powerful, and generalizes the CLOS dispatch system. I thought about making all clauses the same priority by default, but concluded that specificity was likely going to be confusing hence is better off opt-in. Specificity is found in predicate dispatch and Zarf’s rule based programming, but both are far off from practical languages.</p>
<section id="clos-method-dispatch">
<h3>CLOS method dispatch<a class="headerlink" href="#clos-method-dispatch" title="Link to this heading"></a></h3>
<p>CLOS has method qualifiers <code class="docutils literal notranslate"><span class="pre">before</span></code>, <code class="docutils literal notranslate"><span class="pre">after</span></code>, and <code class="docutils literal notranslate"><span class="pre">around</span></code>. The basic idea of method combination can be seen here:</p>
<img alt="../_images/Method-combination.png" src="../_images/Method-combination.png" />
<p>But it turns out these can simply be implemented with priorities <code class="docutils literal notranslate"><span class="pre">around_clause</span> <span class="pre">&gt;</span> <span class="pre">before_clause</span> <span class="pre">&gt;</span> <span class="pre">after_clause</span> <span class="pre">&gt;</span> <span class="pre">prioHigh</span></code> and next-method. <code class="docutils literal notranslate"><span class="pre">before</span></code> and <code class="docutils literal notranslate"><span class="pre">after</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">before</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">around</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span><span class="n">next</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="p">}</span>
<span class="nf">after</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">around</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">next</span><span class="o">-</span><span class="n">method</span><span class="p">;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Guards are handled by calling next-method on failure:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">around</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">next</span><span class="o">-</span><span class="n">method</span>
</pre></div>
</div>
</section>
</section>
<section id="overloading">
<h2>Overloading<a class="headerlink" href="#overloading" title="Link to this heading"></a></h2>
<p>Overloading is having methods with the same name but different type signatures. A special case is operator overloading, so you can add both floats and ints with <code class="docutils literal notranslate"><span class="pre">+</span></code>. Even <a class="reference external" href="https://go.dev/doc/faq#overloading">the Go FAQ</a>, an opponent of overloading, admits that overloading is useful and convenient. Overloading enables ad-hoc polymorphism and solves the expression problem. It is incredibly useful.</p>
<p>Although in many cases using separate function names can lead to a clearer API, supporting overloading does not prevent this. And there are cases where overloading is the right choice. Suppose you are trying to wrap a Java library that makes heavy use of overloading. Name mangling using simple rules will give relatively long names like <code class="docutils literal notranslate"><span class="pre">divide_int_int</span></code>. More complicated rules will give shorter name like <code class="docutils literal notranslate"><span class="pre">div_ii</span></code>, but the names will be hard to remember. Either way, overloading means no mangling is needed in the API at all, a strictly better alternative. Similarly the Go API is full of families of functions like <code class="docutils literal notranslate"><span class="pre">FindAll</span> <span class="pre">:</span> <span class="pre">[Byte]</span> <span class="pre">-&gt;</span> <span class="pre">[[Byte]],</span> <span class="pre">FindAllString</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">[String]</span></code> which differ only by their type. These additional name parts cannot be guessed easily and require looking up the API docs to determine the appropriate version. Overloading means only the base name needs to be remembered.</p>
<p>Per the FAQ, Go supposedly “does not support overloading” and restricts itself to matching only by name. Actually, overloading is <a class="reference external" href="https://www.richyhbm.co.uk/posts/method-overloading-in-go/">still possible</a> in Go by defining a function which takes variadic arguments of the empty interface type and manually dispatches with <code class="docutils literal notranslate"><span class="pre">if</span></code> statements and runtime type analysis. What’s missing in Go is that the compiler does not implement an overloaded dispatch mechanism. The FAQ claims that implicit dispatch will lead to confusion about which function is being called. In particular <a class="reference external" href="https://github.com/golang/go/issues/21659#issuecomment-325382091">Ian Lance Taylor</a> brings up the situation where an overloaded function application could be resolved to multiple valid clauses. Any rule that assigns an implicit priority of clauses in going to be fragile in practice.</p>
<p>Stroscot’s solution is to require the system to produce a unique normal form. So it is an error if the multiple valid clauses produce different results, and otherwise the interpreter will pick an applicable clause at random. When compiling, the most efficient implementation will be chosen.</p>
</section>
<section id="return-type-overloading">
<h2>Return type overloading<a class="headerlink" href="#return-type-overloading" title="Link to this heading"></a></h2>
<p>In Haskell, typeclasses can cause ambiguity errors. For example <code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">(read</span> <span class="pre">&quot;1&quot;)</span></code> gives “Ambiguous type variable ‘a0’ arising from ‘show’ and ‘read’ prevents the constraint ‘(Show a0, Read a0)’ from being solved.”</p>
<p>Following <span id="id1">[<a class="reference internal" href="../zzreferences.html#id122" title="Martin Odersky, Philip Wadler, and Martin Wehr. A second look at overloading. In Proceedings of the Seventh International Conference on Functional Programming Languages and Computer Architecture - FPCA '95, 135–146. La Jolla, California, United States, 1995. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=224164.224195 (visited on 2022-06-07), doi:10.1145/224164.224195.">OWW95</a>]</span> the ambiguity can be further attributed to <code class="docutils literal notranslate"><span class="pre">read</span></code>. The function <code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">::</span> <span class="pre">Show</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code> takes a value of type <code class="docutils literal notranslate"><span class="pre">a</span></code>, so dynamic dispatch can deduce the type <code class="docutils literal notranslate"><span class="pre">a</span></code> and there is no ambiguity. In contrast <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">&quot;1&quot;</span></code> produces a type out of nowhere and could be of type <code class="docutils literal notranslate"><span class="pre">Integer</span></code> or <code class="docutils literal notranslate"><span class="pre">Double</span></code>. Since <code class="docutils literal notranslate"><span class="pre">read</span></code> has a constraint <code class="docutils literal notranslate"><span class="pre">Read</span> <span class="pre">a</span></code> and does not take a value of type <code class="docutils literal notranslate"><span class="pre">a</span></code> as argument it is said to be return type overloaded (RTOed).</p>
<p>A brief categorization of some RTO functions in GHC’s base libraries:</p>
<ul class="simple">
<li><p>Conversion functions, functions that extract a value: <code class="docutils literal notranslate"><span class="pre">toEnum</span> <span class="pre">::</span> <span class="pre">Enum</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">fromInteger</span> <span class="pre">::</span> <span class="pre">Num</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Integer</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">fromRational</span> <span class="pre">::</span> <span class="pre">Fractional</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Rational</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">encodeFloat</span> <span class="pre">::</span> <span class="pre">RealFloat</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Integer</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">indexByteArray#</span> <span class="pre">::</span> <span class="pre">Prim</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">ByteArray#</span> <span class="pre">-&gt;</span> <span class="pre">Int#</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code></p></li>
<li><p>Overloaded constants: <code class="docutils literal notranslate"><span class="pre">maxBound</span> <span class="pre">::</span> <span class="pre">Bounded</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">mempty</span> <span class="pre">::</span> <span class="pre">Monoid</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">::</span> <span class="pre">Default</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code></p></li>
<li><p>Monadically-overloaded operations: <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">::</span> <span class="pre">Applicative</span> <span class="pre">f</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">getLine</span> <span class="pre">::</span> <span class="pre">Interactive</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">String</span></code>, <code class="docutils literal notranslate"><span class="pre">fail</span> <span class="pre">::</span> <span class="pre">MonadFail</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">ask</span> <span class="pre">::</span> <span class="pre">MonadReader</span> <span class="pre">r</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">r</span></code> <code class="docutils literal notranslate"><span class="pre">parsec</span> <span class="pre">::</span> <span class="pre">(Parsec</span> <span class="pre">a,</span> <span class="pre">CabalParsing</span> <span class="pre">m)</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code></p></li>
<li><p>Type-indexed constant: <code class="docutils literal notranslate"><span class="pre">get</span> <span class="pre">::</span> <span class="pre">Binary</span> <span class="pre">t</span> <span class="pre">=&gt;</span> <span class="pre">Get</span> <span class="pre">t</span></code>, <code class="docutils literal notranslate"><span class="pre">readsPrec</span> <span class="pre">::</span> <span class="pre">(Read</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">ReadS</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">buildInfo</span> <span class="pre">::</span> <span class="pre">HasBuildInfo</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Lens'</span> <span class="pre">a</span> <span class="pre">BuildInfo</span></code>, <code class="docutils literal notranslate"><span class="pre">garbitrary</span> <span class="pre">::</span> <span class="pre">GArbitrary</span> <span class="pre">f</span> <span class="pre">=&gt;</span> <span class="pre">Gen</span> <span class="pre">(f</span> <span class="pre">())</span></code></p></li>
<li><p>GADT faffing: <code class="docutils literal notranslate"><span class="pre">iodataMode</span> <span class="pre">::</span> <span class="pre">KnownIODataMode</span> <span class="pre">mode</span> <span class="pre">=&gt;</span> <span class="pre">IODataMode</span> <span class="pre">mode</span></code>, <code class="docutils literal notranslate"><span class="pre">hGetIODataContents</span> <span class="pre">::</span> <span class="pre">KnownIODataMode</span> <span class="pre">mode</span> <span class="pre">=&gt;</span> <span class="pre">System.IO.Handle</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">mode</span></code></p></li>
<li><p>Creating arrays of type: <code class="docutils literal notranslate"><span class="pre">newArray</span> <span class="pre">::</span> <span class="pre">(MArray</span> <span class="pre">a</span> <span class="pre">e</span> <span class="pre">m</span> <span class="pre">,</span> <span class="pre">Ix</span> <span class="pre">i)</span> <span class="pre">=&gt;</span> <span class="pre">(i,i)</span> <span class="pre">-&gt;</span> <span class="pre">e</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">(a</span> <span class="pre">i</span> <span class="pre">e)</span></code>, <code class="docutils literal notranslate"><span class="pre">basicUnsafeNew</span> <span class="pre">::</span> <span class="pre">PrimMonad</span> <span class="pre">m,</span> <span class="pre">MVector</span> <span class="pre">v</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">(v</span> <span class="pre">(PrimState</span> <span class="pre">m)</span> <span class="pre">a)</span></code></p></li>
<li><p>Representable functors: <code class="docutils literal notranslate"><span class="pre">tabulate</span> <span class="pre">::</span> <span class="pre">Representable</span> <span class="pre">f</span> <span class="pre">=&gt;</span> <span class="pre">(Rep</span> <span class="pre">f</span> <span class="pre">-&gt;</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">unmodel</span> <span class="pre">::</span> <span class="pre">TestData</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Model</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, where <code class="docutils literal notranslate"><span class="pre">Rep</span></code> and <code class="docutils literal notranslate"><span class="pre">Model</span></code> are type synonym families of their respective classes</p></li>
</ul>
<p>GHC has several ways to resolve an RTOed expression:</p>
<section id="defaulting">
<h3>Defaulting<a class="headerlink" href="#defaulting" title="Link to this heading"></a></h3>
<p>Defaulting is considered by <a class="reference external" href="https://web.archive.org/web/20200107071106/https://prime.haskell.org/wiki/Defaulting">Haskell Prime Proposal 4</a> to be a wart of the language. <a class="reference external" href="https://www.reddit.com/r/haskell/comments/mprk2e/generalized_named_and_exportable_default/gubpfbn/">clinton84</a> want a switch NoDefaulting to remove it entirely. But GHC plans to move in the opposite direction, expanding its use by allowing more and more classes to be defaulted, and recently allowing defaulting rules to be exported. <a class="reference external" href="https://ghc-proposals.readthedocs.io/en/latest/proposals/0409-exportable-named-default.html">ref</a></p>
<p>In Haskell 98 defaulting is limited to numeric types, where it allows numerical calculations such as <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">^</span> <span class="pre">2</span></code> - <code class="docutils literal notranslate"><span class="pre">^</span></code> is generic in the 2 so must be defaulted. This usage can be replaced with using a single arbitrary-precision type for all literals that can accurately hold both <code class="docutils literal notranslate"><span class="pre">Integer</span></code> and <code class="docutils literal notranslate"><span class="pre">Double</span></code>, and then Julia’s conversion/promotion mechanism in operations.</p>
<p>With -XOverloadedStrings every string literal is wrapped in a call to <code class="docutils literal notranslate"><span class="pre">fromString</span> <span class="pre">:</span> <span class="pre">IsString</span> <span class="pre">s</span> <span class="pre">=&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">s</span></code>. The usage is that Haskell has several text types, such as <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> and <code class="docutils literal notranslate"><span class="pre">Text</span></code>, and also some people define newtypes over them. The defaulting to <code class="docutils literal notranslate"><span class="pre">IsString</span> <span class="pre">String</span></code> seems to mainly be added for compatibility with existing source code. Probably Julia’s conversion/promotion mechanism is sufficient for this as well. The corresponding <code class="docutils literal notranslate"><span class="pre">IsList</span></code> class for -XOverloadedLists has no defaulting rules, and nobody is complaining.</p>
<p>ExtendedDefaultRules for the Show, Eq, Ord, Foldable and Traversable classes is simply a hack for Curry-style type system oddities in GHCi - since the involved classes have no RTOed functions, it is unnecessary in an untyped setting. For instance, <code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">[]</span></code> is unambiguous in a dynamically typed language - it matches a rule <code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">[]</span> <span class="pre">=</span> <span class="pre">...</span></code>. In Haskell it has a polymorphic type <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">[a]</span></code> and no principal <code class="docutils literal notranslate"><span class="pre">Show</span></code> instance because GHC does not allow polymorphic type class instances. GHCi defaulting to <code class="docutils literal notranslate"><span class="pre">[Void]</span></code> instead of <code class="docutils literal notranslate"><span class="pre">[()]</span></code> would make this clear, but <code class="docutils literal notranslate"><span class="pre">Void</span></code> was only recently added to the base library so GHCi uses <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
<p>GHC also supports defaulting plugins, <a class="reference external" href="https://github.com/hasktorch/hasktorch/issues/514">supposedly</a> to specify default device types and numeric types for tensors in haskell-torch. The defaulting can likely be solved by using default or implicit parameters. And Haskell-torch is a port of PyTorch so everything can be solved by using dynamic types. AFAICT there are no working defaulting plugins currently available.</p>
</section>
<section id="signatures">
<h3>Signatures<a class="headerlink" href="#signatures" title="Link to this heading"></a></h3>
<p>The most direct way to resolve RTO in Haskell is to specify the type. There is an inline signature <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">x</span> <span class="pre">::</span> <span class="pre">Float</span></code>, defining a helper <code class="docutils literal notranslate"><span class="pre">readFloat</span> <span class="pre">::</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">Float;</span> <span class="pre">readFloat</span> <span class="pre">=</span> <span class="pre">read</span></code>, or using type application <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">&#64;Float</span></code>. Rust traits are similar, the turbofish specifies the type explicitly, like <code class="docutils literal notranslate"><span class="pre">iterator.collect::&lt;Vec&lt;i32&gt;&gt;</span></code>, and the type inference for defaulting is local rather than global. Ada similarly can disambiguate by return type because the type of the LHS is specified.</p>
<p>Inline signatures and type application can be replaced in a dynamic language by passing the type explicitly as a parameter, <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">Double</span></code> or <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">Float</span></code>, using normal overloading. Sometimes it can be shortened by making the type itself the function, <code class="docutils literal notranslate"><span class="pre">Vec</span> <span class="pre">i32</span> <span class="pre">iterator</span></code> or <code class="docutils literal notranslate"><span class="pre">Vec</span> <span class="pre">iterator</span></code> instead of <code class="docutils literal notranslate"><span class="pre">collect</span> <span class="pre">(Vec</span> <span class="pre">i32)</span> <span class="pre">iterator</span></code>. Either way, the resulting syntax is uniform, and more standard and simple than the observed Haskell / Rust syntax.</p>
<p>Multiple parameters can be handled in the obvious way, <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">A</span> <span class="pre">B</span></code>, or we can pack them in a term <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">(term</span> <span class="pre">A</span> <span class="pre">B)</span></code>.</p>
<section id="return-types-signatures">
<h4>Return types signatures<a class="headerlink" href="#return-types-signatures" title="Link to this heading"></a></h4>
<p>Julia essentially uses the same syntax I’m planning, <code class="docutils literal notranslate"><span class="pre">zeros(Float64,0)</span></code>, with strict matching on the type <code class="docutils literal notranslate"><span class="pre">Float64</span></code>. Contrariwise Martin Holters, a professor in Germany researching audio processing (i.e. not a language designer), filed a <a class="reference external" href="https://github.com/JuliaLang/julia/issues/19206">Julia issue</a> to introduce more complex syntax <code class="docutils literal notranslate"><span class="pre">foo(x,y,z)::Type</span></code> that specifies the return type. The issue generated no substantial discussion for 5 years so could be ignored, but let’s go through it.</p>
<p>Martin says a dedicated syntax would be clearer than the “return type as first argument” convention because the type passed is used inconsistently. He gives a list of function calls using <code class="docutils literal notranslate"><span class="pre">Float64</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">map(Float64,</span> <span class="pre">1)</span> <span class="pre">=</span> <span class="pre">1.0</span></code>: this applies <code class="docutils literal notranslate"><span class="pre">Float64</span></code> to 1. IMO this should error because <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">:</span> <span class="pre">Int</span></code> is not a collection type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">map(Float64,</span> <span class="pre">(1,</span> <span class="pre">2))</span> <span class="pre">=</span> <span class="pre">(1.0,2.0)</span></code>: good, so long as the overloading of types as conversions is remembered. It would be clearer to write <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">(convert</span> <span class="pre">Float64)</span> <span class="pre">(1,</span> <span class="pre">2)</span> <span class="pre">=</span> <span class="pre">(1.0,2.0)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rand(Float64)</span> <span class="pre">=</span> <span class="pre">0.16908130360440443</span></code>: <code class="docutils literal notranslate"><span class="pre">Float64</span></code> is the return type, good.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rand(Float64,</span> <span class="pre">1)</span> <span class="pre">=</span> <span class="pre">Vector{Float64}</span> <span class="pre">[0.1455494388391413]</span></code>: returning a vector is a bit inconsistent with the previous. It would be better to have a separate function <code class="docutils literal notranslate"><span class="pre">randvec</span></code> that takes a varargs list of dimensions, so <code class="docutils literal notranslate"><span class="pre">randvec(Float64)</span></code> would return a 0-dimensional array. With this using interpreting the parameter as the element type is fine.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zeros(Float64)</span> <span class="pre">=</span> <span class="pre">Array{Float64,</span> <span class="pre">0}</span> <span class="pre">[0.0]</span></code>: This always returns an array and interprets as the element type, like the proposed <code class="docutils literal notranslate"><span class="pre">randvec</span></code>. Good.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zeros(Float64,</span> <span class="pre">1)</span> <span class="pre">=</span> <span class="pre">Vector{Float64}</span> <span class="pre">[0.0]</span></code>; Writing the full return type like <code class="docutils literal notranslate"><span class="pre">zeros(1)::Vector{Float64}</span></code> is verbose, and you would inconsistently write <code class="docutils literal notranslate"><span class="pre">zeros(1,1)::Matrix{Float64}</span></code> or <code class="docutils literal notranslate"><span class="pre">zeros(1,1)::Array{Float64,</span> <span class="pre">2}</span></code> for a 2D array, compared to <code class="docutils literal notranslate"><span class="pre">fill</span></code> which has no types involved in calling it and is length invariant.</p></li>
</ul>
<p>So the inconsistencies he points out are due to standard library oddities, rather than the syntax, and in the practical cases of <code class="docutils literal notranslate"><span class="pre">zeros</span></code> / <code class="docutils literal notranslate"><span class="pre">randvec</span></code> Martin’s syntax would be worse IMO.</p>
<p>Martin also says <code class="docutils literal notranslate"><span class="pre">foo()::T</span></code> should invoke the method <code class="docutils literal notranslate"><span class="pre">foo()::S</span></code> such that <code class="docutils literal notranslate"><span class="pre">S</span></code> is the largest type with <code class="docutils literal notranslate"><span class="pre">S&lt;:T</span></code>. It’s not clear why - he just says it “seems logical” but admits it doesn’t “translate into any real benefits”. Practically, one has to write the return type out, and writing the exact type used in the dispatch clause is simpler than picking out a supertype. For a trivial example, writing <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">{None}</span></code> instead of <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">{None,1,2}</span></code> makes it clearer that <code class="docutils literal notranslate"><span class="pre">None</span></code> will be used as the default. Furthermore it avoids conflicts like for <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">(Int|{None})</span></code> if there were two rules <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">Int</span> <span class="pre">=</span> <span class="pre">0;</span> <span class="pre">default</span> <span class="pre">{None}</span> <span class="pre">=</span> <span class="pre">None</span></code></p>
</section>
</section>
<section id="inference">
<h3>Inference<a class="headerlink" href="#inference" title="Link to this heading"></a></h3>
<p>The case where a parameter approach falls down is when we desire an inferred type rather than specifying the type directly on the function. For example <code class="docutils literal notranslate"><span class="pre">(fromInteger</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">fromInteger</span> <span class="pre">2)</span> <span class="pre">::</span> <span class="pre">Int</span></code>, Haskell pushes the constraint down and deduces <code class="docutils literal notranslate"><span class="pre">fromInteger</span> <span class="pre">1</span> <span class="pre">::</span> <span class="pre">Int</span></code>. If we went with giving the type as a parameter we would have to write <code class="docutils literal notranslate"><span class="pre">fromInteger</span> <span class="pre">Int</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">fromInteger</span> <span class="pre">Int</span> <span class="pre">2</span></code>, duplicating the type. With a function expression of fixed type <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">id</span> <span class="pre">::</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">in</span> <span class="pre">show</span> <span class="pre">(f</span> <span class="pre">$</span> <span class="pre">read</span> <span class="pre">&quot;1&quot;)</span></code> or case statement <code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">(case</span> <span class="pre">read</span> <span class="pre">&quot;1&quot;</span> <span class="pre">of</span> <span class="pre">(1</span> <span class="pre">::</span> <span class="pre">Int)</span> <span class="pre">-&gt;</span> <span class="pre">&quot;x&quot;)</span></code> the type is far removed from the ambiguous <code class="docutils literal notranslate"><span class="pre">read</span></code>.</p>
<p>It is arguable whether inference is desirable. The programmer has to perform the same type inference in their head to follow the path the compiler is taken, which can make code tricky to understand. The meaning of an expression is context-dependent. But the original typeclasses paper <span id="id2">[<a class="reference internal" href="../zzreferences.html#id168" title="P. Wadler and S. Blott. How to make ad-hoc polymorphism less ad hoc. In Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages - POPL '89, 60–76. Austin, Texas, United States, 1989. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=75277.75283 (visited on 2022-06-07), doi:10.1145/75277.75283.">WB89</a>]</span> mentions resolving overloaded constants based on the context as a feature. So this section discusses possible ways of implementing the context resolution.</p>
<p>One approach is similar to <a class="reference external" href="https://artificial-mind.net/blog/2020/10/10/return-type-overloading">this C++ thing</a>. We create a “blob” type that represents an RTO value of unknown type as a function from type to value. Then we overload operations on the blob to return blobs, delaying resolution until the full type can be inferred. Furthermore the blob can store its type in a mutable reference and use <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code> to ensure that it resolves to the same type if it is used multiple times. Or it can be safe and evaluate at multiple types. This requires overloading every function to support the blob, so can be some boilerplate.</p>
<p>A little simpler approach is to use a term, so e.g. <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">&quot;x&quot;</span></code> is a normal form. Then you overload functions to deal with these terms. This works well for nullary symbols like <code class="docutils literal notranslate"><span class="pre">maxBound</span></code> - you implement conversion <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">maxBound</span> <span class="pre">Float</span> <span class="pre">=</span> <span class="pre">float</span> <span class="pre">Infinity</span></code> and promotion will take care of the rest. The issue is that an expression like <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">&quot;1&quot;</span> <span class="pre">+</span> <span class="pre">read</span> <span class="pre">&quot;2&quot;</span></code> will not resolve the return type, and returning <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">&quot;3&quot;</span></code> is inefficient. I think the best solution is to return a blob. So this ends up being the blob solution but with readable literals for the first level of return value.</p>
<p>Another approach is to add type inference, but as a macro transformation. All it has to do is infer the types using Hindley Milner or similar and insert explicit type parameters for the RTOed functions. But this is really the opposite of what Stroscot aims for. Stroscot avoided static typing to begin with because there are no principal types if you have union types. For example a value of type <code class="docutils literal notranslate"><span class="pre">A</span></code> may take on the type <code class="docutils literal notranslate"><span class="pre">(A|B)</span></code> or <code class="docutils literal notranslate"><span class="pre">(A|C)</span></code> depending on context. The inserted types would have to be principal, negating the advantage of dynamic typing. Furthermore you’d have to use more macros to specify type instances and types of functions.</p>
<p>Despite the naysayers I still like my original idea of using nondeterminism: an overloaded function <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">Something</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code> is interpreted as <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">A)</span> <span class="pre">amb</span> <span class="pre">(f</span> <span class="pre">B)</span> <span class="pre">amb</span> <span class="pre">...</span></code>, combining all the typeclass instances. Disambiguating types using annotations is then replaced with disambiguating the result using assertion failures. This actually preserves the semantics of the static typeclass resolution AFAICT. In the discussion <a class="reference external" href="https://www.reddit.com/r/ProgrammingLanguages/comments/uynw2i/return_type_overloading_for_dynamic_languages/">on Reddit</a>, it was brought up that if there are a lot of overloadings or the overloadings are recursive, it would be slow, exponential in the number of function calls. That’s for a quite naive implementation; I think the compiler could do a type analysis and give good performance for most cases. HM also has exponential blowup on pathological cases. Overall I think this approach is the best, but it is not clear if it is actually helpful because features like automatic promotion will make many programs ambiguous.</p>
</section>
</section>
<section id="default-arguments">
<h2>Default arguments<a class="headerlink" href="#default-arguments" title="Link to this heading"></a></h2>
<p>Default arguments are very similar in expressiveness to overloading, so as one might expect <a class="reference external" href="https://talks.golang.org/2012/splash.article">Rob Pike</a> says Go deliberately does not support default arguments. Supposedly adding default arguments to a function results in interactions among arguments that are difficult to understand.</p>
<p>Pike admits that it is really easy to patch API design flaws by adding a default argument. Expanding on this, it seems default arguments have a good place in the lifecycle of an API parameter:</p>
<ol class="arabic simple">
<li><p>A new parameter can be added to a function, just give it a default value such that the function behavior is unchanged.</p></li>
<li><p>The whole argument can be deprecated and removed on a major release, hard-coding the default value</p></li>
<li><p>The default value can be deprecated and then removed on a major release, forcing the value to be specified.</p></li>
<li><p>An existing parameter can be given a default value without breaking compatibility</p></li>
</ol>
<div class="graphviz"><object data="../_images/graphviz-f5df746232bb87f68aa9c40b9d520f54204a1d7c.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
rankdir=LR
Missing -&gt; Defaulted [label=&quot;1&quot;]
Defaulted -&gt; Missing [label=&quot;2&quot;, color=&quot;blue&quot;]
Defaulted -&gt; Present [label=&quot;3&quot;, color=&quot;blue&quot;]
Present -&gt; Defaulted [label=&quot;4&quot;]
}</p></object></div>
<p>One side effect of this lifecycle is it gravitates towards default parameters, because those don’t break compatibility. So programs accumulate many default parameters that should be made into required parameters or removed. This is probably why developers say default parameters are a code smell (nonwithstanding the internet’s main opinion, which comes from C#’s implementation breaking ABI compatibility in a way that can be fixed by using regular overloading). But regular pruning should be possible, just do occasional surveys as to remove/make mandatory/leave alone. And, without default parameters, adding or removing a parameter immediately breaks the API without a deprecation window, so it is effectively impossible - you have to make a new method name. This is why Linux has the unimaginatively named syscalls <code class="docutils literal notranslate"><span class="pre">dup</span></code>, <code class="docutils literal notranslate"><span class="pre">dup2</span></code> and <code class="docutils literal notranslate"><span class="pre">dup3</span></code>. IMO having deprecated parameters is better than trying to come up with a new name or having version numbers in names.</p>
<p>A <a class="reference external" href="https://github.com/wartremover/wartremover/issues/116">wartremover issue</a> provides 4 potentially problematic cases for default arguments. Going through them:</p>
<ul class="simple">
<li><p>Automatically allocated resource arg - this is deallocated by the finalizer system in Stroscot, hence no resource management problem. To avoid statefulness, the pattern is to default to a special value like <code class="docutils literal notranslate"><span class="pre">AutoAllocate</span></code> and do the allocation in the method body.</p></li>
<li><p>Config - a big win convenience-wise for default arguments, only specify the parameters you care about.</p></li>
<li><p>Delegated parameter: this is nicely handled in Stroscot by implicit parameters. Hence a pattern like <code class="docutils literal notranslate"><span class="pre">ingest</span> <span class="pre">{compressor</span> <span class="pre">=</span> <span class="pre">None}</span> <span class="pre">=</span> <span class="pre">...;</span> <span class="pre">doIngestion</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">log;</span> <span class="pre">ingest</span> <span class="pre">};</span> <span class="pre">executeIngest</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">prepare;</span> <span class="pre">doIngestion</span> <span class="pre">};</span> <span class="pre">parseAndExec</span> <span class="pre">cmdline</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">compressor</span> <span class="pre">=</span> <span class="pre">parse</span> <span class="pre">cmdline;</span> <span class="pre">executeIngest</span> <span class="pre">}</span></code> is possible. Once you realize the compressor is important you can remove the default and make it a keyword parameter - the default can still be provided as a definition in an importable module, and you get an unset argument error if no implicit parameter is set.</p></li>
<li><p>Faux overloading like <code class="docutils literal notranslate"><span class="pre">foo(i,</span> <span class="pre">name</span> <span class="pre">=</span> <span class="pre">&quot;s&quot;)</span></code> - useful just like overloading.</p></li>
</ul>
<p>The verdict here is that defaulting, like overloading, is a power vs predictability tradeoff. The obvious choice given Stroscot’s principles is power. There are no easy solutions for adding new behavior to a function besides adding a default argument flag to modifying an API in a backwards-compatible way, so default arguments are necessary. And default arguments have been used in creative ways to make fluent interfaces, giving programmers the enjoyment of complex interface design. The added implementation complexity is small. Security concerns are on the level of misreading the API docs, which is possible in any case. Adding a warning that a default argument has not been specified, forcing supplying all parameters to every method, seems sufficient.</p>
</section>
<section id="currying">
<h2>Currying<a class="headerlink" href="#currying" title="Link to this heading"></a></h2>
<p>Per <span id="id3">[<a class="reference internal" href="../zzreferences.html#id91">KKSV95</a>]</span>, an uncurried function symbol has an arity n and a function application <code class="docutils literal notranslate"><span class="pre">f(t1,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">tn)</span></code> is formed from <code class="docutils literal notranslate"><span class="pre">f</span></code> and n terms t1,…,tn. In a curried system there are no arities and function applications are formed starting from a nullary constant <code class="docutils literal notranslate"><span class="pre">f</span></code> and applying the binary “application” operator, like <code class="docutils literal notranslate"><span class="pre">App(...App(App(f,t1),...),tn)</span></code> but more concisely written as left-associative juxtaposition <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">t1</span> <span class="pre">...</span> <span class="pre">tn</span></code>. We ignore the partially-applied system mentioned by Kennaway here and just assume the use of term matching.</p>
<p>Partial application creates a function that takes one or more omitted parameters and plugs them into f to produce a final result. Currying allows easy partial function application for lastmost positional parameters and keyword parameters, which in turn allows using higher-order functions more easily, e.g. passing a partially-applied function as the argument to map. For example <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">(add</span> <span class="pre">2)</span> <span class="pre">[1,2]</span> <span class="pre">=</span> <span class="pre">[3,4]</span></code>. Without currying this would have to use a lambda to perform the partial application like <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">(\x.</span> <span class="pre">add</span> <span class="pre">2</span> <span class="pre">x)</span></code>. So in Stroscot positional parameters and keyword parameters are curried. This allows passing any function “directly”, without “wrapping” it in an anonymous function.</p>
<p>The parentheses for a curried function don’t matter, e.g. all of the following are equivalent:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">((</span><span class="n">f</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span>
<span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span>
<span class="nf">f</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span>
</pre></div>
</div>
<p>Currying is independent of function call syntax, e.g. with C-style syntax we would write:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">3</span><span class="p">)</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)(</span><span class="mi">3</span><span class="p">)</span>
<span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>for the various currying possibilities.</p>
<p>R allows some kind of “partial matching” so you can write <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">,</span> <span class="pre">y)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">\a</span> <span class="pre">-&gt;</span> <span class="pre">f(x,</span> <span class="pre">a,</span> <span class="pre">y)</span></code>. Seems stupid.</p>
<section id="variadic-arguments">
<h3>Variadic arguments<a class="headerlink" href="#variadic-arguments" title="Link to this heading"></a></h3>
<p>A variadic function has no fixed arity. So can currying and variadic functions coexist? Well consider a variadic function <code class="docutils literal notranslate"><span class="pre">sum</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span>
<span class="o">#</span><span class="w"> </span><span class="n">true</span>
<span class="nf">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="o">#</span><span class="w"> </span><span class="mi">1</span>

<span class="nf">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span>
<span class="nf">g</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span>
<span class="o">#</span><span class="w"> </span><span class="n">true</span>
<span class="nf">g</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span>
<span class="o">#</span><span class="w"> </span><span class="mi">15</span>
</pre></div>
</div>
<p>So even though <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">==</span> <span class="pre">6</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code> is different from <code class="docutils literal notranslate"><span class="pre">6</span></code> - <code class="docutils literal notranslate"><span class="pre">g</span></code> is both a function and non-function at the same time. Similarly <code class="docutils literal notranslate"><span class="pre">sum</span></code> is both <code class="docutils literal notranslate"><span class="pre">0</span></code> and a function. This causes confusion. In particular the issue is there are multiple interpretations of a function call: it could be a partial application waiting for more arguments, or it could be a complete application with the intention to use defaults for default parameters and terminate the varargs list. To avoid this confusion we need to know when the function call is complete. It seems to be a common misconception (e.g. in the Flix principles) that this means currying and variadic functions cannot be in the same language. But there are several approaches:</p>
<ul>
<li><p>nondeterminism: Just accept that the meaning of <code class="docutils literal notranslate"><span class="pre">g`</span></code> depends on its usage. This is not a good option because it means things that look like values aren’t actually values.</p></li>
<li><p>a special terminator value, function, or type. For example in <a class="reference external" href="http://reasonmlhub.com/exploring-reasonml/ch_functions.html">ReasonML</a> every function needs at least one positional parameter. There are no nullary functions; a definition or function call without any positional parameters is transformed to take or pass an empty tuple argument (). ReasonML accumulates parameters until it first encounters a positional parameter, then defaults all default parameters and (if it supported varargs) ends varargs, creating a partially-applied function taking only positional parameters. So <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">{x=0,y=0}</span> <span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> can be called as <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">{x=3}</span> <span class="pre">{y=3}</span> <span class="pre">()</span> <span class="pre">=</span> <span class="pre">6</span></code> or <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">{x=3}</span> <span class="pre">()</span> <span class="pre">=</span> <span class="pre">3</span></code>, including splitting the intermediate values like <code class="docutils literal notranslate"><span class="pre">plus3</span> <span class="pre">=</span> <span class="pre">add</span> <span class="pre">{x=3};</span> <span class="pre">result</span> <span class="pre">=</span> <span class="pre">plus3</span> <span class="pre">()</span></code>. Another example is <a class="reference external" href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Printf.html">Haskell printf</a> which can do <code class="docutils literal notranslate"><span class="pre">finalize</span> <span class="pre">(printf</span> <span class="pre">&quot;%d&quot;</span> <span class="pre">23)</span></code> (In Haskell the finalize is implicit as a type constraint). Essentially we construct types <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">=</span> <span class="pre">end</span> <span class="pre">|</span> <span class="pre">(param</span> <span class="pre">-&gt;</span> <span class="pre">T);</span> <span class="pre">finalize</span> <span class="pre">:</span> <span class="pre">end</span> <span class="pre">-&gt;</span> <span class="pre">...</span></code>. It is also possible to use a specific <code class="docutils literal notranslate"><span class="pre">end</span></code> value, like <code class="docutils literal notranslate"><span class="pre">sum</span> <span class="pre">end</span> <span class="pre">=</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span> <span class="pre">1</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">end</span> <span class="pre">=</span> <span class="pre">6</span></code>.</p></li>
<li><p>using a explicit length parameter. <a class="reference external" href="https://softwareengineering.stackexchange.com/questions/286231/is-it-possible-to-have-currying-and-variadic-function-at-the-same-time">SO</a> proposes passing the length as the first parameter, like <code class="docutils literal notranslate"><span class="pre">sum</span> <span class="pre">4</span> <span class="pre">1</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">4</span> <span class="pre">=</span> <span class="pre">10</span></code>, but this is error-prone and inferior to just passing a list <code class="docutils literal notranslate"><span class="pre">sum</span> <span class="pre">[1,2,3,4]</span></code>.</p></li>
<li><p>using the syntactic boundary: Arguably both of the previous are hacks. They do allow currying, but at the expense of exposing the dispatch machinery. Generally currying is not needed and the function is fully applied at its use site. Per <span id="id4">[<a class="reference internal" href="../zzreferences.html#id107" title="Simon Marlow and Simon Peyton Jones. Making a fast curry: push/enter vs. eval/apply for higher-order languages. Journal of Functional Programming, 16(4-5):415–449, July 2006. URL: https://www.cambridge.org/core/product/identifier/S0956796806005995/type/journal_article (visited on 2020-06-15), doi:10.1017/S0956796806005995.">MJ06</a>]</span> Figure 6, around 80% of calls are fully applied with known arguments. Finalizing varargs at the site of the function call is a simple and clear strategy:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sum</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span>
<span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span>
</pre></div>
</div>
<p>This is the same behavior as languages without currying (<code class="docutils literal notranslate"><span class="pre">sum(1,2,3)</span></code> vs <code class="docutils literal notranslate"><span class="pre">sum(1,2)(3)</span></code>) and is only really complicated if you think too much about consistency. If we want more arguments we can use a lambda, or a builder DSL like <code class="docutils literal notranslate"><span class="pre">finalize</span> <span class="pre">(f</span> <span class="pre">`add`</span> <span class="pre">a</span> <span class="pre">`add`</span> <span class="pre">b)</span></code>.</p>
</li>
</ul>
</section>
<section id="optional-arguments">
<h3>Optional arguments<a class="headerlink" href="#optional-arguments" title="Link to this heading"></a></h3>
<p>A similar issue is optional arguments - when do we decide to put in the default value? Again Stroscot’s answer is it must be syntactically supplied.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">opt</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>

<span class="nf">opt</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">3</span>
<span class="p">(</span><span class="n">opt</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
<p>Again a lambda or builder works for anything tricky.</p>
<p><a class="reference external" href="reasonmlhub.com/exploring-reasonml/ch_functions.html">ReasonML</a> uses an empty tuple to mark the end of supplied arguments.</p>
</section>
<section id="keyword-arguments">
<h3>Keyword arguments<a class="headerlink" href="#keyword-arguments" title="Link to this heading"></a></h3>
<p>Keyword arguments allow passing arguments without regards to the order in the function definition, making the code more robust to forgetting argument order. Of course keyword-only arguments do not work with currying either. But if they are mixed keyword-positional arguments then specifying most of them using keywords and leaving the rest as curried positional parameters can work:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">kw</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span>

<span class="nf">zipWith</span><span class="w"> </span><span class="p">(</span><span class="n">kw</span><span class="w"> </span><span class="p">{</span><span class="n">b</span><span class="ow">=</span><span class="mi">1</span><span class="p">})</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">--&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>This kind of partial specification is possible to emulate with records and partial application logic, but since currying is built in, this dispatch logic also seems best to build into the language.</p>
<p>Julia separates positional arguments from keyword arguments using a semicolon (;).</p>
</section>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Link to this heading"></a></h2>
<p>The full dispatch mechanism is as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">dispatch</span><span class="w"> </span><span class="n">clauses</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="n">warnIfAnyPrioEqual</span><span class="w"> </span><span class="n">clauses</span>
<span class="w">  </span><span class="n">starting_clauses</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">find_no_predecessors</span><span class="w"> </span><span class="n">clauses</span>
<span class="w">  </span><span class="n">callParallel</span><span class="w"> </span><span class="n">starting_clauses</span>
<span class="w">   </span><span class="kr">where</span>
<span class="w">    </span><span class="n">callParallel</span><span class="w"> </span><span class="n">clauses</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lubAll</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">clauses</span><span class="p">)</span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="n">clause</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">clause</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">next</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">callParallel</span><span class="w"> </span><span class="p">(</span><span class="n">find_covering</span><span class="w"> </span><span class="n">methods</span><span class="w"> </span><span class="n">clause</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">lubAll</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fold</span><span class="w"> </span><span class="n">lub</span><span class="w"> </span><span class="kt">DispatchError</span>
</pre></div>
</div>
<p>This depends on the <code class="docutils literal notranslate"><span class="pre">lub</span></code> primitive defined in <a class="reference external" href="http://conal.net/blog/posts/merging-partial-values">Conal’s post</a>. <code class="docutils literal notranslate"><span class="pre">lub</span></code> evaluates both sides to HNF, in a timeboxed fashion. If both sides are exceptions then an exception is returned. If one side gives an exception but the other doesn’t, then the other side is returned. If both sides evaluate to HNF and the heads are equal, the result is the head followed by the lub of the sub-arguments. Otherwise the context is used, <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(a</span> <span class="pre">`lub`</span> <span class="pre">b)</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">`lub`</span> <span class="pre">f</span> <span class="pre">b</span></code>. <code class="docutils literal notranslate"><span class="pre">lub</span></code> is an oracle, analyzing the whole program - we want return type overloading, and that return values not accepted by the surrounding context are discarded. This falls out naturally from doing the analysis on the CPS-transformed version of the program.</p>
<p>The dispatch semantics is that all methods are run in parallel using lub.</p>
<p>The way Stroscot optimizes dispatch is:</p>
<ul class="simple">
<li><p>eliminate all the statically impossible cases (cases that fail)</p></li>
<li><p>use profiling data to identify the hot paths</p></li>
<li><p>build a hot-biased dispatch tree</p></li>
<li><p>use conditionals for small numbers of branches, tables for large/uniform branches (like switch statements)</p></li>
</ul>
<p>The standard vtable implementation of Java/C++ arises naturally as a table dispatch on a method name. It looks like ‘load klass pointer from object; load method from klass-vtable (fixed offset from klass pointer); load execution address from method (allows you to swap execution strategies, like interp-vs-C1-vs-C2, or multiple copies of C2 jit’d depending on context); jump’. But usually we can do better by building a custom table and fast-pathing the hot cases.</p>
<p>Cliff says what we do for overloaded calls doesn’t matter so long as in practice, &gt;90% of calls are statically resolved to one clause.</p>
<p>THe inline-cache hack observes that, while in theory many different things might get called here, in practice there’s one highly dominant choice.  Same for big switches: you huffman-encode by execution frequency.</p>
<blockquote>
<div><p>TODO: check out pattern dispatch paper</p>
</div></blockquote>
<p>Karnaugh map with profiling data</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="CoreSyntax.html" class="btn btn-neutral float-left" title="Core syntax" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Errors.html" class="btn btn-neutral float-right" title="Errors" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>