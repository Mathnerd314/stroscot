<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dispatch &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Evaluation strategy" href="Evaluation-Strategy.html" />
    <link rel="prev" title="Core syntax" href="CoreSyntax.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Dispatch</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#priorities">Priorities</a></li>
<li class="toctree-l3"><a class="reference internal" href="#method-qualifiers">Method qualifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#next-method">Next method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conversion">Conversion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#promotion">Promotion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#equality">Equality</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="F2G2_example.html">F2 G2</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fexprs.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">About</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Imperative programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Commentary</a> &raquo;</li>
      <li>Dispatch</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Dispatch.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="dispatch">
<h1>Dispatch<a class="headerlink" href="#dispatch" title="Permalink to this heading">ÔÉÅ</a></h1>
<p>Stroscot supports pattern matching as well as predicate dispatch:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
</pre></div>
</div>
<p>Dispatch cases are not ordered. If multiple predicates match, it is required that all matching cases produce the same result. For example if we were to modify the last case:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>

<span class="nf">f</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="o">#</span><span class="w"> </span><span class="kt">Error:</span><span class="w"> </span><span class="n">rule</span><span class="w"> </span><span class="n">conflict</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="p">`</span><span class="n">f</span><span class="w"> </span><span class="mi">1</span><span class="p">`</span><span class="w"></span>
</pre></div>
</div>
<p>But if the first clause was <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">2</span></code> it would be allowed. This behavior is useful for creating optimized methods for specific types, and also for tests:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fib</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="nf">fib</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="nf">fib</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>

<span class="o">#</span><span class="w"> </span><span class="n">test</span><span class="w"></span>
<span class="nf">fib</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">5</span><span class="w"></span>
</pre></div>
</div>
<p>Although writing <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">(fib</span> <span class="pre">5</span> <span class="pre">==</span> <span class="pre">5)</span></code> might be clearer.</p>
<p>Local functions are applied in the same way as global ones, i.e., the argument patterns of each rule are matched against the actual function arguments and optimal reduction is performed.</p>
<p>If none of the rules match then the function application remains unevaluated (it becomes a normal form) - by default no exception is raised.</p>
<section id="priorities">
<h2>Priorities<a class="headerlink" href="#priorities" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>The way sequential matching expands is that there is a chain of priorities.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">clause</span><span class="w"> </span><span class="n">c1</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="nf">clause</span><span class="w"> </span><span class="n">c2</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>

<span class="nf">clause</span><span class="w"> </span><span class="n">c3</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>

<span class="nf">prioConstrain</span><span class="w"> </span><span class="n">prioHigh</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">prioLow</span><span class="w"></span>
</pre></div>
</div>
<p>Each clause has its own priority. Clauses with lower priority are ignored if there are clauses with higher priorities. Clauses with incomparable priorities are combined with lub. Clauses with equal priorities have their priorities disambiguated by adding specificity overriding (i.e., the actual priority is the tuple (priority, specificity) ordered by lexicographical order). Specificity is another poset relation defined by an SMT solver: <code class="docutils literal notranslate"><span class="pre">a</span></code> overrides <code class="docutils literal notranslate"><span class="pre">b</span></code> if <code class="docutils literal notranslate"><span class="pre">UNSAT(a</span> <span class="pre">&amp;</span> <span class="pre">not</span> <span class="pre">b)</span></code> and <code class="docutils literal notranslate"><span class="pre">SAT</span> <span class="pre">(not</span> <span class="pre">a</span> <span class="pre">&amp;</span> <span class="pre">b)</span></code>. If the priorities + specificity are still equal then a warning is given and they are combined with lub.</p>
<p>If a priority is not specified it uses a fresh priority with <code class="docutils literal notranslate"><span class="pre">prioLow</span> <span class="pre">&lt;</span> <span class="pre">fresh</span> <span class="pre">&lt;</span> <span class="pre">prioHigh</span></code>.</p>
<p>There is a macro to give all clauses in a region the same priority, which makes the specificity implementation more useful.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prioAll</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">isDoor</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">no</span><span class="w"></span>
<span class="w">   </span><span class="n">isDoor</span><span class="w"> </span><span class="s">&quot;garden gate&quot;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">yes</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">-- the second clause is more specific than the first, hence overrides it</span><span class="w"></span>

<span class="nf">prioAll</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">isPerson</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">no</span><span class="w"></span>
<span class="w">   </span><span class="n">isPerson</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">isMan</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">yes</span><span class="w"></span>

<span class="w">   </span><span class="n">isMan</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">no</span><span class="w"></span>
<span class="w">   </span><span class="n">isMan</span><span class="w"> </span><span class="s">&quot;Steve&quot;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">yes</span><span class="w"></span>

<span class="w">   </span><span class="n">isDoor</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">no</span><span class="w"></span>
<span class="w">   </span><span class="n">isDoor</span><span class="w"> </span><span class="s">&quot;Steve&quot;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">yes</span><span class="w"></span>

<span class="w">   </span><span class="n">describe</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">isPerson</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Humanoid&quot;</span><span class="w"></span>
<span class="w">   </span><span class="n">describe</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">isMan</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Masculine&quot;</span><span class="w"></span>
<span class="w">   </span><span class="c1">-- describe m | isDoor m = &quot;Door&quot; -- conflict with isMan for &quot;Steve&quot;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="c1">-- again each clause overrides the second</span><span class="w"></span>
</pre></div>
</div>
<p>I thought about making all clauses the same priority by default, but concluded that specificity was too confusing.</p>
<p>You can get the priority of a clause with <code class="docutils literal notranslate"><span class="pre">prioOf</span> <span class="pre">{</span> <span class="pre">clause</span> <span class="pre">|</span> <span class="pre">condition</span> <span class="pre">}</span></code>, so as to constrain a clause that has an anonymous priority. The AST must match exactly.</p>
<p>There is also <code class="docutils literal notranslate"><span class="pre">prioBound</span> <span class="pre">{}</span></code>, similar in syntax to <code class="docutils literal notranslate"><span class="pre">prioAll</span></code> but puts a top/bottom constraint on fresh priorities.</p>
<p>You can also define sets of priorities, either by listing or with <code class="docutils literal notranslate"><span class="pre">prioSet</span> <span class="pre">{</span> <span class="pre">}</span></code>, and use <code class="docutils literal notranslate"><span class="pre">prioSetDef</span></code> to define large-scale orderings. You can resolve conflicts in the priority ordering definitions by declaring the priorities (meta-priorities) of the definitions. See Posets.</p>
</section>
<section id="method-qualifiers">
<h2>Method qualifiers<a class="headerlink" href="#method-qualifiers" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>Stroscot also supports Common Lisp‚Äôs method qualifiers <code class="docutils literal notranslate"><span class="pre">before</span></code>, <code class="docutils literal notranslate"><span class="pre">after</span></code>, and <code class="docutils literal notranslate"><span class="pre">around</span></code>, as well as a custom qualifier <code class="docutils literal notranslate"><span class="pre">list</span></code>. Although the dispatch algorithm is complex, the idea is that it is so generic that including it once in the language proper will save everyone‚Äôs time by avoiding the need to reimplement it.</p>
<p><code class="docutils literal notranslate"><span class="pre">before</span></code> and <code class="docutils literal notranslate"><span class="pre">after</span></code> are simply <code class="docutils literal notranslate"><span class="pre">around</span></code> methods with the fixed priority <code class="docutils literal notranslate"><span class="pre">around</span> <span class="pre">&gt;</span> <span class="pre">before</span> <span class="pre">&gt;</span> <span class="pre">after</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">before</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">around</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span><span class="n">next</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="nf">after</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">around</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">next</span><span class="o">-</span><span class="n">method</span><span class="p">;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Guards on around clauses are handled by unconditionally calling next-method:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">around</span><span class="w"> </span><span class="p">{</span><span class="n">f</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">d</span><span class="p">}</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">next</span><span class="o">-</span><span class="n">method</span><span class="w"></span>
</pre></div>
</div>
<p>The basic idea of method combination can be seen in this <a class="reference external" href="https://commons.wikimedia.org/w/index.php?title=Special:Redirect/file/Method-combination.png">illustration</a></p>
<p><code class="docutils literal notranslate"><span class="pre">list</span></code> simply produces the list of applicable methods, that can then be applied or manipulated as needed. It is an error to define a list method if there are any other types of methods (primary, before, after, or around).</p>
</section>
<section id="next-method">
<h2>Next method<a class="headerlink" href="#next-method" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>High priority methods shadow lower-priority methods, rather than entirely replacing them. <code class="docutils literal notranslate"><span class="pre">next-method</span></code> allows access to these shadowed methods.</p>
<p>You can run the methods with different parameters, <code class="docutils literal notranslate"><span class="pre">next-method</span> <span class="pre">{</span> <span class="pre">silently=true</span> <span class="pre">}</span></code>.</p>
<p>You can also call a specific clause, <code class="docutils literal notranslate"><span class="pre">callClause</span> <span class="pre">{</span> <span class="pre">clause</span> <span class="pre">|</span> <span class="pre">guard,</span> <span class="pre">module</span> <span class="pre">=</span> <span class="pre">...,</span> <span class="pre">priority</span> <span class="pre">=</span> <span class="pre">...</span> <span class="pre">}</span></code>, or its <code class="docutils literal notranslate"><span class="pre">next-method</span></code>, <code class="docutils literal notranslate"><span class="pre">callClauseNext</span></code>.</p>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>The full dispatch mechanism is as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">dispatch</span><span class="w"> </span><span class="n">methods</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="n">arounds</span><span class="p">,</span><span class="w"> </span><span class="n">befores</span><span class="p">,</span><span class="w"> </span><span class="n">afters</span><span class="p">,</span><span class="w"> </span><span class="n">primaries</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">topological_sort</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">partition</span><span class="w"> </span><span class="n">methods</span><span class="w"></span>
<span class="w">  </span><span class="n">next</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">DispatchError</span><span class="w"></span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="n">arounds</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">     </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="kt">:</span><span class="n">as</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">next</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">     </span><span class="n">f</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">primaries</span><span class="w"></span>

<span class="w">     </span><span class="n">g</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">DispatchError</span><span class="w"></span>
<span class="w">     </span><span class="n">g</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">         </span><span class="n">map</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">befores</span><span class="w"></span>
<span class="w">         </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="p">(</span><span class="n">concat</span><span class="w"> </span><span class="n">primaries</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">map</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="p">(</span><span class="n">reverse</span><span class="w"> </span><span class="n">afters</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="n">return</span><span class="w"> </span><span class="n">x</span><span class="w"></span>

<span class="nf">call</span><span class="w"> </span><span class="n">binds</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fold</span><span class="w"> </span><span class="n">lub</span><span class="w"> </span><span class="kt">DispatchError</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="n">binds</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The way Stroscot optimizes dispatch is:
* eliminate all the statically impossible cases (cases that fail)
* use profiling data to identify the hot paths
* build a hot-biased dispatch tree
* use conditionals for small numbers of branches, tables for large/uniform branches (like switch statements)</p>
</section>
<section id="conversion">
<h2>Conversion<a class="headerlink" href="#conversion" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>There is a function <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">:</span> <span class="pre">(T</span> <span class="pre">:</span> <span class="pre">Set)</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">T</span></code> in a module in the core library.</p>
<p>Conversion is intended for equivalent values, so it should satisfy the properties of an equivalence relation (assuming all conversions succeed):
* Reflexive: <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">T</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span></code>, if <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">T</span></code>
* Symmetric: <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">T</span> <span class="pre">(convert</span> <span class="pre">T2</span> <span class="pre">a)</span> <span class="pre">=</span> <span class="pre">a</span></code>, if <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">T</span></code>
* Transitive: <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">T3</span> <span class="pre">(convert</span> <span class="pre">T2</span> <span class="pre">a)</span> <span class="pre">=</span> <span class="pre">convert</span> <span class="pre">T3</span> <span class="pre">a</span></code></p>
<p>Conversion is only a partial function, hence these properties may not hold due to some of the conversions resulting in errors. For example <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">Float32</span> <span class="pre">(2^24+1)</span></code> fails because only <code class="docutils literal notranslate"><span class="pre">2^24</span></code> and <code class="docutils literal notranslate"><span class="pre">2^24+2</span></code> are exactly representable as floats. The ‚Äúexactly representable‚Äù is a requirement because of transitivity and the existence of arbitrary-precision types (<code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">Exact</span> <span class="pre">(convert</span> <span class="pre">Approx</span> <span class="pre">a)</span> <span class="pre">==</span> <span class="pre">convert</span> <span class="pre">Exact</span> <span class="pre">a</span></code>).</p>
<p>Conversion for unions is often undefined, because if <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">T</span></code> converts to <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">:</span> <span class="pre">T2</span></code>, <code class="docutils literal notranslate"><span class="pre">T</span></code> disjoint from <code class="docutils literal notranslate"><span class="pre">T2</span></code>, then by reflexivity we have <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">(T|T2)</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span></code> and by assumption and reflexivity we have <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">(T|T2)</span> <span class="pre">(convert</span> <span class="pre">T2</span> <span class="pre">a)</span> <span class="pre">=</span> <span class="pre">convert</span> <span class="pre">(T|T2)</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">b</span></code>, violating transitivity. Hence <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">(T|T2)</span></code> must be undefined.</p>
<p>The conversion syntax overlaps somewhat with a constructor function, e.g. it is often the case that <code class="docutils literal notranslate"><span class="pre">int32</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">convert</span> <span class="pre">Int32</span> <span class="pre">x</span></code>. But conversion works ‚Äúdeeply‚Äù on arrays and such, and because it is an equivalence relation can be applied automatically, whereas constructors may lose information, be stateful, or lazily evaluate their argument. A constructor can call convert, but not the reverse.</p>
<p>Values could be made equivalent to their string representation. This would mainly be useful for displaying values by calling <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">String</span></code>, as multiple decimal literals parse to floating point numbers so the other direction is unpredictable. So an explicit parse function is also needed. It seems easier to hide this functionality away in a <code class="docutils literal notranslate"><span class="pre">NumLiteral</span></code> type.</p>
<p>Often we prefer conversions to be total; this is accomplished by adding flags to convert describing the desired behavior. These flags may break the equivalence relation. For example <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">Byte</span> <span class="pre">1099</span> <span class="pre">{</span> <span class="pre">narrowing</span> <span class="pre">=</span> <span class="pre">true</span> <span class="pre">}</span> <span class="pre">=</span> <span class="pre">75</span></code> whereas without the narrowing flag it would error, as it is not exactly representable. This allows re-using the promotion mechanism from the next section so is preferred to defining a new function like <code class="docutils literal notranslate"><span class="pre">lossyConvert</span></code>. Some conversions such as <a class="reference external" href="https://stackoverflow.com/questions/13269523/can-all-32-bit-ints-be-exactly-represented-as-a-double">int32 to float64</a> do not need flags as they are already total.</p>
</section>
<section id="promotion">
<h2>Promotion<a class="headerlink" href="#promotion" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>Promotion is a catch-all dispatch rule for arithmetic operators on mixed types, similar to <a class="reference external" href="https://docs.julialang.org/en/v1/manual/conversion-and-promotion/">Julia‚Äôs</a>. It works as follows:</p>
<ol class="arabic simple">
<li><p>Compute a common type using <code class="docutils literal notranslate"><span class="pre">promote_rule</span></code></p></li>
<li><p>Promote all operands to common type using <code class="docutils literal notranslate"><span class="pre">convert</span></code></p></li>
<li><p>Invoke the same-type implementation of the operator, if it exists</p></li>
</ol>
<p>For example <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">:</span> <span class="pre">Int32)</span> <span class="pre">+</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">Float32)</span> <span class="pre">=</span> <span class="pre">(convert</span> <span class="pre">Float32</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">convert</span> <span class="pre">Float32</span> <span class="pre">b)</span> <span class="pre">{</span> <span class="pre">lossy</span> <span class="pre">=</span> <span class="pre">true</span> <span class="pre">}</span></code> since <code class="docutils literal notranslate"><span class="pre">promote_rule</span> <span class="pre">(a</span> <span class="pre">:</span> <span class="pre">Int32)</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">Float32)</span> <span class="pre">=</span> <span class="pre">out</span> <span class="pre">{</span> <span class="pre">lossy</span> <span class="pre">=</span> <span class="pre">true};</span> <span class="pre">Float32</span></code>. The system is extensible by defining new conversions and new promotion rules.</p>
<p>Julia‚Äôs promotion rules:
* Floating-point values are promoted to the largest of the floating-point argument types.
* Integer values are promoted to the larger of either the native machine word size or the largest integer argument type.
* Mixtures of integers and floating-point values are promoted to a floating-point type big enough to hold all the values.
* Integers mixed with rationals are promoted to rationals.
* Rationals mixed with floats are promoted to floats.
* Complex values mixed with real values are promoted to the appropriate kind of complex value.</p>
</section>
<section id="equality">
<h2>Equality<a class="headerlink" href="#equality" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>Since functions can return multiple values and comparing them can give multiple results, we might want equality operations anyEqual and allEqual to control how values are merged.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="CoreSyntax.html" class="btn btn-neutral float-left" title="Core syntax" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Evaluation-Strategy.html" class="btn btn-neutral float-right" title="Evaluation strategy" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2020 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>