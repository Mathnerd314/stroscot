<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Errors &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=7f41d439"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Evaluation strategy" href="Evaluation-Strategy.html" />
    <link rel="prev" title="Dispatch" href="Dispatch.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Aspects.html">Aspects</a></li>
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler-Library.html">Compiler library</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Errors</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#error-levels">Error levels</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#don-t-stop">Don’t stop</a></li>
<li class="toctree-l4"><a class="reference internal" href="#level-presets">Level presets</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#error-types">Error types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#error-messages">Error messages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#location">Location</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#debugging">Debugging</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="FunctionalLogic.html">Functional logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="OpPrims.html">Operational primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Security.html">Security</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard-Library.html">Standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Symbolic.html">Symbolic computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Values.html">Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Errors</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Errors.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="errors">
<h1>Errors<a class="headerlink" href="#errors" title="Link to this heading"></a></h1>
<p>The compiler gives clear and helpful error messages that make it easier for developers to identify and fix problems in their code.</p>
<section id="error-levels">
<h2>Error levels<a class="headerlink" href="#error-levels" title="Link to this heading"></a></h2>
<p>In general flags can take 4 levels: ignore, warn, fatal, and fix. Ignore ignores the issue as much as possible and produces no output. Warn issues a warning but otherwise ignores the issue. Fatal stops the compilation from succeeding (but not from continuing, see next). Fix automatically constructs a fix for the issue and either modifies the source file(s) in-place or outputs a patch.</p>
<section id="don-t-stop">
<h3>Don’t stop<a class="headerlink" href="#don-t-stop" title="Link to this heading"></a></h3>
<p>(Soundtrack: <a class="reference external" href="https://www.youtube.com/watch?v=0SdqOC8NA7s">“Another Way” by Gigi D’Agostino</a>)</p>
<p>Stroscot is designed so that as few errors as possible actually stop compilation. Generally one wants to see as many errors as possible, because rerunning the compiler every time you fix an error is slow. Continuing with compilation allows finding all the errors in a file, hence produce more information than errors that simply stop at the first one. This choice is inspired by the <code class="docutils literal notranslate"><span class="pre">--keep-going</span></code> option in many build systems and the <code class="docutils literal notranslate"><span class="pre">-fdefer-type-errors</span></code> flag in GHC. In both cases a “stop the world” error is turned into a diagnostic; this is clearly a trend that should be jumped on.</p>
<p>Of course in a CI environment, some “fatal” errors should still prevent the build from succeeding. Probably this is subjective and defined per-project, as a quality standard. Stroscot’s build system should be smart enough to produce a build for debugging purposes while still propagating the fatal errors and not proceeding with tests or other downstream tasks.</p>
<p>Onw reason to stop at the first error is to avoid wasted CPU cycles, but CPU is cheap these days and incremental building means going as far as possible is probably cheaper overall than rerunning from scratch each time. Another reason to stop at the first error is to avoid console scroll; for this there is a flag <code class="docutils literal notranslate"><span class="pre">-ferror-limit=123</span></code> to limit output.</p>
</section>
<section id="level-presets">
<h3>Level presets<a class="headerlink" href="#level-presets" title="Link to this heading"></a></h3>
<p>One default is too restrictive, so we have several, tagged by year, that can be used just like the hard levels, e.g. you can write <code class="docutils literal notranslate"><span class="pre">-Wunused-var=default2014</span></code>. The values are chosen by a voting process every year or some other reasonable method. More powerful are warning presets, sets of configuration values. You can apply several warning presets and then override them with a list of options like <code class="docutils literal notranslate"><span class="pre">--warning-preset=default2014</span> <span class="pre">--warning-preset=A</span> <span class="pre">--warning-preset=B</span> <span class="pre">-W3=error</span> <span class="pre">-Werror</span></code>.</p>
<p>We want to be able to set levels on a per-project, per-file, and even within-file (per code section) basis, so as to avoid having to configure them several times, and to allow distributing self-contained pieces of code. So we need syntax for all of these. The traditional Werror that turns warnings into errors is an example of a preset transformation. So we even have higher-level programming with presets.</p>
<p>The ‘fatal’ level can cause problems in build scripts. In particular it introduces a hard dependency on the compiler’s diagnostics. For example, consider running:</p>
<ul class="simple">
<li><p>Compiler version 1 on program P with W1=ignore, W2=error</p></li>
<li><p>Compiler version 2 on program P with W1=error, W2=ignore, W3=error</p></li>
</ul>
<p>W2 is fine and will not cause any problems upgrading. But W1 and W3 will break the build when upgrading, if the error is triggered. W3 is usually easy to spot as it is new code. But W1 can happen without any notice if the compiler’s diagnostics are refactored to be more precise. The solution in both cases is to change the fatal errors to warnings, and then to gradually fix them. The fatal-&gt;warning change should follow the pattern of code ownership: first the whole project as a quick fix, then back to fatal for the project and off for each affected file, then on for the files and off for affected sections, and finally fixing each affected section. The “don’t stop” means we can actually short circuit this process and go straight from compiling the whole project with fatal errors disabled to fixing the warnings one by one, but of course that is not feasible in large projects.</p>
<p>We can formalize this process with two presets: a ‘before’ preset warns rather than fatally erroring on any issues that the old compiler didn’t bother about, and an an ‘after’ preset that fatally errors on such issues. Of course this doesn’t help with downgrading or cases where the fatal error cannot be turned into a warning.</p>
</section>
</section>
<section id="error-types">
<h2>Error types<a class="headerlink" href="#error-types" title="Link to this heading"></a></h2>
<p>One question is whether you can run the program with some well-defined language semantics, despite the error. Typically syntax errors and unbound identifiers are treated as outside the language, so that programs cannot execute. But if we introduce the idea of “auto-correct” then we can find a minimal correction to apply to make the program work, and then syntax errors no longer mean the program is malformed.</p>
<blockquote>
<div><p>per the language semantics, but a type signature or assertion is violated, meaning that the programmer’s intentions are not satisfied. Typically we want to output a “crippled” program that fails when it encounters the error, rather than attempting a fix.</p>
</div></blockquote>
<p>Another distinction is compile-time vs. runtime. Generally runtime errors have the execution trace available and produce more precise information, but only appear under the right testing conditions, while compile-time errors are reported earlier and cover all possible executions. In Stroscot, we muddy this distinction and try to get the best of both by using model checking. Model checking essentially simulates all runs of a program at compile time. So, like compile-time errors, it covers all executions and reports errors fairly quickly (although model checking, similarly to type checking, still has pathological cases that will cause state space explosion and timeouts). But like a run-time error, a model checking failure will end up producing a counterexample, basically a failing execution trace, so we get the precise information. The counterexample can be overly complicated compared to practical executions, so we may need to apply minimization. But a small price to pay for avoiding confusing type inference errors that don’t correspond to any runtime execution failure.</p>
</section>
<section id="error-messages">
<h2>Error messages<a class="headerlink" href="#error-messages" title="Link to this heading"></a></h2>
<p>Error messages are the UI of the compiler. Languages such as <a class="reference external" href="https://elm-lang.org/news/compiler-errors-for-humans">Elm</a> and Rust claim to have invested significant effort into improving their error messages, so Stroscot probably should too. Fortunately this has been researched since 1965, with a literature survey in <span id="id1">[]</span>, so we aren’t going in blind.</p>
<section id="location">
<h3>Location<a class="headerlink" href="#location" title="Link to this heading"></a></h3>
<p>Providing the context, namely the location of the error and the relevant program code, is quite important. Ideally, the error message should reported at the location where the fix should be directed, however this is often hard to uphold. For example, a missing close brace or quote may be detected by the parser only at EOF. Indentation sensitivity mitigates the close brace issue. Figuring out where a quote should be inserted probably requires a ML model.
Another tricky example is <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">&lt;expr&gt;;</span> <span class="pre">...;</span> <span class="pre">assert</span> <span class="pre">(a</span> <span class="pre">!=</span> <span class="pre">0)</span></code>, where the assertion is much later than the creation of the value that caused the error. Furthermore, the assertion expression may involve multiple variables, and it could be any one of them that is wrong. For simple cases, we could have a summarizer that tries to guess the important variables, but most likely we cannot give a fix-directed location and will have to use a format where the assertion is the primary location and potential fixes are merely hinted at.</p>
<blockquote>
<div><p>and outputs the callstack or other traditional details. Macros have similar problems - is the error in the macro use site or definition site?</p>
<p>such as  (explicitly or as an IDE annotation) and relevant symbols, identifiers, literals, and types involved in the error, as well as the program state such as variable values and stack traces. If an error message can appear in different contexts or could be sourced to multiple locations then disambiguate.</p>
</div></blockquote>
<ul class="simple">
<li><p>Reduce cognitive load: Include all relevant information and reduce redundancy so the user does not process the same information twice. Use multiple modalities to provide feedback. The error message should use the minimal amount of boilerplate so that a developer can process the information quickly. But there should also be enough that someone who has never seen the message before can understand it.</p></li>
</ul>
<p>Richer error handling such as a location system also introduces a performance concern, requiring more compiler engineering. For example we need an efficient mechanism for storing the start/end source location spans, consisting of two (filename, line number, column number) tuples, as passing around fully formatted strings would be slow. Go uses a map between locations and integers where file A maps to 1-100 and file B maps to 101-200, so that e.g. 150 maps to file B byte offset 50. But it isn’t clear how to make this incremental, as removing a file causes all the integers to change. One idea is to store (filename hash : U32, byte offset : U32), since files are unlikely to be larger than 4 gigabytes. Whatever the solution, we should be able to compare same file, before/after within files, and if two locations are equal.</p>
<p>The wording may be important. A Java editor called Decaf intercepted and re-worded 30 of the most frequent Java error messages, and was found to significantly reduce error frequency and indications of struggling students. However a different study did not, suggesting the effects are weak. Still, some basic attempt at clear and friendly language is appropriate. Specific guidelines from <span id="id2">[]</span>:</p>
<ul>
<li><p>Aim for readability and ensure comprehension by using plain/simple language, familiar vocabulary, and clear/concise/brief messages. Avoid cryptic jargon. There are multiple formal measures of readability for ‘normal’ prose, such as the Fry Readability Graph, Flesch formula, Dale-Chall formula, Farr-Jenkins-Paterson formula, Kincaid formula, Gunning Fog Index, and Linsear Write Index, but nobody has applied these to programming errors or devised a formal readability metric.</p></li>
<li><p>Use a positive tone, and generally aim for a consumer UX: Novices are shaken, confused, dismayed, and discouraged by violent, vague, or obscure phrasing. Messages should be polite, restrained, friendly, and encouraging, making the computer seem subservient. Negative words like incorrect, illegal, and invalid should be avoided. Also <a class="reference external" href="https://www.oreilly.com/library/view/designed-for-use/9781680501902/f_0298.xhtml">general UX guidelines</a> advise to not place fault or blame, scold, or condemn the user (programmer). Sarcastic humor also seems counter-productive, although minor ‘fun’ humor may be OK but runs against briefness. Another <a class="reference external" href="https://faculty.washington.edu/ajko/papers/Lee2011Gidget.pdf">study</a> found personified I-messages such as “I don’t know what this is, so I’ll just go on to the next step” improved novice’s knowledge acquisition rates and thus amount of levels completed in a set time. Of course <a class="reference external" href="https://www.codewithjason.com/whos-blame-bad-code-coders/">others</a> argue the coders are objectively the ones at fault, but this seems to be an impossible to win argument, like arguing that your girlfriend is fat. Even if it’s true winning the argument doesn’t make anyone better off. Psychology is weird. For children, the computer should not appear as if it is a sentient human, so as to develop the correct mental model.</p></li>
<li><p>Provide a catalog of similar error examples (<a class="reference external" href="https://github.com/elm/error-message-catalog">Elm</a>, <a class="reference external" href="https://doc.rust-lang.org/error-index.html">Rust</a>): Providing handpicked, worked examples of how each error message is triggered can improve novices’ understanding and also function as a compiler test suite. Particularly a side-by-side incorrect/correct layout with the differences highlighted has been studied and found helpful. However, brevity offers many advantages, and a study showed novice programmers can be confused as to whether the example code in the message is their code. There is also the issue of overdependence on programming by example. As such relegating the examples to a separate webpage, so there is a clear separation of example from actual, seems the best approach. For example, Rust and Microsoft give each error message a unique ID, and then has a page of all the IDs and their description. This catalog and ID mechanism has not been studied in the literature and poses a discoverability hazard, but a hyperlink in the error message seems sufficient - showing the catalog entry in the error message would be documentation overkill unless it is really short. The quintessential error catalog is Stack Overflow, which indexes both standard error messages and obscure library codes or memory addresses. Popular responses are upvoted and can be quite useful to both novices and experts. Compared to formal reference documentation, the catalog can provide briefer and more concrete and specific assistance. With a feedback loop between catalog and compiler, error message codes can be refined to cover common issues more precisely. However it should be noted that there is little point in trying to organize the catalog with categorization - agreement among category raters was only 60% in <span id="id3">[]</span>. It is better to use a flat list and focus effort on specific tricky error codes rather than attempting to find patterns among errors.</p></li>
<li><p>Show solutions: The actual intent of the programmer may not be clear, but the compiler can analogize from the error catalog or other sources to guess what the programmer likely intended, and either provide a literal solution or sketch the requirements a solution must satisfy. Although debatable, my definition of the difference between an example and a solution is that the solution is phrased using specific information from the actual code, whereas the example is generic to the error ID. Also, the solution is produced only when there is a high degree of certainty for its applicability, avoiding leading the user down the wrong path. When guided appropriately by solutions, novices can repair errors approximately as fast as experts. With IDE integration, solutions may be interactively accepted and applied automatically instead of being transcribed by the user, allowing even experts to benefit from faster fixing. Elm says that every error should have a solution - this is probably overly ambitious. Solutions are doable for trivial errors like unbound identifiers or uncaught exceptions, but many semantic errors have no obvious solution and can take weeks to work out. Although Repairnator <span id="id4">[<a class="reference internal" href="../zzreferences.html#id116" title="Martin Monperrus. Explainable Software Bot Contributions: Case Study of Automated Bug Fixes. In 2019 IEEE/ACM 1st International Workshop on Bots in Software Engineering (BotSE), 12–15. May 2019. URL: http://arxiv.org/abs/1905.02597 (visited on 2023-06-19), arXiv:1905.02597, doi:10.1109/BotSE.2019.00010.">Mon19</a>]</span> focused on providing “explainable bug fixes” and apparently had some success, it only produced 1-3 line fixes - the three algorithms were Nopol, Astor, and NpeFix, which respectively focused on fixing test failures by changing conditional statements, fixing test failures by localization and inserting, removing, or mutating statements, and fixing null pointer exceptions by inserting a null pointer check and one of 9 types of handler, again validated by the test suite.</p></li>
<li><p>Allow dynamic interaction: A simple example is Rust’s <code class="docutils literal notranslate"><span class="pre">--explain</span></code> flag that gives more context for some errors and for others reproduces the explanation from the catalog. This is a “tell-me-more” mechanism that allows requesting more error details. In Stroscot’s case, where many contract errors take the form of failing program traces, another useful tool would be interactive omniscient debugging of these failing traces, so that the programmer can take a failure of <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">(a</span> <span class="pre">!=</span> <span class="pre">0)</span></code> and say “where did <code class="docutils literal notranslate"><span class="pre">a</span></code> come from?”. Both of these cannot be the main interface, because the catalog is verbose and debugging is too time-consuming, but as options they are quite helpful.</p></li>
<li><p>Provide cognitive scaffolding: A user may form the wrong conceptual model and/or move too quickly through writing the program. They then have a false sense of accomplishment. It is then the error messages’s job to dislodge incorrect conceptual models and point out hasty errors. The user may also have misread the problem, but solving the wrong problem is a general issue in cognition, including startups launching and failing due to market fit, so the compiler generally can’t tell that the wrong problem is being solved. Anyways, the goal is to use sufficient verbiage that the user can notice their conceptual model is wrong and search out documentation to repair it. To this end, the message should mention the key constructs and relationships that must be understood, e.g. syntactic construct names, compiler terminology, and library functions.</p></li>
<li><p>Use logical argumentation (maybe): <span id="id5">[]</span> analyzes error messages using Toulmin’s argument model, which allows 6 components (extended to 7 by Barik):</p>
<ul class="simple">
<li><p>The claim is the main assertion to be proven.</p></li>
<li><p>The grounds are evidence and facts that support the claim.</p></li>
<li><p>The warrant links the grounds to the claim.</p></li>
<li><p>The backing supports the warrant, usually by an example.</p></li>
<li><p>The qualifier limits the claim, explaining words such as “presumably”.</p></li>
<li><p>The rebuttal acknowledges other valid views but explains why they are not appropriate.</p></li>
<li><p>A resolution is a claim that a defect will be removed with a specific change. (Added by Barik)</p></li>
</ul>
<p>StackOverflow and compiler error messages used 3 argument layouts: claim alone, a simple argument consisting of claim, grounds, and warrant, and an extended argument which is a simple argument plus backing. These layouts are multiplied times 2 depending on whether there was a resolution in the claim; my notation is that “claim” means a claim without resolution. The tested results were claim &lt; {simple,extended}, extended &lt; claim+resolution (claim+resolution being dubbed a non-logical “quick fix” instruction).</p>
<p>Per the thesis <span id="id6">[]</span> extended arguments are mainly useful for novices and unfamiliar code. Theorizing, if the developer knows what’s going on, they likely want brief messages and their preference is claim+resolution &gt; simple &gt; extended &gt; others. But with an <code class="docutils literal notranslate"><span class="pre">--explain</span></code> flag their preference is more like extended+resolution &gt; simple+resolution &gt; claim+resolution &gt; extended &gt; simple &gt; others. It’s probably worth a survey comparing error messages of varying verbosities to confirm.</p>
</li>
<li><p>Report errors at the right time: Generally one wants to see errors as soon as possible, using static analysis tools.</p></li>
</ul>
<p>Per Elm / <a class="reference external" href="https://style.tidyverse.org/error-messages.html">Tidyverse</a> the message should have a layout like “general summary, program code fragment (location),error details / hints / suggested fix”. The general summary is shown on hover in VSCode, and can be expanded downwards to see the full message. The tooltip seems to be around 120 monospaced characters wide and 5 ish lines tall. The size differs based on popup type so recheck when developing for LSP; it used to be 50 characters wide for everything. There is <a class="reference external" href="https://github.com/microsoft/vscode/issues/14165">an old VSCode bug</a> open for expandable popups, and a <a class="reference external" href="https://stackoverflow.com/questions/44638328/vs-code-size-of-description-popup">CSS hack</a> that makes them larger, but probably Stroscot has to be designed to accommodate small popups.</p>
<p>The code fragment shows the full line of input code with file/line number, and marks the failing expression with <code class="docutils literal notranslate"><span class="pre">^^^`</span></code>. The error and location marks should be colored red so they are easy to spot. Similarly Elm uses a blue separator line <code class="docutils literal notranslate"><span class="pre">----</span></code> to separate messages. With the LSP integration this is already taken care of because VSCode underlines the error location in the editor and has its own UI for browsing through errors.</p>
</section>
</section>
<section id="debugging">
<h2>Debugging<a class="headerlink" href="#debugging" title="Link to this heading"></a></h2>
<p>Consider debugging and error reporting. Tracking down bugs is a systematic process:</p>
<ul class="simple">
<li><p>Step 1: Collect error messages, logs, and any available context, such as a stack trace.</p></li>
<li><p>Step 2: Identify sufficient and necessary conditions that trigger the bug, so that it can be reproduced in a controlled manner.</p></li>
<li><p>Step 3: Use code minimization and bisection techniques to find the specific lines of code causing the issue. Debugging tools can help with navigation.</p></li>
<li><p>Step 4: Review the relevant code. Look for syntax errors, typos, or missing semicolons. Reading the code backwards or writing comments above every line can help. If your code relies on external libraries or APIs, review the documentation and usage to ensure you’re using them correctly. Static analysis tools and linters may also catch potential coding errors, style violations, and other issues, pointing out patterns that are difficult to spot by eye.</p></li>
<li><p>Step 5: If no mistakes jumped out, trace the flow of data and logic through the code. Check if variables are being modified as expected and if conditional statements are behaving correctly.</p></li>
<li><p>Step 6: If you still haven’t found the bug, collaborate with a colleague to review the code together. A fresh pair of eyes can often spot issues that you might have missed.</p></li>
<li><p>Step 7: At this point the bug may be unsolvable, but try taking a break and stepping away from the code. Returning with a fresh perspective can help you see the issue differently.</p></li>
<li><p>Step 8: Once you have found (or not found) the bug, document the bug, your findings, and the steps you’ve taken to troubleshoot it. This documentation can be helpful for future reference. Implement the necessary changes or workarounds and thoroughly test to ensure the bug is resolved without introducing new problems. Automated CI tests can be very helpful at preventing regressions.</p></li>
</ul>
<p>Any improvement in error messages and the ability to spot and find bugs would be a massive improvement. A one character mistake in an XML file for a Java project can take a week to track down. If you read that XML file backwards, you might find it more easily. Similarly typing comments above every line force you to slow down and think in a different mode and they’ll go “oh, that code is wrong”. Just writing an email to your colleague explaining what you’ve done and asking a question can lead you to the answer. There are a lot of weird little mental hacks like that.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Dispatch.html" class="btn btn-neutral float-left" title="Dispatch" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Evaluation-Strategy.html" class="btn btn-neutral float-right" title="Evaluation strategy" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>