<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Compiler library &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Compiler output" href="CompilerOutput.html" />
    <link rel="prev" title="Compiler design" href="Compiler.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Compiler library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#synthesizing">Synthesizing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#importing">Importing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scope">Scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="#booleans">Booleans</a></li>
<li class="toctree-l3"><a class="reference internal" href="#numbers">Numbers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#representation">Representation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#syntax">Syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#digit-grouping">Digit grouping</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operations">Operations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#matrix-multiplication">Matrix multiplication</a></li>
<li class="toctree-l3"><a class="reference internal" href="#strings">Strings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#poison-values">Poison values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#null">Null</a></li>
<li class="toctree-l3"><a class="reference internal" href="#relations">Relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#posets">Posets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#primitive-values">Primitive values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dictionaries">Dictionaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tables">Tables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#typed-collections">Typed collections</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transactional-memory">Transactional memory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#wait-free">Wait-free</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#iterators">Iterators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#control-structures">Control structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#goto-break-continue">Goto/Break/continue</a></li>
<li class="toctree-l3"><a class="reference internal" href="#work-stealing-task-queues">Work stealing task queues</a></li>
<li class="toctree-l3"><a class="reference internal" href="#properties">Properties</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arrays">Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conversion">Conversion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#promotion">Promotion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#equality-and-comparison">Equality and comparison</a></li>
<li class="toctree-l3"><a class="reference internal" href="#value-representation">Value representation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#terms">Terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-structures">Data structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#list-flattening">List flattening</a></li>
<li class="toctree-l3"><a class="reference internal" href="#list-homomorphisms">List homomorphisms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#serialization">Serialization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cycles-and-non-serializable-data">Cycles and non-serializable data</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#function-pipelines">Function pipelines</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Intrinsics.html">Intrinsics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#resources">Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#metrics">Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#methods">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#action">Action</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#caches">Caches</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard-Library.html">Standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Compiler library</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Compiler-Library.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="compiler-library">
<h1>Compiler library<a class="headerlink" href="#compiler-library" title="Permalink to this heading"></a></h1>
<p>For the language to be useful it must have an implementation, and ideally a self-hosting implementation. In this framework the compiler, and hence the language, are really just another set of library modules. I will unimaginatively call this library the “compiler library”. Per the standard library evolutionary design process, the compiler library will likely serve as the prototype for the standard library, so some investment is worthwhile.</p>
<section id="synthesizing">
<h2>Synthesizing<a class="headerlink" href="#synthesizing" title="Permalink to this heading"></a></h2>
<p>Designing a good, quality API is hard, but lots of people have tried. There are various existing libraries that seem worth inspecting:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/rust-lang/rust/tree/master/library">Rust</a> (MIT + Apache 2.0, <a class="reference external" href="https://blog.nindalf.com/posts/rust-stdlib/">small</a>)</p></li>
<li><p><a class="reference external" href="https://github.com/golang/go/tree/master/src">Go</a> (BSD-style)</p></li>
<li><p><a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/tree/master/libraries">Haskell</a> (BSD-style)</p>
<ul>
<li><p>The alternate prelude <a class="reference external" href="https://github.com/haskell-foundation/foundation">Foundation</a> (BSD)</p></li>
</ul>
</li>
<li><p>Julia <a class="reference external" href="https://github.com/JuliaLang/julia/tree/master/base">1</a> <a class="reference external" href="https://github.com/JuliaLang/julia/tree/master/stdlib">2</a> (MIT)</p></li>
<li><p>C</p>
<ul>
<li><p><a class="reference external" href="https://sourceware.org/git/?p=glibc.git;a=tree">glibc</a> (LGPLv2.1, some files BSD/ISC/etc.)</p></li>
<li><p><a class="reference external" href="https://git.musl-libc.org/cgit/musl/tree/">Musl</a> (MIT)</p></li>
</ul>
</li>
<li><p>C++</p>
<ul>
<li><p><a class="reference external" href="https://nvidia.github.io/libcudacxx/">NVIDIA</a>, <a class="reference external" href="https://libcxx.llvm.org/">LLVM</a>, <a class="reference external" href="https://github.com/microsoft/STL">MSVC</a> (Apache 2 with LLVM Exceptions)</p></li>
<li><p><a class="reference external" href="https://hpx.stellar-group.org/">HPX</a> (Boost Software License 1.0)</p></li>
<li><p><a class="reference external" href="https://github.com/electronicarts/EASTL">EASTL</a> (BSD 3-Clause)</p></li>
</ul>
</li>
<li><p>Python <a class="reference external" href="https://github.com/python/cpython/tree/master/Modules">1</a> <a class="reference external" href="https://github.com/python/cpython/tree/master/Lib">2</a> (PSFv2)</p></li>
<li><p><a class="reference external" href="https://github.com/ziglang/zig/tree/master/lib/std">Zig</a> (MIT)</p></li>
<li><p>Slate <a class="reference external" href="https://github.com/briantrice/slate-language/tree/master/src/core">1</a> <a class="reference external" href="https://github.com/briantrice/slate-language/tree/master/src/lib">2</a> <a class="reference external" href="https://github.com/briantrice/slate-language/tree/master/src/i18n">3</a> (MIT)</p></li>
</ul>
<p>We don’t just copy wholesale, rather we look for what libraries agree on (commonalities), what is unique to one library (innovations), and what libraries overlap but disagree on (competition). Commonalities and innovations are fairly straightforward, they can just be adopted. But if there are multiple competing solution to a problem, then we have to look at experience reports as to which solution is best, and create a new solution with the best parts of each.</p>
<p>The proposals of the various languages can be useful, as they include motivation as to why the library was designed that way. An aspect of the library might simply be a historical “accident” from the initial design, but a proposal is always a deliberate design choice. Even the rejected proposals are useful as they indicate language/library “smells”, areas that could use improvement.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/pulls">GHC</a></p></li>
<li><p><a class="reference external" href="https://github.com/python/peps">Python</a>. The repo includes almost all proposals, but there are a few stray PRs:</p>
<ul>
<li><p><a class="reference external" href="https://github.com/python/peps/pull/2066/files">https://github.com/python/peps/pull/2066/files</a></p></li>
<li><p><a class="reference external" href="https://github.com/python/peps/pull/609/files">https://github.com/python/peps/pull/609/files</a></p></li>
<li><p><a class="reference external" href="https://github.com/python/peps/pull/641/files">https://github.com/python/peps/pull/641/files</a></p></li>
<li><p><a class="reference external" href="https://github.com/python/peps/pull/671/files">https://github.com/python/peps/pull/671/files</a></p></li>
<li><p><a class="reference external" href="https://github.com/python/peps/pull/686/files">https://github.com/python/peps/pull/686/files</a></p></li>
<li><p><a class="reference external" href="https://github.com/python/peps/pull/690/files">https://github.com/python/peps/pull/690/files</a></p></li>
<li><p><a class="reference external" href="https://github.com/python/peps/pull/2620/files">https://github.com/python/peps/pull/2620/files</a> (and other PRs after Jun 1 2022)</p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://github.com/rust-lang/rfcs/pulls">Rust</a> (<a class="reference external" href="https://rust-lang.github.io/rfcs/">accepted</a>)</p></li>
<li><p><a class="reference external" href="https://github.com/golang/go/labels/Proposal">Go</a></p></li>
<li><p><a class="reference external" href="https://wiki.php.net/rfc">PHP</a></p></li>
</ul>
<p>TODO: go through these, unfortunately there’s a lot</p>
</section>
<section id="importing">
<h2>Importing<a class="headerlink" href="#importing" title="Permalink to this heading"></a></h2>
<p>Stroscot should support the standard libraries of popular languages, so e.g. if you want the C functions with C semantics you would <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">Library.C</span></code>. Compatibility is a natural step to world domination, and this allows an intermediate step of C semantics with Stroscot syntax. For example a function of type <code class="docutils literal notranslate"><span class="pre">C.int</span> <span class="pre">-&gt;</span> <span class="pre">C.size_t</span></code> is different from plain <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code>, and if you really need the semantics of C++’s unstable sort then it has to be included.</p>
<p>It’s only worth supporting the biggies, in particular:</p>
<ul class="simple">
<li><p>C, the standardized library. Quite lean, and it’s the basis of most OS’s, so it’s definitely the one to start with, and maybe the only one needed</p></li>
<li><p>C++, the standardized library</p></li>
<li><p>Java, OpenJDK libraries (GPL but with linking exception, should be OK to use for most projects. And Oracle v Google found that reimplementing the API via Apache-2 licensed Apache Harmony was fair use)</p></li>
</ul>
<p>Others, such as the Python standard library, Glib, and Boost, are probably not worth the effort of copying directly, rather programs using these libraries can be linked via FFI or rewritten into Stroscot.</p>
</section>
<section id="scope">
<h2>Scope<a class="headerlink" href="#scope" title="Permalink to this heading"></a></h2>
<p>The C library is considered somewhat small, so this defines a minimum:</p>
<ul class="simple">
<li><p>file system input/output</p></li>
<li><p>data types and conversions</p></li>
<li><p>memory allocation and manipulation</p></li>
<li><p>concurrency / threading</p></li>
<li><p>OS date and time</p></li>
<li><p>math functions</p></li>
<li><p>error handling and assertions.</p></li>
</ul>
<p>For metacircularity Stroscot should also expose the compiler’s API and an eval function.</p>
<p>C++ also provides:</p>
<ul class="simple">
<li><p>containers, such as arrays, hash maps, and binary trees</p></li>
<li><p>algorithms operating over those containers, such as insertion, lookup, and sorting</p></li>
<li><p>string tokenization</p></li>
<li><p>regular expressions</p></li>
</ul>
<p>Python has more:</p>
<ul class="simple">
<li><p>data compression</p></li>
<li><p>cryptography</p></li>
<li><p>networking</p></li>
<li><p>CSV/XML parsing</p></li>
<li><p>unit testing</p></li>
<li><p>profiling</p></li>
</ul>
<p>Maybe once the language is more defined it will be worth standardizing the embedding of some application-specific libraries. Audio, graphics (GUI), databases, servers.</p>
<p>Then there are the APIs that have caused endless bikeshedding:</p>
<ul class="simple">
<li><p>random number generation</p></li>
<li><p>serialization (data persistence)</p></li>
</ul>
</section>
<section id="booleans">
<h2>Booleans<a class="headerlink" href="#booleans" title="Permalink to this heading"></a></h2>
<p>four distinct 2-valued types, for true/false, yes/no, on/off, and 0/1</p>
<p>Per <span id="id1">[<a class="reference internal" href="../zzreferences.html#id129" title="Michael Pradel and Koushik Sen. The Good, the Bad, and the Ugly: An Empirical Study of Implicit Type Conversions in JavaScript. In John Tang Boyland, editor, 29th European Conference on Object-Oriented Programming (ECOOP 2015), volume 37 of Leibniz International Proceedings in Informatics (LIPIcs), 519–541. Dagstuhl, Germany, 2015. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik. \subsection Other Most popular programming languages support situations where a value of one type is converted into a value of another type without any explicit cast. Such implicit type conversions, or type coercions, are a highly controversial language feature. Proponents argue that type coercions enable writing concise code. Opponents argue that type coercions are error-prone and that they reduce the understandability of programs. This paper studies the use of type coercions in JavaScript, a language notorious for its widespread use of coercions. We dynamically analyze hundreds of programs, including real-world web applications and popular benchmark programs. We find that coercions are widely used (in 80.42% of all function executions) and that most coercions are likely to be harmless (98.85%). Furthermore, we identify a set of rarely occurring and potentially harmful coercions that safer subsets of JavaScript or future language designs may want to disallow. Our results suggest that type coercions are significantly less evil than commonly assumed and that analyses targeted at real-world JavaScript programs must consider coercions. URL: http://drops.dagstuhl.de/opus/volltexte/2015/5236 (visited on 2022-07-25), doi:10.4230/LIPIcs.ECOOP.2015.519.">PS15</a>]</span> the only acceptable coercions are coercing to bool in <code class="docutils literal notranslate"><span class="pre">if-else</span></code>, <code class="docutils literal notranslate"><span class="pre">!x</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&amp;&amp;</span> <span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">||</span> <span class="pre">y</span></code>.</p>
</section>
<section id="numbers">
<h2>Numbers<a class="headerlink" href="#numbers" title="Permalink to this heading"></a></h2>
<p>Mathematically, the definition of <a class="reference external" href="https://en.wikipedia.org/wiki/Number#Main_classification">number</a> mainly refers to natural numbers, integers, rationals, real numbers, and complex numbers (the “numeric tower”), but other mathematical structures like p-adics or the surreal numbers are also considered numbers.</p>
<section id="representation">
<h3>Representation<a class="headerlink" href="#representation" title="Permalink to this heading"></a></h3>
<p>There are various ways to represent these numbers. Naturals are generally represented as a list of digits in some base (a decimal). Integers are naturals with a sign. Rationals may be written as a (possibly improper) fraction of integers, a terminating or infinitely repeating decimal, a “mixed number” an integer and a proper fraction, or a floating point of a decimal times an exponent 1/2^n. For the complete fields such as reals and p-adics there are even more representations:</p>
<ul class="simple">
<li><p>Cauchy sequence of rationals</p></li>
<li><p>nondecreasing bounded sequence of rationals</p></li>
<li><p>an infinite decimal</p></li>
<li><p>predicate which determines if a rational is lower, equal to, or higher than the number</p></li>
<li><p>“sign expansion”, an ordinal and a function from the domain of that ordinal to {-1,+1}</p></li>
</ul>
<p>Completion also brings with it the computability issue. For example, finding a rational approximation of Chaitin’s Ω constant within a given precision has complexity at least <span class="math notranslate nohighlight">\(\Sigma^0_1\)</span>, meaning that every Turing program attempting to compute Ω has a precision beyond which it will unconditionally fail to produce an answer. Practically, one mainly restricts attention to computable numbers, i.e. those numbers for which the predicate/sequence/function is representable as a terminating program, but although they are closed under the field operations, equality is still complexity at least <span class="math notranslate nohighlight">\(\Sigma^0_1\)</span>. I’m not sure of a direct example, but for example it is an open question if <span class="math notranslate nohighlight">\(e+\pi\)</span> is rational, algebraic, irrational or transcendental.</p>
<p>Complex numbers have two main representations, rectangular (1+2i) and polar (sqrt(5) e^(i arctan(2))). Each of these has two coordinates, so we might represent them as <code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">Complex</span> <span class="pre">=</span> <span class="pre">Rectangular</span> <span class="pre">Real</span> <span class="pre">Real</span> <span class="pre">|</span> <span class="pre">Polar</span> <span class="pre">Real</span> <span class="pre">Real</span></code>. Most complex numbers have a 1-1 conversion between the two forms. There are the issues that 0 has only one rectangular form but many polar forms, and the polar angle can differ by any multiple of 360 degrees, but restricting the polar number set to the “small” polar set where theta in [0,360 degrees) and r=0 -&gt; theta=0 fixes this.</p>
<p>So far we have only considered the variety of mathematical forms. The representation on a computer also involves a certain amount of differentiation based on practicalities. There are arbitrary-precision bignums and symbolic representations that can represent almost all values, subject to memory and computability limits, which are great for those who don’t care much about performance. But for reasons of efficiency, and also for faithfulness to standards etc. which specify a representation, many programs will want to use fixed-size types that restrict values to a certain range, precision, and bit representation, such as int8, uint16, or the IEEE floating point formats.</p>
<p>So, how do we deal with this multitude of forms? Generally, programs are not representation-independent, and each algorithm or operation in a program will have a preferred representation that it works with for input and output, preferred for reasons of accuracy, speed, or convenience. We cannot reliably perform automatic conversion between formats, as they differ in ranges and so on; there will be unrepresentable value in one direction or the other, loss of precision in the case of floating-point, and the conversion itself adds nontrivial overhead. Thus, we must consider each representation of a mathematical value to be a distinct programmatic value. There are thus several sets relevant to, for example, the integers:</p>
<ul class="simple">
<li><p>Int8, Int16, UInt16, etc.: the sets of integers representable in various fixed representations</p></li>
<li><p>GmpIntegers: the set of all integers as represented in arbitrary precision in libGMP (disjoint from the above)</p>
<ul>
<li><p>GmpIntegers8, GmpIntegers16, GmpIntegersU16, etc.: the subsets of libGMP integers corresponding to the fixed representations</p></li>
</ul>
</li>
<li><p>Integers: the disjoint union (sum type) of all integer representations</p></li>
<li><p>Any: the universal set containing the above and all other values</p></li>
</ul>
</section>
<section id="syntax">
<h3>Syntax<a class="headerlink" href="#syntax" title="Permalink to this heading"></a></h3>
<p>Number syntax is mainly <a class="reference external" href="https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_numeric-literal">Swift’s</a>. There is the integer literal <code class="docutils literal notranslate"><span class="pre">4211</span></code>, extended to the decimal <code class="docutils literal notranslate"><span class="pre">12.11</span></code>. Different bases are provided, indicated with a prefix - decimal <code class="docutils literal notranslate"><span class="pre">1000</span></code>, hexadecimal <code class="docutils literal notranslate"><span class="pre">0x3e8</span></code>, octal <code class="docutils literal notranslate"><span class="pre">0o1750</span></code>, binary <code class="docutils literal notranslate"><span class="pre">0b1111101000</span></code>. Exponential notation <code class="docutils literal notranslate"><span class="pre">1.23e+3</span></code> may be either integer or rational. Positive exponents with decimal (e) / hexadecimal (p) / binary (b) are allowed. Also there is a sign. Numbers can also have a suffix interpreted as the format. This expand to a term that specifies the format by applying it, e.g.  <code class="docutils literal notranslate"><span class="pre">123i8</span></code> expands to <code class="docutils literal notranslate"><span class="pre">int8</span> <span class="pre">123</span></code>. Formats include IEE 754 float/double, signed and unsigned fixed bit-width integers, and fixed-point rationals. So the full syntax is sign, base, mantissa, exponent, format.</p>
<p>Leadings 0’s are significant - literals with leading zeros must be stored in a type that can hold the digits all replaced with their highest value, e.g. <code class="docutils literal notranslate"><span class="pre">0001</span></code> cannot be stored in a <code class="docutils literal notranslate"><span class="pre">i8</span></code> (type must be able to contain <code class="docutils literal notranslate"><span class="pre">9999</span></code>). Parsing leading <code class="docutils literal notranslate"><span class="pre">0</span></code> as octal is widely acknowledged as a mistake and should not be done. On the other hand trailing 0’s are not significant - the decimal point should never be the last character in numeric literals (e.g. 1. is invalid, and must be written as 1 or 1.0).</p>
<p>It seems worth allowing extension of bases / exponential formats to characters other than xob / epb.</p>
<p>Then there are the standard arithmetic operations, no need to mess with them.</p>
</section>
<section id="digit-grouping">
<h3>Digit grouping<a class="headerlink" href="#digit-grouping" title="Permalink to this heading"></a></h3>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Decimal_separator#Digit_grouping">Wikipedia</a> lists the following commonly used digit grouping delimiters: comma “,”, dot “.”, thin space ” “, space ” “, underscore “_”, apostrophe/single quote «’».Traditionally, English-speaking countries employ commas, and other European countries employ dots. This causes ambiguity as <code class="docutils literal notranslate"><span class="pre">1.000</span></code> could either be <code class="docutils literal notranslate"><span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">1000</span></code> depending on country. To resolve this ambiguity, various standards organizations have advocated the thin space in groups of three since 1948, using a regular word space or no delimiter if not available. However, comma, dot, and space are already in use in programming languages as list separator, radix point, and token separator.</p>
<p>Hence underscore and apostrophe have been used in PLs instead. Simon of <a class="reference external" href="https://github.com/core-lang/core/issues/52">Core</a> says apostrophe is more readable. Underscore is also used in identifiers, which can confuse as to whether a symbol is an identifier or a numeric literal. But the underscore is the natural ASCII replacement for a space. 13+ languages have settled on underscore, <a class="reference external" href="https://softwareengineering.stackexchange.com/questions/403931/which-was-the-first-language-to-allow-underscore-in-numeric-literals">following</a> Ada that was released circa 1983. Only C++14, Rebol, and Red use the “Swiss” apostrophe instead.</p>
<p>C++14 chose quote to solve an ambiguity in whether the <code class="docutils literal notranslate"><span class="pre">_db</span></code> in <code class="docutils literal notranslate"><span class="pre">0xdead_beef_db</span></code> is a user-defined format or additional hexadecimal digits, by making it <code class="docutils literal notranslate"><span class="pre">0xdead'beef_db</span></code>. This could have been solved by specifying that the last group parses as a format if defined and digits otherwise, or parses as digits and requires an extra underscore <code class="docutils literal notranslate"><span class="pre">__db</span></code> to specify a format.</p>
<p>Rebol uses comma/period for decimal point so quote was a logical choice. There doesn’t seem to be any reason underscore couldn’t have been used. Red is just a successor of Rebol and copied many choices.</p>
</section>
<section id="operations">
<h3>Operations<a class="headerlink" href="#operations" title="Permalink to this heading"></a></h3>
<p>Considering the multitude of forms, and the fact that representations are often changed late in a project, it seems reasonable to expect that most code should be representation-agnostic. The library should support this by making the syntax “monotonous”, in the sense of <a class="reference external" href="https://en.wikipedia.org/wiki/The_Humane_Interface">Jef Raskin</a>, meaning that there should be only one common way to accomplish an operation. For example, addition should have one syntax, <code class="docutils literal notranslate"><span class="pre">a+b</span></code>, but this syntax should work on numerous forms. This avoids a profusion of operators such as <code class="docutils literal notranslate"><span class="pre">+.</span></code> for addition of floating-point in OCaml which is just noisy and hard to remember.</p>
<p>Internally, each exposed operation is implemented as overloading the symbol for various more specific “primitive” operations, <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">=</span> <span class="pre">lub</span> <span class="pre">[add_int8,</span> <span class="pre">add_int16,</span> <span class="pre">...]</span></code>. The compiler will be able to use profiling data to observe the forms of the numbers involved and select the appropriate primitive operation, so it should always be possible to replace a direct use of the primitive <code class="docutils literal notranslate"><span class="pre">add</span></code> with the normal <code class="docutils literal notranslate"><span class="pre">+</span></code> operation without significantly affecting performance. But for expressiveness purposes, it does seem worth exposing the primitives. Conceptually, since the primitives don’t overlap, each primitive <code class="docutils literal notranslate"><span class="pre">add</span></code> operation is the restriction of the overloaded <code class="docutils literal notranslate"><span class="pre">(+)</span></code> to the domain of the specific primitive, so even if we didn’t expose the primitives we could define them ourselves as <code class="docutils literal notranslate"><span class="pre">add_int8</span> <span class="pre">=</span> <span class="pre">(+)</span> <span class="pre">:</span> <span class="pre">Int8</span> <span class="pre">-&gt;</span> <span class="pre">Int8</span> <span class="pre">-&gt;</span> <span class="pre">Int8</span></code> and so on. It makes sense to avoid this convolutedness and simply expose the primitives directly - in one stroke, we avoid any potential optimization problems, and we also ensure that the domains of the primitives are only defined in one place (DRY). Of course, such primitives are quite low-level and most likely will only be needed during optimization, as a sanity check that the representation expected is the representation in use.</p>
<p>For fixed-precision integers and floating point, the operations work in stages: first, the numbers are converted to arbitrary-precision, then the operation is performed in arbitrary precision, then the result is rounded. In the case of fixed-precision integers, there are choices such as truncating (clamping/saturating), wrapping, or erroring on overflow. In the case of floating point, there are numerous rounding modes and errors as well.</p>
<p>Commonly, the rounding is considered part of the operation, and the rounding mode is just fixed to some ambient default, but this is not optimal with respect to performance. Herbie provides a different approach. Given a real-valued expression and assumptions on the inputs, Herbie produces a list of equivalent computations, and computes their speed and accuracy for various choices of machine types and rounding. The programmer can then choose among these implementations, selecting the fastest, the most accurate, or some trade-off of speed and precision. The question is then how to expose this functionality in the language. The obvious choice is to make the rounding operation explicit. In interpreted mode arbitrary-precision is used, at least to the precision of the rounding, and in compiled mode Herbie is used. Or something like that.</p>
</section>
</section>
<section id="matrix-multiplication">
<h2>Matrix multiplication<a class="headerlink" href="#matrix-multiplication" title="Permalink to this heading"></a></h2>
<p>Suppose we are multiplying three matrices A, B, C. Since matrix multiplication is associative, (AB)C = A(BC). But one order may be much better, depending on the sizes of A, B, C. Say A,B,C are m by n, n by p, p by q respectively. Then computing (AB)C requires mp(n + q) multiplications, and computing A(BC) requires (m + p)nq multiplications. So if m = p = kn = kq, then (AB)C costs 2k^3 n^3, while A(BC) costs 2 k n^3, which if k is large means A(BC) is going to be much faster than multiplying (AB)C. The matrix chain multiplication algorithm by Hu Shing finds the most efficient parenthesization in O(n log n) time, given the sizes of the matrices. In practice the sizes must be observed through profiling. But this data must be collected at the level of the matrix chain  multiplication, as re-association optimisations are hard to recognise when the multiplication is expanded into loops.</p>
</section>
<section id="strings">
<h2>Strings<a class="headerlink" href="#strings" title="Permalink to this heading"></a></h2>
<p>Text types:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Text</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Text</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">ByteArray</span><span class="o">#</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">-- sequence of bytes, integers are byte offsets</span>
<span class="kt">ByteString</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">BS</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">payload</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Addr</span><span class="o">#</span><span class="p">,</span><span class="w"> </span><span class="n">finalizer</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="kt">Finalizers</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">}</span>
<span class="kt">Lazy</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Chunk</span><span class="w"> </span><span class="kt">Text</span><span class="w"> </span><span class="kt">Lazy</span>
</pre></div>
</div>
<p>Interpolation and internationalization are two things that have to work together, copy JS i18n and Python interpolation like <code class="docutils literal notranslate"><span class="pre">i'{x}</span> <span class="pre">{y}'.format(locale_dict)</span></code>.</p>
</section>
<section id="poison-values">
<h2>Poison values<a class="headerlink" href="#poison-values" title="Permalink to this heading"></a></h2>
<p>This requires some support from the OS to implement. Pointer reads generate page faults, which if they are invalid will be returned to the program via the signal “Segmentation fault” (SIGSEGV). C/C++ <a class="reference external" href="https://stackoverflow.com/questions/2350489/how-to-catch-segmentation-fault-in-linux">can’t handle these easily</a> because they are <a class="reference external" href="https://lwn.net/Articles/414618/">synchronous signals</a> and synchronous signal behavior is mostly left undefined, but in fact signals are <a class="reference external" href="https://hackaday.com/2018/11/21/creating-black-holes-division-by-zero-in-practice/">fairly well-behaved</a> (<a class="reference external" href="https://sources.debian.org/src/openssl/1.1.1k-1/crypto/s390xcap.c/?hl=48#L48">OpenSSL</a>’s method of recovering from faults even seems standards-compliant). It definitely seems possible to implement this as an error value in a new language. Go <a class="reference external" href="https://stackoverflow.com/questions/43212593/handling-sigsegv-with-recover">allows</a> turning (synchronous) signals into “panics” that can be caught with recover.</p>
<p>UDIV by 0 on ARM simply produces 0. So on ARM producing the division by 0 error requires checking if the argument is zero beforehand and branching. The people that really can’t afford this check will have to use the unchecked division instruction in the assembly module, or make sure that the check is compiled out. But on x86, DIV by 0 on produces a fault, which on Linux the kernel picks up and sends to the application as a SIGFPE. So on x86 we can decide between inserting a check and handling the SIGFPE. It’ll require testing to see which is faster in typical programs - my guess is the handler, since division by zero is rare.</p>
</section>
<section id="null">
<h2>Null<a class="headerlink" href="#null" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">null</span></code> is just a symbol. The interesting part is the types. A type may either contain or not contain the null value. If the type does contain null, then the null value represents an absent or uninitialized element, and should be written with a question mark, like <code class="docutils literal notranslate"><span class="pre">Pointer?</span></code>. If the type does not contain null, then the value is guaranteed to be non-null, and the type should not have a question mark. We can formalize this by making <code class="docutils literal notranslate"><span class="pre">?</span></code> a type operator, <code class="docutils literal notranslate"><span class="pre">A?</span> <span class="pre">=</span> <span class="pre">assert</span> <span class="pre">(null</span> <span class="pre">notin</span> <span class="pre">A);</span> <span class="pre">A</span> <span class="pre">|</span> <span class="pre">{null}</span></code>.</p>
</section>
<section id="relations">
<h2>Relations<a class="headerlink" href="#relations" title="Permalink to this heading"></a></h2>
<p>There are various types of relations: <a class="reference external" href="https://en.wikipedia.org/wiki/Binary_relation#Special_types_of_binary_relations">https://en.wikipedia.org/wiki/Binary_relation#Special_types_of_binary_relations</a></p>
<p>The question is, what data types do we need for relations?</p>
<ul class="simple">
<li><p>Function: a function, obviously.</p></li>
<li><p>Functional: This is a function too, just add a <code class="docutils literal notranslate"><span class="pre">NoClauseDefined</span></code> element to the result type.</p></li>
<li><p>One-to-one: a function with an assertion, <code class="docutils literal notranslate"><span class="pre">assume(forall</span> <span class="pre">x</span> <span class="pre">y;</span> <span class="pre">if</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">f</span> <span class="pre">y</span> <span class="pre">{</span> <span class="pre">assert</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y})</span></code></p></li>
<li><p>Many-to-one: A function, no constraints</p></li>
<li><p>Injective: This is the converse of a function, just use the function.</p></li>
<li><p>One-to-many: the converse of a function, again just use the function.</p></li>
<li><p>Many-to-many: the only relation that can’t be represented by a one-argument function</p></li>
</ul>
<p>So, a function represents most relations, and for a many-to-many relation, we need to represent a set of tuples. There are choices of how to implement this set.</p>
<p>We could use a function of two arguments returning a boolean, if the domain/codomain are infinite. Or if both domain and codomain are finite, a set data structure containing tuples. Or a boolean matrix, if there are lots of tuples. Or a map of sets if one of the elements is sparse. Or a directed simple graph if we have a graph library.</p>
<p>Then we have the reflexive, symmetric, transitive closures for many-to-many relations. With a finite relation these are straightforward to compute via matrix algorithms or their equivalent. For infinite sets we have to work harder and use some form of symbolic reasoning.</p>
</section>
<section id="posets">
<h2>Posets<a class="headerlink" href="#posets" title="Permalink to this heading"></a></h2>
<p>Discussed in the posets commentary.</p>
</section>
<section id="primitive-values">
<h2>Primitive values<a class="headerlink" href="#primitive-values" title="Permalink to this heading"></a></h2>
<p>ISO/IEC 11404 has a classification of values:</p>
<ol class="arabic simple">
<li><p>primitive - defined axiomatically or by enumeration</p></li>
<li><p>primitive - cannot be decomposed into other values without loss of all semantics</p></li>
<li><p>primitive - not constructed in any way from other values, has no reference to other values</p></li>
<li><p>non-primitive - wholly or partly defined in terms of other values</p></li>
<li><p>generated - defined by the application of a generator to one or more previously-defined values</p></li>
<li><p>generated - specified, and partly defined, in terms of other values</p></li>
<li><p>generated - syntactically and in some ways semantically dependent on other values used in the specification</p></li>
<li><p>atomic - a value which is intrinsically indivisible. All primitive values are atomic, and some generated values such as pointers, procedures, and classes are as well.</p></li>
<li><p>aggregate - generated value that is made up of component values or parametric values, in the sense that operations on all component values are meaningful</p></li>
<li><p>aggregate - value which can be seen as an organization of specific component values with specific functionalities</p></li>
<li><p>aggregate - organized collection of accessible component values</p></li>
</ol>
<p>Even ignoring the fact that the multiple definitions are all slightly different, these distinctions are also a matter of definition: we can define a 32-bit integer as one of 2^32 symbols, hence primitive and atomic, or as a list of boolean values of length 32, hence generated and aggregate. It seems easiest to avoid going down this rabbit hole and simply make a big list of all the sets of values, without attempting to create such a broad classification of the sets.</p>
</section>
<section id="dictionaries">
<h2>Dictionaries<a class="headerlink" href="#dictionaries" title="Permalink to this heading"></a></h2>
<p>Wikipedia calls these “associative arrays” and C++ and Haskell calls them maps. There is also the ISO/IEC 11404 “record” which only allows identifiers as keys and has a fixed key set. But dictionary seems to be the accepted term in the data structure textbooks, and it’s about the right length as a word.</p>
</section>
<section id="tables">
<h2>Tables<a class="headerlink" href="#tables" title="Permalink to this heading"></a></h2>
<p>Tables such as those found in SQL are bags of records that all have the same fields.</p>
</section>
<section id="typed-collections">
<h2>Typed collections<a class="headerlink" href="#typed-collections" title="Permalink to this heading"></a></h2>
<p>A straightforward collection implementation produces a heterogeneous collection that can contain anything. So for example a linked list <code class="docutils literal notranslate"><span class="pre">mkList</span> <span class="pre">[x,...y]</span> <span class="pre">=</span> <span class="pre">Cons</span> <span class="pre">x</span> <span class="pre">(mkList</span> <span class="pre">y);</span> <span class="pre">mkList</span> <span class="pre">[]</span> <span class="pre">=</span> <span class="pre">Nil</span></code>. We can type these lists by a set that contains all the elements, in particular defining <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">Cons</span> <span class="pre">t</span> <span class="pre">(List</span> <span class="pre">t)</span> <span class="pre">|</span> <span class="pre">Nil</span></code>. The type of all lists is <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">Any</span></code> We can infer a good type for a list value with <code class="docutils literal notranslate"><span class="pre">contents</span> <span class="pre">(l</span> <span class="pre">:</span> <span class="pre">List</span> <span class="pre">Any)</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">e</span> <span class="pre">|</span> <span class="pre">e</span> <span class="pre">elementOf</span> <span class="pre">l</span> <span class="pre">};</span> <span class="pre">type</span> <span class="pre">(l</span> <span class="pre">:</span> <span class="pre">UList)</span> <span class="pre">=</span> <span class="pre">List</span> <span class="pre">(contents</span> <span class="pre">l)</span></code> - we have <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">(l</span> <span class="pre">:</span> <span class="pre">List</span> <span class="pre">t).</span> <span class="pre">contents</span> <span class="pre">l</span> <span class="pre">subset</span> <span class="pre">t</span></code> so this is the lower bound / principal type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">uncons</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="nf">cons</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">|</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>We see from looking at <code class="docutils literal notranslate"><span class="pre">uncons</span></code> that this type parameter is a read bound, i.e. the returned value must be one of the elements. Following section 9.1.1 of <span id="id2">[<a class="reference internal" href="../zzreferences.html#id44" title="Stephen Dolan. Algebraic Subtyping. PhD thesis, University of Cambridge, September 2016. URL: https://www.cs.tufts.edu/~nr/cs257/archive/stephen-dolan/thesis.pdf.">Dol16</a>]</span> we might expect two parameters, a read bound and a write bound. But as far as I can tell, with first-class stores we don’t need a second parameter - rather we write constraints, and if necessary two constraints:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">get</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Store</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Ref</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w">  </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Store</span><span class="p">)</span>
<span class="nf">set</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Store</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Ref</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Store</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="nf">modify</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Store</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Ref</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Store</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>With the formulation here, values are pure, so there is no polymorphic aliasing problem or whatever.</p>
<p>One other way to add a parameter that both I and Cliff Click came up with independently is a “restricted list”, that for example makes <code class="docutils literal notranslate"><span class="pre">(RList</span> <span class="pre">Int</span> <span class="pre">[])</span> <span class="pre">++</span> <span class="pre">[&quot;a&quot;]</span></code> an error. Unrestricted lists construct heterogeneous lists and errors on unexpected elements will not show up until you try to read and use an element of the wrong type. Likely the error message will not be so clear on when the element was inserted, making it hard to debug. Instead of adding type assertions in random places, the restricted list will verify that all values are members of the write type when inserted.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">RList</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">write_type</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Type</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">Any</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">subseteq</span><span class="w"> </span><span class="n">rt</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">subseteq</span><span class="w"> </span><span class="n">write_type</span><span class="p">,</span><span class="w"> </span><span class="n">wt</span><span class="w"> </span><span class="n">subseteq</span><span class="w"> </span><span class="n">write_type</span><span class="w"> </span><span class="p">}</span>
<span class="nf">uncons</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="n">wt</span><span class="w"> </span><span class="n">rt</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="p">(</span><span class="n">rt</span><span class="p">,</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="n">wt</span><span class="w"> </span><span class="n">rt</span><span class="p">)</span>
<span class="nf">uncons</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Nil</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">l</span><span class="o">.</span><span class="n">l</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span>
<span class="nf">uncons</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">l&#39;</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">l</span><span class="o">.</span><span class="n">l</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="n">l</span><span class="o">.</span><span class="n">write_type</span><span class="w"> </span><span class="n">l&#39;</span><span class="p">)</span>
<span class="nf">cons</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">wt</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="n">wt</span><span class="w"> </span><span class="n">rt</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="n">wt</span><span class="w"> </span><span class="p">(</span><span class="n">rt</span><span class="o">|</span><span class="p">{</span><span class="n">v</span><span class="p">})</span>
<span class="nf">cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">assert</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">write_type</span><span class="w"> </span><span class="n">l</span><span class="p">);</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">l</span><span class="o">.</span><span class="n">l</span><span class="w"> </span><span class="p">}</span>
<span class="nf">nil</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">wt</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="n">wt</span><span class="w"> </span><span class="p">{}</span>
<span class="nf">nil</span><span class="w"> </span><span class="n">wt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="n">wt</span><span class="w"> </span><span class="kt">Nil</span>
<span class="nf">setWriteType</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">wt&#39;</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">RList</span><span class="w"> </span><span class="n">wt</span><span class="w"> </span><span class="n">rt</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">rt</span><span class="w"> </span><span class="n">subseteq</span><span class="w"> </span><span class="n">wt&#39;</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="n">wt&#39;</span><span class="w"> </span><span class="n">rt</span>
<span class="nf">setWriteType</span><span class="w"> </span><span class="n">wt&#39;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">write_type</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">wt&#39;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>The constraint <code class="docutils literal notranslate"><span class="pre">contents</span> <span class="pre">l</span> <span class="pre">subseteq</span> <span class="pre">rt</span></code> follows naturally from the list parameter discussion above. The constraint <code class="docutils literal notranslate"><span class="pre">write_type</span> <span class="pre">subseteq</span> <span class="pre">rt</span></code> in the constructor follows Dolan and can be derived from requiring that all lists are constructible from  <code class="docutils literal notranslate"><span class="pre">cons</span></code> and <code class="docutils literal notranslate"><span class="pre">nil</span></code>. This constraint can be dropped if <code class="docutils literal notranslate"><span class="pre">RList</span></code> is taken as the primitive constructor, allowing mismatches between write type and contents.</p>
<p>The constraint <code class="docutils literal notranslate"><span class="pre">wt</span> <span class="pre">subseteq</span> <span class="pre">write_type</span></code> allows subtyping like <code class="docutils literal notranslate"><span class="pre">RList</span> <span class="pre">(Int|String)</span> <span class="pre">[1]</span> <span class="pre">:</span> <span class="pre">RList</span> <span class="pre">Int</span> <span class="pre">Int</span></code>; the alternative would be <code class="docutils literal notranslate"><span class="pre">wt</span> <span class="pre">==</span> <span class="pre">write_type</span></code> which would make it an invariant parameter and then you would have to use type coercions. As far as subtyping, <code class="docutils literal notranslate"><span class="pre">RList</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">subseteq</span> <span class="pre">RList</span> <span class="pre">c</span> <span class="pre">d</span></code> iff <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">subseteq</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">subseteq</span> <span class="pre">d</span></code>. The type of all restricted lists is <code class="docutils literal notranslate"><span class="pre">RList</span> <span class="pre">{}</span> <span class="pre">Any</span></code>.</p>
<p>The write operation can be extended by calling <code class="docutils literal notranslate"><span class="pre">x'</span> <span class="pre">=</span> <span class="pre">convert</span> <span class="pre">write_type</span> <span class="pre">x</span></code> instead of just asserting membership, but the combination of loose and restricted typing seems unlikely to be desired.</p>
<p>Because the write type is part of the value, empty lists of different write types are distinct, e.g. the empty list <code class="docutils literal notranslate"><span class="pre">RList</span> <span class="pre">Int</span> <span class="pre">[]</span></code> is not equal to the empty list <code class="docutils literal notranslate"><span class="pre">RList</span> <span class="pre">String</span> <span class="pre">[]</span></code>. Cliff suggested an alternate design where the empty list is special-cased as a symbol that is an element of all list types and the write bound is specified on the cons operation, like <code class="docutils literal notranslate"><span class="pre">cons</span> <span class="pre">Int</span> <span class="pre">x</span> <span class="pre">l</span></code>. But this requires duplicating the type each time and has some bugs if the types mismatch; it seems more convenient to be have empty restricted lists know their type.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">setWriteType</span></code> function is a bit weird. In fact we can always set the write bound to <code class="docutils literal notranslate"><span class="pre">Any</span></code> and have the program still work. The benefit of the restricted list is in invalidating programs. To get maximum invalidation we have to use a pattern like <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">(l</span> <span class="pre">:</span> <span class="pre">RList</span> <span class="pre">Int</span> <span class="pre">Int)</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">l</span> <span class="pre">=</span> <span class="pre">setWriteType</span> <span class="pre">Int</span> <span class="pre">l;</span> <span class="pre">...</span> <span class="pre">}</span></code> or a view pattern <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">(coerceRList</span> <span class="pre">Int</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">l)</span> <span class="pre">=</span> <span class="pre">...</span></code>, so that the value-level write type is always as small as possible and matches the expected type-level write type.</p>
<p>Per Dolan we have 5 type synonyms that cover some common cases (unfortunately <code class="docutils literal notranslate"><span class="pre">RList</span></code> is still necessary for complex read-and-add situations):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">RListI</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">mutable</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="kr">type</span>
<span class="kt">RListP_R</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="kt">Any</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">(</span><span class="n">unrestricted</span><span class="w"> </span><span class="n">writes</span><span class="p">)</span>
<span class="kt">RListP_L</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">unwriteable</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="n">t</span>
<span class="kt">RListN_R</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="kt">Any</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">any</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">write</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="n">t</span>
<span class="kt">RListN_L</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">empty</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">write</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="n">t</span>
</pre></div>
</div>
<p>How to use <code class="docutils literal notranslate"><span class="pre">RList</span></code>? Some playing around:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">IorS</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="o">|</span><span class="kt">String</span>
<span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mkRList</span><span class="w"> </span><span class="kt">IorS</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">assert</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="kt">IorS</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span>
<span class="nf">assert</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="kt">IorS</span><span class="w"> </span><span class="kt">IorS</span><span class="p">)</span>
<span class="nf">assert</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="kt">Any</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="n">containing</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="kt">RLists</span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">a</span>
<span class="nf">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="s">&quot;bar&quot;</span><span class="p">]</span>
<span class="nf">assertNot</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="kt">IorS</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span>
<span class="nf">assert</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="kt">IorS</span><span class="w"> </span><span class="kt">IorS</span><span class="p">)</span>
<span class="nf">err</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="kt">[]</span><span class="p">]</span>
<span class="nf">assert</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">RListWriteException</span><span class="p">)</span>
<span class="nf">d</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">setWriteType</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="o">|</span><span class="kt">String</span><span class="o">|</span><span class="kt">List</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="kt">[]</span><span class="p">]</span>
<span class="nf">assertNot</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">RListWriteException</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="transactional-memory">
<h2>Transactional memory<a class="headerlink" href="#transactional-memory" title="Permalink to this heading"></a></h2>
<p>STM is a good abstraction for beginners or those who can sacrifice some performance to ensure correctness. Per studies it provides the ease of use of coarse locks with most of the performance of fine-grained locks. But livelock errors are hard to debug and when a program using STM is slow it is somewhat complex to profile and optimize. So STM hasn’t seen broad success. Stroscot’s base concurrency primitives still have to be OS mutexes and atomic instructions.</p>
<p>Still, providing STM as a library would be good. Haskell has STM, Fortress worked on STM, there’s an Intel C++ STM library. The programming pattern of “read struct pointer, read members, allocate new structure, compare-and-swap struct pointer” is really common for high-performance concurrency and encapsulating this pattern in an STM library would be great.</p>
<p>STM syntax is a simple DSL, <code class="docutils literal notranslate"><span class="pre">atomically</span> <span class="pre">{</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">{</span> <span class="pre">retry</span> <span class="pre">};</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">z</span> <span class="pre">}</span></code>. Transactions nested inside another transaction are combined, so that one big transaction forms. The semantics is that a transaction has a visible effect (commits its writes) only if all state read during the transaction is not modified by another thread. The <code class="docutils literal notranslate"><span class="pre">retry</span></code> command blocks the transaction until the read state has changed, then starts it over, in an endless loop until a path avoiding the <code class="docutils literal notranslate"><span class="pre">retry</span></code> is taken. The implementation should guarantee eventual fairness: A transaction will be committed eventually, provided it doesn’t retry all the time. The latest research STM implementation seems to be <span id="id3">[<a class="reference internal" href="../zzreferences.html#id135" title="Pedro Ramalhete, Andreia Correia, and Pascal Felber. Efficient algorithms for persistent transactional memory. In Proceedings of the 26th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, PPoPP '21, 1–15. New York, NY, USA, February 2021. Association for Computing Machinery. URL: https://doi.org/10.1145/3437801.3441586 (visited on 2021-11-11), doi:10.1145/3437801.3441586.">RCF21</a>]</span>, it might be usable. It doesn’t handle retries though. The most naive implementation just puts transactions on a FIFO queue, takes a global lock when entering a transaction, and adds retries to the back.</p>
<p>Transactions have sequentially consistent semantics by default, but mixing transactions with low-level relaxed-semantics code might work, IDK. There could be <code class="docutils literal notranslate"><span class="pre">atomically</span> <span class="pre">{order=relaxed}</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> to use the CPU’s memory model instead of totally ordered. The transaction syntax is more expressive than atomic instructions, so providing an atomic DSL for machine code instructions would be nice. I.e. transactions matching atomic machine code instructions should compile to the atomic machine code instructions and nothing else. If there are waiting threads with <code class="docutils literal notranslate"><span class="pre">retry</span></code> involved, then we do need extra junk like thread wakeups etc., but it would be nice to avoid this in simple cases.</p>
<section id="wait-free">
<h3>Wait-free<a class="headerlink" href="#wait-free" title="Permalink to this heading"></a></h3>
<p><span id="id4">[<a class="reference internal" href="../zzreferences.html#id135" title="Pedro Ramalhete, Andreia Correia, and Pascal Felber. Efficient algorithms for persistent transactional memory. In Proceedings of the 26th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, PPoPP '21, 1–15. New York, NY, USA, February 2021. Association for Computing Machinery. URL: https://doi.org/10.1145/3437801.3441586 (visited on 2021-11-11), doi:10.1145/3437801.3441586.">RCF21</a>]</span> claims to be wait-free. But Cliff says it’s impossible to get wait-free. CAS is lock-free, about a dozen clocks on X86 (L2 miss time). But ‘s’ You can NOT have a wait-free under any circumstance, except single-thread simulation of a multi-core device.  i.e., under current hardware a wait-free is always slower than a single core.
Still playing catchup.  Parents made it home after a 36hr delay.  😛
Sure, OS schedules threads.  As an example, some linux kernel kept 8 runnables on a core-local runnable queue for fast rotation and time-slicing.  On my 10 real-core, 20 hyper-thread machine, that would be 8x20 or 160 runnables on local queues.  I launch 1000 runnables.  One of them attempts a wait-free program shutdown by writing a single boolean “true” to a global that the other 999 threads read.  Kernel launches 120 threads on 20 cores and rotates between them.  All those 999 threads are computing e.g. Mandelbrots in a loop (might as well be bit-miners).  Kernel rotates amongst the 160, which get equal billing at 1/8 a hyper-core.  Kernel will rotate in a different thread when one of the currently running stops - which is never.  So kernel never gives a single clock cycle to the other ~820 threads.  So the stop bit thread never runs, and the program never halts.  Seen in practice during our Azul days, on non-Azul hardware.</p>
</section>
</section>
<section id="iterators">
<h2>Iterators<a class="headerlink" href="#iterators" title="Permalink to this heading"></a></h2>
<p>Haskell has <code class="docutils literal notranslate"><span class="pre">Foldable</span></code>, the main function being <code class="docutils literal notranslate"><span class="pre">foldr</span> <span class="pre">:</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">t</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>, which is equivalently <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>, the latter part being the <a class="reference external" href="https://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html">Boehm-Berarducci encoding</a> of <code class="docutils literal notranslate"><span class="pre">[a]</span></code>. So really <code class="docutils literal notranslate"><span class="pre">Foldable</span> <span class="pre">t</span></code> is just a function <code class="docutils literal notranslate"><span class="pre">toList</span> <span class="pre">:</span> <span class="pre">t</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span></code>. <code class="docutils literal notranslate"><span class="pre">foldMap</span></code> has a more general type that would allow a parallel fold, but in Haskell it’s is required to be right-associative. So Haskell <code class="docutils literal notranslate"><span class="pre">Foldable</span></code> is strictly a linked list with <code class="docutils literal notranslate"><span class="pre">foldr</span></code> applied. We might as well call the class <code class="docutils literal notranslate"><span class="pre">ListLike</span></code>.</p>
<p><a class="reference external" href="https://homes.luddy.indiana.edu/samth/fortress-spec.pdf#page=128">Fortress</a> has real parallel folds similar to <code class="docutils literal notranslate"><span class="pre">foldMap</span></code>. They have “reductions” which are just monoids, and then a “generator” is <code class="docutils literal notranslate"><span class="pre">generate</span> <span class="pre">:</span> <span class="pre">(Monoid</span> <span class="pre">r)</span> <span class="pre">=&gt;</span> <span class="pre">Generator</span> <span class="pre">e</span> <span class="pre">-&gt;</span> <span class="pre">(e</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>. The monoid does not have to be commutative - results are combined in the natural order of the generator. Empty elements may be inserted freely by <code class="docutils literal notranslate"><span class="pre">generate</span></code>. The implementation is based on recursive subdivision to divide a blocked range into approximately equal-sized chunks of work.</p>
<p>They also have generator comprehensions and big operator syntax, but the description is confusing.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">impure_list</span><span class="w"> </span><span class="p">(</span><span class="kt">Item</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Set</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nil</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kr">data</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Item</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Op</span><span class="w"> </span><span class="p">(</span><span class="n">impure_list</span><span class="w"> </span><span class="kt">Item</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="nf">getIterator</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Op</span><span class="w"> </span><span class="p">(</span><span class="n">impure_list</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="nf">getIterator</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="n">go</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">(</span><span class="n">go</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span>
<span class="w">           </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Nil</span>
</pre></div>
</div>
<p>The problem with this design is you can accidentally store the <code class="docutils literal notranslate"><span class="pre">next</span></code> operation and re-use it. With <code class="docutils literal notranslate"><span class="pre">next</span> <span class="pre">:</span> <span class="pre">Iterator</span> <span class="pre">-&gt;</span> <span class="pre">Op</span> <span class="pre">(Done</span> <span class="pre">|</span> <span class="pre">Yield</span> <span class="pre">a)</span></code> the similar pattern <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">next</span> <span class="pre">iter</span> <span class="pre">in</span> <span class="pre">{</span> <span class="pre">y;</span> <span class="pre">y}</span></code> just results in calling <code class="docutils literal notranslate"><span class="pre">next</span></code> twice and does not corrupt the iterator state.</p>
</section>
<section id="control-structures">
<h2>Control structures<a class="headerlink" href="#control-structures" title="Permalink to this heading"></a></h2>
<blockquote>
<div><p><a class="reference external" href="https://www.ccs.neu.edu/home/shivers/papers/loop.pdf">https://www.ccs.neu.edu/home/shivers/papers/loop.pdf</a> / <a class="reference external" href="https://www.youtube.com/watch?v=PCzNwWmQdb0">https://www.youtube.com/watch?v=PCzNwWmQdb0</a></p>
<p>see also Reference/Syntax, a lot of potential control structures</p>
</div></blockquote>
</section>
<section id="goto-break-continue">
<h2>Goto/Break/continue<a class="headerlink" href="#goto-break-continue" title="Permalink to this heading"></a></h2>
<p><a class="reference external" href="https://github.com/core-lang/core/issues/44">Core</a> proposes to drop break and continue due to implementation complexity and mental complexity. He argues that it is clearer to use an extra boolean variable and only slightly clunkier. Per the <a class="reference external" href="https://en.wikipedia.org/wiki/Structured_program_theorem#Implications_and_refinements">structured program theorem</a> it is possible to compute any computable function with three control structures, semicolon, if, and while (and no break/continue). There are drawbacks in that the theorem usually must introduce additional local variables and duplicate code. For example consider <a class="reference external" href="https://ecommons.cornell.edu/bitstream/handle/1813/34898/bbang.pdf?sequence=2">this program</a>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">start</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">state0</span>
<span class="nf">state0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">halt</span>
<span class="w">       </span><span class="o">|</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">p01</span><span class="p">;</span><span class="w"> </span><span class="n">state1</span>
<span class="w">       </span><span class="o">|</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">p02</span><span class="p">;</span><span class="w"> </span><span class="n">state2</span>
<span class="nf">state1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">halt</span>
<span class="w">       </span><span class="o">|</span><span class="w"> </span><span class="n">a0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">p10</span><span class="p">;</span><span class="w"> </span><span class="n">state0</span>
<span class="w">       </span><span class="o">|</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">p12</span><span class="p">;</span><span class="w"> </span><span class="n">state2</span>
<span class="nf">state2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">halt</span>
<span class="w">       </span><span class="o">|</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">p21</span><span class="p">;</span><span class="w"> </span><span class="n">state1</span>
<span class="w">       </span><span class="o">|</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">p20</span><span class="p">;</span>
</pre></div>
</div>
<p>A translation into structured programming loosely based on the paper:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">state</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mut</span><span class="w"> </span><span class="mi">0</span>
<span class="nf">halt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mut</span><span class="w"> </span><span class="n">false</span>
<span class="nf">while</span><span class="w"> </span><span class="o">!</span><span class="n">halt</span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">then</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="n">α1</span><span class="w"> </span><span class="kr">then</span>
<span class="w">       </span><span class="n">p01</span><span class="p">;</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">α2</span><span class="w"> </span><span class="kr">then</span>
<span class="w">       </span><span class="n">p02</span><span class="p">;</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="kr">else</span><span class="w"> </span><span class="n">halt</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">true</span>
<span class="w">  </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kr">then</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="n">α2</span><span class="w"> </span><span class="kr">then</span>
<span class="w">      </span><span class="n">p12</span><span class="p">;</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">α0</span><span class="w"> </span><span class="kr">then</span>
<span class="w">      </span><span class="n">p10</span><span class="p">;</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="kr">else</span><span class="w"> </span><span class="n">halt</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">true</span>
<span class="w">  </span><span class="kr">else</span>
<span class="w">    </span><span class="n">assert</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="n">must</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="n">α0</span><span class="w"> </span><span class="kr">then</span>
<span class="w">       </span><span class="n">p20</span><span class="p">;</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">α1</span><span class="w"> </span><span class="kr">then</span>
<span class="w">       </span><span class="n">p21</span><span class="p">;</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="kr">else</span><span class="w"> </span><span class="n">halt</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">true</span>
</pre></div>
</div>
<p>Notice this is longer than the original description using recursion, mainly due to the extra variables. S. Rao Kosaraju proved that with arbitrary-depth, multi-level breaks from loops it’s possible to avoid adding additional variables in structured programming, but known algorithms still duplicate code. In common cases the duplication can be avoided by clever structuring though.</p>
<p>Per <a class="reference external" href="https://hal.inria.fr/inria-00072269/document">https://hal.inria.fr/inria-00072269/document</a> Table 5, the most common flow-affecting constructs in Java were (as a percentage of methods) return (65.5%), short-circuit operators (13.2%), single-level break (3.6%), single-level continue (0.3%), and labelled break/continue (0.13%). A <a class="reference external" href="https://sci-hub.se/10.1002/spe.2298">different comparison</a> (Table IV) finds that continue and goto are about equal in frequency in C, that synchronized and continue are about equal in frequency in Java, and break is about half as common as try/catch/throw in Java.</p>
<p>In Stroscot, it’s not too hard to provide break/continue/goto within the continuation-based I/O model, and many C programmers will expect these operators, so they are planned to be implemented. They will be provided as functions, rather than as keywords, so will be imported and not steal syntax by default.</p>
</section>
<section id="work-stealing-task-queues">
<h2>Work stealing task queues<a class="headerlink" href="#work-stealing-task-queues" title="Permalink to this heading"></a></h2>
<p>Java has them, C++ has OpenMPI and libuv. Many other languages have a library for them as well. So Stroscot should too.</p>
<p><a class="reference external" href="https://wingolog.org/archives/2022/10/03/on-correct-and-efficient-work-stealing-for-weak-memory-models">https://wingolog.org/archives/2022/10/03/on-correct-and-efficient-work-stealing-for-weak-memory-models</a>
Chase-Lev work-stealing double-ended queue updated by “Correct and Efficient Work-Stealing for Weak Memory Models”</p>
<p>per comment in <a class="reference external" href="https://news.ycombinator.com/item?id=33065142">https://news.ycombinator.com/item?id=33065142</a> there is a patent</p>
</section>
<section id="properties">
<h2>Properties<a class="headerlink" href="#properties" title="Permalink to this heading"></a></h2>
<p>Partial orders are good, no reason not to have them. The orders defined with posets should be usable dynamically. Similarly they should be in a set <code class="docutils literal notranslate"><span class="pre">TotalOrder</span></code> if appropriate. Similarly <code class="docutils literal notranslate"><span class="pre">Commutative</span></code>, <code class="docutils literal notranslate"><span class="pre">Associative</span></code> for binary operators.</p>
</section>
<section id="arrays">
<h2>Arrays<a class="headerlink" href="#arrays" title="Permalink to this heading"></a></h2>
<p>In Stroscot the only mutable thing is a reference. So mutable arrays could mean two things: a fixed-size immutable array containing mutable values, or a mutable variable storing an immutable array. The second seems more similar to Java’s ArrayList or C++ std::vector so is probably what is meant.</p>
<p>The key here for efficient performance is in-place (destructive) update, so that the array re-uses its storage instead of copying on every operation. There is a paper <span id="id5">[<a class="reference internal" href="../zzreferences.html#id77" title="Paul Hudak and Adrienne Bloss. The aggregate update problem in functional programming systems. In Proceedings of the 12th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages - POPL '85, 300–314. New Orleans, Louisiana, United States, 1985. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=318593.318660 (visited on 2022-01-04), doi:10.1145/318593.318660.">HB85</a>]</span> on how to do it for lazy programming - basically you perform reads eagerly, and delay array update operations as long as possible, until it is clear if you can do in-place update or will have to copy.</p>
<p><a class="reference external" href="https://aplwiki.com/wiki/Leading_axis_theory">https://aplwiki.com/wiki/Leading_axis_theory</a></p>
</section>
<section id="conversion">
<h2>Conversion<a class="headerlink" href="#conversion" title="Permalink to this heading"></a></h2>
<p>There is a function <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">:</span> <span class="pre">(T</span> <span class="pre">:</span> <span class="pre">Set)</span> <span class="pre">-&gt;</span> <span class="pre">Any</span> <span class="pre">-&gt;</span> <span class="pre">T|Exception</span></code> in a module in the core library. Conversion is intended to produce equivalent values, so these modified equivalence relation properties should hold:</p>
<ul class="simple">
<li><p>Reflexive: <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">T</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span></code>, if <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">T</span></code></p></li>
<li><p>Symmetric: <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">T</span> <span class="pre">(convert</span> <span class="pre">T2</span> <span class="pre">a)</span> <span class="pre">=</span> <span class="pre">a</span></code>, if <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">T</span></code> (assuming <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">T2</span> <span class="pre">a</span></code> succeeds)</p></li>
<li><p>Transitive: <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">T3</span> <span class="pre">(convert</span> <span class="pre">T2</span> <span class="pre">a)</span> <span class="pre">=</span> <span class="pre">convert</span> <span class="pre">T3</span> <span class="pre">a</span></code> (assuming all conversions succeed)</p></li>
</ul>
<p>These rules avoid conversion “gotchas” where information is lost during conversion. For example all convertible numbers must be exactly representable in the target type because of transitivity and the existence of arbitrary-precision types (<code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">Exact</span> <span class="pre">(convert</span> <span class="pre">Approx</span> <span class="pre">a)</span> <span class="pre">==</span> <span class="pre">convert</span> <span class="pre">Exact</span> <span class="pre">a</span></code>).</p>
<p>Conversion is only a partial function, hence these properties may not hold due to some of the conversions resulting in errors. For example <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">Float32</span> <span class="pre">(2^24+1</span> <span class="pre">:</span> <span class="pre">Int32)</span></code> fails because only <code class="docutils literal notranslate"><span class="pre">2^24</span></code> and <code class="docutils literal notranslate"><span class="pre">2^24+2</span></code> are exactly representable as floats. Generally one direction of the conversion should be total, or there should be subtypes like <code class="docutils literal notranslate"><span class="pre">Float32_Int</span> <span class="pre">subset</span> <span class="pre">Float</span> <span class="pre">32</span></code> for which conversion to both <code class="docutils literal notranslate"><span class="pre">Float32</span></code> and <code class="docutils literal notranslate"><span class="pre">Int32</span></code> is total.</p>
<p>Conversion for unions is often undefined, because if <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">T2</span> <span class="pre">(a</span> <span class="pre">:</span> <span class="pre">T)</span> <span class="pre">=</span> <span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code>, then by reflexivity we have <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">(T|T2)</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span></code>.  and by assumption and reflexivity we have <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">(T|T2)</span> <span class="pre">(convert</span> <span class="pre">T2</span> <span class="pre">a)</span> <span class="pre">=</span> <span class="pre">convert</span> <span class="pre">(T|T2)</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">b</span></code>, violating transitivity. Hence <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">(T|T2)</span></code> on at least one of <code class="docutils literal notranslate"><span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span></code> must be undefined.</p>
<p>Also, it is generally too much work (quadratic) to define all conversions explicitly. Conversion thus relies on an A* search through the conversion graph for the minimum cost conversion. The conversion graph is specified via some functions:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">guess_starting_type</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Any</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Set</span><span class="p">]</span>
<span class="nf">neighbors</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[(</span><span class="kt">Set</span><span class="p">,</span><span class="kt">Cost</span><span class="p">)]</span>
<span class="nf">est_distance</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Cost</span>
</pre></div>
</div>
<p>The cost can be an estimate of the CPU cycles needed to compute it, or the amount of precision lost during conversion, or both (combined with a lexicographic order). With precise numbers the lowest-cost conversion will be unambiguous, and probably fairly stable even if conversions are added or removed.</p>
<p>The conversion syntax overlaps somewhat with a constructor function, e.g. it is often the case that <code class="docutils literal notranslate"><span class="pre">int32</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">convert</span> <span class="pre">Int32</span> <span class="pre">x</span></code>. But constructors have fewer rules. Because convert is an equivalence relation it can be applied semi-automatically, whereas constructors may lose information, be stateful, or lazily evaluate their argument.</p>
<p>Values could be made equivalent to their string representation. This would mainly be useful for converting values to strings, as multiple decimal literals parse to the same floating point number so that direction would be a partial function. So an explicit parse function is also needed.</p>
<p>Often we prefer conversions to be total; this is accomplished by overloading <code class="docutils literal notranslate"><span class="pre">convert</span></code> with a default flag argument to get the desired behavior. These flags are outside the scope of the equivalence relation. For example <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">Byte</span> <span class="pre">1099</span> <span class="pre">{</span> <span class="pre">narrowing</span> <span class="pre">=</span> <span class="pre">true</span> <span class="pre">}</span> <span class="pre">=</span> <span class="pre">75</span></code> whereas without the narrowing flag it would error, as it is not exactly representable. This allows re-using the promotion mechanism so is preferred to defining a new function like <code class="docutils literal notranslate"><span class="pre">lossyConvert</span></code>. Some conversions such as <a class="reference external" href="https://stackoverflow.com/questions/13269523/can-all-32-bit-ints-be-exactly-represented-as-a-double">int32 to float64</a> do not need flags as they are already total.</p>
<p>Conversion is misleading when it privileges one out of multiple sensible mappings. For example, a date July 30, 1989 might convert to an int with a decimal representation of the year, month, and day 19800730, or a Unix epoch date 617760000 / 86400 = 7150. Both these conversions might be useful; e.g. they both have the desirable property that later dates correspond to larger integers. In such cases, it is better not to define the convert operator, and instead provide multiple named conversion functions <code class="docutils literal notranslate"><span class="pre">toDateDecimal</span></code>, <code class="docutils literal notranslate"><span class="pre">toUnixTime</span></code> to implement the various mappings.</p>
<p>C++ has implicit conversion. This allows adding an appropriate function to the source or destination type, which is called when there is a type mismatch. The <a class="reference external" href="https://google.github.io/styleguide/cppguide.html">Google C++ Guide</a> recommends never using this feature and always making conversions explicit with a cast like <code class="docutils literal notranslate"><span class="pre">(X)</span> <span class="pre">y</span></code>. But apparently there are waivers to this rule when the objects are in fact interchangable representations of the same value.</p>
</section>
<section id="promotion">
<h2>Promotion<a class="headerlink" href="#promotion" title="Permalink to this heading"></a></h2>
<p>Promotion is a catch-all dispatch rule for arithmetic operators on mixed types, based on <a class="reference external" href="https://docs.julialang.org/en/v1/manual/conversion-and-promotion/">Julia’s</a>. It works as follows:</p>
<ol class="arabic simple">
<li><p>Compute a common type using <code class="docutils literal notranslate"><span class="pre">promote_rule</span></code></p></li>
<li><p>Promote all operands to common type using <code class="docutils literal notranslate"><span class="pre">convert</span></code></p></li>
<li><p>Invoke the same-type implementation of the operator, if it exists</p></li>
</ol>
<p>For example if <code class="docutils literal notranslate"><span class="pre">promote_rule</span> <span class="pre">(a</span> <span class="pre">:</span> <span class="pre">Int32)</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">Float32)</span> <span class="pre">=</span> <span class="pre">out</span> <span class="pre">{</span> <span class="pre">lossy</span> <span class="pre">=</span> <span class="pre">true};</span> <span class="pre">Float32</span></code> then <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">:</span> <span class="pre">Int32)</span> <span class="pre">+</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">Float32)</span> <span class="pre">=</span> <span class="pre">(convert</span> <span class="pre">Float32</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">convert</span> <span class="pre">Float32</span> <span class="pre">b)</span> <span class="pre">{</span> <span class="pre">lossy</span> <span class="pre">=</span> <span class="pre">true</span> <span class="pre">}</span></code>. The system is extensible by defining new conversions and new promotion rules.</p>
<p>Julia’s promotion rules:
* Floating-point values are promoted to the largest of the floating-point argument types.
* Integer values are promoted to the larger of either the native machine word size or the largest integer argument type.
* Mixtures of integers and floating-point values are promoted to a floating-point type big enough to hold all the values.
* Integers mixed with rationals are promoted to rationals.
* Rationals mixed with floats are promoted to floats.
* Complex values mixed with real values are promoted to the appropriate kind of complex value.</p>
<p>Promotion is effectively implicit type conversion but scoped to certain functions. Standard ML, OCaml, Elm, F#, Haskell, and Rust don’t have any implicit type conversions and work fine. Scala has full implicit conversions, a search invoked when types mismatch. The search is brute force, hence expensive to compile, and promotion seems sufficient. Also the semantics of promotion are simple (expanded function domain) vs implicit conversion which requires some kind of nondeterminism.</p>
<p>JavaScript is notorious for its pervasive and byzantine coercion rules. They are as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p>0, -0, null, false, NaN, undefined, and the empty string (“”) coerce to false.</p></li>
<li><p>Objects, including empty objects {}, empty array [], all nonempty strings (including “false”), all numbers except zero and NaN coerce to true.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>binary <code class="docutils literal notranslate"><span class="pre">+</span></code> can combine two numbers or a string and a defined value (not null or undefined).</p></li>
<li><p>unary <code class="docutils literal notranslate"><span class="pre">+,</span> <span class="pre">-</span></code> and binary <code class="docutils literal notranslate"><span class="pre">-,</span> <span class="pre">*,</span> <span class="pre">/,</span> <span class="pre">%,</span> <span class="pre">&lt;&lt;,</span> <span class="pre">&gt;&gt;,</span> <span class="pre">&gt;&gt;&gt;</span></code> only work on numbers</p></li>
<li><p>relational operators <code class="docutils literal notranslate"><span class="pre">&lt;,</span> <span class="pre">&gt;,</span> <span class="pre">&lt;=,</span> <span class="pre">&gt;=</span></code> works on two numbers or two strings</p></li>
<li><p>bitwise operators <code class="docutils literal notranslate"><span class="pre">~,</span> <span class="pre">&amp;,</span> <span class="pre">|</span></code> work only on numbers. For example <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&amp;</span> <span class="pre">8192</span> <span class="pre">!=</span> <span class="pre">8192</span></code> parses as <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&amp;</span> <span class="pre">(8192</span> <span class="pre">!=</span> <span class="pre">8192)</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">&amp;</span> <span class="pre">false</span></code>, not as intended. Forbidding using a boolean in place of a number makes it an error.</p></li>
<li><p>equality is of type <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">a.</span> <span class="pre">(a|undefined|null)</span> <span class="pre">-&gt;</span> <span class="pre">(a|undefined|null)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></code> and does no coercions, as e.g. having <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">==</span> <span class="pre">&quot;5&quot;</span></code> by converting the number to a string is counterintuitive.</p></li>
</ul>
<p>The counter idiom <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">(x</span> <span class="pre">|</span> <span class="pre">0)</span> <span class="pre">+</span> <span class="pre">1</span></code> seems to be hardly used, probably not worth supporting.</p>
</section>
<section id="equality-and-comparison">
<h2>Equality and comparison<a class="headerlink" href="#equality-and-comparison" title="Permalink to this heading"></a></h2>
<p>The comparison function itself is discussed in Posets. Basically it is a single function <code class="docutils literal notranslate"><span class="pre">comp</span> <span class="pre">:</span> <span class="pre">Any</span> <span class="pre">-&gt;</span> <span class="pre">Any</span> <span class="pre">-&gt;</span> <span class="pre">{LessThan,Equal,GreaterThan,Incomparable}</span></code> satisfying the requirements of a “partial comparison operation”.</p>
<p>Loose comparison will perform a type conversion when comparing two things. In particular in JS it will convert objects to strings, booleans and strings to numbers, and numbers to bigints, and transitive chains of these. Loose comparison is considered a confusing mistake; equality should not do type conversion. Almost all JS programs do not use this feature, either via <code class="docutils literal notranslate"><span class="pre">===</span></code> or by avoiding cases that invoke conversion. <span id="id6">[<a class="reference internal" href="../zzreferences.html#id129" title="Michael Pradel and Koushik Sen. The Good, the Bad, and the Ugly: An Empirical Study of Implicit Type Conversions in JavaScript. In John Tang Boyland, editor, 29th European Conference on Object-Oriented Programming (ECOOP 2015), volume 37 of Leibniz International Proceedings in Informatics (LIPIcs), 519–541. Dagstuhl, Germany, 2015. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik. \subsection Other Most popular programming languages support situations where a value of one type is converted into a value of another type without any explicit cast. Such implicit type conversions, or type coercions, are a highly controversial language feature. Proponents argue that type coercions enable writing concise code. Opponents argue that type coercions are error-prone and that they reduce the understandability of programs. This paper studies the use of type coercions in JavaScript, a language notorious for its widespread use of coercions. We dynamically analyze hundreds of programs, including real-world web applications and popular benchmark programs. We find that coercions are widely used (in 80.42% of all function executions) and that most coercions are likely to be harmless (98.85%). Furthermore, we identify a set of rarely occurring and potentially harmful coercions that safer subsets of JavaScript or future language designs may want to disallow. Our results suggest that type coercions are significantly less evil than commonly assumed and that analyses targeted at real-world JavaScript programs must consider coercions. URL: http://drops.dagstuhl.de/opus/volltexte/2015/5236 (visited on 2022-07-25), doi:10.4230/LIPIcs.ECOOP.2015.519.">PS15</a>]</span></p>
<p><a class="reference external" href="https://github.com/lampepfl/dotty/issues/1247">Scala</a> categorizes equality as universal and multiversal. A <a class="reference external" href="https://github.com/lampepfl/dotty/blob/language-reference-stable/docs/_docs/reference/contextual/multiversal-equality.md">multiversal equality</a> is allowed to error if no suitable comparison for the two values is defined; this is a fine-grained way of saying that the values are incomparable. Due to symmetry and transitivity, the scheme partitions the universe of values into a “multiverse” of sets, where values within a set can be compared but comparison of values from different sets errors. In contrast a “universal” comparison assigns some arbitrary order to unrelated types; it creates a total order and never says two values are incomparable.</p>
<p>As far as defaults, it seems from googling “TypeError: ‘&lt;’ not supported between instances of ‘str’ and ‘int’” that forgetting to parse a string to an int is a common error in Python - multiversal comparison makes this error obvious. Also many types such as compiled lambdas do not have a portable intrinsic ordering, and there is no canonical ordering across different types. So making the default equality and comparison operators multiversal should catch many errors. This doesn’t seem like it will be too controversial: <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> and <code class="docutils literal notranslate"><span class="pre">==</span></code> are multiversal in Java, C++, Haskell, and Rust, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> is multiversal in Python and Ruby, and Java’s <code class="docutils literal notranslate"><span class="pre">.compareTo()</span></code> is multiversal as well. The only default universal comparison operators are Python <code class="docutils literal notranslate"><span class="pre">==</span></code> and maybe Java <code class="docutils literal notranslate"><span class="pre">.equals()</span></code>. It seems Python’s universal equality has bitten at least <a class="reference external" href="https://lists.archive.carbon60.com/python/dev/919516">one guy</a>. Quoting in case the link breaks, “It bit me when I tried to compare a byte string element with a single character byte string (of course they should have matched, but since the element was an int, the match was not longer True)”. Universal equality is easier to implement than universal comparison because you just have to return not equal, but conceptually this “not equal” actually means “greater than or less than” using the universal comparison operator, so it is the same sort of footgun. Universal comparison is just too powerful to make it the syntactic default - a little ugliness in abstract code is a small price to pay for catching indavertent errors.</p>
<p>Now even though universal comparison cannot be the default, it is still quite useful. In particular, a universal comparison operation based on the language’s built-in notion of “contextual equivalence” is really useful, i.e. two values are considered equal if their behavior in all contexts is <em>functionally identical</em>. This is the finest-grained notion of equality available and can be used for non-linear pattern matching and writing type assertions and unit tests. For example we can extend multiversal equality <code class="docutils literal notranslate"><span class="pre">==</span></code> to <code class="docutils literal notranslate"><span class="pre">(a|None)</span></code> by delegating, <code class="docutils literal notranslate"><span class="pre">None</span> <span class="pre">==</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">universal_equal</span> <span class="pre">None</span> <span class="pre">a</span></code> and its symmetric variant. Because the equality is universal we are guaranteed a boolean false rather than an exception. This built-in universal equality can be extended to universal comparison, which then allows sorting heterogeneous lists/containers, ordering record fields, doing serialization and meta-programming. So this should be available somehow. In Python universal comparison is relegated to a third-party library <a class="reference external" href="https://github.com/wolever/safesort">safesort</a> - that is definitely too obscure. Julia provides universal equality as <code class="docutils literal notranslate"><span class="pre">===</span></code> in the default prelude, which seems too up-front (and also confuses Javascript programmers). For now I think they will live in the default prelude as wordy functions <code class="docutils literal notranslate"><span class="pre">universal_equal</span></code> and <code class="docutils literal notranslate"><span class="pre">universal_compare</span></code>. The wordy expressions seem clear and the long names will discourage their careless use. But this should be verified as maybe Julia’s <code class="docutils literal notranslate"><span class="pre">===</span></code> is better. But what would universal comparison be? <code class="docutils literal notranslate"><span class="pre">&lt;==</span></code>?</p>
<p>What is the result of <code class="docutils literal notranslate"><span class="pre">NaN</span> <span class="pre">==</span> <span class="pre">NaN</span></code>? IEEE 754 2019 says “Language standards should map their notation for the symbols = and ≠ to the Quiet predicates <code class="docutils literal notranslate"><span class="pre">compareQuietEqual</span></code> and <code class="docutils literal notranslate"><span class="pre">compareQuietNotEqual</span></code>”. This recommended behavior was decided circa 1985 so that <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">x</span></code> could be used to detect NaN values, in place of the <code class="docutils literal notranslate"><span class="pre">isnan</span></code> predicate which was not yet widely available in languages (<a class="reference external" href="https://stackoverflow.com/questions/1565164/what-is-the-rationale-for-all-comparisons-returning-false-for-ieee754-nan-values">1</a>). Thus (traditionally) ordered comparison predicates (&lt;, &gt;, ≤, ≥) were signaling, but unordered comparison predicates (= and ≠) were quiet, and this small inconsistency in the behavior of NaN was deemed unlikely to cause a program malfunction. And Fortran’s checks for uncaught signals were very conservative so most programmers wanted as few signals as possible. (<a class="reference external" href="https://grouper.ieee.org/groups/msc/ANSI_IEEE-Std-754-2019/background/predicates.txt">2</a>) But since “should” means “preferred and recommended as particularly suitable but not necessarily required,” deviating from the standard is allowed, although discouraged.</p>
<p>In this case I think mapping <code class="docutils literal notranslate"><span class="pre">==</span></code> to <code class="docutils literal notranslate"><span class="pre">compareSignalingEqual</span></code> has become desirable, for several reasons:</p>
<ul class="simple">
<li><p>Stroscot’s floating point exception handling is quite improved compared to Fortran: it generates language-level exceptions, rather than OS-level signals. This is relevant because the behavior of <code class="docutils literal notranslate"><span class="pre">signalingEqual</span></code> is that we will get an exception on a NaN comparison, compared to <code class="docutils literal notranslate"><span class="pre">quietEqual</span></code> where we get a boolean false (with =) or true (with ≠), . At the interpreter prompt, this exception will most likely escape to the top level and prompt the user to redo their computation so as to not produce the NaN, with a nice traceback. When compiling, it will most likely generate an ignorable warning, similar to very early Fortran compilers. But Stroscot checks ranges of floating point numbers so if a NaN is not possible it will not give the warning, hence this warning will be more useful. And the exception can be handled quite naturally by pattern-matching on the result of the <code class="docutils literal notranslate"><span class="pre">==</span></code>, whereas Fortran requires writing a program-level SIGFPE signal handler with a lot of boilerplate and no information about the exception context.</p></li>
<li><p>Few novices know what NaNs are or think about behavior on NaNs. The <code class="docutils literal notranslate"><span class="pre">compareSignalingEqual</span></code> predicate is “intended for use by programs not written to take into account the possibility of NaN operands”, so it is more novice-friendly. Even for experts the behavior of <code class="docutils literal notranslate"><span class="pre">compareQuietEqual(NaN,NaN)</span> <span class="pre">=</span> <span class="pre">false</span></code> is considered “counter-intuitive” and “very difficult for a programmer to accept”. And since you get an error message it is quite learnable since you just have to read the message and learn about the whole sordid NaN story.</p></li>
<li><p>Bertrand Meyer <a class="reference external" href="https://bertrandmeyer.com/2010/02/06/reflexivity-and-other-pillars-of-civilization/">has an argument</a> that erroring on NaN preserves monotonicity.</p></li>
<li><p>It is not too hard to modify Stroscot to follow the standard: hide <code class="docutils literal notranslate"><span class="pre">(==)</span></code> from the default prelude and import it from IEEE. This can be accomplished at the top level in a per-project fashion so should not be too burdensome.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">compareSignalingEqual</span></code> predicate was only created relatively recently, in the 2008 standard. AFAICT no other programming language has actually tried changing the behavior of <code class="docutils literal notranslate"><span class="pre">==</span></code> yet. Few recent language developers have actually read the IEEE 754 standard carefully enough to notice this issue, and discussions in the context of older languages such as <a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2012-October/016627.html">Python</a> were hampered by compatibility constraints. So the time seems ripe to try it out and see if changing it annoys people, makes them happy, or doesn’t really matter. It is easy to stop throwing an exception but hard to start.</p></li>
</ul>
<p>So (unless there is a flood of complaints) in Stroscot the result of <code class="docutils literal notranslate"><span class="pre">NaN</span> <span class="pre">==</span> <span class="pre">NaN</span></code> is some exceptional value like <code class="docutils literal notranslate"><span class="pre">InvalidOperation</span></code>. Of course though <code class="docutils literal notranslate"><span class="pre">universal_equal</span> <span class="pre">NaN</span> <span class="pre">NaN</span> <span class="pre">=</span> <span class="pre">true</span></code> so there is a reflexive equality available. In fact IEEE provides a guide for <code class="docutils literal notranslate"><span class="pre">universal_compare</span></code> with its totalOrder predicate, namely <code class="docutils literal notranslate"><span class="pre">-0</span> <span class="pre">&lt;</span> <span class="pre">+0</span></code>, <code class="docutils literal notranslate"><span class="pre">-NaN</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">NaN</span></code>, <code class="docutils literal notranslate"><span class="pre">10e1</span> <span class="pre">&lt;</span> <span class="pre">1e2</span></code>, <code class="docutils literal notranslate"><span class="pre">abs</span> <span class="pre">signalingNaN</span> <span class="pre">&lt;</span> <span class="pre">abs</span> <span class="pre">quietNaN</span></code>, but there is a little more to define because (since inspecting the representation is possible by casting to a bytestring) all NaNs and encodings must be distinguished. There should be a note that different encodings of the value will compare unequal. Printing out “f32 0x1234 (un-normalized representation of 1.0)” for these values should make the failures clear.</p>
<p>Deep comparison compares the values of references rather than the reference identities. It’s less common in Stroscot because more things are values, but it can still be useful for mutable structures. It basically is some logic to memoize comparisons of cyclic structures and then a call to a passed-in “value comparison” which should itself call back to the deep comparison for references.</p>
<p>Since functions can nondeterministically return multiple values and comparing them can give multiple results, we might want equality operations anyEqual and allEqual to resolve the nondeterminism.</p>
<p>Generally we want to define equality on records by comparing some subset of the fields, like <code class="docutils literal notranslate"><span class="pre">eqPoint</span> <span class="pre">=</span> <span class="pre">(==)</span> <span class="pre">on</span> <span class="pre">[x,y]</span></code> and <code class="docutils literal notranslate"><span class="pre">eqColorPoint</span> <span class="pre">=</span> <span class="pre">(==)</span> <span class="pre">on</span> <span class="pre">{x,y,color}</span></code>. In fact :cite:`` proposes that all object equality in a language should be declared in terms of equality of a subset of fields. But this would exclude IEEE float equality so Stroscot still allows user-defined equality.</p>
</section>
<section id="value-representation">
<h2>Value representation<a class="headerlink" href="#value-representation" title="Permalink to this heading"></a></h2>
<p>Nanboxing / nunboxing</p>
</section>
<section id="terms">
<h2>Terms<a class="headerlink" href="#terms" title="Permalink to this heading"></a></h2>
<p>The name “term” comes from term rewriting, where a term is recursively constructed from constant symbols, variables, and function symbols. Technically there are also “lambda terms”, but in Stroscot aas in most programming languages we call them “lambda expressions”, and use “expression” to refer to all syntax that evaluates to a value.</p>
</section>
<section id="data-structures">
<h2>Data structures<a class="headerlink" href="#data-structures" title="Permalink to this heading"></a></h2>
<p>Copy Python’s, they’ve been optimized and should be as efficient as anything I’ll write.</p>
</section>
<section id="list-flattening">
<h2>List flattening<a class="headerlink" href="#list-flattening" title="Permalink to this heading"></a></h2>
<p>Lists don’t automatically flatten, e.g. <code class="docutils literal notranslate"><span class="pre">[a,[b,c]]</span> <span class="pre">!=</span> <span class="pre">[a,b,c]</span></code>. Instead you can use a flatten function in the standard library, <code class="docutils literal notranslate"><span class="pre">flatten</span> <span class="pre">[a,[b,c]]</span> <span class="pre">=</span> <span class="pre">[a,b,c]</span></code>. MATLAB’s justification for flattening is that <code class="docutils literal notranslate"><span class="pre">[A</span> <span class="pre">B]</span></code> is the concatenated matrix with <code class="docutils literal notranslate"><span class="pre">A</span></code> left of <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">[A;B]</span></code> the concatenation with <code class="docutils literal notranslate"><span class="pre">A</span></code> above <code class="docutils literal notranslate"><span class="pre">B</span></code>. This seems hard to remember and infix operators <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">horcat</span> <span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">vertcat</span> <span class="pre">B</span></code> are just as clear.</p>
</section>
<section id="list-homomorphisms">
<h2>List homomorphisms<a class="headerlink" href="#list-homomorphisms" title="Permalink to this heading"></a></h2>
<p>List concatenation is an associative binary operation, as such we can represent repeatedly applying an associative operation (a semigroup) as applying an operation to a (nonempty) list.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">combine</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl1</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="n">list</span>
<span class="nf">sum</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">combine</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span>
<span class="nf">product</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">combine</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)</span>

<span class="nf">sum</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">product</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>If the empty list is a possibility we need a monoid, i.e. specifying an identity element for the operation</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">combine</span><span class="w"> </span><span class="n">monoid</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldMap</span><span class="w"> </span><span class="n">monoid</span><span class="o">.</span><span class="n">op</span><span class="w"> </span><span class="n">monoid</span><span class="o">.</span><span class="n">identity</span><span class="w"> </span><span class="n">list</span>
<span class="nf">sum</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">combine</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">),</span><span class="w"> </span><span class="n">identity</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span>
<span class="nf">product</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">combine</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="n">identity</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>This all works because the set of lists/nonempty lists under concatenation is isomorphic to the free monoid / free semigroup.</p>
</section>
<section id="serialization">
<h2>Serialization<a class="headerlink" href="#serialization" title="Permalink to this heading"></a></h2>
<p>Serialization is the ability to convert an object graph into a stream of bytes, and more broadly the reverse as well (deserialization). In Java the OO model was defined first and serialization was added later as a “magic function”. The design has various problems, as described in <a class="reference external" href="https://openjdk.org/projects/amber/design-notes/towards-better-serialization">Project Amber</a>:</p>
<ul class="simple">
<li><p>serialization can access private classes and fields, an implicit public set of accessors</p></li>
<li><p>deserialization bypasses defined constructors and directly creates objects via the runtime, an implicit public constructor</p></li>
<li><p>serialization/deserialization uses magic private methods and fields to guide the process, such as readObject, writeObject, readObjectNoData, readResolve, writeReplace, serialVersionUID, and serialPersistentFields</p></li>
<li><p>The Serializable marker interface doesn’t actually mean that instances are serializable. Objects may throw during serialization, as e.g. Java has no way to express the constraint that a TreeMap is serializable only if the Comparator passed to the constructor is serializable. Also there are objects such as lambdas, which are easily serializable but error due to lacking Serializable, requiring special type casts.</p></li>
<li><p>Serialization uses a fixed encoding format that cannot be modified to JSON/XML/a more efficient/flexible format, or one with version markers. There are no checks that serialization/deserialization is a round trip.</p></li>
</ul>
<p>In Stroscot the privacy is a non-issue because everything is exposed through the internal module. Magic methods are no issue either because they are just normal multimethods. The hard parts are that Stroscot has more types of values: cyclic terms, lambdas. Ideally these would be deconstructible with term rewriting. References are also a sticking point, the store needs special handling, probably just a reference &lt;-&gt; refid map. We would like a friendly, generic way to write a function that can serialize all types of values, so that implementing new serialization formats in 3rd-party libraries is possible.</p>
<p>Amber also says the format should be versioned, because unless you plan for versioning from the beginning, it can be very difficult to version the serialized form with the tools available without sacrificing compatibility. But JSON has no version numbers, and XML only barely. So this can be folded into general library-level compatibility and versioning.</p>
<section id="cycles-and-non-serializable-data">
<h3>Cycles and non-serializable data<a class="headerlink" href="#cycles-and-non-serializable-data" title="Permalink to this heading"></a></h3>
<p>Cyclic data occurs in many places, e.g. a doubly linked list <code class="docutils literal notranslate"><span class="pre">rec</span> <span class="pre">{</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">{next:</span> <span class="pre">b,</span> <span class="pre">prev:</span> <span class="pre">None};</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">{next:</span> <span class="pre">None,</span> <span class="pre">prev:</span> <span class="pre">a}</span> <span class="pre">}</span></code>. We also have non-serializable data such as finalizers that does not live across program restarts. These cannot be serialized to JSON etc. as-is, because the format doesn’t support it. The solution is a replacer, which transforms cyclic and non-serializable data to a form suitable for serialization. The replacer produces a bijection from bad values to good values, so that we can serialize the good values in place of the bad values and do the opposite transformation on deserialization. Then we serialize this bijection separately (out-of-band).</p>
<p>It is much easier to do replacement out of band because in-band replacement leads to DOS attacks such as “billion laughs”. Basically the attacker defines a system such as <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">&quot;lol&quot;;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a+a;</span> <span class="pre">c=b+b;</span> <span class="pre">d=c+c;</span></code>, etc., constructing a string of a billion laughs, or similarly a large object that takes up too much memory. A simple solution is to cap memory usage, but this means some objects fail to serialize. Instead in-band entities must be treated lazily and not expanded unless necessary. Out-of-band avoids the issue by not allowing references in data.</p>
</section>
</section>
<section id="function-pipelines">
<h2>Function pipelines<a class="headerlink" href="#function-pipelines" title="Permalink to this heading"></a></h2>
<p>Haskell has function composition <code class="docutils literal notranslate"><span class="pre">(.)</span></code> and Julia has the “pipe” operator <code class="docutils literal notranslate"><span class="pre">(|&gt;)</span></code>.</p>
<p>According to <a class="reference external" href="https://github.com/jrevels/YASGuide#other-syntax-guidelines">YSAGuide</a> pipelines like <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">.</span> <span class="pre">b</span> <span class="pre">.</span> <span class="pre">c</span></code> are bad style and one should instead use intermediate results, <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">{</span> <span class="pre">a1</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">x;</span> <span class="pre">b1</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">a1;</span> <span class="pre">c1</span> <span class="pre">=</span> <span class="pre">c</span> <span class="pre">b1;</span> <span class="pre">return</span> <span class="pre">b1</span> <span class="pre">}</span></code>, except with better named variables than <code class="docutils literal notranslate"><span class="pre">x,a1,b1,c1</span></code>. The reason given is that debugging composed functions in the REPL is hard and clutters stacktraces. This sounds like a debugger problem - function pipelines are shorter and easier to read.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Compiler.html" class="btn btn-neutral float-left" title="Compiler design" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="CompilerOutput.html" class="btn btn-neutral float-right" title="Compiler output" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>