<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stateful programming &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Syntax" href="Syntax.html" />
    <link rel="prev" title="Standard library" href="Standard-Library.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler-Library.html">Compiler library</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Intrinsics.html">Intrinsics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#resources">Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#metrics">Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#methods">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#action">Action</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#caches">Caches</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard-Library.html">Standard library</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Stateful programming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#blocks">Blocks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bang-notation">Bang notation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#monad-comprehensions">Monad comprehensions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#applicativedo">ApplicativeDo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recursivedo">RecursiveDo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arrows">Arrows</a></li>
<li class="toctree-l4"><a class="reference internal" href="#idiom-brackets">Idiom brackets</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-like-reference-access">C-like reference access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#i-o-monad-showdown">I/O monad showdown</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#one-choice-for-operations">One choice for operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#monad-constructions">Monad constructions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#continuations">Continuations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multi-prompt-delimited-continuations">Multi-prompt delimited continuations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#streams">Streams</a></li>
<li class="toctree-l4"><a class="reference internal" href="#free-monad">Free monad</a></li>
<li class="toctree-l4"><a class="reference internal" href="#yoneda">Yoneda</a></li>
<li class="toctree-l4"><a class="reference internal" href="#algebraic-effects">Algebraic effects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#call-by-push-value">Call by push value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#applicative">Applicative</a></li>
<li class="toctree-l4"><a class="reference internal" href="#promises">Promises</a></li>
<li class="toctree-l4"><a class="reference internal" href="#monad-combined-with-identity-monad">Monad combined with identity monad</a></li>
<li class="toctree-l4"><a class="reference internal" href="#async">Async</a></li>
<li class="toctree-l4"><a class="reference internal" href="#futures">Futures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tasks">Tasks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#world-token">World token</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#logic-programming">Logic programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="#colored-values">Colored values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unsafe-i-o">“Unsafe” I/O</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#top-level-i-o">Top-level I/O</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#limitations-of-purity">Limitations of purity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#automatic-destructive-update">Automatic destructive update</a></li>
<li class="toctree-l3"><a class="reference internal" href="#store">Store</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#store-state">Store state</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Stateful programming</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/State.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="stateful-programming">
<h1>Stateful programming<a class="headerlink" href="#stateful-programming" title="Permalink to this heading"></a></h1>
<p>In Stroscot, like in denotational semantics, a program is conceptually a mathematical function. That is, for any given input, the program will always produce the same output, and this output is the entire scope of the program - there are no implicit side effects, like mutating some external state. Practically, this works well for using the programming language like a calculator: put in an expression, get an answer. And theory-wise the denotational semantics is useful for reasoning about the behavior of programs, such as asking whether two programs are equivalent.</p>
<section id="blocks">
<h2>Blocks<a class="headerlink" href="#blocks" title="Permalink to this heading"></a></h2>
<p>One issue with this denotational semantics view is that most programs these days are expected to operate in an interactive manner, receiving input, producing output, and manipulating a persistent state. How do we handle this? Well, we extend the semantics to include more values. In particular, the output of the program now includes values representing procedures or blocks of statements. So for example we might have a simple “check password” block that inputs a string, exits with failure if it is not the string “42”, and otherwise outputs the string “You got it” and exits with success.</p>
<p>Following Haskell, what we need is do-notation. In Haskell, this is by default tied to monads, but with GHC’s language extensions such as RebindableSyntax and QualifiedDo, there are really no restrictions on the types. The basic syntax is three productions:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">statement</span><span class="w"> </span><span class="p">{</span><span class="n">e</span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span>
<span class="nf">command</span><span class="w"> </span><span class="p">{</span><span class="n">e</span><span class="p">;</span><span class="n">stmts</span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">stmts</span><span class="p">}</span>
<span class="nf">operation</span><span class="w"> </span><span class="p">{</span><span class="n">pat</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="n">stmts</span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">pat</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">stmts</span><span class="p">};</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>In Haskell, <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">&gt;&gt;</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">e</span> <span class="pre">&gt;&gt;=</span> <span class="pre">\_</span> <span class="pre">-&gt;</span> <span class="pre">m</span></code>, and the type is <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span> <span class="pre">:</span> <span class="pre">IO</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">b</span></code>. I actually consider this a mistake. First, <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">a</span></code> makes it too easy to ignore return values - it should at least be a fixed type like <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">()</span></code>. But even <code class="docutils literal notranslate"><span class="pre">()</span></code> has some use, e.g. to allow returning exceptions, so really <code class="docutils literal notranslate"><span class="pre">()</span></code> should be replaced with a specialized type like <code class="docutils literal notranslate"><span class="pre">FixedReturnValue</span></code>. At that point it seems worth defining a separate type synonym. So we can really consider statements to be two disjoint categories, <code class="docutils literal notranslate"><span class="pre">Command</span> <span class="pre">=</span> <span class="pre">IO</span> <span class="pre">FixedReturnValue</span></code> and <code class="docutils literal notranslate"><span class="pre">Operation</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">IO</span> <span class="pre">(a</span> <span class="pre">\</span> <span class="pre">FixedReturnValue)</span></code>. If we hide <code class="docutils literal notranslate"><span class="pre">FixedReturnValue</span></code> then we just get two opaque types <code class="docutils literal notranslate"><span class="pre">Command</span></code> and <code class="docutils literal notranslate"><span class="pre">Operation</span> <span class="pre">a</span></code> and a combination <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Command</span> <span class="pre">|</span> <span class="pre">Operation</span> <span class="pre">a</span></code>. At that point there is essentially no linkage and we can just take <code class="docutils literal notranslate"><span class="pre">Command</span></code> and <code class="docutils literal notranslate"><span class="pre">Operation</span> <span class="pre">a</span></code> as two distinct types to begin with. So really <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> should not be hardcoded to its monadic definition, for example it is useful to take <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> to be function composition or category composition.</p>
<p>There is also <code class="docutils literal notranslate"><span class="pre">return</span></code>, which in Haskell is one of the monad operations. There is definitely a difference between writing <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">prompt</span> <span class="pre">=</span> <span class="pre">getLine</span> <span class="pre">prompt</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">prompt</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">return</span> <span class="pre">(getLine</span> <span class="pre">prompt)</span> <span class="pre">}</span></code>, and it is not clear how one would phrase the second version “return a block that reads a line with this prompt” any other way.</p>
<p>Ensuring that adding or removing braces on a single statement is a no-op is a useful property; this property is clear based on the translation but may be confusing to some. So for example we would write <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">prompt</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">getLine</span> <span class="pre">prompt</span> <span class="pre">}</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">prompt</span> <span class="pre">=</span> <span class="pre">return</span> <span class="pre">(getLine</span> <span class="pre">prompt)</span></code>. The “last statement’s value is returned” property is somewhat common in newer languages, the naked return less so.</p>
<p>There are many extensions to do-notation, we go over them here.</p>
<section id="bang-notation">
<h3>Bang notation<a class="headerlink" href="#bang-notation" title="Permalink to this heading"></a></h3>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">print</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">!</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>

<span class="o">//</span><span class="w"> </span><span class="n">desugars</span><span class="w"> </span><span class="n">to</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">t1</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">y</span>
<span class="w">  </span><span class="n">t2</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="n">t3</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">t2</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="n">t3</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In Idris, the notation <code class="docutils literal notranslate"><span class="pre">!expr</span></code> within a block means that the expression <code class="docutils literal notranslate"><span class="pre">expr</span></code> should be bound in the block to a temporary before computing the surrounding expression. The expression is bound in the nearest enclosing block. Expressions are lifted leftmost innermost. It’s a purely syntactic extension, introducing no new operations.</p>
<p>It’s kind of noisy though since you have to write the bang on each subexpression. What we’d really like a natural way to enforce LTR call-by-value-style evaluation order on a compound expression. So for example if <code class="docutils literal notranslate"><span class="pre">!(f</span> <span class="pre">(g</span> <span class="pre">(print</span> <span class="pre">y)</span> <span class="pre">x))</span></code> could desugar to the same as above, disambiguating based on whether each subexpression was a simple value or a block. At that point the evaluation order might even be implicit as in Java, without even the need for a bang. But we also want to preserve non-strictness; it’s kind of hard to determine whether an expression is a block without evaluating the expression, but possible.</p>
</section>
<section id="monad-comprehensions">
<h3>Monad comprehensions<a class="headerlink" href="#monad-comprehensions" title="Permalink to this heading"></a></h3>
<p>Originally, there were list comprehensions, a convenient means to construct lists based loosely off set-builder notation. Then, people realized that they could be used for any monad, so now they support various operations. The full syntactic translation is as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Basic forms</span>
<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">e</span>
<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">,</span><span class="n">e3</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">[</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">,</span><span class="n">e3</span><span class="p">]</span>
<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span><span class="w">  </span><span class="ow">=</span>
<span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">e</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span>
<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">guard</span><span class="w"> </span><span class="n">e</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span>
<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">d</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span>

<span class="c1">-- Parallel comprehensions (iterate for multiple parallel branches)</span>
<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="kt">Q</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">R</span><span class="p">),</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="p">(</span><span class="kt">Qv</span><span class="p">,</span><span class="kt">Rv</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mzip</span><span class="w"> </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="kt">Rv</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="c1">-- Qv is the tuple of variables bound by Q (and used subsequently)</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="p">]</span>

<span class="c1">-- Transform comprehensions</span>
<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="kt">Qv</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span>

<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="kt">Qv</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="kt">Qv</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span>

<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=\</span>
<span class="w">  </span><span class="n">ys</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">fmap</span><span class="w"> </span><span class="n">selQv1</span><span class="w"> </span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">,</span><span class="w"> </span><span class="n">fmap</span><span class="w"> </span><span class="n">selQvn</span><span class="w"> </span><span class="n">ys</span><span class="p">)</span><span class="w"> </span><span class="c1">-- selQvi is a selector mapping Qv to the ith component of Qv</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span>

<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">ys</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="kt">Qv</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">fmap</span><span class="w"> </span><span class="n">selQv1</span><span class="w"> </span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">,</span><span class="w"> </span><span class="n">fmap</span><span class="w"> </span><span class="n">selQvn</span><span class="w"> </span><span class="n">ys</span><span class="p">)</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span>
</pre></div>
</div>
<p>We see that <code class="docutils literal notranslate"><span class="pre">guard</span> <span class="pre">::</span> <span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">()</span></code> and <code class="docutils literal notranslate"><span class="pre">mzip</span> <span class="pre">::</span> <span class="pre">m</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">(a,</span> <span class="pre">b)</span></code> are new functions. <code class="docutils literal notranslate"><span class="pre">guard</span></code> actually has some non-trivial behavior - there’s special integration of the blocks (monads) and exceptions so exceptions propagate between pure expressions and blocks. <code class="docutils literal notranslate"><span class="pre">mzip</span></code> is implementable using <code class="docutils literal notranslate"><span class="pre">liftA2</span> <span class="pre">(,)</span></code>. In fact, in the base library, lists are the only non-<code class="docutils literal notranslate"><span class="pre">liftA2</span></code> instance, using the <code class="docutils literal notranslate"><span class="pre">ZipList</span></code> instance. Thus the parallel comprehensions really are only applicable to lists.</p>
</section>
<section id="applicativedo">
<h3>ApplicativeDo<a class="headerlink" href="#applicativedo" title="Permalink to this heading"></a></h3>
<p>ApplicativeDo <span id="id1">[<a class="reference internal" href="../zzreferences.html#id105" title="Simon Marlow, Simon Peyton Jones, Edward Kmett, and Andrey Mokhov. Desugaring Haskell's do-notation into applicative operations. In Proceedings of the 9th International Symposium on Haskell, Haskell 2016, 92–104. New York, NY, USA, September 2016. Association for Computing Machinery. URL: https://doi.org/10.1145/2976002.2976007 (visited on 2021-07-16), doi:10.1145/2976002.2976007.">MPJKM16</a>]</span> has two functions. The first is to make some do-notation sequences be Applicative-only and not use Monad. In fact though, such Applicative-only sequences are limited; they are exactly the sequences handled by idiom brackets, the <code class="docutils literal notranslate"><span class="pre">liftAn</span></code> family of operations. If we assume a single variadic function <code class="docutils literal notranslate"><span class="pre">liftA</span></code>, we can do the transformation <code class="docutils literal notranslate"><span class="pre">{a</span> <span class="pre">&lt;-</span> <span class="pre">ax;</span> <span class="pre">b</span> <span class="pre">&lt;-</span> <span class="pre">bx;</span> <span class="pre">return</span> <span class="pre">(f</span> <span class="pre">a</span> <span class="pre">b)}</span> <span class="pre">=</span> <span class="pre">liftA</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span></code>. <code class="docutils literal notranslate"><span class="pre">liftA</span></code> is shorter and clearer, so the value the do-notation translation provides is minimal when the functor is only Applicative and not a Monad. Furthermore, for many monads, the applicative functions compile to exactly the same code as the monadic functions.</p>
<p>The second function of ApplicativeDo is performance: in “some” monads, the applicative operation is more efficient than the corresponding monadic operations. Marlow’s example is the Haxl DSL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">numCommonFriends</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Id</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Id</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Haxl</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">numCommonFriends</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="n">fx</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">friendsOf</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="n">fy</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">friendsOf</span><span class="w"> </span><span class="n">y</span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="p">(</span><span class="n">intersect</span><span class="w"> </span><span class="n">fx</span><span class="w"> </span><span class="n">fy</span><span class="p">))</span>
</pre></div>
</div>
<p>Basically, with monadic <code class="docutils literal notranslate"><span class="pre">liftM2</span></code>, the <code class="docutils literal notranslate"><span class="pre">friendsOf</span></code> operations cannot be easily performed in parallel, because the computation must first materialize an <code class="docutils literal notranslate"><span class="pre">fx</span></code>, whereas with <code class="docutils literal notranslate"><span class="pre">liftA2</span></code> it is clear that the operations are independent and can be performed in parallel. My reaction is that, if you’re writing a DSL, then writing it as a macro is much more powerful than trying to shoehorn it into an applicative framework, or in general any kind of “shallow” framework where you have to implement each operation piecemeal and can’t examine the entire computation as an AST. The details in the paper confirm this: the translation to use applicative operations is ambiguous, reordering based on commutativity may be useful but is design-dependent, and overall the best translation still depends on a detailed estimate of the costs of each sub-computation. And of course their approach can’t compute these costs because functions are opaque. It’s exactly these kinds of details that <em>are</em> accessible in a DSL - you just write a pass that walks over the expression tree and estimates the costs. Similarly the <a class="reference external" href="https://en.wikipedia.org/wiki/Use-define_chain">use/def analysis</a> that they use for the rewriting is a standard compiler pass.</p>
<p>Verdict: Just use <code class="docutils literal notranslate"><span class="pre">liftA</span></code> or a DSL, this specific syntax is not needed.</p>
</section>
<section id="recursivedo">
<h3>RecursiveDo<a class="headerlink" href="#recursivedo" title="Permalink to this heading"></a></h3>
<p><span id="id2">[<a class="reference internal" href="../zzreferences.html#id58" title="Levent Erkok. Value Recursion in Monadic Computations. PhD thesis, Oregon Health and Science University, October 2002. URL: http://leventerkok.github.io/papers/erkok-thesis.pdf.">Erk02</a>]</span> introduced the idea of “value recursion”, in particular the operation <code class="docutils literal notranslate"><span class="pre">mfix</span> <span class="pre">::</span> <span class="pre">MonadFix</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code>. The GHC extension RecursiveDo introduces two syntaxes based on this operation, <code class="docutils literal notranslate"><span class="pre">mdo</span></code> and <code class="docutils literal notranslate"><span class="pre">rec</span> <span class="pre">{</span> <span class="pre">}</span></code>. Erkok’s motivating example was a circuit DSL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">toggle</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Signal</span><span class="w"> </span><span class="kt">Bool</span>
<span class="nf">toggle</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">out</span>
<span class="w">   </span><span class="kr">where</span>
<span class="w">      </span><span class="n">inp</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">inv</span><span class="w"> </span><span class="n">out</span>
<span class="w">      </span><span class="n">out</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">delay</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="n">inp</span>

<span class="nf">counter</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Signal</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Signal</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">counter</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">out</span>
<span class="w">   </span><span class="kr">where</span>
<span class="w">      </span><span class="n">next</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">delay</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">inc</span>
<span class="w">      </span><span class="n">inc</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">      </span><span class="n">out</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mux</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="n">next</span>
<span class="w">      </span><span class="n">zero</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span>
</pre></div>
</div>
<p>But wait, where’s the do notation? In fact, this is really just a DSL. There are no monads and no sequencing to be found. All of these operations happen in parallel. The uses for these circuit descriptions all depend on the circuits being specified using a small set of operations specified in a typeclass.</p>
<p>Investigating Hackage, value recursion is uncommon. “Many Haskell programmers will never use it in their careers.” (<a class="reference external" href="https://ro-che.info/articles/2015-09-02-monadfix">1</a>) Uses fall into categories:</p>
<ul class="simple">
<li><p>DSLs, where variable assignments are interpreted as data</p></li>
<li><p>Gratuitous (no/one binding, or bindings do not refer to bindings from later)</p></li>
<li><p>Rare use cases where using <code class="docutils literal notranslate"><span class="pre">mfix</span></code> directly is probably clearer than either <code class="docutils literal notranslate"><span class="pre">mdo</span></code> or the rec-notation</p></li>
</ul>
<p>For example, in the I/O monad, <code class="docutils literal notranslate"><span class="pre">mfix</span></code> can be used to fork two threads that kill each other:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mdo</span>
<span class="w">   </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">killThread</span><span class="w"> </span><span class="n">b</span>
<span class="w">   </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">killThread</span><span class="w"> </span><span class="n">a</span>

<span class="c1">-- vs</span>
<span class="nf">bId</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">newEmptyMVar</span>
<span class="nf">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">readMVar</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">killThread</span>
<span class="nf">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">killThread</span><span class="w"> </span><span class="n">a</span>
<span class="nf">writeMVar</span><span class="w"> </span><span class="n">bId</span><span class="w"> </span><span class="n">b</span>
</pre></div>
</div>
<p>But the version with the variable is arguably clearer. The code for IO’s mfix uses unsafeDupableInterleaveIO. This has been the subject of at least one <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/issues/5421">bug</a> (<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/issues/15349">two</a> counting fixST), and is why there is both fixIO and <a class="reference external" href="https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO-Unsafe.html#v:unsafeFixIO">unsafeFixIO</a>. Reasoning about fixIO seems to <a class="reference external" href="https://wiki.haskell.org/Evaluation_order_and_state_tokens">require</a> laziness semantics and maybe also an understanding of Haskell’s state-token-based I/O model.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">mfix</span></code> vs <code class="docutils literal notranslate"><span class="pre">mdo</span></code>, there are many implicit laws promoted by the <code class="docutils literal notranslate"><span class="pre">mdo</span></code> notation that are not satisfied. For example, right shrinking:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lhs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mdo</span>
<span class="w">   </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">z</span>
<span class="w">   </span><span class="n">w</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">z</span>
<span class="w">   </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>

<span class="c1">-- is NOT usually equivalent to</span>

<span class="nf">rhs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mdo</span>
<span class="w">   </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mdo</span>
<span class="w">            </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">z</span>
<span class="w">            </span><span class="n">return</span><span class="w"> </span><span class="n">z</span>
<span class="w">   </span><span class="n">w</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">z</span>
<span class="w">   </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p>Unfortunately, the only known monad satisfying right shrinking is the lazy state monad <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">-&gt;</span> <span class="pre">(a,s)</span></code> (and its restrictions, the output monad <code class="docutils literal notranslate"><span class="pre">Monoid</span> <span class="pre">w</span> <span class="pre">=&gt;</span> <span class="pre">(a,w)</span></code>, reader monad <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, identity monad <code class="docutils literal notranslate"><span class="pre">a</span></code>, and trivial monad <code class="docutils literal notranslate"><span class="pre">Void</span></code>). Erkok has a proof 3.1.6 that the trivial monad <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">Void</span></code> is the only monad satisfying left-strictness <code class="docutils literal notranslate"><span class="pre">undefined</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">undefined</span></code>, right shrinking, strictness 2.1.1, and various other properties. The setup is the above right shrinking rule where <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">return</span> <span class="pre">(1</span> <span class="pre">:</span> <span class="pre">xs);</span> <span class="pre">g</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">case</span> <span class="pre">xs</span> <span class="pre">of</span> <span class="pre">[x]</span> <span class="pre">-&gt;</span> <span class="pre">return</span> <span class="pre">x;</span> <span class="pre">_</span> <span class="pre">-&gt;</span> <span class="pre">return</span> <span class="pre">1</span></code>. He says “It is easy to see that [the LHS mdo block] must yield bottom by the strictness property”. Expanding on this, if we start with <code class="docutils literal notranslate"><span class="pre">(z,w)</span> <span class="pre">=</span> <span class="pre">undefined</span></code>, then after one loop we get <code class="docutils literal notranslate"><span class="pre">z=1:undefined</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">undefined</span></code>, so the overall function returns <code class="docutils literal notranslate"><span class="pre">undefined</span></code> by the left-strictness property, so therefore by strictness 2.1.1 the overall <code class="docutils literal notranslate"><span class="pre">mfix</span></code> is also undefined. But of course, if we start with the fixed point of the RHS, <code class="docutils literal notranslate"><span class="pre">(z,w)</span> <span class="pre">=</span> <span class="pre">(repeat</span> <span class="pre">1,1)</span></code>, we get that back even in the LHS. So Erkok’s proof relies on strictness and <code class="docutils literal notranslate"><span class="pre">mfix</span></code> producing the least fixed point. Using similar arguments about bottom, there is a proof that Haskell <a class="reference external" href="https://smallbone.se/no-state-monad.html">cannot have a State monad</a>. Really, the discussion should focus on the monad’s behavior for defined values and total functions, and not discuss bottom or seq at all. I think it’s best to suppose that the premises of the proof are incorrect, but the fact remains that the only known right-shrinkable monad is the lazy state monad. Absent other monads, it seems the lazy state monad is really the canonical implementation of <code class="docutils literal notranslate"><span class="pre">MonadFix</span></code>, similar to how lists are the only non-trivial implementation of <code class="docutils literal notranslate"><span class="pre">MonadZip</span></code> and everything else is just lifting.</p>
<p>But Erkok had to write a thesis, so of course he can’t just say “lazy state is MonadFix” and leave it there. Erkok proposes to leave out right shrinking and other properties to obtain a more general definition. The main issue with this is that <code class="docutils literal notranslate"><span class="pre">mfix</span></code> for the lazy state monad is no longer unique - there is a “shallow” mfix operations which simply apply the function to the bottom state. Erkok’s definition of <code class="docutils literal notranslate"><span class="pre">mfix</span></code> for I/O is shallow in this sense. For ADT-style monads, <code class="docutils literal notranslate"><span class="pre">mfix</span></code> simply follows the structure of the monad (c.f. <a class="reference external" href="https://hackage.haskell.org/package/base-4.18.0.0/docs/src/Control.Monad.Fix.html#line-140">GHC.Generics instances</a>). These operations are kind of useful for</p>
<p>data    U1        p = U1                  – lifted version of ()
data    (:+:) f g p = L1 (f p) | R1 (g p) – lifted version of Either
data    (:<em>:) f g p = (f p) :</em>: (g p)     – lifted version of (,)
newtype K1    i c p = K1 { unK1 :: c }    – a container for a c
newtype M1  i t f p = M1 { unM1 :: f p }  – a wrapper
newtype Par1   p = Par1 { unPar1 ::   p } – gives access to parameter p
newtype Rec1 f p = Rec1 { unRec1 :: f p } – a wrapper</p>
<p>Consider f ⊥. If it is ⊥, mfix f must be ⊥ by strictness. If f ⊥ = Left l, then f must factor through Left by monotonicity, i.e., there must be a function h such that f = Left · h, or equivalently, h = unLeft · f. Then mfix f = mfix (Left · h) = Left $ mfix h = Left $ mfix (unLeft . f). Similarly Right r must factor as f = Right . h, h = unRight . f, and mfix f = Right $ mfix (unRight . f). So to summarize, we have:</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>mfix f = case f ⊥ of</dt><dd><p>L1 _ -&gt; L1 $ mfix (x -&gt; case f x of L1 y -&gt; y)
R1 _ -&gt; R1 $ mfix (x -&gt; case f x of R1 y -&gt; y)</p>
</dd>
</dl>
</div></blockquote>
<p>(4.3)</p>
</div></blockquote>
<dl class="simple">
<dt>Just</dt><dd><p>→ return (fix (unJust · f ))</p>
</dd>
</dl>
<p>Note that we did not make any choices in constructing Equation 4.3; the behavior of
mfix is completely dictated by the properties that must be satisfied by all value recursion
operators. We leave it to the reader to show that Equations 4.2 and 4.3 are equivalent,
establishing uniqueness.</p>
<dl class="simple">
<dt>instance MonadFix Par1 where</dt><dd><p>mfix f = Par1 (fix (unPar1 . f))</p>
</dd>
</dl>
<p>– | &#64;since 4.9.0.0
instance MonadFix f =&gt; MonadFix (Rec1 f) where</p>
<blockquote>
<div><p>mfix f = Rec1 (mfix (unRec1 . f))</p>
</div></blockquote>
<p>– | &#64;since 4.9.0.0
instance MonadFix f =&gt; MonadFix (M1 i c f) where</p>
<blockquote>
<div><p>mfix f = M1 (mfix (unM1. f))</p>
</div></blockquote>
<p>– | &#64;since 4.9.0.0
instance (MonadFix f, MonadFix g) =&gt; MonadFix (f :<a href="#id3"><span class="problematic" id="id4">*</span></a>: g) where</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>mfix f = (mfix (fstP . f)) :<a href="#id5"><span class="problematic" id="id6">*</span></a>: (mfix (sndP . f))</dt><dd><dl class="simple">
<dt>where</dt><dd><p>fstP (a :<em>: _) = a
sndP (_ :</em>: b) = b</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>And then, for continuations, Erkok has a type-theoretic argument for why no implement of mfix exists. For codensity, there are <a class="reference external" href="https://github.com/ekmett/kan-extensions/issues/64">several potential implementations</a> of <code class="docutils literal notranslate"><span class="pre">mfix</span></code>, based on I/O and state, but nobody has proven them correct.</p>
</div></blockquote>
<p>or just a few operations (mfix state, fixIO, fix applied to a generic traversal of a strict sum-like monad) that happened to be collected in an ad-hoc manner. The main issue with the “relaxed” mfix definition is that, because the instances satisfy barely any properties, the <code class="docutils literal notranslate"><span class="pre">mdo</span></code> notation is completely unintuitive - simply adding a non-recursive statement at the end can break the program. For this reason, <code class="docutils literal notranslate"><span class="pre">mdo</span></code> is pretty much deprecated and most recommendations are to use <code class="docutils literal notranslate"><span class="pre">mfix</span></code> directly or <code class="docutils literal notranslate"><span class="pre">rec</span> <span class="pre">{}</span></code> which is just a lightweight macro for <code class="docutils literal notranslate"><span class="pre">mfix</span></code> with a tuple argument. At that point, <code class="docutils literal notranslate"><span class="pre">mfix</span></code> is just an ordinary function, not really part of the monad syntax.</p>
<p><code class="docutils literal notranslate"><span class="pre">let</span></code> allows recursive definitions, bare definitions are not recursive:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">shadowing</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="n">x</span>
<span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">fixed</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">unique</span><span class="w"> </span><span class="n">solution</span><span class="w"> </span><span class="n">x</span><span class="ow">=</span><span class="mi">0</span>

<span class="nf">fact</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">fails</span><span class="w"> </span><span class="n">due</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="n">being</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">unbound</span><span class="w"> </span><span class="n">symbol</span>
<span class="kr">let</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">proper</span><span class="w"> </span><span class="n">definition</span>
</pre></div>
</div>
</section>
<section id="arrows">
<h3>Arrows<a class="headerlink" href="#arrows" title="Permalink to this heading"></a></h3>
<p>You might be getting the pattern here. Arrows were inspired by a parsing DSL. Any arrow which supports the ArrowApply class is a monad. Arrows not supporting ArrowApply must write operations for every language element supported (variable, function, conditional, grammar production choice, and so on). Continuations require ArrowApply to even implement the basic arrow interface. Verdict: trash, a leaky “abstraction” that just wastes everyone’s time.</p>
</section>
<section id="idiom-brackets">
<h3>Idiom brackets<a class="headerlink" href="#idiom-brackets" title="Permalink to this heading"></a></h3>
<p>While do notation is defined for monads, idiom brackets are defined for applicative functors, <code class="docutils literal notranslate"><span class="pre">[[</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">]]</span> <span class="pre">=</span> <span class="pre">pure</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">a</span> <span class="pre">&lt;*&gt;</span> <span class="pre">b</span></code>. But DSL notation works too: <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">{</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">}</span></code>.</p>
<p>The issue with translating to <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> is that it assumes left-to-right evaluation. You can see this in the <a class="reference external" href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Applicative.html#t:Applicative">translation</a> for Monads: <code class="docutils literal notranslate"><span class="pre">m1</span> <span class="pre">&lt;*&gt;</span> <span class="pre">m2</span></code> binds <code class="docutils literal notranslate"><span class="pre">m1</span></code> before <code class="docutils literal notranslate"><span class="pre">m2</span></code>. In Stroscot the program is required to be equivalent under all evaluation orders. So to enforce this we need a function <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">:</span> <span class="pre">[m</span> <span class="pre">a]</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">[a]</span></code> that checks there is no issue with evaluating in parallel. Then using parallel the translation of <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">{</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">x</span> <span class="pre">}</span></code> looks like <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">(av,bv,cv)</span> <span class="pre">=</span> <span class="pre">parallel</span> <span class="pre">(a,b,c);</span> <span class="pre">return</span> <span class="pre">(f</span> <span class="pre">av</span> <span class="pre">bv</span> <span class="pre">cv)</span> <span class="pre">}</span></code></p>
<p>Idris defines <a class="reference external" href="http://docs.idris-lang.org/en/latest/tutorial/interfaces.html#notation">!-notation</a>, “implicitly bound application”. The scoping is <a class="reference external" href="https://github.com/idris-lang/Idris-dev/issues/4395">unintuitive</a>, but the notation itself is powerful. Binding it to a syntactic block seems reasonable. And it can easily express idiom brackets, <code class="docutils literal notranslate"><span class="pre">[[</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">]]</span></code> becomes <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">f</span> <span class="pre">!a</span> <span class="pre">!b</span> <span class="pre">}</span></code>. Idiom brackets save characters with more arguments, but bang notation looks natural if there are multiple bindings in the block.</p>
</section>
<section id="c-like-reference-access">
<h3>C-like reference access<a class="headerlink" href="#c-like-reference-access" title="Permalink to this heading"></a></h3>
<p>For example we want to do:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="nf">a</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">c</span>
</pre></div>
</div>
<p>Translated this looks like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ref</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="nf">\</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="nf">ref</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="nf">\</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="nf">parallel</span><span class="w"> </span><span class="p">(</span><span class="n">read</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="nf">\</span><span class="p">(</span><span class="n">av</span><span class="p">,</span><span class="n">bv</span><span class="p">)</span><span class="w">  </span><span class="ow">-&gt;</span>
<span class="kr">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">av</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bv</span><span class="w"> </span><span class="kr">in</span>
<span class="nf">writeRef</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span>
</pre></div>
</div>
<p>I think the solution is another DSL. Inserting <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">a</span></code> is not too complicated, just follow the C/C++ rules about converting lvalues to rvalues.</p>
</section>
</section>
<section id="i-o-monad-showdown">
<h2>I/O monad showdown<a class="headerlink" href="#i-o-monad-showdown" title="Permalink to this heading"></a></h2>
<section id="one-choice-for-operations">
<h3>One choice for operations<a class="headerlink" href="#one-choice-for-operations" title="Permalink to this heading"></a></h3>
<p>We might think that there are a lot of monads. After all, every library defines a few. But actually, there is a universal construction for monads. Specifically, <code class="docutils literal notranslate"><span class="pre">Codensity</span> <span class="pre">m</span> <span class="pre">a</span></code> in <a class="reference external" href="https://hackage.haskell.org/package/kan-extensions-0.5.0/docs/Control-Monad-Codensity.html">kan-extensions</a> is <a class="reference external" href="http://blog.sigfpe.com/2008/12/mother-of-all-monads.html">the mother of all monads</a> - it is a monad regardless of <code class="docutils literal notranslate"><span class="pre">m</span></code> (<a class="reference external" href="http://blog.sigfpe.com/2008/12/mother-of-all-monads.html#c3279179532869319461">see comment</a>), and if <code class="docutils literal notranslate"><span class="pre">m</span></code> is a monad, then the monad values <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">a</span></code> can be embedded and retrieved via <code class="docutils literal notranslate"><span class="pre">lift</span> <span class="pre">::</span> <span class="pre">m</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Codensity</span> <span class="pre">m</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">lowerCodensity</span> <span class="pre">::</span> <span class="pre">Codensity</span> <span class="pre">m</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code>.</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> and retrieved via <code class="docutils literal notranslate"><span class="pre">\f</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">return</span></code>. That blog post gives a generic way to implement monads via the continuation monad, but the direct implementation is pretty clean. For example the <a class="reference external" href="https://github.com/Mathnerd314/stroscot/blob/master/tests/Continuations-State.hs">StateT monad</a>.</p>
</div></blockquote>
</section>
<section id="monad-constructions">
<h3>Monad constructions<a class="headerlink" href="#monad-constructions" title="Permalink to this heading"></a></h3>
<p>A monad transformer is a way of constructing monads from other monads - given a basic monad <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">a</span></code>, and a transformer <code class="docutils literal notranslate"><span class="pre">T</span></code>, <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">m</span> <span class="pre">a</span></code> is a new monad with a function <code class="docutils literal notranslate"><span class="pre">lift</span> <span class="pre">::</span> <span class="pre">m</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">T</span> <span class="pre">m</span> <span class="pre">a</span></code>. It is also generally possible to implement something like the inverse function <code class="docutils literal notranslate"><span class="pre">lower</span> <span class="pre">::</span> <span class="pre">T</span> <span class="pre">m</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(m</span> <span class="pre">a</span> <span class="pre">|</span> <span class="pre">Fail)</span></code>, such that <code class="docutils literal notranslate"><span class="pre">lower</span> <span class="pre">(lift</span> <span class="pre">x)</span> <span class="pre">==</span> <span class="pre">x</span></code>. Note though that <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">m</span> <span class="pre">a</span></code> is generally larger, so <code class="docutils literal notranslate"><span class="pre">lower</span></code> erases some information and is partial. Monad transformers seem attractive - who doesn’t want extra functionality in their I/O monad? But following this line of reasoning, applying a monad transformer once is not enough - we could apply the monad transformer a second time, and get even more functionality. To maximize functionality we would need an infinite monad transformer stack. But of course most type systems don’t handle infinite types very well. The conclusion is that monad transformers are actually a clunky way to express functionality and we are better off implementing the functionality provided by monad transformers as dedicated features of the language. But to get rid of monad transformers completely, we need to ensure that these dedicated features provide functionality equivalent to arbitrary numbers of monad transformers, for every type of monad transformer.</p>
<p>Let’s go through the list of existing monad transformers. I checked &lt;<a class="reference external" href="https://hackage.haskell.org/package/transformers">https://hackage.haskell.org/package/transformers</a>&gt;`__, ChatGPT, and used various Google queries such as “monad transformer -MaybeT - StateT -…”.</p>
<blockquote>
<div><p>IdentityT <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">a</span></code>
MaybeT/OptionT <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">(Maybe</span> <span class="pre">a)</span></code>
EitherT/ExceptT/ErrorT <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">(Either</span> <span class="pre">e</span> <span class="pre">a)</span></code>
StateT/AccumT `` s -&gt; m (a, s)``
ReaderT <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code>
WriterT <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">(a,</span> <span class="pre">w)</span></code>
ContT <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">r</span></code>
ListT - <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">(Nil</span> <span class="pre">|</span> <span class="pre">Cons</span> <span class="pre">a</span> <span class="pre">(ListT</span> <span class="pre">m</span> <span class="pre">a))</span></code>
pipes Proxy - <code class="docutils literal notranslate"><span class="pre">Request</span> <span class="pre">(a',</span> <span class="pre">a</span>&#160; <span class="pre">-&gt;</span> <span class="pre">Proxy)</span> <span class="pre">|</span> <span class="pre">Response</span> <span class="pre">(b,</span> <span class="pre">b'</span> <span class="pre">-&gt;</span> <span class="pre">Proxy)</span> <span class="pre">|</span> <span class="pre">M</span> <span class="pre">(m</span> <span class="pre">Proxy)</span> <span class="pre">|</span> <span class="pre">Pure</span> <span class="pre">r</span></code>
Free codensity transformer <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">(f</span> <span class="pre">(m</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">r</span></code>
Free monad transformer <code class="docutils literal notranslate"><span class="pre">mu</span> <span class="pre">T.</span> <span class="pre">m</span> <span class="pre">(Pure</span> <span class="pre">a</span> <span class="pre">|</span> <span class="pre">Free</span> <span class="pre">(f</span> <span class="pre">T))</span></code>
ListZipperT: Transforms a base monad into a monad that supports efficient list manipulations.
ParsecT: Enables building parser combinators using monadic style.</p>
<p>LogicT
SelectT</p>
</div></blockquote>
<p>we see this is pretty much the case for Stroscot. The I/O store (discussed later in this document) allows implementing any number of StateT’s (mutable variables). AccumT / WriterT is a mutable variable that’s not read, and similarly ReaderT is a mutable variable that’s not written. We can also use implicit parameters to get ambient values like ReaderT provides. Exceptions are a more general and powerful version of MaybeT/ErrorT/ExceptT/MonadFail. Logic-programming style nondeterminism covers ListT / SelectT.</p>
<p>The remaining monad transformer is ContT. ContT is not really a well-behaved monad transformer - although we can lift values <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">ContT</span> <span class="pre">m</span> <span class="pre">a</span></code>, we cannot lift continuations, i.e. no function <code class="docutils literal notranslate"><span class="pre">ContT</span> <span class="pre">Identity</span> <span class="pre">r</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">ContT</span> <span class="pre">m</span> <span class="pre">r</span> <span class="pre">a</span></code> exists. Applying <code class="docutils literal notranslate"><span class="pre">ContT</span></code> twice, we find <code class="docutils literal notranslate"><span class="pre">ContT</span> <span class="pre">r</span> <span class="pre">(ContT</span> <span class="pre">s</span> <span class="pre">m)</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">ContT</span> <span class="pre">s</span> <span class="pre">m</span> <span class="pre">(Either</span> <span class="pre">(a,</span> <span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">s)</span> <span class="pre">r)</span></code></p>
</section>
<section id="continuations">
<h3>Continuations<a class="headerlink" href="#continuations" title="Permalink to this heading"></a></h3>
<p>Typing continuations is a little hard because they allow answer-type modification, e.g. the type of <code class="docutils literal notranslate"><span class="pre">reset</span> <span class="pre">(3</span> <span class="pre">+</span> <span class="pre">shift</span> <span class="pre">\k</span> <span class="pre">-&gt;</span> <span class="pre">k)</span></code> is <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code>. Using prefix syntax <code class="docutils literal notranslate"><span class="pre">reset</span> <span class="pre">(liftA</span> <span class="pre">(+)</span> <span class="pre">3</span> <span class="pre">(shift</span> <span class="pre">(\k</span> <span class="pre">-&gt;</span> <span class="pre">k)))</span></code> this ability to change type is a little more obvious. Since the operators are lambdas, the principal intersection types will be the most general, since intersection types can type all strongly normalizing programs. In this case it turns out we do not need the intersection operator and the Hindley-Milner type signature is sufficient. To express the types it is helpful to define the indexed continuation type <code class="docutils literal notranslate"><span class="pre">ICont</span> <span class="pre">r</span> <span class="pre">s</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">s)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>. Then the most general simple types are:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">return</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ICont</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">ICont</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">i</span>
</pre></div>
</div>
<p>A general chain <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;&gt;=</span> <span class="pre">b</span> <span class="pre">&gt;&gt;=</span> <span class="pre">c</span> <span class="pre">&gt;&gt;=</span> <span class="pre">d</span></code> has <code class="docutils literal notranslate"><span class="pre">a</span></code> of type <code class="docutils literal notranslate"><span class="pre">ICont</span> <span class="pre">i</span> <span class="pre">j</span> <span class="pre">a1</span></code>, <code class="docutils literal notranslate"><span class="pre">b/c</span></code> of type <code class="docutils literal notranslate"><span class="pre">a1/b1</span> <span class="pre">-&gt;</span> <span class="pre">ICont</span> <span class="pre">j/k</span> <span class="pre">k/l</span> <span class="pre">b1/c1</span> <span class="pre">``,</span> <span class="pre">``d</span></code> of type <code class="docutils literal notranslate"><span class="pre">c1</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">l</span></code>, and returns a function <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">i</span></code>. So the last callback in a chain can be represented using tokens or other weird things - it’s only when we bind the continuation to another continuation that it has to use a function type. This freedom is useful when writing I/O simulators. Ignoring this the usual indexed monad signature for <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> is <code class="docutils literal notranslate"><span class="pre">ICont</span> <span class="pre">i</span> <span class="pre">j</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">ICont</span> <span class="pre">j</span> <span class="pre">k</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">ICont</span> <span class="pre">i</span> <span class="pre">k</span> <span class="pre">b</span></code>.</p>
<p>Using universal quantification and type constructors gives the <a class="reference external" href="https://www.reddit.com/r/haskell/comments/6vu2i4/fun_exploration_right_kan_extensions_swapped/">indexed codensity monad</a>  or <a class="reference external" href="https://hackage.haskell.org/package/kan-extensions-5.2.5/docs/Data-Functor-Kan-Ran.html">right Kan extension</a> <code class="docutils literal notranslate"><span class="pre">Ran</span> <span class="pre">m</span> <span class="pre">n</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">forall</span> <span class="pre">r.</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">n</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">r</span> <span class="pre">=</span> <span class="pre">forall</span> <span class="pre">r.</span> <span class="pre">ICont</span> <span class="pre">(m</span> <span class="pre">r)</span> <span class="pre">(n</span> <span class="pre">r)</span> <span class="pre">a</span></code>. <code class="docutils literal notranslate"><span class="pre">ICont</span> <span class="pre">i</span> <span class="pre">j</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Ran</span> <span class="pre">(K</span> <span class="pre">i)</span> <span class="pre">(K</span> <span class="pre">j)</span> <span class="pre">a</span></code> where <code class="docutils literal notranslate"><span class="pre">K</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a</span></code>.</p>
<p>Due to the quantification, the operations on <code class="docutils literal notranslate"><span class="pre">Ran</span></code> are restricted.  In particular <code class="docutils literal notranslate"><span class="pre">callCC</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">\c</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">(\x</span> <span class="pre">_</span> <span class="pre">-&gt;</span> <span class="pre">c</span> <span class="pre">x)</span> <span class="pre">c</span></code> has type <code class="docutils literal notranslate"><span class="pre">((a</span> <span class="pre">-&gt;</span> <span class="pre">p</span> <span class="pre">-&gt;</span> <span class="pre">j)</span> <span class="pre">-&gt;</span> <span class="pre">ICont</span> <span class="pre">i</span> <span class="pre">j</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">ICont</span> <span class="pre">i</span> <span class="pre">j</span> <span class="pre">a</span></code>, which does not unify with the desired type <code class="docutils literal notranslate"><span class="pre">((a</span> <span class="pre">-&gt;</span> <span class="pre">Ran</span> <span class="pre">n</span> <span class="pre">o</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">Ran</span> <span class="pre">m</span> <span class="pre">n</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">Ran</span> <span class="pre">m</span> <span class="pre">n</span> <span class="pre">a</span></code>. <span id="id7">[<a class="reference internal" href="../zzreferences.html#id166" title="Philip Wadler. The essence of functional programming. In Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages - POPL '92, 1–14. Albuquerque, New Mexico, United States, 1992. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=143165.143169 (visited on 2021-11-22), doi:10.1145/143165.143169.">Wad92</a>]</span> section 3.4 says that the lack of callCC is a good thing because it means every continuation corresponds to an <code class="docutils literal notranslate"><span class="pre">m-n</span></code> operation. It’s a semantic distinction: are your values “special” values with known types, hence in the type <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">forall</span> <span class="pre">r.</span> <span class="pre">m</span> <span class="pre">r</span></code> and possible to use with callCC, or are they “return” values that have unknown structure?</p>
<p>We call the values in <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">m</span></code> continuations, and the values in <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">r</span></code> actions. A continuation represents “the future of the program”. Executing a continuation plugs this future into a program description with a hole - usually there is one hole, but the continuation can discard the future or run it multiple times. The implementation can compile continuations to jumps under most circumstances and closures otherwise, so the execution model is also conceptually simple. Continuations are the basis in formal denotational semantics for all control flow, including vanilla call flow, loops, goto statements, recursion, generators, coroutines, exception handling, and backtracking. This allows a uniform and consistent interface. Continuations are more powerful than goto.</p>
<p><code class="docutils literal notranslate"><span class="pre">Codensity</span></code> is quite efficient - the case analysis is pushed to the monad’s operations, and there is no pile-up of binds - all uses of the underlying monad’s bind are right-associated. It converts the computation to continuation-passing style. In particular free tree-like monads <span id="id8">[<a class="reference internal" href="../zzreferences.html#id163" title="Janis Voigtländer. Asymptotic Improvement of Computations over Free Monads. In Philippe Audebaud and Christine Paulin-Mohring, editors, Mathematics of Program Construction, volume 5133, pages 388–403. Springer Berlin Heidelberg, Berlin, Heidelberg, 2008. URL: https://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf (visited on 2021-07-09), doi:10.1007/978-3-540-70594-9_20.">Voi08</a>]</span> and <a class="reference external" href="http://r6.ca/blog/20071028T162529Z.html">MTL monad stacks</a> are much cheaper when implemented via Codensity. As a contrary point, in the <a class="reference external" href="https://www.mail-archive.com/haskell-cafe&#64;haskell.org/msg66512.html">case</a> of the Maybe monad an ADT version seemed to be faster than a Church encoding. Unfortunately hpaste is defunct so the code can’t be analyzed further. It’s not clear if the “CPS” version mentioned was actually Codensity.</p>
<p><span id="id9">[<a class="reference internal" href="../zzreferences.html#id111" title="Leo A. Meyerovich and Ariel S. Rabkin. Socio-PLT: principles for programming language adoption. In Proceedings of the ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software - Onward! '12, 39. Tucson, Arizona, USA, 2012. ACM Press. URL: http://dl.acm.org/citation.cfm?doid=2384592.2384597 (visited on 2020-06-15), doi:10.1145/2384592.2384597.">MR12</a>]</span> mentions that generators and coroutines (one-shot continuations) have been preferred to multi-shot continuations, and if you read <span id="id10">[]</span>, they say “The main reason for this is believed to be the
inherent complexity of the continuation-based code, and the difficulty of making it performant.” But here we are simply implementing continuations as lambdas, so there is not really any more complexity added, and it seems safe to assume that an efficient lambda implementation (e.g. using optimal reduction) will also lead to efficient continuations, although perhaps it will need some tweaking.</p>
</section>
<section id="multi-prompt-delimited-continuations">
<h3>Multi-prompt delimited continuations<a class="headerlink" href="#multi-prompt-delimited-continuations" title="Permalink to this heading"></a></h3>
<p>Multi-prompt delimited continuations are described in <span id="id11">[<a class="reference internal" href="../zzreferences.html#id51" title="R. Kent Dyvbig, Simon Peyton Jones, and Amr Sabry. A monadic framework for delimited continuations. Journal of Functional Programming, 17(6):687–730, November 2007. URL: https://doi.org/10.1017/S0956796807006259 (visited on 2020-06-19), doi:10.1017/S0956796807006259.">DPJS07</a>]</span> . These might appear more expressive than standard delimited continuations , but as the paper shows, multi-prompt continuations can be implemented as a monad and hence as a library to use with the standard continuations. So the simplicity of the standard continuations wins out. With the multi-prompt continuations you have to have a unique id supply and a stack. The unique id supply complicates multithreading, and the stack can overflow and requires care to handle tail recursion. Whereas standard continuations translate to pure lambdas, and tail recursion is dealt with by the host language’s semantics.</p>
</section>
<section id="streams">
<h3>Streams<a class="headerlink" href="#streams" title="Permalink to this heading"></a></h3>
<p>With the stream I/O model a program is of type <code class="docutils literal notranslate"><span class="pre">[Response]</span> <span class="pre">-&gt;</span> <span class="pre">[Request]</span></code>, where <code class="docutils literal notranslate"><span class="pre">[]</span></code> is the type constructor of destructively updateable lists. With an unsafe lazy read operation we can write an interpreter with constant overhead like so:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">RList</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Ref</span><span class="w"> </span><span class="p">(</span><span class="kt">Bottom</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Nil</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">Rlist</span><span class="w"> </span><span class="n">a</span><span class="p">))</span>

<span class="nf">c</span><span class="w"> </span><span class="p">(</span><span class="n">prog</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="kt">Response</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Request</span><span class="p">])</span><span class="w">  </span><span class="ow">=</span>
<span class="w">  </span><span class="n">lst</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="kt">Bottom</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="kt">Response</span>
<span class="w">  </span><span class="n">reqs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">prog</span><span class="w"> </span><span class="p">(</span><span class="n">unsafeLazyRead</span><span class="w"> </span><span class="n">lst</span><span class="p">)</span>
<span class="w">  </span><span class="n">loop</span><span class="w"> </span><span class="n">reqs</span><span class="w"> </span><span class="n">lst</span><span class="w"> </span><span class="kr">where</span>
<span class="w">    </span><span class="n">loop</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lst</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="kt">Nil</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="kt">Done</span>
<span class="w">    </span><span class="n">loop</span><span class="w"> </span><span class="p">((</span><span class="kt">ReadRequest</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">reqs&#39;</span><span class="p">)</span><span class="w"> </span><span class="n">lst</span><span class="w"> </span><span class="ow">=</span>
<span class="w">      </span><span class="n">read</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">contents</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">        </span><span class="n">tl</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="kt">Bottom</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="kt">Response</span>
<span class="w">        </span><span class="n">lst</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="p">(</span><span class="kt">ReadResponse</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="w"> </span><span class="n">tl</span>
<span class="w">        </span><span class="n">loop</span><span class="w"> </span><span class="n">reqs&#39;</span><span class="w"> </span><span class="n">tl</span>
</pre></div>
</div>
<p>In a purely functional model, defining streams in terms of continuations requires linear space and quadratic time in terms of the number of requests issued. In particular, given <code class="docutils literal notranslate"><span class="pre">prog</span> <span class="pre">[...xs,Bottom])</span> <span class="pre">=</span> <span class="pre">[...as,newreq,Bottom]</span></code>, each request-response iteration has to evaluate <code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">(drop</span> <span class="pre">(length</span> <span class="pre">as)</span> <span class="pre">(prog</span> <span class="pre">[...xs,newresp,bottom]))</span></code> to get the new request, duplicating the evaluation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> over the first <code class="docutils literal notranslate"><span class="pre">xs</span></code> elements. <span id="id12">[]</span> Haskell 1.0 used streams as its I/O model due to this performance consideration. But given the destructive update implementation, I don’t think this is an issue.</p>
<p>Per <span id="id13">[]</span>, continuations are easier to use than streams and preferred by most programmers. With continuations, responses are localized to each request, whereas streams require careful pattern-matching to ensure that requests and responses are matched up.</p>
</section>
<section id="free-monad">
<h3>Free monad<a class="headerlink" href="#free-monad" title="Permalink to this heading"></a></h3>
<p>There are some definitions on Hackage of free monads:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- free, control-monad-free, transformers-free</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Free</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Pure</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Free</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Free</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">))</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">FreeF</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Pure</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Free</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">FreeT</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="kt">FreeF</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">FreeT</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">))</span>

<span class="c1">-- indexed-free</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">IxFree</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">where</span>
<span class="w">    </span><span class="kt">Pure</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IxFree</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="kt">Free</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">(</span><span class="kt">IxFree</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IxFree</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">a</span>

<span class="c1">-- free-operational</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">ProgramT</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">FreeT</span><span class="w"> </span><span class="p">(</span><span class="kt">Coyoneda</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">Program</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Free</span><span class="w"> </span><span class="p">(</span><span class="kt">Coyoneda</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="n">a</span>

<span class="c1">-- operational</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">ProgramT</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="kt">Lift</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ProgramT</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
<span class="w">  </span><span class="kt">Bind</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ProgramT</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ProgramT</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ProgramT</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
<span class="w">  </span><span class="kt">Instr</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ProgramT</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>

<span class="c1">-- MonadPrompt, https://www.eyrie.org/%7Ezednenem/2013/06/prompt,</span>
<span class="c1">-- https://www.reddit.com/r/haskell/comments/5a5frc/a_correct_free_monad_and_free_monad_fix/</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Prompt</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Done</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="w"> </span><span class="kt">Prompt</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Prompt</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">Prompt</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">a</span><span class="w">  </span><span class="ow">=</span><span class="w">  </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span>
</pre></div>
</div>
<p>These are simple, but have drawbacks, per <a class="reference external" href="https://web.archive.org/web/20220124082435/http://comonad.com/reader/2011/free-monads-for-less/">Kmett</a>. (&gt;&gt;=) used left-associatively has quadratic running time, as like (++) it must rescan the list of instructions with every bind. Every time you bind in a free monad, structure accumulates and this structure must be traversed past to deal with subsequent left-associated bind invocations. Free monads never shrink after a bind and the main body of the tree never changes.</p>
<p>Due to this, free monads are spine-strict - instructions must always be evaluated. Similarly MonadFix is not possible.</p>
</section>
<section id="yoneda">
<h3>Yoneda<a class="headerlink" href="#yoneda" title="Permalink to this heading"></a></h3>
<p><a class="reference external" href="http://comonad.com/reader/2011/free-monads-for-less-2/">Kmett</a> says to use <code class="docutils literal notranslate"><span class="pre">Yoneda</span> <span class="pre">(Rec</span> <span class="pre">f)</span> <span class="pre">a</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">newtype</span> <span class="pre">F</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">F</span> <span class="pre">{</span> <span class="pre">runF</span> <span class="pre">::</span> <span class="pre">forall</span> <span class="pre">r.</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">(f</span> <span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span> <span class="pre">}</span></code>, instead of <code class="docutils literal notranslate"><span class="pre">Codensity</span> <span class="pre">f</span> <span class="pre">a</span></code>. The claim is that this type is “smaller” than Codensity in the sense that the inhabitants of <code class="docutils literal notranslate"><span class="pre">F</span></code> are in a one-to-one correspondence with those of <code class="docutils literal notranslate"><span class="pre">Free</span> <span class="pre">f</span> <span class="pre">a</span></code>. But what we are interested in is <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code>; the recursive layering actually adds extra inhabitants as well, and there is also the <code class="docutils literal notranslate"><span class="pre">Pure</span></code> constructor that doesn’t make much sense for I/O. For example <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">Identity</span> <span class="pre">()</span></code> is the type of Church numerals, <code class="docutils literal notranslate"><span class="pre">(r</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">(r</span> <span class="pre">-&gt;</span> <span class="pre">r)</span></code> while <code class="docutils literal notranslate"><span class="pre">Codensity</span> <span class="pre">Identity</span> <span class="pre">()</span> <span class="pre">=</span> <span class="pre">forall</span> <span class="pre">r.</span> <span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">r</span> <span class="pre">=</span> <span class="pre">()</span> <span class="pre">=</span> <span class="pre">Identity</span> <span class="pre">()</span></code>. So in this case it is actually <code class="docutils literal notranslate"><span class="pre">F</span></code> that is larger.</p>
<p>Just looking at the types, F has more arrows. Similarly compare the instances:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- F f</span>
<span class="nf">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">kp</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">kp</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="kt">F</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">kp</span><span class="w"> </span><span class="n">kf</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">runF</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">kp</span><span class="w"> </span><span class="n">kf</span><span class="p">)</span><span class="w"> </span><span class="n">kf</span><span class="p">)</span>

<span class="c1">-- C f</span>
<span class="nf">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="nf">m</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">runC</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">runC</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">))</span>
</pre></div>
</div>
<p>The instance for <code class="docutils literal notranslate"><span class="pre">C</span></code> is fewer characters.</p>
<p>There is <span id="id14">[<a class="reference internal" href="../zzreferences.html#id136" title="Exequiel Rivas and Mauro Jaskelioff. Notions of computation as monoids. Journal of Functional Programming, May 2014. URL: https://www.cambridge.org/core/journals/journal-of-functional-programming/article/notions-of-computation-as-monoids/70019FC0F2384270E9F41B9719042528 (visited on 2022-06-08), doi:10.1017/S0956796817000132.">RJ14</a>]</span> which derives the Codensity monad from the Yoneda lemma and the assumption that <code class="docutils literal notranslate"><span class="pre">f</span></code> is a small functor. Whereas the Yoneda-Rec seems to have no category theory behind it.</p>
<p>Generally it seems that Yoneda solves a different problem than an I/O monad.</p>
</section>
<section id="algebraic-effects">
<h3>Algebraic effects<a class="headerlink" href="#algebraic-effects" title="Permalink to this heading"></a></h3>
<p>Codensity and algebraic effects are quite similar, both using a data type to represent operations. In fact the two are macro-expressively equivalent. <span id="id15">[<a class="reference internal" href="../zzreferences.html#id61" title="Yannick Forster, Ohad Kammar, Sam Lindley, and Matija Pretnar. On the Expressive Power of User-Defined Effects: Effect Handlers, Monadic Reflection, Delimited Control. arXiv:1610.09161 [cs], February 2017. URL: http://arxiv.org/abs/1610.09161 (visited on 2021-11-29), arXiv:1610.09161.">FKLP17</a>]</span> But Codensity doesn’t require new syntax unlike the handler functionality. In the effect approach, computations are not first-class values.</p>
<p>OTOH effect types are quite useful, because you can define code that is polymorphic over the effect type, hence can be used as both pure and impure code. They use a monadic translation and then pure code is the identity monad. This can be shoehorned into continuations too by using a symbol marker with cases for pure and impure but maybe it is not as nice.</p>
</section>
<section id="call-by-push-value">
<h3>Call by push value<a class="headerlink" href="#call-by-push-value" title="Permalink to this heading"></a></h3>
<p>CBPV has “values” and “computations”. The original presentation has these as separate categories, but <span id="id16">[<a class="reference internal" href="../zzreferences.html#id52" title="J. Egger, R. E. Mogelberg, and A. Simpson. The enriched effect calculus: syntax and semantics. Journal of Logic and Computation, 24(3):615–654, June 2014. URL: https://academic.oup.com/logcom/article-lookup/doi/10.1093/logcom/exs025 (visited on 2021-11-09), doi:10.1093/logcom/exs025.">EMS14</a>]</span> presents an alternative calculus EC+ where every computation is also a value. There is exactly one primitive that sequences computation, <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">to</span> <span class="pre">x.</span> <span class="pre">N</span></code>, which acts like the monadic bind <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">&gt;&gt;=</span> <span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">N</span></code>, and similarly there is <code class="docutils literal notranslate"><span class="pre">return</span></code>. And the evaluation is CBV. So stripping away the thunk stuff it seems to be a disguised version of monads. And the thunk stuff is a rather fragile way to implement CBN - it doesn’t generalize to call by need. <span id="id17">[<a class="reference internal" href="../zzreferences.html#id110" title="Dylan McDermott and Alan Mycroft. Extended Call-by-Push-Value: Reasoning About Effectful Programs and Evaluation Order. In Luís Caires, editor, Programming Languages and Systems, volume 11423, pages 235–262. Springer International Publishing, Cham, 2019. URL: http://link.springer.com/10.1007/978-3-030-17184-1_9 (visited on 2021-11-09), doi:10.1007/978-3-030-17184-1_9.">MM19</a>]</span> And then there is jump-with-argument (JWA) which uses continuations and is equivalent to CBPV.</p>
</section>
<section id="applicative">
<h3>Applicative<a class="headerlink" href="#applicative" title="Permalink to this heading"></a></h3>
<p>All uses of Applicative can be rewritten using the laws to be of the form <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">a</span> <span class="pre">&lt;*&gt;</span> <span class="pre">b</span> <span class="pre">...</span> <span class="pre">&lt;*&gt;</span> <span class="pre">d</span></code> (where <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> is left associative), hence all uses can be rewritten to the idiom bracket syntax. And the idiom bracket syntax <code class="docutils literal notranslate"><span class="pre">([</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span> <span class="pre">])</span></code> can be replaced with variadic function syntax, <code class="docutils literal notranslate"><span class="pre">apply_thing</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code>. So variadic functions are sufficient.</p>
<p>Applicative can also be represented typeclass-free as functions using their Cayley representation and the Yoneda lemma, see <span id="id18">[<a class="reference internal" href="../zzreferences.html#id136" title="Exequiel Rivas and Mauro Jaskelioff. Notions of computation as monoids. Journal of Functional Programming, May 2014. URL: https://www.cambridge.org/core/journals/journal-of-functional-programming/article/notions-of-computation-as-monoids/70019FC0F2384270E9F41B9719042528 (visited on 2022-06-08), doi:10.1017/S0956796817000132.">RJ14</a>]</span> and <a class="reference external" href="https://fa.haskell.narkive.com/hUgYjfKJ/haskell-cafe-the-mother-of-all-functors-monads-categories#post3">this email</a>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Rep</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
<span class="kt">Yoneda</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span>
<span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Rep</span><span class="w"> </span><span class="p">(</span><span class="kt">Yoneda</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">a</span>
<span class="nf">pure</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span>

<span class="nf">lift</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">pure</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">((</span><span class="o">&lt;*&gt;</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span>
<span class="nf">lower</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
<p>So every function <code class="docutils literal notranslate"><span class="pre">Applicative</span> <span class="pre">f</span> <span class="pre">=&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">...</span></code> can be replaced with <code class="docutils literal notranslate"><span class="pre">Applicative</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Applicative</span> <span class="pre">f</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">...</span></code> - the normalization enabled by Cayley and Yoneda means you don’t have to worry about instance coherency.</p>
</section>
<section id="promises">
<h3>Promises<a class="headerlink" href="#promises" title="Permalink to this heading"></a></h3>
<p>An example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">function</span><span class="w"> </span><span class="n">foo</span><span class="nb">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="n">f</span><span class="nb">()</span><span class="o">.</span><span class="kr">then</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">then</span></code> operation is basically monadic bind, so this is another form of monad syntax. There are <a class="reference external" href="https://buzzdecafe.github.io/2018/04/10/no-promises-are-not-monads">inconsistencies</a> with the Monad laws due to Promise flattening, which are enshrined in the spec and <a class="reference external" href="https://github.com/promises-aplus/promises-spec/issues/94">unfixable</a> without creating a wrapper API. But ignoring those, the Promise type is something like <code class="docutils literal notranslate"><span class="pre">Promise</span> <span class="pre">err</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Fulfilled</span> <span class="pre">a</span> <span class="pre">|</span> <span class="pre">Rejected</span> <span class="pre">err</span> <span class="pre">|</span> <span class="pre">Pending</span> <span class="pre">({</span> <span class="pre">resolve</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">(),</span> <span class="pre">reject</span> <span class="pre">:</span> <span class="pre">err</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()}</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">())</span></code>, which focusing on <code class="docutils literal notranslate"><span class="pre">Pending</span></code> is a CPS monad <code class="docutils literal notranslate"><span class="pre">(Either</span> <span class="pre">err</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">())</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span> <span class="pre">=</span> <span class="pre">EitherT</span> <span class="pre">err</span> <span class="pre">(Cont</span> <span class="pre">(IO</span> <span class="pre">()))</span> <span class="pre">a</span></code>.</p>
<p>Some arguments against:</p>
<ul class="simple">
<li><p>Promises do not conform to functor or monad laws and thus are not safe for compositional refactoring.</p></li>
<li><p>JS promises allow execution after the promise is resolved or rejected, resulting in untraceable behavior (fixed in C# by overriding return/throw instead of using resolve/reject)</p></li>
</ul>
</section>
<section id="monad-combined-with-identity-monad">
<h3>Monad combined with identity monad<a class="headerlink" href="#monad-combined-with-identity-monad" title="Permalink to this heading"></a></h3>
<p>With the lazy identity monad you can recover lazy pure code, as if there was no monad syntax. <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">m</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Either</span> <span class="pre">a</span> <span class="pre">(m</span> <span class="pre">a)</span></code> is a monad (<a class="reference external" href="https://stackoverflow.com/a/49703783">SO implementation</a>) so we can mix this in with other monads. For a dynamic language, we would like to split the universal type <code class="docutils literal notranslate"><span class="pre">Any</span></code> into actions and pure values, so that <code class="docutils literal notranslate"><span class="pre">Any</span></code> forms a monad and actions are just a special type of value that has more complex sequencing behavior. We calculate:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Any</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Either</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Either</span><span class="w"> </span><span class="kt">Pure</span><span class="w"> </span><span class="kt">Action</span>
<span class="kt">Pure</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span>
<span class="kt">Action</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">Pure</span>
<span class="kt">Pure</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Any</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="kt">Action</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Int</span></code> is not <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">_</span></code>, so it is pure. <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">Int</span></code> is therefore an action. Therefore <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">(m</span> <span class="pre">Int)</span></code> is not an action, because to be an action it would have to return a pure value. Hence <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">(m</span> <span class="pre">Int)</span></code> is pure, a surprising conclusion. Similarly <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">(m</span> <span class="pre">(m</span> <span class="pre">Int))</span></code> is an action. We can convert between these with <code class="docutils literal notranslate"><span class="pre">join</span></code> and <code class="docutils literal notranslate"><span class="pre">return</span></code>. This weirdness somewhat explains why JS felt the need to collapse nested promises and break the monad laws - it avoids the need to unroll the promise chain to deduce whether a value is an action.</p>
</section>
<section id="async">
<h3>Async<a class="headerlink" href="#async" title="Permalink to this heading"></a></h3>
<p>In JavaScript</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">async</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">foo</span><span class="nb">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">await</span><span class="w"> </span><span class="n">f</span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Async/await notation requires marking core library calls with “await” and the whole call chain with “async”, a tedious syntactic burden that Bob Nystrom calls <a class="reference external" href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">function coloring</a>.</p>
<p>It’s better to make the async behavior automatic. Zig has done this but has <a class="reference external" href="https://gavinhoward.com/2022/04/i-believe-zig-has-function-colors/">tons of bugs</a>. Monads in general and continuations in particular seem like a more principled approach, e.g. there is a <a class="reference external" href="https://github.com/dmitriz/cpsfy/blob/master/DOCUMENTATION.md">JS CPS library</a>.</p>
</section>
<section id="futures">
<h3>Futures<a class="headerlink" href="#futures" title="Permalink to this heading"></a></h3>
<p>According to <a class="reference external" href="https://www.youtube.com/watch?v=QNpKYypLAO8">Erik Meijer</a> (38:16), futures are kind of like comonads. A comonad has three operations: fmap, extract, and duplicate. Fmap make sense for a future, you can apply a function on the result. Duplicate is a little pointless but also possible, you can make a future that returns a future. There is the question of why not just the monadic <code class="docutils literal notranslate"><span class="pre">return</span></code> but it sort of makes sense, a future is delayed whereas a value is not. Finally you can <code class="docutils literal notranslate"><span class="pre">extract</span></code> the value from a future. This one is really pushing it though because the extract operation blocks, and can throw a deadlock exception, so it’s not pure. We have to model extract more carefully as <code class="docutils literal notranslate"><span class="pre">Future</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">M</span> <span class="pre">a</span></code> for some monad. <span id="id19">[]</span> called this kind of comonad-monad function a “BiKleisli category”, i.e. the category <code class="docutils literal notranslate"><span class="pre">BiKlesli</span> <span class="pre">Future</span> <span class="pre">M</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">Future</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">M</span> <span class="pre">b</span></code>. So rather than the comonad structure, we just have the identity and composition operations of the category, and arrow stuff. So really we aren’t talking about comonads at all but rather arrows.</p>
</section>
<section id="tasks">
<span id="id20"></span><h3>Tasks<a class="headerlink" href="#tasks" title="Permalink to this heading"></a></h3>
<p>We can model I/O operations as members of a <code class="docutils literal notranslate"><span class="pre">Task</span></code> type, consisting of constructor terms plus callback(s) for what to do with the return value. Sequences of I/O operations are values of type <code class="docutils literal notranslate"><span class="pre">Task</span></code>, similar to a <a class="reference external" href="https://www.reddit.com/r/haskell/comments/swffy/why_do_we_not_define_io_as_a_free_monad/">free monad</a>. Statements that don’t return are directly of the Task type, like <code class="docutils literal notranslate"><span class="pre">Exit</span> <span class="pre">{</span> <span class="pre">code</span> <span class="pre">:</span> <span class="pre">Int}</span></code>. Statements that continue in a sequential fashion have a <code class="docutils literal notranslate"><span class="pre">continuation</span></code> argument, like <code class="docutils literal notranslate"><span class="pre">Print</span> <span class="pre">{</span> <span class="pre">s</span> <span class="pre">:</span> <span class="pre">String,</span> <span class="pre">continuation</span> <span class="pre">:</span> <span class="pre">Task</span> <span class="pre">}</span></code>, so are of type <code class="docutils literal notranslate"><span class="pre">Command</span> <span class="pre">=</span> <span class="pre">Task</span> <span class="pre">-&gt;</span> <span class="pre">Task</span></code>. Statements that return a value use a continuation of type <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Task</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">ReadFile</span> <span class="pre">{</span> <span class="pre">path</span> <span class="pre">:</span> <span class="pre">Fd,</span> <span class="pre">continuation</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">Task}</span></code>, so are of type <code class="docutils literal notranslate"><span class="pre">Operation</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">Task)</span> <span class="pre">-&gt;</span> <span class="pre">Task</span></code>. And since tasks are values we can also use them as arguments, like the <code class="docutils literal notranslate"><span class="pre">delayed_task</span></code> in <code class="docutils literal notranslate"><span class="pre">SetTimeout</span> <span class="pre">{</span> <span class="pre">delay</span> <span class="pre">:</span> <span class="pre">Int,</span> <span class="pre">delayed_task</span> <span class="pre">:</span> <span class="pre">Task,</span> <span class="pre">continuation</span> <span class="pre">:</span> <span class="pre">Task}</span></code>.</p>
<p>With this approach an I/O operation is data that can be pattern-matched over, allowing many metaprogramming techniques. It’s a little harder for the compiler to optimize that readIORef has no observable side effects, as it’s a reordering property (commutativity), but strict languages have been doing this for years.</p>
<p>To see how this works, consider the program <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;Hi&quot;</span></code>. As a task this is the value <code class="docutils literal notranslate"><span class="pre">Print</span> <span class="pre">&quot;Hi&quot;</span> <span class="pre">(Exit</span> <span class="pre">0)</span></code>, where <code class="docutils literal notranslate"><span class="pre">Exit</span> <span class="pre">0</span></code> is what happens after printing (the continuation). The operation is <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">Print</span> <span class="pre">a</span> <span class="pre">cont</span></code>. With the continuation as the last argument we can just use the partially-applied function, <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">=</span> <span class="pre">Print</span></code>. <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">a</span> <span class="pre">&gt;&gt;</span> <span class="pre">print</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">Print</span> <span class="pre">a</span> <span class="pre">(Print</span> <span class="pre">b</span> <span class="pre">cont)</span></code>. Now consider <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">ref</span> <span class="pre">&gt;&gt;=</span> <span class="pre">print</span></code>. The operation is <code class="docutils literal notranslate"><span class="pre">Read</span> <span class="pre">ref</span> <span class="pre">&gt;&gt;=</span> <span class="pre">Print</span></code> where <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> is the continuation monad’s bind operation, which expands to <code class="docutils literal notranslate"><span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">Read</span> <span class="pre">ref</span> <span class="pre">(\v</span> <span class="pre">-&gt;</span> <span class="pre">Print</span> <span class="pre">v</span> <span class="pre">cont)</span></code>.</p>
<p>Actually print isn’t a primitive operation, it’s more like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Data</span><span class="w"> </span><span class="s">&quot;Hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">msg</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">Block</span><span class="w"> </span><span class="s">&quot;_start&quot;</span><span class="w"> </span><span class="p">[</span><span class="kt">Sys_write</span><span class="w"> </span><span class="n">stdout</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Sys_exit</span><span class="w"> </span><span class="mi">0</span><span class="p">)])</span>
</pre></div>
</div>
<p>with Stroscot’s internal assembler language.</p>
<p>Task isn’t really a monad, but we can compose operations that return values using the continuation monad’s bind operation, as implemented with do-notation.</p>
<p>The datatype is similar to the “fudgets” mentioned in <span id="id21">[<a class="reference internal" href="../zzreferences.html#id58" title="Levent Erkok. Value Recursion in Monadic Computations. PhD thesis, Oregon Health and Science University, October 2002. URL: http://leventerkok.github.io/papers/erkok-thesis.pdf.">Erk02</a>]</span>, except we don’t have a pure constructor. Or <a class="reference external" href="http://comonad.com/reader/2011/free-monads-for-less-3/">this</a> type <code class="docutils literal notranslate"><span class="pre">FFI</span> <span class="pre">o</span> <span class="pre">i</span></code>, but with control flow represented explicitly instead of using <code class="docutils literal notranslate"><span class="pre">o</span></code> or <code class="docutils literal notranslate"><span class="pre">i</span></code> parameters.</p>
</section>
<section id="world-token">
<h3>World token<a class="headerlink" href="#world-token" title="Permalink to this heading"></a></h3>
<p>Haskell uses a state monad <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">s</span> <span class="pre">-&gt;</span> <span class="pre">(#</span> <span class="pre">s,</span> <span class="pre">a</span> <span class="pre">#))</span></code> for implementing I/O, where <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">World</span></code> is a special zero-sized token type. Clean is similar but <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">*World</span></code> has the uniqueness type annotation so the tokens must be used linearly. Regardless, this approach is quite awkward:</p>
<ul class="simple">
<li><p>Programs like <code class="docutils literal notranslate"><span class="pre">(a,_)</span> <span class="pre">=</span> <span class="pre">getChar</span> <span class="pre">s;</span> <span class="pre">(b,s')</span> <span class="pre">=</span> <span class="pre">getChar</span> <span class="pre">s;</span> <span class="pre">putChar</span> <span class="pre">(a,b)</span> <span class="pre">s'</span></code> that reuse tokens are broken and have to be forbidden. Similarly programs like <code class="docutils literal notranslate"><span class="pre">(a,s2)</span> <span class="pre">=</span> <span class="pre">getChar</span> <span class="pre">s;</span> <span class="pre">(b,s)</span> <span class="pre">=</span> <span class="pre">getChar</span> <span class="pre">s2</span></code> that pass the token back also have to be forbidden.</p></li>
<li><p>GHC requires many hacks to ensure that linearity holds during core-to-core transformations.</p></li>
<li><p>Commands like <code class="docutils literal notranslate"><span class="pre">exit</span> <span class="pre">0</span></code> have to be modeled as returning a world token, even though they don’t return at all.</p></li>
<li><p>It is not clear what the token represents: a thread? a core? a state? The semantics of an infinite program like <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">write</span> <span class="pre">&quot;x&quot;</span> <span class="pre">&gt;&gt;</span> <span class="pre">x</span></code> is tricky to specify - it is not really a function at all.</p></li>
<li><p>An I/O operation is an abstract function which makes it quite difficult to inspect IO values or implement simulations of I/O such as <a class="reference external" href="https://hackage.haskell.org/package/pure-io-0.2.1/docs/PureIO.html">PureIO</a>.</p></li>
</ul>
</section>
</section>
<section id="logic-programming">
<h2>Logic programming<a class="headerlink" href="#logic-programming" title="Permalink to this heading"></a></h2>
<p>To make a general-purpose relational programming language, we must find a method of embedding I/O that preserves the relational semantics. What I’ve come up with is to make programs produce a functional I/O term as output, so that the satisfying states contains bindings like <code class="docutils literal notranslate"><span class="pre">main</span> <span class="pre">=</span> <span class="pre">readln</span> <span class="pre">(\x</span> <span class="pre">-&gt;</span> <span class="pre">(print</span> <span class="pre">(&quot;hello</span> <span class="pre">&quot;++x)</span> <span class="pre">end)))</span></code>.</p>
<p>In general running a relational program may produce infinite satisfying states. Using the <code class="docutils literal notranslate"><span class="pre">run</span></code> function, the list of possible states of a term can be inspected, so it would limit expressiveness to disallow local nondeterminism. But nondeterminism in the I/O term is an error - there is no way to reconcile <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;b&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;c&quot;</span></code>, because the user can only see one output. Arbitrarily choosing a state would just be confusing. So we require that the I/O be unique over all satisfying states. In standalone programs the state only contains the <code class="docutils literal notranslate"><span class="pre">main</span></code> term, so this means standalone programs must be deterministic overall and resolve to a single state. But <code class="docutils literal notranslate"><span class="pre">run</span></code> transforms a nondeterministic logic program to a deterministic stream of data, and spawning threads uses a fresh <code class="docutils literal notranslate"><span class="pre">threadMain</span></code> binding, so this shouldn’t be too restrictive. Mercury <a class="reference external" href="https://www.mercurylang.org/information/doc-latest/mercury_trans_guide/IO.html">uses</a> the “unique world” state-passing model of I/O, and has a similar restriction that predicates that do I/O must be deterministic (may not fail or return multiple times).</p>
</section>
<section id="colored-values">
<h2>Colored values<a class="headerlink" href="#colored-values" title="Permalink to this heading"></a></h2>
<p>Often mentioned during I/O discussions are Bob Nystrom’s traits of <a class="reference external" href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">function coloring</a>. <a class="reference external" href="https://news.ycombinator.com/item?id=8985436">tel on HN</a> suggested using red = impure, and <a class="reference external" href="https://gavinhoward.com/2022/04/i-believe-zig-has-function-colors/#review-of-function-colors">Gavin</a> suggested replacing “call” with “use”. Most of the traits are then about “impure functions”, which Stroscot calls actions. Stroscot allows running actions in a pure environment using an I/O simulation. With these modifications the traits read:</p>
<ol class="arabic simple">
<li><p>Values include pure functions and actions.</p></li>
<li><p>The way you use a value depends on its type.</p></li>
<li><p>You can only use an action from within another action, or within an I/O simulator.</p></li>
<li><p>Actions are more painful to use (than pure functions).</p></li>
<li><p>Some core library members are actions.</p></li>
</ol>
<p>The only trait here that might be disadvantageous is 4. Nystrom lists the following pain points for JS async actions:</p>
<ul class="simple">
<li><p>verbose to compose in expressions because of the callbacks / promise goop</p></li>
<li><p>annoying hoops to use error-handling</p></li>
<li><p>can’t be used with try/catch or a lot of other control flow statements.</p></li>
<li><p>can’t call a function that returns a future from synchronous code</p></li>
</ul>
<p>C# async-await solves all but the first, but the await keyword is still painful. Nystrom says the real solution is “multiple independent callstacks that can be switched between.” Stroscot goes further than switching and makes I/O callstacks first-class continuations. With continuations as the I/O abstraction, there is no distinction between sync and async, or rather it is all async. In particular all low-level operations are implemented in async style (taking callbacks), and combinators must be written using the callback/continuation model. But simple sequential code can be written in sync style and this interoperates seamlessly with the async code. Thus Stroscot’s I/O continuation model solves the distinction pain Nystrom was complaining about.</p>
<p>There is still a pure/impure dichotomy though. Regardless of syntax, impurity cannot be hidden completely. Actions will always have some conceptual overhead compared to pure functions because they are sensitive to execution order. I don’t know if this will make anyone “spit in your coffee and/or deposit some even less savory fluids in it” (Nystrom), but I/O is unfortunately awkward in a pure or mathematical world. A program that does no I/O must be an infinite loop (it cannot even exit, because that requires a syscall). <span id="id22">[<a class="reference internal" href="../zzreferences.html#id84" title="Simon Peyton Jones. Tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell. In Engineering Theories of Software Construction, 47–96. 2001. URL: https://www.microsoft.com/en-us/research/publication/tackling-awkward-squad-monadic-inputoutput-concurrency-exceptions-foreign-language-calls-haskell/.">Jon01</a>]</span> classifies I/O under the “awkward squad”.</p>
</section>
<section id="unsafe-i-o">
<h2>“Unsafe” I/O<a class="headerlink" href="#unsafe-i-o" title="Permalink to this heading"></a></h2>
<p>Haskell has <code class="docutils literal notranslate"><span class="pre">runST</span></code> and <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code> that allow turning impure computation into pure computations. These can be implemented by throwing a resumable exception that’s caught in a top-level handler that does the I/O. <code class="docutils literal notranslate"><span class="pre">runST</span></code> scrutinizes its computation for impure behavior such as printing or returning allocated references, while <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code> does not and exposes the internal evaluation order.</p>
<p>If one wants to understand the evaluation order or is dealing with commutative operations, these functions are quite useful, e.g. Debug.Trace.trace looks like a non-I/O function but actually outputs something on the console, and allocation can be done in any order.</p>
<p>The main things to avoid is global variables like <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">unsafePerformIO</span> <span class="pre">(newIORef</span> <span class="pre">1)</span></code> pattern. Implicit parameters initialized in main compose much better. Similarly C’s <code class="docutils literal notranslate"><span class="pre">static</span></code> variables inlined in functions should be forbidden. Although, optimal reduction should mean an unsafePerformIO is only evaluated once, hence reading a file or something should be fine.</p>
<section id="top-level-i-o">
<h3>Top-level I/O<a class="headerlink" href="#top-level-i-o" title="Permalink to this heading"></a></h3>
<p>In Python we can write a simple script like <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;hello</span> <span class="pre">world&quot;</span></code>. In Haskell we must have the boilerplate <code class="docutils literal notranslate"><span class="pre">main</span> <span class="pre">=</span></code>, which is more verbose. We can address this by allowing modules to be actions that return the actual record. The main issue is we must have an instance of MonadFix in order to tie the recursive knot. But fortunately there are <a class="reference external" href="https://github.com/ekmett/kan-extensions/issues/64">several implementations</a> of MonadFix for continuations; the only question is which one is correct.</p>
<p>The other option is to restrict I/O outside of main, e.g. to only the main module, which means that e.g. mutable variables cannot exist between calls of a function. This seems too restrictive.</p>
<blockquote>
<div><ul class="simple">
<li><p>pure data, pure state, pure value - immutable data/state/value, cannot be modified and does not depend on any external factors</p></li>
<li><p>pure expression - Side-effect-free expression, evaluates to a value without any side effects. Also, deterministic expression, for an expression that has only one value. So instead of “impure expression” refer to an expression that has no value (unevaluatable expression) or multiple values (ambiguous expression) or executes side effects (imperative expression). Actually with the TRS formalism I use every expression is evaluatable so we don’t worry about unevaluatable expressions.</p></li>
<li><p>pure programming language - a language that models the program as a mathematical function and enforces a clear distinction between immutable values and mutable or side-effectful expressions. Kind of a broad concept so doesn’t need a term.</p></li>
</ul>
</div></blockquote>
<p>Stroscot is pure, because purity is great for equational reasoning. But it’s also not pure, because pure programs can’t do anything imperative. Confused yet? Obviously. The issue is that “pure” is an undefined term and different people mean it to use different things.</p>
<p>In Stroscot there are shared non-global states (stores), and a non-shared global state (I/O). But there is no shared global state, as this leads to initialization races and non-reentrant operations. With the store mechanism a programmer is free to declare some variables and assign some state, and the store will be passed around automatically. But the store only contains a map from variables to data and it is instead the I/O mechanism which interacts with the file system, the network, and other resources.</p>
</section>
</section>
<section id="limitations-of-purity">
<h2>Limitations of purity<a class="headerlink" href="#limitations-of-purity" title="Permalink to this heading"></a></h2>
<p>At present, destructive update is required to implement some algorithms efficiently. In particular consider some languages:</p>
<ol class="arabic simple">
<li><p>PURE: a “pure” CBV Lisp using a small set of primitive Lisp operations, <code class="docutils literal notranslate"><span class="pre">ATOM</span> <span class="pre">EQ</span> <span class="pre">READ</span> <span class="pre">WRITE</span> <span class="pre">CONS</span> <span class="pre">CAR</span> <span class="pre">CDR</span></code> assumed to be of constant cost, and “flow-chart style” control flow, assumed free</p></li>
<li><p>IMPURE: the Lisp extended with destructive mutation operators <code class="docutils literal notranslate"><span class="pre">RPLACA</span> <span class="pre">RPLACD</span></code> also of constant cost</p></li>
<li><p>HASK: a Haskell with lambdas, case, tuples, and lists</p></li>
<li><p>CYCLE: PURE but with an operation to construct cyclic data structures, CYCLE</p></li>
</ol>
<p>It has been established that PURE ⊆ CYCLE ⊊ HASK ⊆ IMPURE as far as expressing efficient online programs:</p>
<ul class="simple">
<li><p>For the first relation, PURE programs can be run unmodified in CYCLE with equivalent reduction steps, showing inclusion. <span id="id23">[<a class="reference internal" href="../zzreferences.html#id17" title="Amir M. Ben-amram. Notes on Pippenger's Comparison of Pure and Impure LISP. 1996. URL: citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.3024&amp;rep=rep1&amp;type=pdf.">Benamram96</a>]</span> says that it is an open problem to demonstrate an efficiency advantage of CYCLE over PURE.</p></li>
<li><p>For the second relation, lazy languages allow cycles, hence showing inclusion. <span id="id24">[<a class="reference internal" href="../zzreferences.html#id17" title="Amir M. Ben-amram. Notes on Pippenger's Comparison of Pure and Impure LISP. 1996. URL: citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.3024&amp;rep=rep1&amp;type=pdf.">Benamram96</a>]</span> says that <span id="id25">[<a class="reference internal" href="../zzreferences.html#id128" title="Nicholas Pippenger. Pure versus impure Lisp. ACM Transactions on Programming Languages and Systems, 19(2):223–238, March 1997. URL: https://dl.acm.org/doi/10.1145/244795.244798 (visited on 2022-01-06), doi:10.1145/244795.244798.">Pip97</a>]</span> shows that for a specific online problem “perm” any CYCLE solution will require at least O(n log n) time. The proof depends on the property of CYCLE that a cons cell can refer only to itself or previously-constructed values, which does not hold for LAZY as it allows naming future computations. <span id="id26">[<a class="reference internal" href="../zzreferences.html#id19" title="Richard Bird, Geraint Jones, and Oege De Moor. More haste, less speed: lazy versus eager evaluation. Journal of Functional Programming, 7(5):541–547, September 1997. URL: https://www.cambridge.org/core/journals/journal-of-functional-programming/article/more-haste-less-speed-lazy-versus-eager-evaluation/162B391CBCD864794C766CA2A2EC7CBE (visited on 2022-01-06), doi:10.1017/S0956796897002827.">BJM97</a>]</span> demonstrate that HASK can solve “perm” in amortized O(n) time, via the use of lazy streams, hence HASK is strictly more efficient than CYCLE.</p></li>
<li><p>For the third relation, the thunk mechanism of HASK can be emulated in IMPURE, showing inclusion. <span id="id27">[<a class="reference internal" href="../zzreferences.html#id17" title="Amir M. Ben-amram. Notes on Pippenger's Comparison of Pure and Impure LISP. 1996. URL: citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.3024&amp;rep=rep1&amp;type=pdf.">Benamram96</a>]</span> theorizes that for IMPURE programs following a read-update-write structure, there is a correspondingly efficient HASK program. Since Haskell 1.0 programs use a lazy stream <code class="docutils literal notranslate"><span class="pre">[Response]</span> <span class="pre">-&gt;</span> <span class="pre">[Request]</span></code> for I/O, this read-update-write model seems to encompass all programs, hence it seems likely that the two languages are of equal efficiency, although nobody has formally proved this (TODO).</p></li>
</ul>
<p>The log(n) gap between CYCLE and HASK is calculated using the cost of updating a balanced binary tree. This is the cost of the predecessor problem in the <a class="reference external" href="https://en.wikipedia.org/wiki/Pointer_machine">pointer machine</a>. In the more accurate RAM model the update cost is optimally O(log log m) time under some assumptions. (<span id="id28">[<a class="reference internal" href="../zzreferences.html#id155" title="Milan Straka. Functional Data Stuctures and Algorithms. PhD thesis, Computer Science Institute of Charles University, September 2013. URL: https://dspace.cuni.cz/handle/20.500.11956/52896 (visited on 2022-01-04).">Str13</a>]</span>, chapter 5) Straka’s implementation uses vEB trees which have a huge constant factor and space usage, but y-fast trees probably work too for a practical implementation.</p>
<p>Still though, a gap is a gap, so to get performance we must provide laziness or destructive update. And programming efficient amortized pure lazy data structures is quite complex, and not well-studied. It seems that any practical programming language will have to provide destructive update.</p>
</section>
<section id="automatic-destructive-update">
<h2>Automatic destructive update<a class="headerlink" href="#automatic-destructive-update" title="Permalink to this heading"></a></h2>
<p>Although pure programs do not have operators for destructive update, they can still express similar programs using a copying update operation that returns a new data structure with the relevant index modified. For <a class="reference external" href="https://prog21.dadgum.com/41.html">example</a> counting the frequency of byte values within a block of binary data:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">freq</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Binary</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">scanr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">arr</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">repeat</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">b</span>

<span class="c1">-- expands to:</span>

<span class="nf">freq</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Binary</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="n">repeat</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="n">go</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="n">rest</span><span class="w"> </span><span class="p">(</span><span class="n">update</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span>
<span class="w">    </span><span class="n">go</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">arr</span>
</pre></div>
</div>
<p>The issue is that a naive implementation of “update” copies the entire array, using O(n) memory and time. <span id="id29">[<a class="reference internal" href="../zzreferences.html#id77" title="Paul Hudak and Adrienne Bloss. The aggregate update problem in functional programming systems. In Proceedings of the 12th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages - POPL '85, 300–314. New Orleans, Louisiana, United States, 1985. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=318593.318660 (visited on 2022-01-04), doi:10.1145/318593.318660.">HB85</a>]</span> shows that with a compiler analysis (hereafter called “automatic destructive update”) a language can provide O(1) update-copy operations. The compiler searches through possible evaluation orders for an evaluation order that never accesses the old version of data after updating, and transforms such “single-threaded” programs to destructively update, giving the speedup. Programming with pure arrays in a “single-threaded” style is at least as expressive as imperative arrays - per Hudak, all the natural translations of imperative algorithms are single-threaded. Some of <span id="id30">[<a class="reference internal" href="../zzreferences.html#id123" title="Chris Okasaki. Purely Functional Data Structures. Cambridge University Press, Cambridge, U.K. ; New York, 1998. ISBN 978-0-521-63124-2.">Oka98</a>]</span>’s lazy data structures have a similar single-threaded use condition for amortized good performance, so the single-threaded condition seems reasonable. Also well-defined Ocaml programs that use side effects must be single-threaded, else there is a race condition.</p>
<p>Roc and Koka seem to be going down the automatic destructive update route via alias analysis and ref-counting optimizations. It seems like a great optimization and it does not seem too hard to allow marking array uses as single-threaded so the compiler warns if it has to copy.</p>
<p>Haskell avoided automatic destructive update because per SPJ it seemed too complicated, and instead relies on monads. Monadic style fixes an evaluation order, hence guarantees single threading because the old version is inaccessible. Monadic style is verbose, because simple function applications require the use of Applicative like <code class="docutils literal notranslate"><span class="pre">liftA</span> <span class="pre">(+)</span> <span class="pre">1</span> <span class="pre">2</span></code>. It also is not very composable because <code class="docutils literal notranslate"><span class="pre">runST</span></code> is required to escape from the monad and the phantom state token type prevents mixing certain computations.</p>
<p>Clean has uniqueness types, which also enforce single threadedness. Uniqueness types disallow a simple example of implementing id in terms of const:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">id</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span>
<span class="nf">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span>

<span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="n">a</span>
<span class="nf">b</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">10</span>
</pre></div>
</div>
<p>Automatic destructive update may or may not work on this example depending on how smart the compiler is. But it definitely works on all uniqueness-typable programs, and is pretty much syntactically identical. So this is another case of tractable but incomplete vs difficult but complete - Stroscot aims for completeness.</p>
</section>
<section id="store">
<h2>Store<a class="headerlink" href="#store" title="Permalink to this heading"></a></h2>
<p>We can formalize traditional imperative programming with mutable variables using the notion of a store. A store is a first-class value representing a subset of computer memory. It is basically a map from identifiers to values, a little “bundle of state”, but it’s more complicated than just a hash table to as to support implicit concurrency in expressions. In particular a store is a per-variable ordered list of reads and writes so that read-write and write-write conflicts may be detected.</p>
<p>A function that uses the store is a value of the State monad, <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">-&gt;</span> <span class="pre">(s,</span> <span class="pre">a)</span></code>, where <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">Store</span></code>. For example an assignment statement <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:=</span> <span class="pre">f</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">g</span> <span class="pre">c</span></code> translates to</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">\</span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">s1a</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="s">&quot;b&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">s1a</span>
<span class="w">  </span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">s2a</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="s">&quot;c&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">s2a</span>
<span class="w">  </span><span class="n">s&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">merge</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">[</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">]</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="w">  </span><span class="n">update</span><span class="w"> </span><span class="n">s&#39;</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
<p>The store is passed into each function and returned as a result. The special <code class="docutils literal notranslate"><span class="pre">merge</span></code> operation combines concurrent stores and checks for conflicts by examining the list of operations - if there is a conflict, the variables involved are set to <code class="docutils literal notranslate"><span class="pre">DataRace</span></code> exceptions.</p>
<p><span id="id31">[]</span> has an asymmetric commit operation instead of a merge operation. This takes a parent and a child and propagates child writes to the parent. This is impure, still requiring a global state (the root). For example the behavior of this program seems really unintuitive:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">thisWorld</span><span class="o">.</span><span class="n">sprout</span><span class="nb">()</span>
<span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
<span class="kr">in</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="c1">-- prints 2, not 1</span>
</pre></div>
</div>
<p>IMO it is much more intuitive to have a “snapshot” model that merges immutable map-like structures, so that the program works like so:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">currentState</span>
<span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">with</span><span class="w"> </span><span class="n">state</span><span class="ow">=</span><span class="kt">A</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="c1">-- prints 1</span>
</pre></div>
</div>
<p>The “worlds” approach seems to have adopted the asymmetric model based on Javascript’s property lookup semantics. Per <span id="id32">[]</span> the rollback and undo examples they give can be implemented just as easily using the snapshot model.</p>
<p>The allowed “side effects” of stores are restricted to variable updates - I/O such as reading files and networking is not possible, because the program can’t continue without external input, but it has already been given the full state of the store so there is no further place to insert this input. But per <span id="id33">[]</span> continuations and stores can coexist. The idea is that a continuation takes a result continuation and a store, operates on the store, then calls the result continuation with a final store and the result. So the type of a continuation returning <code class="docutils literal notranslate"><span class="pre">a</span></code> is <code class="docutils literal notranslate"><span class="pre">(Store</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">Store</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>. Written differently this is <code class="docutils literal notranslate"><span class="pre">Store</span> <span class="pre">-&gt;</span> <span class="pre">((Store,</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code> which is <code class="docutils literal notranslate"><span class="pre">Store</span> <span class="pre">-&gt;</span> <span class="pre">Cont</span> <span class="pre">r</span> <span class="pre">(Store,</span> <span class="pre">a)</span></code> or <code class="docutils literal notranslate"><span class="pre">StateT</span> <span class="pre">(Cont</span> <span class="pre">r)</span> <span class="pre">Store</span> <span class="pre">a</span></code>.</p>
<p>In fact monads and continuation-based IO can express mutable variable programming directly, e.g. Haskell has the <code class="docutils literal notranslate"><span class="pre">readIORef</span></code> primitive. So first-class stores aren’t actually necessary. But per <span id="id34">[]</span> “the resulting increase in power of the environment appears to be well worth the cost” (in complexity and implementation overhead). The store has several advantages:</p>
<ul class="simple">
<li><p>The store is a first-class value similar to a dictionary, whereas a continuation is similar to a linked list. Thus variable values can be accessed in O(1) time from a store value, whereas a continuation value must be stepped through sequentially (simulated) to extract values, requiring O(n) time. Essentially, the store formalizes program data state, while continuations formalize program control state. Per <span id="id35">[]</span>, continuations do not capture the state of mutable objects. For example, <code class="docutils literal notranslate"><span class="pre">callCC</span> <span class="pre">(\c</span> <span class="pre">-&gt;</span> <span class="pre">c;</span> <span class="pre">c);</span> <span class="pre">modify</span> <span class="pre">&quot;a&quot;</span> <span class="pre">(+1)</span></code> increments by 2, rather than setting <code class="docutils literal notranslate"><span class="pre">a</span></code> twice.</p></li>
<li><p>It is much simpler semantically to use a store for implicitly concurrent computations. In the above example, where <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">c</span></code> run in parallel, if we used a monad we would have to sequence the operations <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">f</span> <span class="pre">b;</span> <span class="pre">y</span> <span class="pre">&lt;-</span> <span class="pre">g</span> <span class="pre">c</span></code> or use explicit <code class="docutils literal notranslate"><span class="pre">fork</span></code>/ <code class="docutils literal notranslate"><span class="pre">merge</span></code> operations <code class="docutils literal notranslate"><span class="pre">x_t</span> <span class="pre">&lt;-</span> <span class="pre">fork</span> <span class="pre">(f</span> <span class="pre">b);</span> <span class="pre">y_t</span> <span class="pre">&lt;-</span> <span class="pre">fork</span> <span class="pre">(g</span> <span class="pre">c);</span> <span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">wait</span> <span class="pre">x_t;</span> <span class="pre">y</span> <span class="pre">&lt;-</span> <span class="pre">wait</span> <span class="pre">y_t</span></code>. In either case, the operations are not fully commutative: in the first we cannot swap the order of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> if there is a data race, and in the second we cannot move a wait before a fork. In contrast the store’s <code class="docutils literal notranslate"><span class="pre">merge</span></code> operation is fully commutative because the result of a data race is well-defined to be an exception. The <code class="docutils literal notranslate"><span class="pre">wait/fork</span></code> machinery is not needed as it is simply passing around a value. Essentially stores provide a transactional view of memory.</p></li>
<li><p>First-class stores allow manipulating the program data state in complex ways. Multiple stores may exist simultaneously, allowing isolated computations. In particular, the empty store value allows turning a stateful function into a pure function, without any type trickery like <code class="docutils literal notranslate"><span class="pre">runST</span></code>. More generally the ability to apply a function to different explicitly-written store values allows program testing and debugging.</p></li>
</ul>
<p>The efficient implementation of stores is somewhat of a research area. Automatic destructive update should allow linear or non-conflicting usage of the store to translate to direct memory reads and writes. With non-linear usage, efficiently making copies and allowing persistent access to old stores may require some cleverness, for example a persistent hash map backed by the persistent array found in <span id="id36">[]</span>. Per <span id="id37">[]</span> the cost of a stack-based implementation is about 10% overhead on an ancient machine. Per <span id="id38">[]</span> this can be reduced through caching optimizations, so that if a variable is looked up and we know it has not been written then it does not need to be looked up again, i.e. <code class="docutils literal notranslate"><span class="pre">lookup</span> <span class="pre">x</span> <span class="pre">(update</span> <span class="pre">s</span> <span class="pre">y</span> <span class="pre">yv)</span> <span class="pre">|</span> <span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">lookup</span> <span class="pre">s</span> <span class="pre">x</span></code>. We also want to coalesce updates and reads so that new versions do not have to be created all the time.</p>
<section id="store-state">
<h3>Store state<a class="headerlink" href="#store-state" title="Permalink to this heading"></a></h3>
<p>Most papers limit themselves to keeping the values of mutable variables in the store. But conceptually the state of a program could include the state of the computer, the stock market, quantum fluctuations, etc. - all information within the chronological past of a program. But practically we are limited to state that we can read and write deterministically. In particular the read operation must satisfy the associative array definition:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">read</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="n">write</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kt">D</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kt">D</span>
<span class="nf">read</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">emptyStore</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MissingValue</span>
</pre></div>
</div>
<p>So one constraint to be a variable is that the state must be accessible. So for example the kernel limits us - we do not have full control over peripheral devices or processes not related to ours. We can represent this by using shadowing access-controlled variables and returning <code class="docutils literal notranslate"><span class="pre">WriteFailed</span></code> for inaccessible variables.</p>
<p>Conveniently the CRIU project has a <a class="reference external" href="https://criu.org/Images">list</a> of what’s in the state of a Linux user process. We reproduce it here:</p>
<ul class="simple">
<li><p>Core process info</p>
<ul>
<li><p>name, sigmask, itimers, etc.</p></li>
<li><p>Task credentials: uids, gids, caps, etc.</p></li>
<li><p>Process tree linkage</p></li>
<li><p>arch-dependent information (registers, etc.)</p></li>
<li><p>Signal handling map</p></li>
<li><p>IDs of objects (mm, files, sihand, etc.) and namespaces</p></li>
</ul>
</li>
<li><p>Address space information (VMAs, segments, exe file, etc.)</p>
<ul>
<li><p>Info about which virtual regions are populated with data (pagemap)</p></li>
<li><p>4k page data dumps for each mapped page in the pagemap.</p></li>
</ul>
</li>
<li><p>Filesystem info</p>
<ul>
<li><p>chroot and chdir information</p></li>
<li><p>Open file descriptors</p></li>
<li><p>Paths to files opened with open(2) syscall</p></li>
<li><p>File paths remaps (e.g. for invisible files)</p></li>
<li><p>Ghost invisible files</p></li>
<li><p>Mountpoints information</p></li>
<li><p>Contents of a tmpfs filesystem</p></li>
</ul>
</li>
<li><p>Special fd’s / sockets</p>
<ul>
<li><p>Eventfd file information</p></li>
<li><p>Eventpoll file information</p></li>
<li><p>Target file descriptors of eventpoll fds</p></li>
<li><p>Inotify file information</p></li>
<li><p>Watch descriptors of inotify fds</p></li>
<li><p>signalfd info</p></li>
<li><p>Pipes information</p></li>
<li><p>Contents of pipes (data sitting in a pipe)</p></li>
<li><p>FIFO information</p></li>
<li><p>Contents of FIFOs</p></li>
<li><p>Unix sockets</p></li>
<li><p>PF_INET sockets, both IPv4 and IPv6</p></li>
<li><p>Contents of socket queues</p></li>
<li><p>Interval timers state</p></li>
<li><p>TCP connection state (including data in queues)</p></li>
<li><p>Uname nodename and domainname of a UTS namespace</p></li>
<li><p>Information about opened TTYs, including Termios and similar stuff</p></li>
<li><p>Info about PF_PACKET sockets</p></li>
<li><p>Info about network devices</p></li>
<li><p>IP addresses on network devices</p></li>
<li><p>Routing tables</p></li>
</ul>
</li>
</ul>
<p>Usually these are modeled using primitive operations, e.g. file descriptors are allocated with the open syscall rather than declaratively as <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">fd1</span> <span class="pre">=</span> <span class="pre">inode</span> <span class="pre">1234</span> <span class="pre">}</span></code>. But the more state we model as state, the more powerful our debugging tools get. A traditional debugger has no way to undo closing a file. However, a filestate-aware debugger can reopen the file. The less we view the program as an I/O machine the easier it is to use high-bandwidth interfaces such as io_uring to perform bulk state changes - describing what rather than how is the hallmark of a high-level language. Of course, in most cases the program will use state in a single-threaded manner and it will simply be compiled to the primitive operation API by the automatic destructive update optimization.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Standard-Library.html" class="btn btn-neutral float-left" title="Standard library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Syntax.html" class="btn btn-neutral float-right" title="Syntax" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>