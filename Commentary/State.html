<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Imperative programming &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Syntax" href="Syntax.html" />
    <link rel="prev" title="Sets" href="Sets.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="F2G2_example.html">F2 G2</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fexprs.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">About</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Imperative programming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#limitations-of-purity">Limitations of purity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#automatic-destructive-update">Automatic destructive update</a></li>
<li class="toctree-l3"><a class="reference internal" href="#state">State</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tasks">Tasks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#i-o-model-showdown">I/O model showdown</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#continuations">Continuations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#monads">Monads</a></li>
<li class="toctree-l4"><a class="reference internal" href="#yoneda">Yoneda</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multi-prompt-delimited-continuations">Multi-prompt delimited continuations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#world-token">World token</a></li>
<li class="toctree-l4"><a class="reference internal" href="#algebraic-effects">Algebraic effects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#call-by-push-value">Call by push value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#applicative">Applicative</a></li>
<li class="toctree-l4"><a class="reference internal" href="#async">Async</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#colored-values">Colored values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unsafe-i-o">“Unsafe” I/O</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Commentary</a> &raquo;</li>
      <li>Imperative programming</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/State.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="imperative-programming">
<h1>Imperative programming<a class="headerlink" href="#imperative-programming" title="Permalink to this heading"></a></h1>
<section id="limitations-of-purity">
<h2>Limitations of purity<a class="headerlink" href="#limitations-of-purity" title="Permalink to this heading"></a></h2>
<p>At present, destructive update is required to implement some algorithms efficiently. In particular consider some classes of language:</p>
<ol class="arabic simple">
<li><p>PURE: a “pure” CBV Lisp using a small set of primitive Lisp operations, <code class="docutils literal notranslate"><span class="pre">ATOM</span> <span class="pre">EQ</span> <span class="pre">READ</span> <span class="pre">WRITE</span> <span class="pre">CONS</span> <span class="pre">CAR</span> <span class="pre">CDR</span></code> assumed to be of constant cost, and “flow-chart style” control flow, assumed free</p></li>
<li><p>IMPURE: the Lisp extended with destructive mutation operators <code class="docutils literal notranslate"><span class="pre">RPLACA</span> <span class="pre">RPLACD</span></code> also of constant cost</p></li>
<li><p>HASK: a Haskell with lambdas, case, tuples, and lists</p></li>
<li><p>CYCLE: PURE but with an operation to construct cyclic data structures, CYCLE</p></li>
</ol>
<p>It has been established that PURE &lt;= CYCLE &lt; HASK &lt;= IMPURE as far as expressing efficient online programs.</p>
<p>For the first relation, PURE programs can be run unmodified in CYCLE with equivalent reduction steps, showing inclusion. <span id="id1">[<a class="reference internal" href="../zzreferences.html#id11" title="Amir M. Ben-amram. Notes on Pippenger's Comparison of Pure and Impure LISP. 1996.">Benamram96</a>]</span> says that it is an open problem to demonstrate an advantage of CYCLE over PURE.</p>
<p>For the second relation, lazy languages allow cycles. <span id="id2">[<a class="reference internal" href="../zzreferences.html#id11" title="Amir M. Ben-amram. Notes on Pippenger's Comparison of Pure and Impure LISP. 1996.">Benamram96</a>]</span> says that <span id="id3">[<a class="reference internal" href="../zzreferences.html#id79" title="Nicholas Pippenger. Pure versus impure Lisp. ACM Transactions on Programming Languages and Systems, 19(2):223–238, March 1997. URL: https://dl.acm.org/doi/10.1145/244795.244798 (visited on 2022-01-06), doi:10.1145/244795.244798.">Pip97</a>]</span> shows that for a specific online problem “perm” any CYCLE solution will require at least O(n log n) time. The proof depends on the property of CYCLE that a cons cell can refer only to itself or previously-constructed values. <span id="id4">[<a class="reference internal" href="../zzreferences.html#id13" title="Richard Bird, Geraint Jones, and Oege De Moor. More haste, less speed: lazy versus eager evaluation. Journal of Functional Programming, 7(5):541–547, September 1997. URL: https://www.cambridge.org/core/journals/journal-of-functional-programming/article/more-haste-less-speed-lazy-versus-eager-evaluation/162B391CBCD864794C766CA2A2EC7CBE (visited on 2022-01-06), doi:10.1017/S0956796897002827.">BJM97</a>]</span> demonstrate that HASK can solve “perm” in amortized O(n) time, via the use of lazy streams, hence HASK is strictly more efficient than CYCLE.</p>
<p>For the third relation, it should be clear that the thunk mechanism of HASK can be emulated in IMPURE. <span id="id5">[<a class="reference internal" href="../zzreferences.html#id11" title="Amir M. Ben-amram. Notes on Pippenger's Comparison of Pure and Impure LISP. 1996.">Benamram96</a>]</span> theorizes that for IMPURE programs following a read-update-write structure, there is a correspondingly efficient HASK program. Since Haskell 1.0 programs use a lazy stream <code class="docutils literal notranslate"><span class="pre">[Response]</span> <span class="pre">-&gt;</span> <span class="pre">[Request]</span></code> for I/O, this read-update-write model seems to encompass all programs, hence it seems likely that the two languages are of equal efficiency, although nobody has formally proved this (TODO). But until then it is safer to assume HASK &lt; IMPURE and provide destructive update facilities.</p>
<p>The log(n) gap is calculated using the cost of updating a balanced binary tree. This is the cost of the predecessor problem in the <a class="reference external" href="https://en.wikipedia.org/wiki/Pointer_machine">pointer machine</a>. In the more accurate RAM model the update cost is optimally O(log log m) time under some assumptions. <span id="id6">[<a class="reference internal" href="../zzreferences.html#id95">Str</a>]</span></p>
</section>
<section id="automatic-destructive-update">
<h2>Automatic destructive update<a class="headerlink" href="#automatic-destructive-update" title="Permalink to this heading"></a></h2>
<p>Although pure programs do not have operators for destructive update, they can still express similar programs using an update operation that traverses and copies the data. <span id="id7">[<a class="reference internal" href="../zzreferences.html#id48" title="Paul Hudak and Adrienne Bloss. The aggregate update problem in functional programming systems. In Proceedings of the 12th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages - POPL '85, 300–314. New Orleans, Louisiana, United States, 1985. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=318593.318660 (visited on 2022-01-04), doi:10.1145/318593.318660.">HB85</a>]</span> shows that with a compiler analysis a language can provide O(1) update operations. The compiler searches through possible evaluation orders for an evaluation order that never accesses the old version of data after updating, and transforms such “single-threaded” programs to destructively update, giving the speedup. Programming with pure arrays in a “single-threaded” style is at least as expressive as imperative arrays - per Hudak, all the natural translations of imperative algorithms are single-threaded. Some of <span id="id8">[<a class="reference internal" href="../zzreferences.html#id76" title="Chris Okasaki. Purely Functional Data Structures. Cambridge University Press, Cambridge, U.K. ; New York, 1998. ISBN 978-0-521-63124-2.">Oka98</a>]</span>’s lazy data structures have a similar single-threaded use condition for amortized good performance, so the single-threaded condition seems reasonable.</p>
<p>Haskell avoided automatic destructive update because it seemed too complicated, and instead relies on monads. Monadic style fixes an evaluation order hence guarantees single threading because the old version is inaccessible. Side effects like in Ocaml also are single-threaded. Clean has uniqueness types, which also enforce single threadedness. Uniqueness types disallow a simple example of implementing id in terms of const:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">id</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="nf">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>

<span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"></span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">b</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
</pre></div>
</div>
<p>Roc and Koka seem to be going down the automatic destructive update route via alias analysis and ref-counting optimizations.</p>
<p>Above we take streams as primitive and define continuations in
terms of them. Conversely, with some cleverness it is also possi-
ble to take continuations as primitive and define streams in terms
of them (see (Hudak and Sundaresh, 1989), where the definition
of streams in terms of continuations is attributed to Peyton Jones).
However, the definition of streams in terms of continuations was
inefficient, requiring linear space and quadratic time in terms of
the number of requests issued, as opposed to the expected constant
space and linear time. For this reason, Haskell 1.0 defined streams
as primitive, and continuations in terms of them, even though con-
tinuations were considered easier to use for most purposes.</p>
</section>
<section id="state">
<h2>State<a class="headerlink" href="#state" title="Permalink to this heading"></a></h2>
<p>Conceptually the state of a program could include a lot of things, including the state of the computer, the stock market, quantum fluctuations, etc. - all information within the chronological past of a program. But since we are running on hardware we only care about the hardware’s state, and since the hardware is all digital it is deterministic and expressible as a long binary string. This string would include the kernel and peripheral devices and other processes not related to ours. If we assume we are running as a user process then we can limit ourselves to the process state. Conveniently the CRIU project has a <a class="reference external" href="https://criu.org/Images">list</a> of what’s in the state of a Linux process. We reproduce it here:</p>
<ul class="simple">
<li><p>Core process info</p>
<ul>
<li><p>name, sigmask, itimers, etc.</p></li>
<li><p>Task credentials: uids, gids, caps, etc.</p></li>
<li><p>Process tree linkage</p></li>
<li><p>arch-dependent information (registers, etc.)</p></li>
<li><p>Signal handling map</p></li>
<li><p>IDs of objects (mm, files, sihand, etc.) and namespaces</p></li>
</ul>
</li>
<li><p>Address space information (VMAs, segments, exe file, etc.)</p>
<ul>
<li><p>Info about which virtual regions are populated with data</p></li>
<li><p>4k page data dumps that are to be put into the memory according to the pagemap.</p></li>
</ul>
</li>
<li><p>Filesystem info</p>
<ul>
<li><p>chroot and chdir information</p></li>
<li><p>Open file descriptors</p></li>
<li><p>Paths to files opened with open(2) syscall</p></li>
<li><p>File paths remaps (e.g. for invisible files)</p></li>
<li><p>Ghost invisible files</p></li>
<li><p>Mountpoints information</p></li>
<li><p>Contents of a tmpfs filesystem</p></li>
</ul>
</li>
<li><p>Special fd’s / sockets</p>
<ul>
<li><p>Eventfd file information</p></li>
<li><p>Eventpoll file information</p></li>
<li><p>Target file descriptors of eventpoll fds</p></li>
<li><p>Inotify file information</p></li>
<li><p>Watch descriptors of inotify fds</p></li>
<li><p>signalfd info</p></li>
<li><p>Pipes information</p></li>
<li><p>Contents of pipes (data sitting in a pipe)</p></li>
<li><p>FIFO information</p></li>
<li><p>Contents of FIFOs</p></li>
<li><p>Unix sockets</p></li>
<li><p>PF_INET sockets, both IPv4 and IPv6</p></li>
<li><p>Contents of socket queues</p></li>
<li><p>Interval timers state</p></li>
<li><p>TCP connection state (including data in queues)</p></li>
<li><p>Uname nodename and domainname of a UTS namespace</p></li>
<li><p>Information about opened TTYs, including Termios and similar stuff</p></li>
<li><p>Info about PF_PACKET sockets</p></li>
<li><p>Info about network devices</p></li>
<li><p>IP addresses on network devices</p></li>
<li><p>Routing tables</p></li>
</ul>
</li>
</ul>
<p>What operations are there on this state? Well, it is an aggregate value, so we can read and update fields to form a new state:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">readField</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Field</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Any</span><span class="w"></span>
<span class="nf">setField</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Field</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Any</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">State</span><span class="w"></span>
</pre></div>
</div>
<p>But more interestingly we can load the state with CRIU (frozen), and attach a debugger. Let’s assume we have symbols, then there are lots of operations available from a debugger:</p>
<ul class="simple">
<li><p>dump memory, disassemble memory, print backtrace, print call stack, evaluate (pure) expression in context</p></li>
<li><p>patch executable, jump to address, return early from function, send signal</p></li>
<li><p>run subset of threads until breakpoint (breakpoint can be syscall, call, return, signal injection, etc.)</p></li>
<li><p>evaluate code in current context (e.g. set memory to value)</p></li>
</ul>
<p>The dumping and patching are not too interesting as they are just extending the field get/set to language-specific data formats. But with the breakpoints, particularly by setting breakpoints on syscalls, we get a view of the program as an I/O machine:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">injectSysCallRet</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="kt">SysCallRet</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">State</span><span class="w"></span>

<span class="nf">runToTimeout</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Timeout</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">State</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="kt">SysCallReq</span><span class="p">])</span><span class="w"></span>

<span class="nf">runSysCallsToSysCalls</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="kt">SysCallRet</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">State</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Timeout</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">State</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="kt">SysCallReq</span><span class="p">])</span><span class="w"></span>
<span class="nf">runSysCallsToSysCalls</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">runToTimeout</span><span class="w"> </span><span class="p">(</span><span class="n">injectSysCallRet</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">t</span><span class="w"></span>
</pre></div>
</div>
<p>There are multiple syscalls in flight because of multithreading. Technically we do not need <code class="docutils literal notranslate"><span class="pre">[SysCallReq]</span></code> because it can be determined from the state which threads are blocked on a syscall and what they requested, but the debugger knows this information from the breakpoint trap and it is clearer this way.</p>
</section>
<section id="tasks">
<span id="id9"></span><h2>Tasks<a class="headerlink" href="#tasks" title="Permalink to this heading"></a></h2>
<p>Tasks are a direct approach to I/O - sequences of I/O operations are values of type <code class="docutils literal notranslate"><span class="pre">Task</span></code>, similar to a <a class="reference external" href="https://www.reddit.com/r/haskell/comments/swffy/why_do_we_not_define_io_as_a_free_monad/">free monad</a>. Statements that don’t return are directly of the Task type, like <code class="docutils literal notranslate"><span class="pre">Exit</span> <span class="pre">{</span> <span class="pre">code</span> <span class="pre">:</span> <span class="pre">Int}</span></code>. Statements that continue in a sequential fashion have a <code class="docutils literal notranslate"><span class="pre">continuation</span></code> argument, like <code class="docutils literal notranslate"><span class="pre">Print</span> <span class="pre">{</span> <span class="pre">s</span> <span class="pre">:</span> <span class="pre">String,</span> <span class="pre">continuation</span> <span class="pre">:</span> <span class="pre">Task</span> <span class="pre">}</span></code>, so are of type <code class="docutils literal notranslate"><span class="pre">Command</span> <span class="pre">=</span> <span class="pre">Task</span> <span class="pre">-&gt;</span> <span class="pre">Task</span></code>. Statements that return a value use a continuation of type <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Task</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">ReadFile</span> <span class="pre">{</span> <span class="pre">path</span> <span class="pre">:</span> <span class="pre">Fd,</span> <span class="pre">continuation</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">Task}</span></code>, so are of type <code class="docutils literal notranslate"><span class="pre">Operation</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">Task)</span> <span class="pre">-&gt;</span> <span class="pre">Task</span></code>. And since tasks are values we can also use them as arguments, like the <code class="docutils literal notranslate"><span class="pre">delayed_task</span></code> in <code class="docutils literal notranslate"><span class="pre">SetTimeout</span> <span class="pre">{</span> <span class="pre">delay</span> <span class="pre">:</span> <span class="pre">Int,</span> <span class="pre">delayed_task</span> <span class="pre">:</span> <span class="pre">Task,</span> <span class="pre">continuation</span> <span class="pre">:</span> <span class="pre">Task}</span></code>.</p>
<p>To see how I/O works, consider printing hello world: <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;Hi&quot;</span></code>. As a task this looks like <code class="docutils literal notranslate"><span class="pre">Print</span> <span class="pre">&quot;Hi&quot;</span> <span class="pre">exit</span></code>, where <code class="docutils literal notranslate"><span class="pre">exit</span></code> is what happens after (the continuation). The operation is <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">Print</span> <span class="pre">a</span> <span class="pre">cont</span></code>. With the continuation as the last argument we can just use the partially-applied function, <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">=</span> <span class="pre">Print</span></code>. <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">a</span> <span class="pre">&gt;&gt;</span> <span class="pre">print</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">Print</span> <span class="pre">a</span> <span class="pre">(Print</span> <span class="pre">b</span> <span class="pre">cont)</span></code>. Now consider <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">ref</span> <span class="pre">&gt;&gt;=</span> <span class="pre">print</span></code>. The operation is <code class="docutils literal notranslate"><span class="pre">Read</span> <span class="pre">ref</span> <span class="pre">&gt;&gt;=</span> <span class="pre">Print</span></code> where <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> is the continuation monad’s bind operation, which expands to <code class="docutils literal notranslate"><span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">Read</span> <span class="pre">ref</span> <span class="pre">(\v</span> <span class="pre">-&gt;</span> <span class="pre">Print</span> <span class="pre">v</span> <span class="pre">cont)</span></code>.</p>
<p>So conceptually the “Hello World” program is simply the value <code class="docutils literal notranslate"><span class="pre">Print</span> <span class="pre">&quot;Hello</span> <span class="pre">World&quot;</span> <span class="pre">(Exit</span> <span class="pre">0)</span></code>. Except print isn’t a primitive operation, it’s more like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Data</span><span class="w"> </span><span class="s">&quot;Hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">msg</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">  </span><span class="kt">Block</span><span class="w"> </span><span class="s">&quot;_start&quot;</span><span class="w"> </span><span class="p">[</span><span class="kt">Sys_write</span><span class="w"> </span><span class="n">stdout</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Sys_exit</span><span class="w"> </span><span class="mi">0</span><span class="p">)])</span><span class="w"></span>
</pre></div>
</div>
<p>with Stroscot’s internal assembler language.</p>
<p>Task isn’t really a monad, but we can compose operations that return values using the continuation monad’s bind operation, as implemented with do-notation.</p>
<p>The datatype is similar to the “fudgets” mentioned in <span id="id10">[<a class="reference internal" href="../zzreferences.html#id35" title="Levent Erkok. Value Recursion in Monadic Computations. PhD thesis, Oregon Health and Science University, October 2002. URL: http://leventerkok.github.io/papers/erkok-thesis.pdf.">Erk02</a>]</span>, except we don’t have a pure constructor. Or <a class="reference external" href="http://comonad.com/reader/2011/free-monads-for-less-3/">this</a> type <code class="docutils literal notranslate"><span class="pre">FFI</span> <span class="pre">o</span> <span class="pre">i</span></code>, but with control flow represented explicitly instead of using <code class="docutils literal notranslate"><span class="pre">o</span></code> or <code class="docutils literal notranslate"><span class="pre">i</span></code> parameters.</p>
</section>
<section id="i-o-model-showdown">
<h2>I/O model showdown<a class="headerlink" href="#i-o-model-showdown" title="Permalink to this heading"></a></h2>
<section id="continuations">
<h3>Continuations<a class="headerlink" href="#continuations" title="Permalink to this heading"></a></h3>
<p>Stroscot use continuations for its I/O model because continuations are simple and universal. They’re the supercharged typed equivalent of a goto. A continuation is a function that takes as argument “the rest of the program”, or “its future”. Executing a continuation fills in a skeleton program with this future - or it can discard the future if it is not relevant. The implementation can compile continuations to jumps under most circumstances and closures otherwise, so the execution model is also conceptually simple.</p>
<p>Continuations are the basis in formal denotational semantics for all control flow, including vanilla call flow, loops, goto statements, recursion, generators, coroutines, exception handling, and backtracking. This allows a uniform and consistent interface.</p>
<p>We can turn the continuation approach into data by modeling I/O operations as constructor terms (members of a <code class="docutils literal notranslate"><span class="pre">Task</span></code> type). With this approach an I/O operation is data that can be pattern-matched over, allowing many metaprogramming techniques. It’s a little harder for the compiler to optimize that readIORef has no observable side effects, as it’s a reordering property (commutativity), but strict languages have been doing this for years.</p>
</section>
<section id="monads">
<h3>Monads<a class="headerlink" href="#monads" title="Permalink to this heading"></a></h3>
<p>Continuations are <a class="reference external" href="http://blog.sigfpe.com/2008/12/mother-of-all-monads.html">the mother of all monads</a> as all other monads can be embedded in the continuation type via <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span></code> and retrieved via <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">return</span></code>. In particular the Codensity monad <code class="docutils literal notranslate"><span class="pre">Codensity</span> <span class="pre">m</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">forall</span> <span class="pre">b.</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">b</span></code> is a monad regardless of <code class="docutils literal notranslate"><span class="pre">m</span></code>. (<a class="reference external" href="http://blog.sigfpe.com/2008/12/mother-of-all-monads.html#c3279179532869319461">See comment</a>) Without the forall, callcc is implementable and the type is too large, see <span id="id11">[<a class="reference internal" href="../zzreferences.html#id101" title="Philip Wadler. The essence of functional programming. In Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages - POPL '92, 1–14. Albuquerque, New Mexico, United States, 1992. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=143165.143169 (visited on 2021-11-22), doi:10.1145/143165.143169.">Wad92</a>]</span> section 3.4 for an example.</p>
<p>Using the <code class="docutils literal notranslate"><span class="pre">Codensity</span> <span class="pre">monad</span></code> instead of a monad stack is often faster - the case analysis is pushed to the monad’s operations, and there is no pile-up of binds. It converts the computation to continuation-passing style. In particular free tree-like monads <span id="id12">[<a class="reference internal" href="../zzreferences.html#id99" title="Janis Voigtländer. Asymptotic Improvement of Computations over Free Monads. In Philippe Audebaud and Christine Paulin-Mohring, editors, Mathematics of Program Construction, volume 5133, pages 388–403. Springer Berlin Heidelberg, Berlin, Heidelberg, 2008. URL: https://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf (visited on 2021-07-09), doi:10.1007/978-3-540-70594-9_20.">Voi08</a>]</span> and <a class="reference external" href="http://r6.ca/blog/20071028T162529Z.html">MTL monad stacks</a> are much cheaper when implemented via Codensity. As a contrary point, in the <a class="reference external" href="https://www.mail-archive.com/haskell-cafe&#64;haskell.org/msg66512.html">case</a> of the Maybe monad an ADT version seemed to be faster than a Church encoding. Unfortunately hpaste is defunct so the code can’t be analyzed further. It’s not clear if the “CPS” version mentioned is similar to Codensity.</p>
</section>
<section id="yoneda">
<h3>Yoneda<a class="headerlink" href="#yoneda" title="Permalink to this heading"></a></h3>
<p><a class="reference external" href="http://comonad.com/reader/2011/free-monads-for-less-2/">Kmett</a> says to use <code class="docutils literal notranslate"><span class="pre">Yoneda</span> <span class="pre">(Rec</span> <span class="pre">f)</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">newtype</span> <span class="pre">F</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">F</span> <span class="pre">{</span> <span class="pre">runF</span> <span class="pre">::</span> <span class="pre">forall</span> <span class="pre">r.</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">(f</span> <span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span> <span class="pre">}</span></code>, instead of <code class="docutils literal notranslate"><span class="pre">Codensity</span> <span class="pre">f</span> <span class="pre">a</span></code>. The claim is that this type is “smaller” than Codensity in the sense that the inhabitants of <code class="docutils literal notranslate"><span class="pre">F</span></code> are in a one-to-one correspondence with those of <code class="docutils literal notranslate"><span class="pre">Free</span> <span class="pre">f</span> <span class="pre">a</span></code>. But what we are interested in is <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code>; the recursive layering actually adds extra inhabitants as well, and there is also the <code class="docutils literal notranslate"><span class="pre">Pure</span></code> constructor that doesn’t make much sense for I/O. For example <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">Identity</span> <span class="pre">()</span></code> is the type of Church numerals, while <code class="docutils literal notranslate"><span class="pre">Codensity</span> <span class="pre">Identity</span> <span class="pre">()</span> <span class="pre">=</span> <span class="pre">forall</span> <span class="pre">r.</span> <span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">r</span> <span class="pre">=</span> <span class="pre">()</span> <span class="pre">=</span> <span class="pre">Identity</span> <span class="pre">()</span></code>. So in this case it is actually <code class="docutils literal notranslate"><span class="pre">F</span></code> that is larger.</p>
<p>Just looking at the types, F has more arrows. Similarly compare the instances:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- F f</span><span class="w"></span>
<span class="nf">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">kp</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">kp</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="kt">F</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">kp</span><span class="w"> </span><span class="n">kf</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">runF</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">kp</span><span class="w"> </span><span class="n">kf</span><span class="p">)</span><span class="w"> </span><span class="n">kf</span><span class="p">)</span><span class="w"></span>

<span class="c1">-- C f</span><span class="w"></span>
<span class="nf">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="nf">m</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">runC</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">runC</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>The instance for <code class="docutils literal notranslate"><span class="pre">C</span></code> is fewer characters.</p>
<p>Finally there is <span id="id13">[<a class="reference internal" href="../zzreferences.html#id82">RJ14</a>]</span> which derives the Codensity monad from the Yoneda lemma and the assumption that <code class="docutils literal notranslate"><span class="pre">f</span></code> is a small functor. Whereas the Yoneda-Rec seems to have no category theory behind it.</p>
<p>Generally it seems that the Yoneda thing solves a problem Stroscot doesn’t have.</p>
</section>
<section id="multi-prompt-delimited-continuations">
<h3>Multi-prompt delimited continuations<a class="headerlink" href="#multi-prompt-delimited-continuations" title="Permalink to this heading"></a></h3>
<p>Multi-prompt delimited continuations are described in <span id="id14">[<a class="reference internal" href="../zzreferences.html#id31" title="R. Kent Dyvbig, Simon Peyton Jones, and Amr Sabry. A monadic framework for delimited continuations. Journal of Functional Programming, 17(6):687–730, November 2007. URL: https://doi.org/10.1017/S0956796807006259 (visited on 2020-06-19), doi:10.1017/S0956796807006259.">DPJS07</a>]</span> . These might appear more expressive than standard delimited continuations <code class="docutils literal notranslate"><span class="pre">Cont</span> <span class="pre">b</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>, but as the paper shows, multi-prompt continuations can be implemented as a monad and hence as a library to use with the standard continuations. So the simplicity of the standard continuations wins out. With the multi-prompt continuations you have to have a unique supply and a stack. The unique supply complicates multithreading, and the stack can overflow and requires care to handle tail recursion. Whereas standard continuations translate to pure lambdas, and tail recursion is dealt with by the host language’s semantics.</p>
</section>
<section id="world-token">
<h3>World token<a class="headerlink" href="#world-token" title="Permalink to this heading"></a></h3>
<p>Haskell uses a state monad <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">s</span> <span class="pre">-&gt;</span> <span class="pre">(#</span> <span class="pre">s,</span> <span class="pre">a</span> <span class="pre">#))</span></code> for implementing I/O, where <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">World</span></code> is a special zero-sized token type. Clean is similar but <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">*World</span></code> has the uniqueness type annotation so the state tokens must be used linearly. Regardless, this approach seems quite awkward. Programs like <code class="docutils literal notranslate"><span class="pre">(a,_)</span> <span class="pre">=</span> <span class="pre">getChar</span> <span class="pre">s;</span> <span class="pre">(b,s')</span> <span class="pre">=</span> <span class="pre">getChar</span> <span class="pre">s;</span> <span class="pre">putChar</span> <span class="pre">(a,b)</span> <span class="pre">s'</span></code> that reuse the world are broken and have to be forbidden. Similarly commands like <code class="docutils literal notranslate"><span class="pre">exit</span> <span class="pre">0</span></code> have to be modeled as returning a world token, even though they don’t return at all. Ensuring that linearity holds during core-to-core transformations requires many hacks. Also, an I/O operation is an abstract function which makes it quite difficult to inspect IO values or implement simulations of I/O such as <a class="reference external" href="https://hackage.haskell.org/package/pure-io-0.2.1/docs/PureIO.html">PureIO</a>.</p>
</section>
<section id="algebraic-effects">
<h3>Algebraic effects<a class="headerlink" href="#algebraic-effects" title="Permalink to this heading"></a></h3>
<p>The two approaches are quite similar, both using a data type to represent operations. But continuations are much simpler syntactically than the handler functionality. In the effect approach computations are not first-class values.</p>
<p>OTOH effect types are quite useful, because you can define code that is polymorphic over the effect type, hence can be used as both pure and impure code. They use a monadic translation, I think with the lazy identity monad you can recover lazy pure code.</p>
</section>
<section id="call-by-push-value">
<h3>Call by push value<a class="headerlink" href="#call-by-push-value" title="Permalink to this heading"></a></h3>
<p>CBPV has “values” and “computations”. The original presentation has these as separate categories, but <span id="id15">[<a class="reference internal" href="../zzreferences.html#id32" title="J. Egger, R. E. Mogelberg, and A. Simpson. The enriched effect calculus: syntax and semantics. Journal of Logic and Computation, 24(3):615–654, June 2014. URL: https://academic.oup.com/logcom/article-lookup/doi/10.1093/logcom/exs025 (visited on 2021-11-09), doi:10.1093/logcom/exs025.">EMS14</a>]</span> presents an alternative calculus EC+ where every computation type is also a value type. There is exactly one primitive that sequences computation, <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">to</span> <span class="pre">x.</span> <span class="pre">N</span></code>, which acts like the monadic bind <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">&gt;&gt;=</span> <span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">N</span></code>, and similarly there is <code class="docutils literal notranslate"><span class="pre">return</span></code>. And the evaluation is CBV. So stripping away the thunk stuff it seems to be a disguised version of monads. And the thunk stuff is a rather fragile way to implement CBN - it doesn’t generalize to call by need. <span id="id16">[<a class="reference internal" href="../zzreferences.html#id70" title="Dylan McDermott and Alan Mycroft. Extended Call-by-Push-Value: Reasoning About Effectful Programs and Evaluation Order. In Luís Caires, editor, Programming Languages and Systems, volume 11423, pages 235–262. Springer International Publishing, Cham, 2019. URL: http://link.springer.com/10.1007/978-3-030-17184-1_9 (visited on 2021-11-09), doi:10.1007/978-3-030-17184-1_9.">MM19</a>]</span> And then there is jump-with-argument (JWA) which uses continuations and is equivalent to CBPV.</p>
</section>
<section id="applicative">
<h3>Applicative<a class="headerlink" href="#applicative" title="Permalink to this heading"></a></h3>
<p>All uses of Applicative can be rewritten using the laws to be of the form <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">a</span> <span class="pre">&lt;*&gt;</span> <span class="pre">b</span> <span class="pre">...</span> <span class="pre">&lt;*&gt;</span> <span class="pre">d</span></code> (where <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> is left associative), hence all uses can be rewritten to the idiom bracket syntax. And the idiom bracket syntax <code class="docutils literal notranslate"><span class="pre">([</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span> <span class="pre">])</span></code> can always be replaced with variadic function syntax, <code class="docutils literal notranslate"><span class="pre">apply_thing</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code>. So variadic functions are sufficient.</p>
<p>Applicative can also be represented typeclass-free as functions using their Cayley representation and the Yoneda lemma, see <span id="id17">[<a class="reference internal" href="../zzreferences.html#id82">RJ14</a>]</span> and <a class="reference external" href="https://fa.haskell.narkive.com/hUgYjfKJ/haskell-cafe-the-mother-of-all-functors-monads-categories#post3">this email</a>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Rep</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="kt">Yoneda</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Rep</span><span class="w"> </span><span class="p">(</span><span class="kt">Yoneda</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">pure</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"></span>

<span class="nf">lift</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">pure</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">((</span><span class="o">&lt;*&gt;</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">lower</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>So every function <code class="docutils literal notranslate"><span class="pre">Applicative</span> <span class="pre">f</span> <span class="pre">=&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">...</span></code> can be replaced with <code class="docutils literal notranslate"><span class="pre">Applicative</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Applicative</span> <span class="pre">f</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">...</span></code> - the normalization enabled by Cayley and Yoneda means you don’t have to worry about instance coherency.</p>
</section>
<section id="async">
<h3>Async<a class="headerlink" href="#async" title="Permalink to this heading"></a></h3>
<p>In JavaScript</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">async</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">foo</span><span class="nb">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">await</span><span class="w"> </span><span class="n">f</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>translates to</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">function</span><span class="w"> </span><span class="n">foo</span><span class="nb">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="n">f</span><span class="nb">()</span><span class="o">.</span><span class="kr">then</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">then</span></code> operation is basically monadic bind, so this is another form of monad syntax. There are <a class="reference external" href="https://buzzdecafe.github.io/2018/04/10/no-promises-are-not-monads">inconsistencies</a> with the Monad laws due to Promise flattening, which are enshrined in the spec and <a class="reference external" href="https://github.com/promises-aplus/promises-spec/issues/94">unfixable</a> without creating a wrapper API. But ignoring those, the Promise type is something like <code class="docutils literal notranslate"><span class="pre">Promise</span> <span class="pre">err</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Fulfilled</span> <span class="pre">a</span> <span class="pre">|</span> <span class="pre">Rejected</span> <span class="pre">err</span> <span class="pre">|</span> <span class="pre">Pending</span> <span class="pre">({</span> <span class="pre">resolve</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">(),</span> <span class="pre">reject</span> <span class="pre">:</span> <span class="pre">err</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()}</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">())</span></code>, which focusing on <code class="docutils literal notranslate"><span class="pre">Pending</span></code> is a CPS monad <code class="docutils literal notranslate"><span class="pre">(Either</span> <span class="pre">err</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">())</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span> <span class="pre">=</span> <span class="pre">EitherT</span> <span class="pre">err</span> <span class="pre">(Cont</span> <span class="pre">(IO</span> <span class="pre">()))</span> <span class="pre">a</span></code>.</p>
<p>Some arguments against:</p>
<ul class="simple">
<li><p>Promises do not conform to functor or monad laws and thus are not safe for compositional refactoring.</p></li>
<li><p>JS promises allow execution after the promise is resolved or rejected, resulting in untraceable behavior (fixed in C# by using return/throw)</p></li>
<li><p>async/await notation requires marking core library calls with “await” and the whole call chain with “async”, a tedious syntactic burden that Bob Nystrom calls <a class="reference external" href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">function coloring</a>.</p></li>
</ul>
<p>It’s better to make the async behavior automatic. Zig has done this but has <a class="reference external" href="https://gavinhoward.com/2022/04/i-believe-zig-has-function-colors/">tons of bugs</a>. Monads in general and continuations in particular seem like a more principled approach, e.g. there is a <a class="reference external" href="https://github.com/dmitriz/cpsfy/blob/master/DOCUMENTATION.md">JS CPS library</a>.</p>
</section>
</section>
<section id="colored-values">
<h2>Colored values<a class="headerlink" href="#colored-values" title="Permalink to this heading"></a></h2>
<p>Let’s revisit Bob Nystrom’s traits of <a class="reference external" href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">function coloring</a>. <a class="reference external" href="https://news.ycombinator.com/item?id=8985436">tel on HN</a> suggested using red = impure, and <a class="reference external" href="https://gavinhoward.com/2022/04/i-believe-zig-has-function-colors/#review-of-function-colors">Gavin</a> suggested replacing “call” with “use”. Most of it is then about “impure functions”, which we can call actions. We allow running actions in a pure environment if you provide an I/O simulation. With these modifications the traits read:</p>
<ol class="arabic simple">
<li><p>Values include pure functions and actions.</p></li>
<li><p>The way you use a value depends on its type.</p></li>
<li><p>You can only use an action from within another action, or within an action simulator.</p></li>
<li><p>Actions are more painful to use (than pure functions).</p></li>
<li><p>Some core library members are actions.</p></li>
</ol>
<p>The only trait here that seems disadvantageous is 4. Nystrom lists the following pain points for JS:
* verbose to compose in expressions because of the callbacks / promise goop
* annoying hoops to use error-handling
* can’t be used with try/catch or inside a lot of other control flow statements.
* can’t call a function that returns a future from synchronous code</p>
<p>But then he says C# async-await “solves” all of these but the first - actions can be used similarly to pure functions, but require “a liberal garnish of await”. But he seems to feel that requiring await is a deal-breaker. He further says the real solution is “threads/goroutines/coroutines/fibers. more precisely: multiple independent callstacks that can be switched between.” In fact it is not threads but <em>continuations</em> that make callstacks first-class. By using continuations as the I/O abstraction there is no distinction between sync and async, or rather it is all async. Particularly, all low-level operations are implemented in async style (taking a callback). You can still write sequential code in sync style, but for more complex cases you have to drop back down to the callbacks/continuation model or compose sequential code with combinators.</p>
<p>But this only solves the async/sync distinction Nystrom was complaining about, not the pure/impure dichotomy. Regardless of clever syntactic tricks, impurity cannot be hidden completely. Actions will always have some conceptual overhead compared to pure functions because they are sensitive to execution order. I don’t know if this will make anyone “spit in your coffee and/or deposit some even less savory fluids in it”, but I/O is unfortunately awkward in a pure or mathematical world. A program that does no I/O must be an infinite loop (it cannot even exit, because that requires a syscall). <span id="id18">[<a class="reference internal" href="../zzreferences.html#id54" title="Simon Peyton Jones. Tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell. In Engineering Theories of Software Construction, 47–96. 2001. URL: https://www.microsoft.com/en-us/research/publication/tackling-awkward-squad-monadic-inputoutput-concurrency-exceptions-foreign-language-calls-haskell/.">Jon01</a>]</span> classifies I/O under the “awkward squad”.</p>
</section>
<section id="unsafe-i-o">
<h2>“Unsafe” I/O<a class="headerlink" href="#unsafe-i-o" title="Permalink to this heading"></a></h2>
<p>Haskell has <code class="docutils literal notranslate"><span class="pre">runST</span></code> and <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code> that allow turning impure computation into pure computations. These can be implemented by throwing a resumable exception that’s caught in a top-level handler that does the I/O. <code class="docutils literal notranslate"><span class="pre">runST</span></code> scrutinizes its computation for impure behavior such as printing or returning allocated references, while <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code> does not and exposes the internal evaluation order.</p>
<p>If one wants to understand the evaluation order or is dealing with commutative operations, these functions are quite useful, e.g. Debug.Trace.trace looks like a non-I/O function but actually outputs something on the console, and allocation can be done in any order.</p>
<p>The main things to avoid is global variables like <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">unsafePerformIO</span> <span class="pre">(newIORef</span> <span class="pre">1)</span></code> pattern. Implicit parameters initialized in main compose much better. Similarly C’s <code class="docutils literal notranslate"><span class="pre">static</span></code> variables inlined in functions should be forbidden. Although, optimal reduction should mean an unsafePerformIO is only evaluated once, hence reading a file or something should be fine.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Sets.html" class="btn btn-neutral float-left" title="Sets" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Syntax.html" class="btn btn-neutral float-right" title="Syntax" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2020 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>