<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stateful programming &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Syntax" href="Syntax.html" />
    <link rel="prev" title="Standard library" href="Standard-Library.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler-Library.html">Compiler library</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Intrinsics.html">Intrinsics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#resources">Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#metrics">Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#methods">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#action">Action</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard-Library.html">Standard library</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Stateful programming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#limitations-of-purity">Limitations of purity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#automatic-destructive-update">Automatic destructive update</a></li>
<li class="toctree-l3"><a class="reference internal" href="#store">Store</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#store-state">Store state</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#i-o-sequencing-model-showdown">I/O sequencing model showdown</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#continuations">Continuations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multi-prompt-delimited-continuations">Multi-prompt delimited continuations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#streams">Streams</a></li>
<li class="toctree-l4"><a class="reference internal" href="#free-monad">Free monad</a></li>
<li class="toctree-l4"><a class="reference internal" href="#yoneda">Yoneda</a></li>
<li class="toctree-l4"><a class="reference internal" href="#algebraic-effects">Algebraic effects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#call-by-push-value">Call by push value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#applicative">Applicative</a></li>
<li class="toctree-l4"><a class="reference internal" href="#promises">Promises</a></li>
<li class="toctree-l4"><a class="reference internal" href="#monad-combined-with-identity-monad">Monad combined with identity monad</a></li>
<li class="toctree-l4"><a class="reference internal" href="#async">Async</a></li>
<li class="toctree-l4"><a class="reference internal" href="#futures">Futures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tasks">Tasks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#world-token">World token</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#logic-programming">Logic programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="#colored-values">Colored values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unsafe-i-o">“Unsafe” I/O</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#top-level-i-o">Top-level I/O</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Stateful programming</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/State.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="stateful-programming">
<h1>Stateful programming<a class="headerlink" href="#stateful-programming" title="Permalink to this heading"></a></h1>
<p>In Stroscot there are shared non-global states (stores), and a non-shared global state (I/O). But there is no shared global state, as this leads to initialization races and non-reentrant operations. With the store mechanism a programmer is free to declare some variables and assign some state, and the store will be passed around automatically. But the store only contains a map from variables to data and it is instead the I/O mechanism which interacts with the file system, the network, and other resources.</p>
<section id="limitations-of-purity">
<h2>Limitations of purity<a class="headerlink" href="#limitations-of-purity" title="Permalink to this heading"></a></h2>
<p>At present, destructive update is required to implement some algorithms efficiently. In particular consider some languages:</p>
<ol class="arabic simple">
<li><p>PURE: a “pure” CBV Lisp using a small set of primitive Lisp operations, <code class="docutils literal notranslate"><span class="pre">ATOM</span> <span class="pre">EQ</span> <span class="pre">READ</span> <span class="pre">WRITE</span> <span class="pre">CONS</span> <span class="pre">CAR</span> <span class="pre">CDR</span></code> assumed to be of constant cost, and “flow-chart style” control flow, assumed free</p></li>
<li><p>IMPURE: the Lisp extended with destructive mutation operators <code class="docutils literal notranslate"><span class="pre">RPLACA</span> <span class="pre">RPLACD</span></code> also of constant cost</p></li>
<li><p>HASK: a Haskell with lambdas, case, tuples, and lists</p></li>
<li><p>CYCLE: PURE but with an operation to construct cyclic data structures, CYCLE</p></li>
</ol>
<p>It has been established that PURE ⊆ CYCLE ⊊ HASK ⊆ IMPURE as far as expressing efficient online programs:</p>
<ul class="simple">
<li><p>For the first relation, PURE programs can be run unmodified in CYCLE with equivalent reduction steps, showing inclusion. <span id="id1">[<a class="reference internal" href="../zzreferences.html#id17" title="Amir M. Ben-amram. Notes on Pippenger's Comparison of Pure and Impure LISP. 1996. URL: citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.3024&amp;rep=rep1&amp;type=pdf.">Benamram96</a>]</span> says that it is an open problem to demonstrate an efficiency advantage of CYCLE over PURE.</p></li>
<li><p>For the second relation, lazy languages allow cycles, hence showing inclusion. <span id="id2">[<a class="reference internal" href="../zzreferences.html#id17" title="Amir M. Ben-amram. Notes on Pippenger's Comparison of Pure and Impure LISP. 1996. URL: citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.3024&amp;rep=rep1&amp;type=pdf.">Benamram96</a>]</span> says that <span id="id3">[<a class="reference internal" href="../zzreferences.html#id125" title="Nicholas Pippenger. Pure versus impure Lisp. ACM Transactions on Programming Languages and Systems, 19(2):223–238, March 1997. URL: https://dl.acm.org/doi/10.1145/244795.244798 (visited on 2022-01-06), doi:10.1145/244795.244798.">Pip97</a>]</span> shows that for a specific online problem “perm” any CYCLE solution will require at least O(n log n) time. The proof depends on the property of CYCLE that a cons cell can refer only to itself or previously-constructed values, which does not hold for LAZY as it allows naming future computations. <span id="id4">[<a class="reference internal" href="../zzreferences.html#id19" title="Richard Bird, Geraint Jones, and Oege De Moor. More haste, less speed: lazy versus eager evaluation. Journal of Functional Programming, 7(5):541–547, September 1997. URL: https://www.cambridge.org/core/journals/journal-of-functional-programming/article/more-haste-less-speed-lazy-versus-eager-evaluation/162B391CBCD864794C766CA2A2EC7CBE (visited on 2022-01-06), doi:10.1017/S0956796897002827.">BJM97</a>]</span> demonstrate that HASK can solve “perm” in amortized O(n) time, via the use of lazy streams, hence HASK is strictly more efficient than CYCLE.</p></li>
<li><p>For the third relation, the thunk mechanism of HASK can be emulated in IMPURE, showing inclusion. <span id="id5">[<a class="reference internal" href="../zzreferences.html#id17" title="Amir M. Ben-amram. Notes on Pippenger's Comparison of Pure and Impure LISP. 1996. URL: citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.3024&amp;rep=rep1&amp;type=pdf.">Benamram96</a>]</span> theorizes that for IMPURE programs following a read-update-write structure, there is a correspondingly efficient HASK program. Since Haskell 1.0 programs use a lazy stream <code class="docutils literal notranslate"><span class="pre">[Response]</span> <span class="pre">-&gt;</span> <span class="pre">[Request]</span></code> for I/O, this read-update-write model seems to encompass all programs, hence it seems likely that the two languages are of equal efficiency, although nobody has formally proved this (TODO).</p></li>
</ul>
<p>The log(n) gap between CYCLE and HASK is calculated using the cost of updating a balanced binary tree. This is the cost of the predecessor problem in the <a class="reference external" href="https://en.wikipedia.org/wiki/Pointer_machine">pointer machine</a>. In the more accurate RAM model the update cost is optimally O(log log m) time under some assumptions. (<span id="id6">[<a class="reference internal" href="../zzreferences.html#id152" title="Milan Straka. Functional Data Stuctures and Algorithms. PhD thesis, Computer Science Institute of Charles University, September 2013. URL: https://dspace.cuni.cz/handle/20.500.11956/52896 (visited on 2022-01-04).">Str13</a>]</span>, chapter 5) Straka’s implementation uses vEB trees which have a huge constant factor and space usage, but y-fast trees probably work too for a practical implementation.</p>
<p>Still though, a gap is a gap, so to get performance we must provide laziness or destructive update. And programming efficient amortized pure lazy data structures is quite complex, and not well-studied. It seems that any practical programming language will have to provide destructive update.</p>
</section>
<section id="automatic-destructive-update">
<h2>Automatic destructive update<a class="headerlink" href="#automatic-destructive-update" title="Permalink to this heading"></a></h2>
<p>Although pure programs do not have operators for destructive update, they can still express similar programs using a copying update operation that returns a new data structure with the relevant index modified. For <a class="reference external" href="https://prog21.dadgum.com/41.html">example</a> counting the frequency of byte values within a block of binary data:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">freq</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Binary</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">scanr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">arr</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">repeat</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">b</span>

<span class="c1">-- expands to:</span>

<span class="nf">freq</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Binary</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="n">repeat</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="n">go</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="n">rest</span><span class="w"> </span><span class="p">(</span><span class="n">update</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span>
<span class="w">    </span><span class="n">go</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">arr</span>
</pre></div>
</div>
<p>The issue is that a naive implementation of “update” copies the entire array, using O(n) memory and time. <span id="id7">[<a class="reference internal" href="../zzreferences.html#id77" title="Paul Hudak and Adrienne Bloss. The aggregate update problem in functional programming systems. In Proceedings of the 12th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages - POPL '85, 300–314. New Orleans, Louisiana, United States, 1985. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=318593.318660 (visited on 2022-01-04), doi:10.1145/318593.318660.">HB85</a>]</span> shows that with a compiler analysis (hereafter called “automatic destructive update”) a language can provide O(1) update-copy operations. The compiler searches through possible evaluation orders for an evaluation order that never accesses the old version of data after updating, and transforms such “single-threaded” programs to destructively update, giving the speedup. Programming with pure arrays in a “single-threaded” style is at least as expressive as imperative arrays - per Hudak, all the natural translations of imperative algorithms are single-threaded. Some of <span id="id8">[<a class="reference internal" href="../zzreferences.html#id120" title="Chris Okasaki. Purely Functional Data Structures. Cambridge University Press, Cambridge, U.K. ; New York, 1998. ISBN 978-0-521-63124-2.">Oka98</a>]</span>’s lazy data structures have a similar single-threaded use condition for amortized good performance, so the single-threaded condition seems reasonable. Also well-defined Ocaml programs that use side effects must be single-threaded, else there is a race condition.</p>
<p>Roc and Koka seem to be going down the automatic destructive update route via alias analysis and ref-counting optimizations. It seems like a great optimization and it does not seem too hard to allow marking array uses as single-threaded so the compiler warns if it has to copy.</p>
<p>Haskell avoided automatic destructive update because per SPJ it seemed too complicated, and instead relies on monads. Monadic style fixes an evaluation order, hence guarantees single threading because the old version is inaccessible. Monadic style is verbose, because simple function applications require the use of Applicative like <code class="docutils literal notranslate"><span class="pre">liftA</span> <span class="pre">(+)</span> <span class="pre">1</span> <span class="pre">2</span></code>. It also is not very composable because <code class="docutils literal notranslate"><span class="pre">runST</span></code> is required to escape from the monad and the phantom state token type prevents mixing certain computations.</p>
<p>Clean has uniqueness types, which also enforce single threadedness. Uniqueness types disallow a simple example of implementing id in terms of const:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">id</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span>
<span class="nf">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span>

<span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="n">a</span>
<span class="nf">b</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">10</span>
</pre></div>
</div>
<p>Automatic destructive update may or may not work on this example depending on how smart the compiler is. But it definitely works on all uniqueness-typable programs, and is pretty much syntactically identical. So this is another case of tractable but incomplete vs difficult but complete - Stroscot aims for completeness.</p>
</section>
<section id="store">
<h2>Store<a class="headerlink" href="#store" title="Permalink to this heading"></a></h2>
<p>We can formalize traditional imperative programming with mutable variables using the notion of a store. A store is a first-class value representing a subset of computer memory. It is basically a map from identifiers to values, a little “bundle of state”, but it’s more complicated than just a hash table to as to support implicit concurrency in expressions. In particular a store is a per-variable ordered list of reads and writes so that read-write and write-write conflicts may be detected.</p>
<p>A function that uses the store is a value of the State monad, <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">-&gt;</span> <span class="pre">(s,</span> <span class="pre">a)</span></code>, where <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">Store</span></code>. For example an assignment statement <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:=</span> <span class="pre">f</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">g</span> <span class="pre">c</span></code> translates to</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">\</span><span class="n">s</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">s1a</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="s">&quot;b&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">s1a</span>
<span class="w">  </span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">s2a</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="s">&quot;c&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">s2a</span>
<span class="w">  </span><span class="n">s&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">merge</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">[</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">]</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="w">  </span><span class="n">update</span><span class="w"> </span><span class="n">s&#39;</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
<p>The store is passed into each function and returned as a result. The special <code class="docutils literal notranslate"><span class="pre">merge</span></code> operation combines concurrent stores and checks for conflicts by examining the list of operations - if there is a conflict, the variables involved are set to <code class="docutils literal notranslate"><span class="pre">DataRace</span></code> exceptions.</p>
<p><span id="id9">[]</span> has an asymmetric commit operation instead of a merge operation. This takes a parent and a child and propagates child writes to the parent. This is impure, still requiring a global state (the root). For example the behavior of this program seems really unintuitive:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">thisWorld</span><span class="o">.</span><span class="n">sprout</span><span class="nb">()</span>
<span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
<span class="kr">in</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="c1">-- prints 2, not 1</span>
</pre></div>
</div>
<p>IMO it is much more intuitive to have a “snapshot” model that merges immutable map-like structures, so that the program works like so:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">currentState</span>
<span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">with</span><span class="w"> </span><span class="n">state</span><span class="ow">=</span><span class="kt">A</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="c1">-- prints 1</span>
</pre></div>
</div>
<p>The “worlds” approach seems to have adopted the asymmetric model based on Javascript’s property lookup semantics. Per <span id="id10">[]</span> the rollback and undo examples they give can be implemented just as easily using the snapshot model.</p>
<p>The allowed “side effects” of stores are restricted to variable updates - I/O such as reading files and networking is not possible, because the program can’t continue without external input, but it has already been given the full state of the store so there is no further place to insert this input. But per <span id="id11">[]</span> continuations and stores can coexist. The idea is that a continuation takes a result continuation and a store, operates on the store, then calls the result continuation with a final store and the result. So the type of a continuation returning <code class="docutils literal notranslate"><span class="pre">a</span></code> is <code class="docutils literal notranslate"><span class="pre">(Store</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">Store</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>. Written differently this is <code class="docutils literal notranslate"><span class="pre">Store</span> <span class="pre">-&gt;</span> <span class="pre">((Store,</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code> which is <code class="docutils literal notranslate"><span class="pre">Store</span> <span class="pre">-&gt;</span> <span class="pre">Cont</span> <span class="pre">r</span> <span class="pre">(Store,</span> <span class="pre">a)</span></code> or <code class="docutils literal notranslate"><span class="pre">StateT</span> <span class="pre">(Cont</span> <span class="pre">r)</span> <span class="pre">Store</span> <span class="pre">a</span></code>.</p>
<p>In fact monads and continuation-based IO can express mutable variable programming directly, e.g. Haskell has the <code class="docutils literal notranslate"><span class="pre">readIORef</span></code> primitive. So first-class stores aren’t actually necessary. But per <span id="id12">[]</span> “the resulting increase in power of the environment appears to be well worth the cost” (in complexity and implementation overhead). The store has several advantages:</p>
<ul class="simple">
<li><p>The store is a first-class value similar to a dictionary, whereas a continuation is similar to a linked list. Thus variable values can be accessed in O(1) time from a store value, whereas a continuation value must be stepped through sequentially (simulated) to extract values, requiring O(n) time. Essentially, the store formalizes program data state, while continuations formalize program control state. Per <span id="id13">[]</span>, continuations do not capture the state of mutable objects. For example, <code class="docutils literal notranslate"><span class="pre">callCC</span> <span class="pre">(\c</span> <span class="pre">-&gt;</span> <span class="pre">c;</span> <span class="pre">c);</span> <span class="pre">modify</span> <span class="pre">&quot;a&quot;</span> <span class="pre">(+1)</span></code> increments by 2, rather than setting <code class="docutils literal notranslate"><span class="pre">a</span></code> twice.</p></li>
<li><p>It is much simpler semantically to use a store for implicitly concurrent computations. In the above example, where <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">c</span></code> run in parallel, if we used a monad we would have to sequence the operations <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">f</span> <span class="pre">b;</span> <span class="pre">y</span> <span class="pre">&lt;-</span> <span class="pre">g</span> <span class="pre">c</span></code> or use explicit <code class="docutils literal notranslate"><span class="pre">fork</span></code>/ <code class="docutils literal notranslate"><span class="pre">merge</span></code> operations <code class="docutils literal notranslate"><span class="pre">x_t</span> <span class="pre">&lt;-</span> <span class="pre">fork</span> <span class="pre">(f</span> <span class="pre">b);</span> <span class="pre">y_t</span> <span class="pre">&lt;-</span> <span class="pre">fork</span> <span class="pre">(g</span> <span class="pre">c);</span> <span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">wait</span> <span class="pre">x_t;</span> <span class="pre">y</span> <span class="pre">&lt;-</span> <span class="pre">wait</span> <span class="pre">y_t</span></code>. In either case, the operations are not fully commutative: in the first we cannot swap the order of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> if there is a data race, and in the second we cannot move a wait before a fork. In contrast the store’s <code class="docutils literal notranslate"><span class="pre">merge</span></code> operation is fully commutative because the result of a data race is well-defined to be an exception. The <code class="docutils literal notranslate"><span class="pre">wait/fork</span></code> machinery is not needed as it is simply passing around a value. Essentially stores provide a transactional view of memory.</p></li>
<li><p>First-class stores allow manipulating the program data state in complex ways. Multiple stores may exist simultaneously, allowing isolated computations. In particular, the empty store value allows turning a stateful function into a pure function, without any type trickery like <code class="docutils literal notranslate"><span class="pre">runST</span></code>. More generally the ability to apply a function to different explicitly-written store values allows program testing and debugging.</p></li>
</ul>
<p>The efficient implementation of stores is somewhat of a research area. Automatic destructive update should allow linear or non-conflicting usage of the store to translate to direct memory reads and writes. With non-linear usage, efficiently making copies and allowing persistent access to old stores may require some cleverness, for example a persistent hash map backed by the persistent array found in <span id="id14">[]</span>. Per <span id="id15">[]</span> the cost of a stack-based implementation is about 10% overhead on an ancient machine. Per <span id="id16">[]</span> this can be reduced through caching optimizations, so that if a variable is looked up and we know it has not been written then it does not need to be looked up again, i.e. <code class="docutils literal notranslate"><span class="pre">lookup</span> <span class="pre">x</span> <span class="pre">(update</span> <span class="pre">s</span> <span class="pre">y</span> <span class="pre">yv)</span> <span class="pre">|</span> <span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">lookup</span> <span class="pre">s</span> <span class="pre">x</span></code>. We also want to coalesce updates and reads so that new versions do not have to be created all the time.</p>
<section id="store-state">
<h3>Store state<a class="headerlink" href="#store-state" title="Permalink to this heading"></a></h3>
<p>Most papers limit themselves to keeping the values of mutable variables in the store. But conceptually the state of a program could include the state of the computer, the stock market, quantum fluctuations, etc. - all information within the chronological past of a program. But practically we are limited to state that we can read and write deterministically. In particular the read operation must satisfy the associative array definition:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">read</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="n">write</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kt">D</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kt">D</span>
<span class="nf">read</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">emptyStore</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">MissingValue</span>
</pre></div>
</div>
<p>So one constraint to be a variable is that the state must be accessible. So for example the kernel limits us - we do not have full control over peripheral devices or processes not related to ours. We can represent this by using shadowing access-controlled variables and returning <code class="docutils literal notranslate"><span class="pre">WriteFailed</span></code> for inaccessible variables.</p>
<p>Conveniently the CRIU project has a <a class="reference external" href="https://criu.org/Images">list</a> of what’s in the state of a Linux user process. We reproduce it here:</p>
<ul class="simple">
<li><p>Core process info</p>
<ul>
<li><p>name, sigmask, itimers, etc.</p></li>
<li><p>Task credentials: uids, gids, caps, etc.</p></li>
<li><p>Process tree linkage</p></li>
<li><p>arch-dependent information (registers, etc.)</p></li>
<li><p>Signal handling map</p></li>
<li><p>IDs of objects (mm, files, sihand, etc.) and namespaces</p></li>
</ul>
</li>
<li><p>Address space information (VMAs, segments, exe file, etc.)</p>
<ul>
<li><p>Info about which virtual regions are populated with data (pagemap)</p></li>
<li><p>4k page data dumps for each mapped page in the pagemap.</p></li>
</ul>
</li>
<li><p>Filesystem info</p>
<ul>
<li><p>chroot and chdir information</p></li>
<li><p>Open file descriptors</p></li>
<li><p>Paths to files opened with open(2) syscall</p></li>
<li><p>File paths remaps (e.g. for invisible files)</p></li>
<li><p>Ghost invisible files</p></li>
<li><p>Mountpoints information</p></li>
<li><p>Contents of a tmpfs filesystem</p></li>
</ul>
</li>
<li><p>Special fd’s / sockets</p>
<ul>
<li><p>Eventfd file information</p></li>
<li><p>Eventpoll file information</p></li>
<li><p>Target file descriptors of eventpoll fds</p></li>
<li><p>Inotify file information</p></li>
<li><p>Watch descriptors of inotify fds</p></li>
<li><p>signalfd info</p></li>
<li><p>Pipes information</p></li>
<li><p>Contents of pipes (data sitting in a pipe)</p></li>
<li><p>FIFO information</p></li>
<li><p>Contents of FIFOs</p></li>
<li><p>Unix sockets</p></li>
<li><p>PF_INET sockets, both IPv4 and IPv6</p></li>
<li><p>Contents of socket queues</p></li>
<li><p>Interval timers state</p></li>
<li><p>TCP connection state (including data in queues)</p></li>
<li><p>Uname nodename and domainname of a UTS namespace</p></li>
<li><p>Information about opened TTYs, including Termios and similar stuff</p></li>
<li><p>Info about PF_PACKET sockets</p></li>
<li><p>Info about network devices</p></li>
<li><p>IP addresses on network devices</p></li>
<li><p>Routing tables</p></li>
</ul>
</li>
</ul>
<p>Usually these are modeled using primitive operations, e.g. file descriptors are allocated with the open syscall rather than declaratively as <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">fd1</span> <span class="pre">=</span> <span class="pre">inode</span> <span class="pre">1234</span> <span class="pre">}</span></code>. But the more state we model as state, the more powerful our debugging tools get. A traditional debugger has no way to undo closing a file. However, a filestate-aware debugger can reopen the file. The less we view the program as an I/O machine the easier it is to use high-bandwidth interfaces such as io_uring to perform bulk state changes - describing what rather than how is the hallmark of a high-level language. Of course, in most cases the program will use state in a single-threaded manner and it will simply be compiled to the primitive operation API by the automatic destructive update optimization.</p>
</section>
</section>
<section id="i-o-sequencing-model-showdown">
<h2>I/O sequencing model showdown<a class="headerlink" href="#i-o-sequencing-model-showdown" title="Permalink to this heading"></a></h2>
<p>All programs behave as a mathematical function, i.e., returns the same output when given the same input(s). But a for a pure function, the input and output are simply values, whereas for impure programs it is more complex. State accounts for a lot, but we still need “change the world” operations like <code class="docutils literal notranslate"><span class="pre">readLn</span> <span class="pre">::</span> <span class="pre">IO</span> <span class="pre">String</span></code> and <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">::</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></code>. Rather than side effects, following Haskell we would like the do-notation blocks that integrate statements as expressions. So a model must provide the basic monad operators <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> and <code class="docutils literal notranslate"><span class="pre">return</span></code>. Another useful operation is recursion, in particular <code class="docutils literal notranslate"><span class="pre">mfix</span> <span class="pre">::</span> <span class="pre">MonadFix</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code>.</p>
<p>Monad transformers are overrated so not needed:</p>
<ul class="simple">
<li><p>StateT is handled by the store</p></li>
<li><p>AccumT / WriterT is a StateT that’s not read</p></li>
<li><p>ReaderT is handled by implicit parameters / the store</p></li>
<li><p>MaybeT/ErrorT/ExceptT/MonadFail are handled by exceptions.</p></li>
<li><p>Select is handled by nondeterminism and exceptions.</p></li>
<li><p>These are all the standard transformers provided in <a class="reference external" href="https://hackage.haskell.org/package/transformers">transformers</a>, besides ContT.</p></li>
</ul>
<p>So let’s consider all the implementations of the I/O monad.</p>
<section id="continuations">
<h3>Continuations<a class="headerlink" href="#continuations" title="Permalink to this heading"></a></h3>
<p>The basic monad operations for continuations are well known:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">x</span>
<span class="nf">m</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">c</span><span class="p">)</span>
<span class="nf">fmap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="p">))</span>
</pre></div>
</div>
<p>Some instances of mfix have been written for Codensity (<a class="reference external" href="https://github.com/ekmett/kan-extensions/issues/64">here</a>), but not proven correct. <span id="id17">[<a class="reference internal" href="../zzreferences.html#id58" title="Levent Erkok. Value Recursion in Monadic Computations. PhD thesis, Oregon Health and Science University, October 2002. URL: http://leventerkok.github.io/papers/erkok-thesis.pdf.">Erk02</a>]</span> argues based on the types that no plausible definition exists. These observations are not in contradiction, as the types are different. Ignoring the types, we should be able to define <code class="docutils literal notranslate"><span class="pre">mfix</span></code> directly via higher-order pattern-matching:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mfix</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">of</span>
<span class="w">  </span><span class="c1">-- purity</span>
<span class="w">  </span><span class="n">exists</span><span class="w"> </span><span class="n">h</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">k</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="n">k</span><span class="p">))</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="p">(</span><span class="n">fix</span><span class="w"> </span><span class="n">h</span><span class="p">)</span>
<span class="w">  </span><span class="c1">-- left shrinking</span>
<span class="w">  </span><span class="n">exists</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">l</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">c</span><span class="p">))</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">l</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">mfix</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">c2</span><span class="p">)</span>
<span class="w">  </span><span class="c1">-- sliding (h is strict)</span>
<span class="w">  </span><span class="n">exists</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">h</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="n">k</span><span class="p">)))</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">mfix</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="n">k</span><span class="p">))</span>
<span class="w">  </span><span class="c1">-- nesting</span>
<span class="w">  </span><span class="n">exists</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">mfix</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">mfix</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">c2</span>
</pre></div>
</div>
<p>Typing continuations is a little hard because they allow answer-type modification, e.g. the type of <code class="docutils literal notranslate"><span class="pre">reset</span> <span class="pre">(3</span> <span class="pre">+</span> <span class="pre">shift</span> <span class="pre">\k</span> <span class="pre">-&gt;</span> <span class="pre">k)</span></code> is <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code>. Using prefix syntax <code class="docutils literal notranslate"><span class="pre">reset</span> <span class="pre">(liftA</span> <span class="pre">(+)</span> <span class="pre">3</span> <span class="pre">(shift</span> <span class="pre">(\k</span> <span class="pre">-&gt;</span> <span class="pre">k)))</span></code> this ability to change type is a little more obvious. Since the operators are lambdas, the principal intersection types will be the most general, since intersection types can type all strongly normalizing programs. In this case it turns out we do not need the intersection operator and the Hindley-Milner type signature is sufficient. To express the types it is helpful to define the indexed continuation type <code class="docutils literal notranslate"><span class="pre">ICont</span> <span class="pre">r</span> <span class="pre">s</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">s)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>. Then the most general simple types are:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">return</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ICont</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">ICont</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">i</span>
</pre></div>
</div>
<p>A general chain <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;&gt;=</span> <span class="pre">b</span> <span class="pre">&gt;&gt;=</span> <span class="pre">c</span> <span class="pre">&gt;&gt;=</span> <span class="pre">d</span></code> has <code class="docutils literal notranslate"><span class="pre">a</span></code> of type <code class="docutils literal notranslate"><span class="pre">ICont</span> <span class="pre">i</span> <span class="pre">j</span> <span class="pre">a1</span></code>, <code class="docutils literal notranslate"><span class="pre">b/c</span></code> of type <code class="docutils literal notranslate"><span class="pre">a1/b1</span> <span class="pre">-&gt;</span> <span class="pre">ICont</span> <span class="pre">j/k</span> <span class="pre">k/l</span> <span class="pre">b1/c1</span> <span class="pre">``,</span> <span class="pre">``d</span></code> of type <code class="docutils literal notranslate"><span class="pre">c1</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">l</span></code>, and returns a function <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">i</span></code>. So the last callback in a chain can be represented using tokens or other weird things - it’s only when we bind the continuation to another continuation that it has to use a function type. This freedom is useful when writing I/O simulators. Ignoring this the usual indexed monad signature for <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> is <code class="docutils literal notranslate"><span class="pre">ICont</span> <span class="pre">i</span> <span class="pre">j</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">ICont</span> <span class="pre">j</span> <span class="pre">k</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">ICont</span> <span class="pre">i</span> <span class="pre">k</span> <span class="pre">b</span></code>.</p>
<p>Using universal quantification and type constructors gives the <a class="reference external" href="https://www.reddit.com/r/haskell/comments/6vu2i4/fun_exploration_right_kan_extensions_swapped/">indexed codensity monad</a>  or <a class="reference external" href="https://hackage.haskell.org/package/kan-extensions-5.2.5/docs/Data-Functor-Kan-Ran.html">right Kan extension</a> <code class="docutils literal notranslate"><span class="pre">Ran</span> <span class="pre">m</span> <span class="pre">n</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">forall</span> <span class="pre">r.</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">n</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">r</span> <span class="pre">=</span> <span class="pre">forall</span> <span class="pre">r.</span> <span class="pre">ICont</span> <span class="pre">(m</span> <span class="pre">r)</span> <span class="pre">(n</span> <span class="pre">r)</span> <span class="pre">a</span></code>. <code class="docutils literal notranslate"><span class="pre">ICont</span> <span class="pre">i</span> <span class="pre">j</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Ran</span> <span class="pre">(K</span> <span class="pre">i)</span> <span class="pre">(K</span> <span class="pre">j)</span> <span class="pre">a</span></code> where <code class="docutils literal notranslate"><span class="pre">K</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a</span></code>.</p>
<p>Due to the quantification, the operations on <code class="docutils literal notranslate"><span class="pre">Ran</span></code> are restricted.  In particular <code class="docutils literal notranslate"><span class="pre">callCC</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">\c</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">(\x</span> <span class="pre">_</span> <span class="pre">-&gt;</span> <span class="pre">c</span> <span class="pre">x)</span> <span class="pre">c</span></code> has type <code class="docutils literal notranslate"><span class="pre">((a</span> <span class="pre">-&gt;</span> <span class="pre">p</span> <span class="pre">-&gt;</span> <span class="pre">j)</span> <span class="pre">-&gt;</span> <span class="pre">ICont</span> <span class="pre">i</span> <span class="pre">j</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">ICont</span> <span class="pre">i</span> <span class="pre">j</span> <span class="pre">a</span></code>, which does not unify with the desired type <code class="docutils literal notranslate"><span class="pre">((a</span> <span class="pre">-&gt;</span> <span class="pre">Ran</span> <span class="pre">n</span> <span class="pre">o</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">Ran</span> <span class="pre">m</span> <span class="pre">n</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">Ran</span> <span class="pre">m</span> <span class="pre">n</span> <span class="pre">a</span></code>. <span id="id18">[<a class="reference internal" href="../zzreferences.html#id163" title="Philip Wadler. The essence of functional programming. In Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages - POPL '92, 1–14. Albuquerque, New Mexico, United States, 1992. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=143165.143169 (visited on 2021-11-22), doi:10.1145/143165.143169.">Wad92</a>]</span> section 3.4 says that the lack of callCC is a good thing because it means every continuation corresponds to an <code class="docutils literal notranslate"><span class="pre">m-n</span></code> operation. It’s a semantic distinction: are your values “special” values with known types, hence in the type <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">forall</span> <span class="pre">r.</span> <span class="pre">m</span> <span class="pre">r</span></code> and possible to use with callCC, or are they “return” values that have unknown structure?</p>
<p>We call the values in <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">m</span></code> continuations, and the values in <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">r</span></code> actions. A continuation represents “the future of the program”. Executing a continuation plugs this future into a program description with a hole - usually there is one hole, but the continuation can discard the future or run it multiple times. The implementation can compile continuations to jumps under most circumstances and closures otherwise, so the execution model is also conceptually simple. Continuations are the basis in formal denotational semantics for all control flow, including vanilla call flow, loops, goto statements, recursion, generators, coroutines, exception handling, and backtracking. This allows a uniform and consistent interface. Continuations are more powerful than goto.</p>
<p>Codensity is <a class="reference external" href="http://blog.sigfpe.com/2008/12/mother-of-all-monads.html">the mother of all monads</a>. In particular <code class="docutils literal notranslate"><span class="pre">Codensity</span> <span class="pre">m</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">forall</span> <span class="pre">b.</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">b</span></code> is a monad regardless of <code class="docutils literal notranslate"><span class="pre">m</span></code>. (<a class="reference external" href="http://blog.sigfpe.com/2008/12/mother-of-all-monads.html#c3279179532869319461">See comment</a>) Furthermore all monads can be embedded in the type via <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;=)</span></code> and retrieved via <code class="docutils literal notranslate"><span class="pre">\f</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">return</span></code>. That blog post gives a generic way to implement monads via the continuation monad, but the direct implementation is pretty clean. For example the <a class="reference external" href="https://github.com/Mathnerd314/stroscot/blob/master/tests/Continuations-State.hs">StateT monad</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">Codensity</span></code> is quite efficient - the case analysis is pushed to the monad’s operations, and there is no pile-up of binds - all uses of the underlying monad’s bind are right-associated. It converts the computation to continuation-passing style. In particular free tree-like monads <span id="id19">[<a class="reference internal" href="../zzreferences.html#id160" title="Janis Voigtländer. Asymptotic Improvement of Computations over Free Monads. In Philippe Audebaud and Christine Paulin-Mohring, editors, Mathematics of Program Construction, volume 5133, pages 388–403. Springer Berlin Heidelberg, Berlin, Heidelberg, 2008. URL: https://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf (visited on 2021-07-09), doi:10.1007/978-3-540-70594-9_20.">Voi08</a>]</span> and <a class="reference external" href="http://r6.ca/blog/20071028T162529Z.html">MTL monad stacks</a> are much cheaper when implemented via Codensity. As a contrary point, in the <a class="reference external" href="https://www.mail-archive.com/haskell-cafe&#64;haskell.org/msg66512.html">case</a> of the Maybe monad an ADT version seemed to be faster than a Church encoding. Unfortunately hpaste is defunct so the code can’t be analyzed further. It’s not clear if the “CPS” version mentioned was actually Codensity.</p>
</section>
<section id="multi-prompt-delimited-continuations">
<h3>Multi-prompt delimited continuations<a class="headerlink" href="#multi-prompt-delimited-continuations" title="Permalink to this heading"></a></h3>
<p>Multi-prompt delimited continuations are described in <span id="id20">[<a class="reference internal" href="../zzreferences.html#id51" title="R. Kent Dyvbig, Simon Peyton Jones, and Amr Sabry. A monadic framework for delimited continuations. Journal of Functional Programming, 17(6):687–730, November 2007. URL: https://doi.org/10.1017/S0956796807006259 (visited on 2020-06-19), doi:10.1017/S0956796807006259.">DPJS07</a>]</span> . These might appear more expressive than standard delimited continuations , but as the paper shows, multi-prompt continuations can be implemented as a monad and hence as a library to use with the standard continuations. So the simplicity of the standard continuations wins out. With the multi-prompt continuations you have to have a unique id supply and a stack. The unique id supply complicates multithreading, and the stack can overflow and requires care to handle tail recursion. Whereas standard continuations translate to pure lambdas, and tail recursion is dealt with by the host language’s semantics.</p>
</section>
<section id="streams">
<h3>Streams<a class="headerlink" href="#streams" title="Permalink to this heading"></a></h3>
<p>With the stream I/O model a program is of type <code class="docutils literal notranslate"><span class="pre">[Response]</span> <span class="pre">-&gt;</span> <span class="pre">[Request]</span></code>, where <code class="docutils literal notranslate"><span class="pre">[]</span></code> is the type constructor of destructively updateable lists. With an unsafe lazy read operation we can write an interpreter with constant overhead like so:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">RList</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Ref</span><span class="w"> </span><span class="p">(</span><span class="kt">Bottom</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Nil</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">Rlist</span><span class="w"> </span><span class="n">a</span><span class="p">))</span>

<span class="nf">c</span><span class="w"> </span><span class="p">(</span><span class="n">prog</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="kt">Response</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Request</span><span class="p">])</span><span class="w">  </span><span class="ow">=</span>
<span class="w">  </span><span class="n">lst</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="kt">Bottom</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="kt">Response</span>
<span class="w">  </span><span class="n">reqs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">prog</span><span class="w"> </span><span class="p">(</span><span class="n">unsafeLazyRead</span><span class="w"> </span><span class="n">lst</span><span class="p">)</span>
<span class="w">  </span><span class="n">loop</span><span class="w"> </span><span class="n">reqs</span><span class="w"> </span><span class="n">lst</span><span class="w"> </span><span class="kr">where</span>
<span class="w">    </span><span class="n">loop</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lst</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="kt">Nil</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="kt">Done</span>
<span class="w">    </span><span class="n">loop</span><span class="w"> </span><span class="p">((</span><span class="kt">ReadRequest</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">reqs&#39;</span><span class="p">)</span><span class="w"> </span><span class="n">lst</span><span class="w"> </span><span class="ow">=</span>
<span class="w">      </span><span class="n">read</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">contents</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">        </span><span class="n">tl</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="kt">Bottom</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">RList</span><span class="w"> </span><span class="kt">Response</span>
<span class="w">        </span><span class="n">lst</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="kt">Cons</span><span class="w"> </span><span class="p">(</span><span class="kt">ReadResponse</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="w"> </span><span class="n">tl</span>
<span class="w">        </span><span class="n">loop</span><span class="w"> </span><span class="n">reqs&#39;</span><span class="w"> </span><span class="n">tl</span>
</pre></div>
</div>
<p>In a purely functional model, defining streams in terms of continuations requires linear space and quadratic time in terms of the number of requests issued. In particular, given <code class="docutils literal notranslate"><span class="pre">prog</span> <span class="pre">[...xs,Bottom])</span> <span class="pre">=</span> <span class="pre">[...as,newreq,Bottom]</span></code>, each request-response iteration has to evaluate <code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">(drop</span> <span class="pre">(length</span> <span class="pre">as)</span> <span class="pre">(prog</span> <span class="pre">[...xs,newresp,bottom]))</span></code> to get the new request, duplicating the evaluation of <code class="docutils literal notranslate"><span class="pre">prog</span></code> over the first <code class="docutils literal notranslate"><span class="pre">xs</span></code> elements. <span id="id21">[]</span> Haskell 1.0 used streams as its I/O model due to this performance consideration. But given the destructive update implementation, I don’t think this is an issue.</p>
<p>Per <span id="id22">[]</span>, continuations are easier to use than streams and preferred by most programmers. With continuations, responses are localized to each request, whereas streams require careful pattern-matching to ensure that requests and responses are matched up.</p>
</section>
<section id="free-monad">
<h3>Free monad<a class="headerlink" href="#free-monad" title="Permalink to this heading"></a></h3>
<p>There are some definitions on Hackage of free monads:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- free, control-monad-free, transformers-free</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Free</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Pure</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Free</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="kt">Free</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">))</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">FreeF</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Pure</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Free</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">FreeT</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="kt">FreeF</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">FreeT</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">))</span>

<span class="c1">-- indexed-free</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">IxFree</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">where</span>
<span class="w">    </span><span class="kt">Pure</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IxFree</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="kt">Free</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">(</span><span class="kt">IxFree</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IxFree</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">a</span>

<span class="c1">-- free-operational</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">ProgramT</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">FreeT</span><span class="w"> </span><span class="p">(</span><span class="kt">Coyoneda</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">Program</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Free</span><span class="w"> </span><span class="p">(</span><span class="kt">Coyoneda</span><span class="w"> </span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="n">a</span>

<span class="c1">-- operational</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">ProgramT</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="kt">Lift</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ProgramT</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
<span class="w">  </span><span class="kt">Bind</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ProgramT</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ProgramT</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ProgramT</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
<span class="w">  </span><span class="kt">Instr</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ProgramT</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>

<span class="c1">-- MonadPrompt, https://www.eyrie.org/%7Ezednenem/2013/06/prompt,</span>
<span class="c1">-- https://www.reddit.com/r/haskell/comments/5a5frc/a_correct_free_monad_and_free_monad_fix/</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Prompt</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Done</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="w"> </span><span class="kt">Prompt</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Prompt</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="kr">type</span><span class="w"> </span><span class="kt">Prompt</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">a</span><span class="w">  </span><span class="ow">=</span><span class="w">  </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span>
</pre></div>
</div>
<p>These are simple, but have drawbacks, per <a class="reference external" href="https://web.archive.org/web/20220124082435/http://comonad.com/reader/2011/free-monads-for-less/">Kmett</a>. (&gt;&gt;=) used left-associatively has quadratic running time, as like (++) it must rescan the list of instructions with every bind. Every time you bind in a free monad, structure accumulates and this structure must be traversed past to deal with subsequent left-associated bind invocations. Free monads never shrink after a bind and the main body of the tree never changes.</p>
<p>Due to this, free monads are spine-strict - instructions must always be evaluated. Similarly MonadFix is not possible.</p>
</section>
<section id="yoneda">
<h3>Yoneda<a class="headerlink" href="#yoneda" title="Permalink to this heading"></a></h3>
<p><a class="reference external" href="http://comonad.com/reader/2011/free-monads-for-less-2/">Kmett</a> says to use <code class="docutils literal notranslate"><span class="pre">Yoneda</span> <span class="pre">(Rec</span> <span class="pre">f)</span> <span class="pre">a</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">newtype</span> <span class="pre">F</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">F</span> <span class="pre">{</span> <span class="pre">runF</span> <span class="pre">::</span> <span class="pre">forall</span> <span class="pre">r.</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">(f</span> <span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span> <span class="pre">}</span></code>, instead of <code class="docutils literal notranslate"><span class="pre">Codensity</span> <span class="pre">f</span> <span class="pre">a</span></code>. The claim is that this type is “smaller” than Codensity in the sense that the inhabitants of <code class="docutils literal notranslate"><span class="pre">F</span></code> are in a one-to-one correspondence with those of <code class="docutils literal notranslate"><span class="pre">Free</span> <span class="pre">f</span> <span class="pre">a</span></code>. But what we are interested in is <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code>; the recursive layering actually adds extra inhabitants as well, and there is also the <code class="docutils literal notranslate"><span class="pre">Pure</span></code> constructor that doesn’t make much sense for I/O. For example <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">Identity</span> <span class="pre">()</span></code> is the type of Church numerals, <code class="docutils literal notranslate"><span class="pre">(r</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">(r</span> <span class="pre">-&gt;</span> <span class="pre">r)</span></code> while <code class="docutils literal notranslate"><span class="pre">Codensity</span> <span class="pre">Identity</span> <span class="pre">()</span> <span class="pre">=</span> <span class="pre">forall</span> <span class="pre">r.</span> <span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">r</span> <span class="pre">=</span> <span class="pre">()</span> <span class="pre">=</span> <span class="pre">Identity</span> <span class="pre">()</span></code>. So in this case it is actually <code class="docutils literal notranslate"><span class="pre">F</span></code> that is larger.</p>
<p>Just looking at the types, F has more arrows. Similarly compare the instances:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- F f</span>
<span class="nf">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">kp</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">kp</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="kt">F</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">F</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">kp</span><span class="w"> </span><span class="n">kf</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">runF</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">kp</span><span class="w"> </span><span class="n">kf</span><span class="p">)</span><span class="w"> </span><span class="n">kf</span><span class="p">)</span>

<span class="c1">-- C f</span>
<span class="nf">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="nf">m</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">runC</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">runC</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">))</span>
</pre></div>
</div>
<p>The instance for <code class="docutils literal notranslate"><span class="pre">C</span></code> is fewer characters.</p>
<p>There is <span id="id23">[<a class="reference internal" href="../zzreferences.html#id133" title="Exequiel Rivas and Mauro Jaskelioff. Notions of computation as monoids. Journal of Functional Programming, May 2014. URL: https://www.cambridge.org/core/journals/journal-of-functional-programming/article/notions-of-computation-as-monoids/70019FC0F2384270E9F41B9719042528 (visited on 2022-06-08), doi:10.1017/S0956796817000132.">RJ14</a>]</span> which derives the Codensity monad from the Yoneda lemma and the assumption that <code class="docutils literal notranslate"><span class="pre">f</span></code> is a small functor. Whereas the Yoneda-Rec seems to have no category theory behind it.</p>
<p>Generally it seems that Yoneda solves a different problem than an I/O monad.</p>
</section>
<section id="algebraic-effects">
<h3>Algebraic effects<a class="headerlink" href="#algebraic-effects" title="Permalink to this heading"></a></h3>
<p>Codensity and algebraic effects are quite similar, both using a data type to represent operations. In fact the two are macro-expressively equivalent. <span id="id24">[<a class="reference internal" href="../zzreferences.html#id61" title="Yannick Forster, Ohad Kammar, Sam Lindley, and Matija Pretnar. On the Expressive Power of User-Defined Effects: Effect Handlers, Monadic Reflection, Delimited Control. arXiv:1610.09161 [cs], February 2017. URL: http://arxiv.org/abs/1610.09161 (visited on 2021-11-29), arXiv:1610.09161.">FKLP17</a>]</span> But Codensity doesn’t require new syntax unlike the handler functionality. In the effect approach, computations are not first-class values.</p>
<p>OTOH effect types are quite useful, because you can define code that is polymorphic over the effect type, hence can be used as both pure and impure code. They use a monadic translation and then pure code is the identity monad. This can be shoehorned into continuations too by using a symbol marker with cases for pure and impure but maybe it is not as nice.</p>
</section>
<section id="call-by-push-value">
<h3>Call by push value<a class="headerlink" href="#call-by-push-value" title="Permalink to this heading"></a></h3>
<p>CBPV has “values” and “computations”. The original presentation has these as separate categories, but <span id="id25">[<a class="reference internal" href="../zzreferences.html#id52" title="J. Egger, R. E. Mogelberg, and A. Simpson. The enriched effect calculus: syntax and semantics. Journal of Logic and Computation, 24(3):615–654, June 2014. URL: https://academic.oup.com/logcom/article-lookup/doi/10.1093/logcom/exs025 (visited on 2021-11-09), doi:10.1093/logcom/exs025.">EMS14</a>]</span> presents an alternative calculus EC+ where every computation is also a value. There is exactly one primitive that sequences computation, <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">to</span> <span class="pre">x.</span> <span class="pre">N</span></code>, which acts like the monadic bind <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">&gt;&gt;=</span> <span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">N</span></code>, and similarly there is <code class="docutils literal notranslate"><span class="pre">return</span></code>. And the evaluation is CBV. So stripping away the thunk stuff it seems to be a disguised version of monads. And the thunk stuff is a rather fragile way to implement CBN - it doesn’t generalize to call by need. <span id="id26">[<a class="reference internal" href="../zzreferences.html#id109" title="Dylan McDermott and Alan Mycroft. Extended Call-by-Push-Value: Reasoning About Effectful Programs and Evaluation Order. In Luís Caires, editor, Programming Languages and Systems, volume 11423, pages 235–262. Springer International Publishing, Cham, 2019. URL: http://link.springer.com/10.1007/978-3-030-17184-1_9 (visited on 2021-11-09), doi:10.1007/978-3-030-17184-1_9.">MM19</a>]</span> And then there is jump-with-argument (JWA) which uses continuations and is equivalent to CBPV.</p>
</section>
<section id="applicative">
<h3>Applicative<a class="headerlink" href="#applicative" title="Permalink to this heading"></a></h3>
<p>All uses of Applicative can be rewritten using the laws to be of the form <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">a</span> <span class="pre">&lt;*&gt;</span> <span class="pre">b</span> <span class="pre">...</span> <span class="pre">&lt;*&gt;</span> <span class="pre">d</span></code> (where <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> is left associative), hence all uses can be rewritten to the idiom bracket syntax. And the idiom bracket syntax <code class="docutils literal notranslate"><span class="pre">([</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span> <span class="pre">])</span></code> can be replaced with variadic function syntax, <code class="docutils literal notranslate"><span class="pre">apply_thing</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code>. So variadic functions are sufficient.</p>
<p>Applicative can also be represented typeclass-free as functions using their Cayley representation and the Yoneda lemma, see <span id="id27">[<a class="reference internal" href="../zzreferences.html#id133" title="Exequiel Rivas and Mauro Jaskelioff. Notions of computation as monoids. Journal of Functional Programming, May 2014. URL: https://www.cambridge.org/core/journals/journal-of-functional-programming/article/notions-of-computation-as-monoids/70019FC0F2384270E9F41B9719042528 (visited on 2022-06-08), doi:10.1017/S0956796817000132.">RJ14</a>]</span> and <a class="reference external" href="https://fa.haskell.narkive.com/hUgYjfKJ/haskell-cafe-the-mother-of-all-functors-monads-categories#post3">this email</a>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Rep</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
<span class="kt">Yoneda</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span>
<span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Rep</span><span class="w"> </span><span class="p">(</span><span class="kt">Yoneda</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">a</span>
<span class="nf">pure</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span>

<span class="nf">lift</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">pure</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">((</span><span class="o">&lt;*&gt;</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span>
<span class="nf">lower</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
<p>So every function <code class="docutils literal notranslate"><span class="pre">Applicative</span> <span class="pre">f</span> <span class="pre">=&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">...</span></code> can be replaced with <code class="docutils literal notranslate"><span class="pre">Applicative</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Applicative</span> <span class="pre">f</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">...</span></code> - the normalization enabled by Cayley and Yoneda means you don’t have to worry about instance coherency.</p>
</section>
<section id="promises">
<h3>Promises<a class="headerlink" href="#promises" title="Permalink to this heading"></a></h3>
<p>An example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">function</span><span class="w"> </span><span class="n">foo</span><span class="nb">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="n">f</span><span class="nb">()</span><span class="o">.</span><span class="kr">then</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">then</span></code> operation is basically monadic bind, so this is another form of monad syntax. There are <a class="reference external" href="https://buzzdecafe.github.io/2018/04/10/no-promises-are-not-monads">inconsistencies</a> with the Monad laws due to Promise flattening, which are enshrined in the spec and <a class="reference external" href="https://github.com/promises-aplus/promises-spec/issues/94">unfixable</a> without creating a wrapper API. But ignoring those, the Promise type is something like <code class="docutils literal notranslate"><span class="pre">Promise</span> <span class="pre">err</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Fulfilled</span> <span class="pre">a</span> <span class="pre">|</span> <span class="pre">Rejected</span> <span class="pre">err</span> <span class="pre">|</span> <span class="pre">Pending</span> <span class="pre">({</span> <span class="pre">resolve</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">(),</span> <span class="pre">reject</span> <span class="pre">:</span> <span class="pre">err</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()}</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">())</span></code>, which focusing on <code class="docutils literal notranslate"><span class="pre">Pending</span></code> is a CPS monad <code class="docutils literal notranslate"><span class="pre">(Either</span> <span class="pre">err</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">())</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span> <span class="pre">=</span> <span class="pre">EitherT</span> <span class="pre">err</span> <span class="pre">(Cont</span> <span class="pre">(IO</span> <span class="pre">()))</span> <span class="pre">a</span></code>.</p>
<p>Some arguments against:</p>
<ul class="simple">
<li><p>Promises do not conform to functor or monad laws and thus are not safe for compositional refactoring.</p></li>
<li><p>JS promises allow execution after the promise is resolved or rejected, resulting in untraceable behavior (fixed in C# by overriding return/throw instead of using resolve/reject)</p></li>
</ul>
</section>
<section id="monad-combined-with-identity-monad">
<h3>Monad combined with identity monad<a class="headerlink" href="#monad-combined-with-identity-monad" title="Permalink to this heading"></a></h3>
<p>With the lazy identity monad you can recover lazy pure code, as if there was no monad syntax. <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">m</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">Either</span> <span class="pre">a</span> <span class="pre">(m</span> <span class="pre">a)</span></code> is a monad (<a class="reference external" href="https://stackoverflow.com/a/49703783">SO implementation</a>) so we can mix this in with other monads. For a dynamic language, we would like to split the universal type <code class="docutils literal notranslate"><span class="pre">Any</span></code> into actions and pure values, so that <code class="docutils literal notranslate"><span class="pre">Any</span></code> forms a monad and actions are just a special type of value that has more complex sequencing behavior. We calculate:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Any</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Either</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Either</span><span class="w"> </span><span class="kt">Pure</span><span class="w"> </span><span class="kt">Action</span>
<span class="kt">Pure</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span>
<span class="kt">Action</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="kt">Pure</span>
<span class="kt">Pure</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Any</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="kt">Action</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Int</span></code> is not <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">_</span></code>, so it is pure. <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">Int</span></code> is therefore an action. Therefore <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">(m</span> <span class="pre">Int)</span></code> is not an action, because to be an action it would have to return a pure value. Hence <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">(m</span> <span class="pre">Int)</span></code> is pure, a surprising conclusion. Similarly <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">(m</span> <span class="pre">(m</span> <span class="pre">Int))</span></code> is an action. We can convert between these with <code class="docutils literal notranslate"><span class="pre">join</span></code> and <code class="docutils literal notranslate"><span class="pre">return</span></code>. This weirdness somewhat explains why JS felt the need to collapse nested promises and break the monad laws - it avoids the need to unroll the promise chain to deduce whether a value is an action.</p>
</section>
<section id="async">
<h3>Async<a class="headerlink" href="#async" title="Permalink to this heading"></a></h3>
<p>In JavaScript</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">async</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">foo</span><span class="nb">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">await</span><span class="w"> </span><span class="n">f</span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Async/await notation requires marking core library calls with “await” and the whole call chain with “async”, a tedious syntactic burden that Bob Nystrom calls <a class="reference external" href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">function coloring</a>.</p>
<p>It’s better to make the async behavior automatic. Zig has done this but has <a class="reference external" href="https://gavinhoward.com/2022/04/i-believe-zig-has-function-colors/">tons of bugs</a>. Monads in general and continuations in particular seem like a more principled approach, e.g. there is a <a class="reference external" href="https://github.com/dmitriz/cpsfy/blob/master/DOCUMENTATION.md">JS CPS library</a>.</p>
</section>
<section id="futures">
<h3>Futures<a class="headerlink" href="#futures" title="Permalink to this heading"></a></h3>
<p>According to <a class="reference external" href="https://www.youtube.com/watch?v=QNpKYypLAO8">Erik Meijer</a> (38:16), futures are kind of like comonads. A comonad has three operations: fmap, extract, and duplicate. Fmap make sense for a future, you can apply a function on the result. Duplicate is a little pointless but also possible, you can make a future that returns a future. There is the question of why not just the monadic <code class="docutils literal notranslate"><span class="pre">return</span></code> but it sort of makes sense, a future is delayed whereas a value is not. Finally you can <code class="docutils literal notranslate"><span class="pre">extract</span></code> the value from a future. This one is really pushing it though because the extract operation blocks, and can throw a deadlock exception, so it’s not pure. We have to model extract more carefully as <code class="docutils literal notranslate"><span class="pre">Future</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">M</span> <span class="pre">a</span></code> for some monad. <span id="id28">[]</span> called this kind of comonad-monad function a “BiKleisli category”, i.e. the category <code class="docutils literal notranslate"><span class="pre">BiKlesli</span> <span class="pre">Future</span> <span class="pre">M</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">Future</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">M</span> <span class="pre">b</span></code>. So rather than the comonad structure, we just have the identity and composition operations of the category, and arrow stuff. So really we aren’t talking about comonads at all but rather arrows.</p>
</section>
<section id="tasks">
<span id="id29"></span><h3>Tasks<a class="headerlink" href="#tasks" title="Permalink to this heading"></a></h3>
<p>We can model I/O operations as members of a <code class="docutils literal notranslate"><span class="pre">Task</span></code> type, consisting of constructor terms plus callback(s) for what to do with the return value. Sequences of I/O operations are values of type <code class="docutils literal notranslate"><span class="pre">Task</span></code>, similar to a <a class="reference external" href="https://www.reddit.com/r/haskell/comments/swffy/why_do_we_not_define_io_as_a_free_monad/">free monad</a>. Statements that don’t return are directly of the Task type, like <code class="docutils literal notranslate"><span class="pre">Exit</span> <span class="pre">{</span> <span class="pre">code</span> <span class="pre">:</span> <span class="pre">Int}</span></code>. Statements that continue in a sequential fashion have a <code class="docutils literal notranslate"><span class="pre">continuation</span></code> argument, like <code class="docutils literal notranslate"><span class="pre">Print</span> <span class="pre">{</span> <span class="pre">s</span> <span class="pre">:</span> <span class="pre">String,</span> <span class="pre">continuation</span> <span class="pre">:</span> <span class="pre">Task</span> <span class="pre">}</span></code>, so are of type <code class="docutils literal notranslate"><span class="pre">Command</span> <span class="pre">=</span> <span class="pre">Task</span> <span class="pre">-&gt;</span> <span class="pre">Task</span></code>. Statements that return a value use a continuation of type <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Task</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">ReadFile</span> <span class="pre">{</span> <span class="pre">path</span> <span class="pre">:</span> <span class="pre">Fd,</span> <span class="pre">continuation</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">Task}</span></code>, so are of type <code class="docutils literal notranslate"><span class="pre">Operation</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">Task)</span> <span class="pre">-&gt;</span> <span class="pre">Task</span></code>. And since tasks are values we can also use them as arguments, like the <code class="docutils literal notranslate"><span class="pre">delayed_task</span></code> in <code class="docutils literal notranslate"><span class="pre">SetTimeout</span> <span class="pre">{</span> <span class="pre">delay</span> <span class="pre">:</span> <span class="pre">Int,</span> <span class="pre">delayed_task</span> <span class="pre">:</span> <span class="pre">Task,</span> <span class="pre">continuation</span> <span class="pre">:</span> <span class="pre">Task}</span></code>.</p>
<p>With this approach an I/O operation is data that can be pattern-matched over, allowing many metaprogramming techniques. It’s a little harder for the compiler to optimize that readIORef has no observable side effects, as it’s a reordering property (commutativity), but strict languages have been doing this for years.</p>
<p>To see how this works, consider the program <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;Hi&quot;</span></code>. As a task this is the value <code class="docutils literal notranslate"><span class="pre">Print</span> <span class="pre">&quot;Hi&quot;</span> <span class="pre">(Exit</span> <span class="pre">0)</span></code>, where <code class="docutils literal notranslate"><span class="pre">Exit</span> <span class="pre">0</span></code> is what happens after printing (the continuation). The operation is <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">Print</span> <span class="pre">a</span> <span class="pre">cont</span></code>. With the continuation as the last argument we can just use the partially-applied function, <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">=</span> <span class="pre">Print</span></code>. <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">a</span> <span class="pre">&gt;&gt;</span> <span class="pre">print</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">Print</span> <span class="pre">a</span> <span class="pre">(Print</span> <span class="pre">b</span> <span class="pre">cont)</span></code>. Now consider <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">ref</span> <span class="pre">&gt;&gt;=</span> <span class="pre">print</span></code>. The operation is <code class="docutils literal notranslate"><span class="pre">Read</span> <span class="pre">ref</span> <span class="pre">&gt;&gt;=</span> <span class="pre">Print</span></code> where <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> is the continuation monad’s bind operation, which expands to <code class="docutils literal notranslate"><span class="pre">\cont</span> <span class="pre">-&gt;</span> <span class="pre">Read</span> <span class="pre">ref</span> <span class="pre">(\v</span> <span class="pre">-&gt;</span> <span class="pre">Print</span> <span class="pre">v</span> <span class="pre">cont)</span></code>.</p>
<p>Actually print isn’t a primitive operation, it’s more like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Data</span><span class="w"> </span><span class="s">&quot;Hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">msg</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">Block</span><span class="w"> </span><span class="s">&quot;_start&quot;</span><span class="w"> </span><span class="p">[</span><span class="kt">Sys_write</span><span class="w"> </span><span class="n">stdout</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Sys_exit</span><span class="w"> </span><span class="mi">0</span><span class="p">)])</span>
</pre></div>
</div>
<p>with Stroscot’s internal assembler language.</p>
<p>Task isn’t really a monad, but we can compose operations that return values using the continuation monad’s bind operation, as implemented with do-notation.</p>
<p>The datatype is similar to the “fudgets” mentioned in <span id="id30">[<a class="reference internal" href="../zzreferences.html#id58" title="Levent Erkok. Value Recursion in Monadic Computations. PhD thesis, Oregon Health and Science University, October 2002. URL: http://leventerkok.github.io/papers/erkok-thesis.pdf.">Erk02</a>]</span>, except we don’t have a pure constructor. Or <a class="reference external" href="http://comonad.com/reader/2011/free-monads-for-less-3/">this</a> type <code class="docutils literal notranslate"><span class="pre">FFI</span> <span class="pre">o</span> <span class="pre">i</span></code>, but with control flow represented explicitly instead of using <code class="docutils literal notranslate"><span class="pre">o</span></code> or <code class="docutils literal notranslate"><span class="pre">i</span></code> parameters.</p>
</section>
<section id="world-token">
<h3>World token<a class="headerlink" href="#world-token" title="Permalink to this heading"></a></h3>
<p>Haskell uses a state monad <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">s</span> <span class="pre">-&gt;</span> <span class="pre">(#</span> <span class="pre">s,</span> <span class="pre">a</span> <span class="pre">#))</span></code> for implementing I/O, where <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">World</span></code> is a special zero-sized token type. Clean is similar but <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">*World</span></code> has the uniqueness type annotation so the tokens must be used linearly. Regardless, this approach is quite awkward:</p>
<ul class="simple">
<li><p>Programs like <code class="docutils literal notranslate"><span class="pre">(a,_)</span> <span class="pre">=</span> <span class="pre">getChar</span> <span class="pre">s;</span> <span class="pre">(b,s')</span> <span class="pre">=</span> <span class="pre">getChar</span> <span class="pre">s;</span> <span class="pre">putChar</span> <span class="pre">(a,b)</span> <span class="pre">s'</span></code> that reuse tokens are broken and have to be forbidden. Similarly programs like <code class="docutils literal notranslate"><span class="pre">(a,s2)</span> <span class="pre">=</span> <span class="pre">getChar</span> <span class="pre">s;</span> <span class="pre">(b,s)</span> <span class="pre">=</span> <span class="pre">getChar</span> <span class="pre">s2</span></code> that pass the token back also have to be forbidden.</p></li>
<li><p>GHC requires many hacks to ensure that linearity holds during core-to-core transformations.</p></li>
<li><p>Commands like <code class="docutils literal notranslate"><span class="pre">exit</span> <span class="pre">0</span></code> have to be modeled as returning a world token, even though they don’t return at all.</p></li>
<li><p>It is not clear what the token represents: a thread? a core? a state? The semantics of an infinite program like <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">write</span> <span class="pre">&quot;x&quot;</span> <span class="pre">&gt;&gt;</span> <span class="pre">x</span></code> is tricky to specify - it is not really a function at all.</p></li>
<li><p>An I/O operation is an abstract function which makes it quite difficult to inspect IO values or implement simulations of I/O such as <a class="reference external" href="https://hackage.haskell.org/package/pure-io-0.2.1/docs/PureIO.html">PureIO</a>.</p></li>
</ul>
</section>
</section>
<section id="logic-programming">
<h2>Logic programming<a class="headerlink" href="#logic-programming" title="Permalink to this heading"></a></h2>
<p>To make a general-purpose relational programming language, we must find a method of embedding I/O that preserves the relational semantics. What I’ve come up with is to make programs produce a functional I/O term as output, so that the satisfying states contains bindings like <code class="docutils literal notranslate"><span class="pre">main</span> <span class="pre">=</span> <span class="pre">readln</span> <span class="pre">(\x</span> <span class="pre">-&gt;</span> <span class="pre">(print</span> <span class="pre">(&quot;hello</span> <span class="pre">&quot;++x)</span> <span class="pre">end)))</span></code>.</p>
<p>In general running a relational program may produce infinite satisfying states. Using the <code class="docutils literal notranslate"><span class="pre">run</span></code> function, the list of possible states of a term can be inspected, so it would limit expressiveness to disallow local nondeterminism. But nondeterminism in the I/O term is an error - there is no way to reconcile <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;b&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;c&quot;</span></code>, because the user can only see one output. Arbitrarily choosing a state would just be confusing. So we require that the I/O be unique over all satisfying states. In standalone programs the state only contains the <code class="docutils literal notranslate"><span class="pre">main</span></code> term, so this means standalone programs must be deterministic overall and resolve to a single state. But <code class="docutils literal notranslate"><span class="pre">run</span></code> transforms a nondeterministic logic program to a deterministic stream of data, and spawning threads uses a fresh <code class="docutils literal notranslate"><span class="pre">threadMain</span></code> binding, so this shouldn’t be too restrictive. Mercury <a class="reference external" href="https://www.mercurylang.org/information/doc-latest/mercury_trans_guide/IO.html">uses</a> the “unique world” state-passing model of I/O, and has a similar restriction that predicates that do I/O must be deterministic (may not fail or return multiple times).</p>
</section>
<section id="colored-values">
<h2>Colored values<a class="headerlink" href="#colored-values" title="Permalink to this heading"></a></h2>
<p>Often mentioned during I/O discussions are Bob Nystrom’s traits of <a class="reference external" href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">function coloring</a>. <a class="reference external" href="https://news.ycombinator.com/item?id=8985436">tel on HN</a> suggested using red = impure, and <a class="reference external" href="https://gavinhoward.com/2022/04/i-believe-zig-has-function-colors/#review-of-function-colors">Gavin</a> suggested replacing “call” with “use”. Most of the traits are then about “impure functions”, which Stroscot calls actions. Stroscot allows running actions in a pure environment using an I/O simulation. With these modifications the traits read:</p>
<ol class="arabic simple">
<li><p>Values include pure functions and actions.</p></li>
<li><p>The way you use a value depends on its type.</p></li>
<li><p>You can only use an action from within another action, or within an I/O simulator.</p></li>
<li><p>Actions are more painful to use (than pure functions).</p></li>
<li><p>Some core library members are actions.</p></li>
</ol>
<p>The only trait here that might be disadvantageous is 4. Nystrom lists the following pain points for JS async actions:</p>
<ul class="simple">
<li><p>verbose to compose in expressions because of the callbacks / promise goop</p></li>
<li><p>annoying hoops to use error-handling</p></li>
<li><p>can’t be used with try/catch or a lot of other control flow statements.</p></li>
<li><p>can’t call a function that returns a future from synchronous code</p></li>
</ul>
<p>C# async-await solves all but the first, but the await keyword is still painful. Nystrom says the real solution is “multiple independent callstacks that can be switched between.” Stroscot goes further than switching and makes I/O callstacks first-class continuations. With continuations as the I/O abstraction, there is no distinction between sync and async, or rather it is all async. In particular all low-level operations are implemented in async style (taking callbacks), and combinators must be written using the callback/continuation model. But simple sequential code can be written in sync style and this interoperates seamlessly with the async code. Thus Stroscot’s I/O continuation model solves the distinction pain Nystrom was complaining about.</p>
<p>There is still a pure/impure dichotomy though. Regardless of syntax, impurity cannot be hidden completely. Actions will always have some conceptual overhead compared to pure functions because they are sensitive to execution order. I don’t know if this will make anyone “spit in your coffee and/or deposit some even less savory fluids in it” (Nystrom), but I/O is unfortunately awkward in a pure or mathematical world. A program that does no I/O must be an infinite loop (it cannot even exit, because that requires a syscall). <span id="id31">[<a class="reference internal" href="../zzreferences.html#id84" title="Simon Peyton Jones. Tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell. In Engineering Theories of Software Construction, 47–96. 2001. URL: https://www.microsoft.com/en-us/research/publication/tackling-awkward-squad-monadic-inputoutput-concurrency-exceptions-foreign-language-calls-haskell/.">Jon01</a>]</span> classifies I/O under the “awkward squad”.</p>
</section>
<section id="unsafe-i-o">
<h2>“Unsafe” I/O<a class="headerlink" href="#unsafe-i-o" title="Permalink to this heading"></a></h2>
<p>Haskell has <code class="docutils literal notranslate"><span class="pre">runST</span></code> and <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code> that allow turning impure computation into pure computations. These can be implemented by throwing a resumable exception that’s caught in a top-level handler that does the I/O. <code class="docutils literal notranslate"><span class="pre">runST</span></code> scrutinizes its computation for impure behavior such as printing or returning allocated references, while <code class="docutils literal notranslate"><span class="pre">unsafePerformIO</span></code> does not and exposes the internal evaluation order.</p>
<p>If one wants to understand the evaluation order or is dealing with commutative operations, these functions are quite useful, e.g. Debug.Trace.trace looks like a non-I/O function but actually outputs something on the console, and allocation can be done in any order.</p>
<p>The main things to avoid is global variables like <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">unsafePerformIO</span> <span class="pre">(newIORef</span> <span class="pre">1)</span></code> pattern. Implicit parameters initialized in main compose much better. Similarly C’s <code class="docutils literal notranslate"><span class="pre">static</span></code> variables inlined in functions should be forbidden. Although, optimal reduction should mean an unsafePerformIO is only evaluated once, hence reading a file or something should be fine.</p>
<section id="top-level-i-o">
<h3>Top-level I/O<a class="headerlink" href="#top-level-i-o" title="Permalink to this heading"></a></h3>
<p>In Python we can write a simple script like <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;hello</span> <span class="pre">world&quot;</span></code>. In Haskell we must have the boilerplate <code class="docutils literal notranslate"><span class="pre">main</span> <span class="pre">=</span></code>, which is more verbose. We can address this by allowing modules to be actions that return the actual record. The main issue is we must have an instance of MonadFix in order to tie the recursive knot. But fortunately there are <a class="reference external" href="https://github.com/ekmett/kan-extensions/issues/64">several implementations</a> of MonadFix for continuations; the only question is which one is correct.</p>
<p>The other option is to restrict I/O outside of main, e.g. to only the main module, which means that e.g. mutable variables cannot exist between calls of a function. This seems too restrictive.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Standard-Library.html" class="btn btn-neutral float-left" title="Standard library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Syntax.html" class="btn btn-neutral float-right" title="Syntax" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>