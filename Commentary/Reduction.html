<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reduction &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Reduction example" href="Reduction-Example.html" />
    <link rel="prev" title="Exemplary programs" href="Programs.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fexprs.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">About</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Reduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#reduction-order">Reduction order</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compressed-graphs">Compressed graphs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#recursion">Recursion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#syntax">Syntax</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#derivation-tree">Derivation tree</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nets">Nets</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expression-tree">Expression “tree”</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bad-syntax">Bad syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#real-syntax">Real syntax</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cut-elimination">Cut elimination</a></li>
<li class="toctree-l3"><a class="reference internal" href="#normal-order-reduction">Normal Order Reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#optimal-reduction">Optimal reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#primitives">Primitives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linear-logic">Linear logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">Recursion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">Optimal reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#random-old-junk">Random old junk</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#levels">Levels</a></li>
<li class="toctree-l3"><a class="reference internal" href="#f2-g2">F2 G2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#readback">Readback</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#junk">Junk</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Imperative programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Commentary</a> &raquo;</li>
      <li>Reduction</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Reduction.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="reduction">
<h1>Reduction<a class="headerlink" href="#reduction" title="Permalink to this headline"></a></h1>
<p>Stroscot takes after Haskell in that all of the language is compiled to a smallish core language. But the core is the jumbo two-sided linear logic sequent calculus. Reduction of this core corresponds to cut elimination - the normal forms (values) are cut-free terms.</p>
<section id="reduction-order">
<h2>Reduction order<a class="headerlink" href="#reduction-order" title="Permalink to this headline"></a></h2>
<p>Lazy evaluation doesn’t introduce more than a constant factor more of CPU overhead over similar strict runtime systems. (<a class="reference external" href="https://stackoverflow.com/questions/63698539/how-is-lazy-evaluation-implemented-in-a-way-that-doesnt-require-more-overhead-t">ref</a> <a class="reference external" href="https://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html">2</a>) The overhead of creating a thunk and forcing its evaluation replaces the overhead of creating a stack frame, calling the function, and returning. The function call is shifted in time but the cost is not significantly increased. Optimal reduction is similar - ignoring bookkeeping, the number of graph reduction steps is linearly related to the number of beta reductions, except for fan-fan duplication, which is quadratic. <span class="xref std std-ref">guerriniOptimalImplementationInefficient2017</span> But my implementation avoids bookkeeping and fan-fan duplication and hence is linear (TODO: prove this).</p>
<p>Lazy evaluation only helps timewise if a box is weakened. The top-level instruction evaluation loop can be written strictly, using a code pointer for conditional nodes.</p>
<p>However memory is a different story. The attraction of non-strict evaluation is the possibility for evaluating modular programs with memory-efficient evaluation orders. For example, consider a data processor, where one wants to parse and process input <em>in constant memory</em>, i.e. the memory consumption is not allowed to depend on the size of the input file. With non-strict evaluation, the task can be split up into logical function (lexer, parser, and emitter), each producing a full data structure. When these are composed with non-strict evaluation the intermediate data structures will be evaluated away, hence using constant memory. With strict evaluation the data structures would instead be evaluated fully at each step, giving terrible performance. In a strict language, one would have to use a streaming abstraction and manage the control flow explicitly to obtain constant memory.</p>
<p>Lazy evaluation only partially addresses this. With the definition <code class="docutils literal notranslate"><span class="pre">sum</span> <span class="pre">=</span> <span class="pre">foldl</span> <span class="pre">(+)</span> <span class="pre">0</span></code>, unevaluated addition thunks pile up and are only forced at the end, hence the sum operation takes O(n) memory instead of running in a streaming fashion over the list. Haskell has introduced the <code class="docutils literal notranslate"><span class="pre">seq</span></code> command, but this is by no means a solution - it means every basic function must come in several strictness variants.</p>
<p>What we need is a “smart” reduction order, that reduces so as to minimize memory usage. Optimal would be nice, but is probably impossible - really it just has to be better than strict evaluation, because strict evaluation has a “reasonable” cost model. So rather than GHC’s strictness analysis or demand analysis which proves usage and falls back to lazy, we want a laziness analysis which identifies nontermination and opportunities for optimization and falls back to strict.</p>
<p><code class="docutils literal notranslate"><span class="pre">avg</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">sum</span> <span class="pre">xs</span> <span class="pre">/</span> <span class="pre">length</span> <span class="pre">xs</span></code> keeps the whole list in memory because it does the sum and then the length (<cite>ref &lt;https://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/&gt;__</cite>) - an optimal strategy would have to switch evaluation back and forth between the sum and the length. With the sequent calculus IR this might actually be solved, because cuts get pushed down continually and the natural strategy is to reduce the topmost cut. So in the average calculation we cycle through the redexes for each list element and can discard the beginning of the list once it is processed.</p>
<p>for efficient graph reduction we want to reduce a term completely, if we are able to.</p>
<p>Reduction of our linear logic trees is not confluent, but only because of commuting cuts. If we drop the black edges and only consider proof nets, then the system is confluent. A cut only interacts with other cuts at identity rules, but with a cut-identity-cut pattern it doesn’t matter which cut reduces with the identity.</p>
<p>Since reduction is confluent, it does not change anything to reduce in non-normal order for a time. The reduction will still terminate when going back to normal order. So terminating reductions can always be performed and even non-terminating reductions can be reduced somewhat. Hence during compilation we want to reduce the program as much as possible - ideally the compiled core should be cut-free. We can detect diverging terms and replace them with error terms. But the way to handle complex recursion isn’t clear. For example the Fibonacci list <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">fibs</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">::</span> <span class="pre">1</span> <span class="pre">::</span> <span class="pre">zipWith</span> <span class="pre">(+)</span> <span class="pre">fibs</span> <span class="pre">(tail</span> <span class="pre">fibs)</span> <span class="pre">in</span> <span class="pre">{</span> <span class="pre">repeat</span> <span class="pre">forever</span> <span class="pre">{</span> <span class="pre">n</span> <span class="pre">&lt;-</span> <span class="pre">readInt;</span> <span class="pre">print</span> <span class="pre">(fibs</span> <span class="pre">!!</span> <span class="pre">n)</span> <span class="pre">}</span> <span class="pre">}</span></code>, this needs some kind of reduction graph or memo stack involved.</p>
</section>
<section id="compressed-graphs">
<h2>Compressed graphs<a class="headerlink" href="#compressed-graphs" title="Permalink to this headline"></a></h2>
<p>64-bit integers are represented as a sigma type with 2^64 possibilities. So addition is represented as a case expression, where each case contains another case expression, and then each case constructs the integer corresponding to the addition. There is a lot of fan-out at each step, which would require 2^128 values to represent, clearly infeasible. So although this is the conceptual representation, the actual representation has no fan-out for the cases - instead the case nodes create symbolic variables <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, and the constructed value has the tag <code class="docutils literal notranslate"><span class="pre">a+b</span></code>.</p>
<p>the value representation is optimized for the platform, and redundant checks are optimized out</p>
<p>The Implementation of Functional Programming Languages
Implementing functional languages: a tutorial
Implementing Lazy Functional Languages on Stock Hardware: The Spineless Tagless G-Machine
How to make a fast curry: push/enter vs eval/apply</p>
<p>a program is a dependency graph which is evaluated through a series of local reductions
the graph itself can be represented as code. In particular, we can represent a node as a function that when invoked, returns the desired value. The first time it is invoked, it asks the subnodes for their values and then operates on them, and then it overwrites itself with a new instruction that just says “return the result.”</p>
<p>The short answer is “because it was designed to do exactly that.” GHC uses the spineless tagless g-machine (STG). You can read a paper about it here (it’s quite complex). GHC does a lot of other things as well, such as strictness analysis and optimistic evaluation.</p>
<blockquote>
<div><p>The reason I say C and other imperative languages are somewhat similar to Turing Machines (but not to the extent that Haskell is similar to Lambda Calculus) is that in an imperative language, you have a finite number of states (a.k.a. line number), along with a Tape (the ram), such that the state and the current tape determine what to do to the tape.</p>
</div></blockquote>
<p>Is the point of confusion then that mutability should lead to slower code? Haskell’s laziness actually means that mutability doesn’t matter as much as you think it would, plus it’s high-level so there are many optimizations the compiler can apply. Thus, modifying a record in-place will rarely be slower than it would in a language such as C.</p>
<p>In this answer I provide a somewhat detailed comparison of function calls in the GHC RTS and a typical Java VM implementation. That answer is focused on memory usage (because the question was about garbage collection), but much of the discussion applies to performance more generally.</p>
<p>Summarizing the relevant bits, if you are trying to determine the overhead in calling a function to multiply two numbers:</p>
<p>bar :: Int -&gt; Int -&gt; Int
bar a b = a * b</p>
<p>as invoked by some other function:</p>
<p>foo :: Int -&gt; Int -&gt; Int -&gt; Int
foo x y z = let u = bar y z in x + u</p>
<p>then in a typical strict implementation, like the Java JVM, the byte code would probably look something like:</p>
<p>The overhead of the bar function call (i.e., the difference between the above and if bar was inlined) looks like it’s two argument pushes, the call itself, and the return.</p>
<p>For the lazy version, GHC (without optimization) compiles this code as something like the following pseudocode:</p>
<dl class="simple">
<dt>foo [x, y, z] =</dt><dd><p>u = new THUNK(sat_u)                   // thunk, 32 bytes on heap
jump: (+) x u</p>
</dd>
<dt>sat_u [] =                                 // saturated closure for “bar y z”</dt><dd><p>push UPDATE(sat_u)                     // update frame, 16 bytes on stack
jump: bar y z</p>
</dd>
<dt>bar [a, b] =</dt><dd><p>jump: (*) a b</p>
</dd>
</dl>
<p>The overhead of the lazy bar function call is the creation of a thunk on the bump heap (as fast as stack) that includes two arguments and a pointer to sat_u (plus room for the return value, though there’s no “cost” for this), and a “call” (not visible in the above code) when the (+) function forces the value u by jumping to sat_u. The update frame more or less replaces the return. (In this case, it can be optimized away.)</p>
<p>The bottom line is that, at least to a first approximation, lazy evaluation as implemented in GHC is roughly as fast as strict evaluation, even when everything is actually evaluated.</p>
</section>
<section id="recursion">
<h2>Recursion<a class="headerlink" href="#recursion" title="Permalink to this headline"></a></h2>
<p>Following <span id="id1">[<a class="reference internal" href="../zzreferences.html#id42" title="Simon Peyton Jones. The Implementation of Functional Programming Languages. Prentice-Hall, 1987. URL: https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/ (visited on 2020-08-02).">Jon87</a>]</span> chapter 12 we give each definition node a static integer. Then the root is a distinguished definition. Assuming the static data is stored on disk and paged in/out as needed, we can minimize runtime memory use in a compiler pass by introducing as many use-def indirections as possible, one for every sequent in the derivation. This also makes the connections between rules uniform. But having lots of indirections is inefficient so a later pass would remove indirections that will be immediately used (chunkification).</p>
<p>The optimal fixedpoint algorithm outlined in <span id="id2">[<a class="reference internal" href="../zzreferences.html#id64" title="Adi Shamir. The Fixedpoints of Recursive Definitions. PhD thesis, Weizmann Institute of Science, Rehovot, October 1976. URL: https://weizmann.primo.exlibrisgroup.com/permalink/972WIS_INST/1d4esio/alma990002185270203596.">Sha76</a>]</span> (10.18, PDF pages 240-242) is a variation of Tarjan’s strongly connected component algorithm. Cuts between two definitions <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> are memoized in a list, and if the SCC algorithm finds a component <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">let</span> <span class="pre">g</span> <span class="pre">=</span> <span class="pre">...</span> <span class="pre">in</span> <span class="pre">g</span> <span class="pre">(f</span> <span class="pre">x)</span></code> then this component is solved. If it has a unique solution then that’s the answer, otherwise <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> diverges and is replaced with a <code class="docutils literal notranslate"><span class="pre">RecursionError</span></code> or <code class="docutils literal notranslate"><span class="pre">AmbiguousError</span></code>. We assume the solver allows uninterpreted “holes”, so that the SCC can be solved before its sub-computations.</p>
<p>For comparison, to compute the least fixed point we would maintain a “working graph” and incrementally unfold the definition when encountered. But with the optimal fixed point we first reduce the definition to a value while copying other definitions in.</p>
<p>The solver is an SMT solver on the predicate <code class="docutils literal notranslate"><span class="pre">SAT(y</span> <span class="pre">==</span> <span class="pre">g</span> <span class="pre">y)</span></code>, and for uniqueness <code class="docutils literal notranslate"><span class="pre">UNSAT(y</span> <span class="pre">==</span> <span class="pre">g</span> <span class="pre">y</span> <span class="pre">&amp;&amp;</span> <span class="pre">y</span> <span class="pre">!=</span> <span class="pre">y0)</span></code> where <code class="docutils literal notranslate"><span class="pre">y0</span></code> is the first solution found. We exclude error values as possible solutions since the recursion error will be more informative.</p>
<p>The posets the paper uses appear to be pointed directed-complete partial orders <a class="reference external" href="https://en.wikipedia.org/wiki/Complete_partial_order">(cppo’s)</a>.</p>
</section>
<section id="syntax">
<h2>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline"></a></h2>
<p>Proofs are programs by the Curry-Howard correspondence. So we can use all these logical rules as a programming language. But we need a syntax for all the proofs.</p>
<section id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline"></a></h3>
<p>We use a simple program, boolean “and”, presented in a Haskell-ish language:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">and</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span> <span class="p">{</span> <span class="kt">False</span> <span class="ow">-&gt;</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">False</span><span class="p">;</span> <span class="kt">True</span> <span class="ow">-&gt;</span> <span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">y</span> <span class="p">}</span>
<span class="nf">r</span> <span class="ow">=</span> <span class="n">and</span> <span class="kt">False</span> <span class="kt">True</span> <span class="kt">:</span> <span class="kt">Bool</span>
</pre></div>
</div>
</section>
<section id="derivation-tree">
<h3>Derivation tree<a class="headerlink" href="#derivation-tree" title="Permalink to this headline"></a></h3>
<p>See the connectives <span class="math notranslate nohighlight">\(\text{B} = \text{Bool}\)</span> and <span class="math notranslate nohighlight">\(\multimap\)</span> defined <a class="reference internal" href="../Reference/Logic.html#connectives"><span class="std std-ref">above</span></a>. <span class="math notranslate nohighlight">\(\multimap\)</span> is right associative as usual. Our program then has the following derivation tree, among others (we could add a bang to the first argument, use a multiple-argument function, expand out the identity, etc.).</p>
<img alt="../_images/Stroscot_AND_Proof_Tree.svg" src="../_images/Stroscot_AND_Proof_Tree.svg" /><p>The derivation tree representation suffers from what Girard calls “bureaucratic problems of transposing rules” (<span id="id3">[<a class="reference internal" href="../zzreferences.html#id34" title="Jean-Yves Girard. Towards a geometry of interaction. In J. W. Gray and A. Scedrov, editors, Categories in Computer Science and Logic, volume 92 of Contemporary Mathematics, 69–108. University of Colorado in Boulder, 1989. American Mathematical Society. URL: https://jb55.com/linear/pdf/Towards%20a%20geometry%20of%20interaction.pdf.">Gir89</a>]</span>, page 30 / 98). Girard’s example is based on cut elimination; but it is also visible in the specification of the proof tree as rule reordering. For example the cuts on <span class="math notranslate nohighlight">\(\Sigma_{F R}\)</span> and “Use and” can be swapped without changing the meaning. The derivation tree is also ambiguous in that rule invocations with a sequent like <span class="math notranslate nohighlight">\(A, A \vdash B\)</span> are ambiguous as to which proposition <span class="math notranslate nohighlight">\(A\)</span> is used - this isn’t resolved by using the exchange rule as then exchange on <span class="math notranslate nohighlight">\(A, A, A \vdash B\)</span> is ambiguous as to which pair of formulas was swapped.</p>
</section>
<section id="nets">
<h3>Nets<a class="headerlink" href="#nets" title="Permalink to this headline"></a></h3>
<p>We can split up the derivation tree into a graph, where each node is a rule instance (the vertical bar in the derivation tree) and the syntactic subderivation relationship is a black edge.</p>
<img alt="../_images/AND_net.svg" src="../_images/AND_net.svg" /><img alt="../_images/AND_net_r.svg" src="../_images/AND_net_r.svg" /><p>To solve the bureaucratic problems there is another set of connecting edges, the red/blue edges in the graph. The edges are each proposition’s introduction/elimination (highest and lowest usage). Exchange rules can be omitted because we reference the propositions directly. The color is for clarity - a proposition on the left (antecedent) is blue and likewise right (succedent) is red. In the code each edge is identified as a unique variable in a slot, so there is no coloring. But depicting n-ary ports in a visual way without ambiguity seems hard.</p>
<p>Most rules do not modify the contexts <span class="math notranslate nohighlight">\(\Gamma, \Delta, \Theta, \Lambda\)</span> and so the proposition edge skips the node as it is not an introduction/elimination (gray in the presentation above). But there are exceptions that do need the context:</p>
<blockquote>
<div><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\Pi_R\)</span> and <span class="math notranslate nohighlight">\(\Sigma_L\)</span> rename and combine the context from each case, similar to a phi-node. This can be skipped if there’s exactly one case.</p></li>
<li><p>Exponential promotion defines a box around a subtree of the derivation, and the box edge must be clearly defined so we can duplicate/erase it properly, so we keep the context there.</p></li>
<li><p>Use/Assign, so that substitution has something to work with and the free variables are identified</p></li>
</ul>
</div></blockquote>
</section>
<section id="expression-tree">
<h3>Expression “tree”<a class="headerlink" href="#expression-tree" title="Permalink to this headline"></a></h3>
<p>For doing stuff, we do not need the syntactic subderivation inclusion relationship at all, all the important bits can be gotten from the blue/red edges. (TODO: is this true? how hard is it to preserve the syntactic relationship under cut elimination?)</p>
<p>If we drop the syntactic inclusion relationship, reverse the directions of the blue edges, and drop the sequents, then the graph looks much more like your traditional expression tree. In particular cuts and identities become straight edges rather than top/bottom. PiL is an application node, PiR is a lambda, SigmaL is case, and SigmaR is a constructor (depicted in the graph as True/False).</p>
<div class="graphviz"><object data="../_images/graphviz-eb05ea4eb94df5d0ba59a678f10b03ebb556ff93.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
and [label=&quot;and =&quot;]
and -&gt; d [color=&quot;red&quot;]

d [label=&quot;PiR&quot;]
e -&gt; d [color=&quot;blue&quot;,dir=back]
d -&gt; e /* f */ [color=&quot;red&quot;]
e [label=&quot;SigmaL&quot;]
e -&gt; f1 [color=&quot;red&quot;]
e -&gt; f2 [color=&quot;red&quot;]
f1 [label=&quot;PiR&quot;]
g1 -&gt; f1 [color=&quot;blue&quot;,dir=back]
f1 -&gt; h1 [color=&quot;red&quot;]
g1 [label=&quot;!w&quot;]
h1 [label=&quot;False&quot;]
f2 [label=&quot;PiR&quot;]
g2 -&gt; f2 [color=&quot;blue&quot;,dir=back]
f2 -&gt; h2 /* h2r */ [color=&quot;red&quot;]
g2 [label=&quot;!d&quot;]
h2 -&gt; g2 [color=&quot;blue&quot;,dir=back]
h2 [label=&quot;I&quot;]
}</p></object></div>
<div class="graphviz"><object data="../_images/graphviz-a27c0b5df9a15191a438afd58f9d5cc24043e520.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
r [label=&quot;r =&quot;]
r -&gt; p /* pr */ [color=&quot;red&quot;]
c1 [label=&quot;Cut&quot;]
c1 -&gt; a [color=&quot;red&quot;]
n -&gt; c1 [color=&quot;blue&quot;,dir=back]
a [label=&quot;!&quot;]
a -&gt; b [color=&quot;red&quot;]
b [label=&quot;True&quot;]
c2 [label=&quot;Cut&quot;]
c2 -&gt; l /* lr */ [color=&quot;red&quot;]
m -&gt; c2 [color=&quot;blue&quot;,dir=back]
c3 [label=&quot;Cut&quot;]
c3 -&gt; c [color=&quot;red&quot;]
k -&gt; c3 [color=&quot;blue&quot;,dir=back]
c [label=&quot;False&quot;]
c4 [label=&quot;Cut&quot;]
c4 -&gt; d2 [color=&quot;red&quot;]
j -&gt; c4 [color=&quot;blue&quot;,dir=back]
d2 [label=&quot;Use and&quot;]

j [label=&quot;PiL&quot;]
j -&gt; k /* kr */ [color=&quot;red&quot;]
l -&gt; j [color=&quot;blue&quot;,dir=back]
k [label=&quot;I&quot;]
l [label=&quot;I&quot;]
m [label=&quot;PiL&quot;]
m -&gt; n /* nr */ [color=&quot;red&quot;]
p -&gt; m [color=&quot;blue&quot;,dir=back]
n [label=&quot;I&quot;]
p [label=&quot;I&quot;]
}</p></object></div>
<p>The identity nodes function like thunk identifiers; the stuff in between the identity and the cut is what will get pushed on the stack to execute the thunk. So the I - Cut connections for True and False can be squinched together. Then the path from the assignment node to the use node reads “push !True to stack, push False to stack, reduce with and” (recall the original expression was <code class="docutils literal notranslate"><span class="pre">and</span> <span class="pre">False</span> <span class="pre">True</span></code>).</p>
</section>
<section id="bad-syntax">
<h3>Bad syntax<a class="headerlink" href="#bad-syntax" title="Permalink to this headline"></a></h3>
<p>The bad syntax serializes the non-simplified net into a textual form. Each edge is assigned a unique identifier, then all the nodes are written out. The order of the nodes is not important, but the pretty-printer can choose something for readability. The syntax for each node is just Haskell’s datatype syntax. You can see how it looks in <a class="reference external" href="https://github.com/Mathnerd314/stroscot/blob/fb648be1ecc3e5c062dbb000d6887a2ce7ac7eb0/src/Core.hs#L50">Core.hs</a>. We should also write out the types of the formulas, so they can be used to get back the full sequent as in the presentation above. But for now Core is untyped, so there is only one universal type and the types of the edges are not written out.</p>
</section>
<section id="real-syntax">
<h3>Real syntax<a class="headerlink" href="#real-syntax" title="Permalink to this headline"></a></h3>
<p>An idea of how a real syntax might look:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;and&quot;</span> <span class="ow">=</span> <span class="kt">Assign</span> <span class="n">d</span>
  <span class="n">d</span> <span class="ow">=</span> <span class="kt">PiR</span>
    <span class="o">^</span><span class="n">func</span> <span class="nf">\</span><span class="p">[</span><span class="n">e</span><span class="p">],</span><span class="kt">[]</span><span class="o">.</span> <span class="p">[</span><span class="n">f</span><span class="p">],</span><span class="kt">[]</span> <span class="ow">-&gt;</span>
      <span class="n">f</span> <span class="ow">=</span> <span class="kt">SigmaL</span> <span class="n">e</span>
        <span class="o">^</span><span class="kt">False</span> <span class="o">\.</span> <span class="n">f1</span> <span class="ow">-&gt;</span>
          <span class="n">f1</span> <span class="ow">=</span> <span class="kt">PiR</span>
            <span class="o">^</span><span class="n">func</span> <span class="nf">\</span><span class="p">[</span><span class="n">g1</span><span class="p">]</span><span class="o">.</span> <span class="n">h1</span>
              <span class="n">h1</span> <span class="ow">=</span> <span class="kt">False</span>
              <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">BangW</span> <span class="n">g1</span>
        <span class="o">^</span><span class="kt">True</span> <span class="o">\.</span> <span class="n">f2</span> <span class="ow">-&gt;</span>
          <span class="n">f2</span> <span class="ow">=</span> <span class="kt">PiR</span>
            <span class="o">^</span><span class="n">func</span> <span class="nf">\</span><span class="n">g2</span><span class="o">.</span> <span class="n">h2r</span>
              <span class="n">h2</span> <span class="ow">=</span> <span class="kt">BangD</span> <span class="n">g2</span>
                <span class="n">h2r</span> <span class="ow">=</span> <span class="kt">I</span> <span class="n">h2</span>

<span class="s">&quot;r&quot;</span> <span class="ow">=</span> <span class="kt">Assign</span> <span class="n">pr</span>
  <span class="n">n</span> <span class="ow">=</span> <span class="kt">Cut</span> <span class="n">a</span>
    <span class="n">a</span> <span class="ow">=</span> <span class="kt">Bang</span> <span class="n">b</span>
      <span class="n">b</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">m</span> <span class="ow">=</span> <span class="kt">Cut</span> <span class="n">lr</span>
      <span class="n">k</span> <span class="ow">=</span> <span class="kt">Cut</span> <span class="n">c</span>
        <span class="n">c</span> <span class="ow">=</span> <span class="kt">False</span>
        <span class="n">j</span> <span class="ow">=</span> <span class="kt">Cut</span> <span class="n">d2</span>
          <span class="n">d2</span> <span class="ow">=</span> <span class="kt">Use</span> <span class="s">&quot;and&quot;</span>
          <span class="p">[(</span><span class="n">l</span><span class="p">,</span>
            <span class="n">lr</span> <span class="ow">=</span> <span class="kt">I</span> <span class="n">l</span>
          <span class="p">)]</span> <span class="ow">=</span> <span class="kt">PiL</span> <span class="o">^</span><span class="n">func</span> <span class="n">j</span> <span class="p">[(</span><span class="n">kr</span><span class="p">,</span>
            <span class="n">kr</span> <span class="ow">=</span> <span class="kt">I</span> <span class="n">k</span>
          <span class="p">)]</span>
      <span class="p">[(</span><span class="n">p</span><span class="p">,</span>
        <span class="n">pr</span> <span class="ow">=</span> <span class="kt">I</span> <span class="n">p</span>
      <span class="p">)]</span> <span class="ow">=</span> <span class="kt">PiL</span> <span class="o">^</span><span class="n">func</span> <span class="n">m</span> <span class="p">[(</span><span class="n">nr</span><span class="p">,</span>
        <span class="n">nr</span> <span class="ow">=</span> <span class="kt">I</span> <span class="n">n</span>
      <span class="p">)}</span>
</pre></div>
</div>
</section>
</section>
<section id="cut-elimination">
<h2>Cut elimination<a class="headerlink" href="#cut-elimination" title="Permalink to this headline"></a></h2>
<p>For all reductions:</p>
<ul class="simple">
<li><p>Move the two nodes of the cut next to the cut, replacing use with copy-paste</p></li>
</ul>
<p>Identity</p>
<ul class="simple">
<li><p>Copy the cut’s non-identity edge to the non-cut edge that links to the identity node. If the cut has levels then label with (id edge)-&gt;(non-id edge).</p></li>
<li><p>Delete cut and identity</p></li>
</ul>
<p>Matching left/right Pi/Sigma</p>
<ul class="simple">
<li><p>Erase non-matching cases, if any</p></li>
<li><p>Link context variables of matching case with outside variables, if any</p></li>
<li><p>Nodes should have same # of edges. Create cut nodes for each edge-pair.</p></li>
<li><p>Link cut nodes with matching variable on each side.</p></li>
<li><p>Preserve cut’s level numbers (but not active status) for red-red, swap for red-blue</p></li>
<li><p>Delete PiR/PiL nodes</p></li>
</ul>
<p>Promotion/contraction</p>
<ul class="simple">
<li><p>Create duplication nodes for each out-edge of promotion, color=red/blue</p></li>
<li><p>Link duplication nodes, if multiple</p></li>
<li><p>Duplicate !p node and point to duplication node, marking one with arrowhead</p></li>
<li><p>Duplicate cut and point to each side of contraction + !p nodes</p></li>
<li><p>Create new contraction node for each context variable pointing to the two !p’s</p></li>
<li><p>Change references to !p to references to context contraction nodes</p></li>
<li><p>Delete original !c contraction node</p></li>
</ul>
<p>Promotion/Dereliction</p>
<ul class="simple">
<li><p>Replace cut’s blue edge with edge of dereliction</p></li>
<li><p>Move level on cut’s red edge to cut’s blue edge, if not set</p></li>
<li><p>Replace cut’s red edge with red edge of promotion</p></li>
<li><p>For each context edge going into !p, replace edge with !p’s edge</p></li>
<li><p>Delete dereliction and promotion</p></li>
</ul>
<p>Duplication:</p>
<ul class="simple">
<li><p>Duplicate node</p></li>
<li><p>Create duplication node for each out-edge of node, copying edge from node</p></li>
<li><p>Point each copy’s edge to duplication node</p></li>
<li><p>Add arrowheads to one of the copy’s edges (higher number)</p></li>
<li><p>Change dup node’s references to point to node copies, deleting arrowheads &amp; using to disambiguate</p></li>
<li><p>Link duplication nodes / fix links</p></li>
</ul>
<p>Multi-node Duplication:</p>
<ul class="simple">
<li><p>Duplicate nodes &amp; rename</p></li>
<li><p>Fixup node copies to point within themselves</p></li>
<li><p>Create duplication node for each non-active out-edge of node, copying edge from node</p></li>
<li><p>Replace each copy’s non-active edges with edge to duplication node.</p></li>
<li><p>Remove arrowheads from first copy’s non-active edges. Add arrowheads to second copy set’s non-active edges.</p></li>
<li><p>Change dup node’s references to point to node copies, deleting arrowheads &amp; using arrowheads to disambiguate</p></li>
<li><p>Link duplication nodes / fix links</p></li>
</ul>
<p>Dup-Id-Dup:</p>
<ul class="simple">
<li><p>Duplicate identity node</p></li>
<li><p>Replace references to dup nodes with identity reference (odot=higher)</p></li>
<li><p>Delete duplication nodes and links</p></li>
<li><p>For !w/?w we delete the rule with ! and create no cuts.</p></li>
<li><p>To eliminate <span class="math notranslate nohighlight">\(\forall\)</span> or <span class="math notranslate nohighlight">\(\exists\)</span>, we extend the variable substitution to the other side.</p></li>
<li><p>The commuting cases are mostly handled by our graph formalism; cuts on the context are pushed down to where they apply. But for PiRight/SigmaLeft there can be a cut on the context variables. To push it down we need to duplicate the cut and its other side for each case. Of course, if there are only 0/1 cases, there is no duplication. But in general we need to introduce a phi-duplication node; when the phi-dup node encounters an identity it adds the edge from the other side to the context variables. Overall commuting deletes code or exposes more reduction opportunities. There is also the potential to reverse-commute and deduplicate part of the cases, if they are the same.</p></li>
<li><p>To expand identities, start with PiRight/SigmaLeft, then use the opposite rule on the opposite side for each case, and terminate with identities. But actually we should prefer to contract identities, searching for expanded identities and replacing them with identities on larger types.</p></li>
</ul>
</section>
<section id="normal-order-reduction">
<h2>Normal Order Reduction<a class="headerlink" href="#normal-order-reduction" title="Permalink to this headline"></a></h2>
<p>Looking at the graph for our simple <code class="docutils literal notranslate"><span class="pre">and</span> <span class="pre">False</span> <span class="pre">True</span></code> example we can see the general pattern for reduction, at least normal-order leftmost-outermost reduction. We start at the root and go down. The first node we encounter is not a data node SigmaRight / PiRight / etc. (we would stop with WHNF, and evaluate the children with NF), instead it is an identity node. Since there is only one root node, the highest parent of the other side of the identity must be a cut node (unless the root node has a blue input edge). We then reduce this cut node. In this case it disappears and we move up to the PiL-PiR cut node. Here we create two cut nodes, one cuts the PiL near the root and the output of the SigmaL while the other cuts Id-Cut-False and the input of the SigmaL. The cut on the output of the SigmaL is blocked, so we go up the input of the SigmaL and our reduction stack looks like Root -&gt; I -&gt; PiL -&gt; Cut -&gt; SigmaL -&gt; Cut. First we cut the Id and then we cut False-SigmaL. This selects the left PiR with !w/False for our output. We cut this with the PiL with !True, creating a disconnected cut between !True and !w (that is immediately erased) and another cut between our result and the root identity node. We erase the identity and end with our result False.</p>
<p>So the general pattern is, go down red / go up blue until you get to a redex (cut node, dup node)</p>
</section>
<section id="optimal-reduction">
<h2>Optimal reduction<a class="headerlink" href="#optimal-reduction" title="Permalink to this headline"></a></h2>
<p>Optimal reduction ensures the minimal amount of cut elimination (reduction) steps. It’s basically normal order, but we have to be careful to avoid duplicating cuts. See the example.</p>
</section>
<section id="primitives">
<h2>Primitives<a class="headerlink" href="#primitives" title="Permalink to this headline"></a></h2>
<p>Primitives can be handled by hacking special cases into Cut; we add primitive functions of type PiR that use the arguments provided by PiL during a cut, and also literals, special values of type SigmaR.</p>
</section>
<section id="linear-logic">
<h2>Linear logic<a class="headerlink" href="#linear-logic" title="Permalink to this headline"></a></h2>
<p>Linear logic has boxes,  The difference is not observable if we do not use duplication; e.g. <code class="docutils literal notranslate"><span class="pre">(\x.print(x+1))</span> <span class="pre">(print(&quot;x&quot;);</span> <span class="pre">2)</span></code> can only print <code class="docutils literal notranslate"><span class="pre">x3</span></code>. But if we change <code class="docutils literal notranslate"><span class="pre">x+1</span></code> to <code class="docutils literal notranslate"><span class="pre">x+x</span></code> then CBV is <code class="docutils literal notranslate"><span class="pre">x4</span></code> while CBN is <code class="docutils literal notranslate"><span class="pre">xx4</span></code>.</p>
<p>So how do we specify the difference between the two, in linear logic?</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">s</span> <span class="n">x</span> <span class="ow">=</span>
  <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="ow">=</span> <span class="n">dup</span> <span class="n">x</span>
  <span class="n">print</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="p">)</span>
<span class="nf">s</span> <span class="p">(</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">);</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Boxes do have some performance cost, so how can they be avoided? There are cases where boxes are not necessary:</p>
<ol class="arabic simple">
<li><p>When the term is linear or affine and does not need to duplicate anything.</p></li>
<li><p>When the duplication is duplication of a graph without any cuts, such as a boolean, integer, list of integers, etc. Even when there are cuts, the value can be forced and then copied directly, using a fold. (per <span id="id4">[<a class="reference internal" href="../zzreferences.html#id32" title="Andrzej Filinski. Linear continuations. In Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL '92, 27–38. Albuquerque, New Mexico, USA, February 1992. Association for Computing Machinery. URL: https://doi.org/10.1145/143165.143174 (visited on 2020-06-19), doi:10.1145/143165.143174.">Fil92</a>]</span>) Q: Does this change the evaluation semantics to be stricter?</p></li>
<li><p>Inlining, when the duplication is carried out, resulting in two terms.</p></li>
<li><p>More complex cases enforced by a typing system, such as Elementary Affine Logic.</p></li>
</ol>
</section>
<section id="id5">
<h2>Recursion<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2>
<p>Sequent Core <span id="id6">[]</span> also introduces two more rules “multicut” and “rec” that are illogical but computationally useful:</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cc}
  \rule
    {\Gamma, \Theta \vdash \Delta, \Lambda \quad \Gamma', \Lambda \vdash \Theta, \Delta' }
    {\Gamma, \Gamma' \vdash \Delta, \Delta' }{\text{multicut}}
  &amp;
  \rule
    { \overrightarrow{\Gamma, \vec \Lambda, \Theta_i \vdash \Lambda_i, \vec \Theta, \Delta }}
    {\Gamma, \overrightarrow{\Theta_i} \vdash \overrightarrow{\Lambda_i}, \Delta }{\text{rec}}
\end{array}\]</div>
<p>These probably aren’t needed, as let can be encoded as a record and recursion via a fixed-point combinator or a cycle in the graph. In particular <span id="id7">[<a class="reference internal" href="../zzreferences.html#id46" title="Oleg Kiselyov. Many faces of the fixed-point combinator. August 2013. URL: http://okmij.org/ftp/Computation/fixed-point-combinators.html (visited on 2020-07-31).">Kis13</a>]</span> outline a polyvariadic combinator:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fix_poly</span> <span class="n">fl</span> <span class="ow">=</span> <span class="n">fix</span> <span class="p">(</span><span class="nf">\</span><span class="n">self</span> <span class="ow">-&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="o">$</span> <span class="n">self</span><span class="p">)</span> <span class="n">fl</span><span class="p">)</span>
</pre></div>
</div>
<p>To implement <code class="docutils literal notranslate"><span class="pre">fix</span></code> we can use the variant of the Y combinator <span class="math notranslate nohighlight">\(\lambda f.(\lambda x.x x) (\lambda x.f (x x))\)</span>. To type it we need the cyclic/recursive type <span class="math notranslate nohighlight">\(Wr = \Pi[(^w, Wr, r)]\)</span> (in the sense of an infinite, regular tree). Though, once we have recursive types, we could allow recursive proof trees as well; then implementing recursion directly is probably not too hard. BOHM uses a fan/duplication node combined with a loop.</p>
</section>
<section id="id8">
<h2>Optimal reduction<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2>
<p>In call-by-value reduction, work is duplicated quite frequently. And lazy or call-by-need reduction, although more efficient computation-wise than call-by-value, still duplicates work. An example is</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">System.IO.Unsafe</span>
<span class="nf">i</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">w</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">unsafePerformIO</span> <span class="p">(</span><span class="n">print</span> <span class="s">&quot;i&quot;</span><span class="p">))</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">w</span>
<span class="nf">z</span> <span class="ow">=</span> <span class="mi">2</span> <span class="ow">::</span> <span class="kt">Integer</span>
<span class="nf">t</span> <span class="ow">=</span> <span class="mi">3</span> <span class="ow">::</span> <span class="kt">Integer</span>
<span class="nf">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="n">t</span><span class="p">)</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">i</span> <span class="n">y</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
</pre></div>
</div>
<p>This produces <code class="docutils literal notranslate"><span class="pre">5</span></code> in Haskell. However, without GHC’s optimizations, <code class="docutils literal notranslate"><span class="pre">&quot;i&quot;</span></code> is evaluated (printed) twice. With optimal reduction, all function applications with known arguments are evaluated exactly once. In particular, the only time a function is evaluated twice is when it is called with different arguments. In the example above it corresponds to a “hoisting” transformation that makes <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">(unsafePerformIO</span> <span class="pre">(print</span> <span class="pre">&quot;i&quot;))</span> <span class="pre">`seq`</span> <span class="pre">\w</span> <span class="pre">-&gt;</span> <span class="pre">w</span></code>, but more complex cases have higher-level sharing that no code transformation can mimic.</p>
<p>Although GHC will do this with <code class="docutils literal notranslate"><span class="pre">-O</span></code>, it does it messily; the interaction of <code class="docutils literal notranslate"><span class="pre">seq</span></code> and inlining is the source of <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/2273">numerous bugs</a>. In contrast, optimal reduction is based on a principled approach to sharing. The graph corresponds almost exactly to linear logic proof nets. Also, since the sharing is part of the reduction semantics rather than a compiler optimization, it is available in the interpreter (and in the runtime system too). There are no thunks, so there is no need for <code class="docutils literal notranslate"><span class="pre">seq</span></code>; instead there are boxes and duplicators.</p>
<p>How does strict/lazy/optimal interact with memory management?</p>
<ul class="simple">
<li><p>Strict: use a stack</p></li>
<li><p>Lazy: evaluation graph stored on the heap</p></li>
<li><p>Optimal: also an evaluation graph, I guess</p></li>
</ul>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline"></a></h2>
<p>Reduction is fairly simple to implement without duplication, as it is just pairs of constructors and destructors annihilating and joining their wires, or, for <code class="docutils literal notranslate"><span class="pre">case</span></code>, joining some eraser nodes. But what about duplication?</p>
<p>Stroscot takes its general inspiration from the delimiter system found in Lambdascope. However, instead of having levels Stroscot keeps explicit track of “environments” or “scopes”. In particular a delimiter has an inside scope and an outside scope. Initially, all delimiters look like opening/closing delimiters where the outside scope is the default/root scope <code class="docutils literal notranslate"><span class="pre">0</span></code> and the inside scope is the scope of the multiplexer involved. When two delimiters meet, the touching outer scopes are compared for equality (they should always be equal) and one inner scope remains the inner scope while the other inner scope become the new delimiter’s outer scope.</p>
<p>To determine which scope becomes the outer scope, delimiters are also marked as “head”, “full”, or “empty” depending on whether they represent a reference to the result of a duplication, the target of a duplication, or a path that crosses the scope but doesn’t duplicate. Interactions are allowed only between head delimiters and other delimiter; the head delimiter’s scope stays on the inside.</p>
<p>For multiplexers the situation is a little more complicated. A multiplexer also has two scopes, an inner “label”/identity-like scope and an outer “ambient” scope. When a multiplexer crosses a delimiter, from outside to inside, its “ambient” scope is changed to the delimiter’s inside scope. Meanwhile the delimiter’s scope is split into a new set of scopes, and this is indexed by the label scope. In the Stroscot code these are referred to as “variant” scopes. In particular, multiplexers with the same label scope must split other scopes into the same set of variant scopes at each interaction. This is not too hard to keep track of, just give each scope a map <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">scope</span> <span class="pre">-&gt;</span> <span class="pre">variant</span> <span class="pre">scope</span> <span class="pre">set</span></code> that’s lazily created.</p>
</section>
</section>
<section id="random-old-junk">
<h1>Random old junk<a class="headerlink" href="#random-old-junk" title="Permalink to this headline"></a></h1>
<section id="levels">
<h2>Levels<a class="headerlink" href="#levels" title="Permalink to this headline"></a></h2>
<p>For the reduction implementation of contraction we add level indices to the terms in the promotion and dereliction rules of <span class="math notranslate nohighlight">\(\bangc/\whimc\)</span>, as in <span id="id9">[<a class="reference internal" href="../zzreferences.html#id53" title="S. Martini and A. Masini. On the fine structure of the exponential rule. In Jean-Yves Girard, Yves Lafont, and Laurent Regnier, editors, Advances in Linear Logic, pages 197–210. Cambridge University Press, Cambridge, 1995. URL: https://pdfs.semanticscholar.org/b2cb/538c8ef21af42e48134a17a3c62ce5167837.pdf (visited on 2020-08-01), doi:10.1017/CBO9780511629150.010.">MM95</a>]</span> and <span id="id10">[<a class="reference internal" href="../zzreferences.html#id37" title="Stefano Guerrini. Theoretical and Practical Issues of Optimal Implementations of Functional Languages. PhD thesis, Università di Pisa. Dipartimento di Informatica, 1996. URL: https://www-lipn.univ-paris13.fr/~guerrini/mysite/sites/default/files/biblio/PhDThesis.pdf.">Gue96</a>]</span>. Conceptually all terms have indices, but we can recover the indices in a proof tree by propagating the indices from the promotion/dereliction rules up/down according to the criteria that the indices involved in all non-<span class="math notranslate nohighlight">\(\bangc/\whimc\)</span> promotion/dereliction rules must be the same.</p>
<p>To handle level indices in infinite trees, we store the difference function <code class="docutils literal notranslate"><span class="pre">\a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">(j-i)</span></code> and recover the levels by tracing from the root of the derivation tree (which is always level 0) and applying the difference function when encountered.</p>
<p>The level of a context is the maximum of the levels of its terms, 0 if it is empty.</p>
<div class="math notranslate nohighlight">
\[\begin{array}{ccc}
  \rule{\bangc\Gamma^i \vdash A^j, \whimc\Delta^i }{\bangc\Gamma^i \vdash \bangc A^i, \whimc\Delta^i}{\bangc}_{j = i+1}
  &amp; \rule{\sk{\Gamma^i}, A^i \vdash \sk{\Delta^i} }{\sk{\Gamma^i}, \bangc A^j \vdash \sk{\Delta^i}}{\bangc d}_{j\leq i}
  &amp; \rule{\sk{\Gamma}, \overrightarrow{\bangc A, \bangc A, \cdots} \vdash \sk{\Delta} }{\sk{\Gamma}, \bangc A \vdash \sk{\Delta}}{\bangc c_n}
\end{array}\]</div>
<div class="math notranslate nohighlight">
\[\begin{array}{ccc}
  \rule{\bangc\Gamma^i, A^j \vdash \whimc\Delta^i }{\bangc\Gamma^i, \whimc A^i \vdash \whimc\Delta^i}{\whimc}_{j = i+1}
  &amp; \rule{\sk{\Gamma^i} \vdash A^i, \sk{\Delta^i} }{\sk{\Gamma^i} \vdash \whimc A^j, \sk{\Delta^i}}{\whimc d}_{j \leq i}
  &amp; \rule{\sk{\Gamma} \vdash \overrightarrow{\whimc A, \whimc A, \cdots}, \sk{\Delta} }{\sk{\Gamma} \vdash \whimc A, \sk{\Delta}}{\whimc c_n}
\end{array}\]</div>
<p>To handle level mismatches we might also need lifting operators. The conditions are unclear.</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cc}
  \rule{\Gamma^i \vdash A^j, \Delta^i }{\Gamma^i \vdash A^i, \Delta^i}{\text{lift}_R}_{j &gt; i}
  &amp;
  \rule{\Gamma^i, A^j \vdash \Delta^i }{\Gamma^i, A^i \vdash \Delta^i}{\text{lift}_L}_{j &gt; i}
\end{array}\]</div>
</section>
<section id="f2-g2">
<h2>F2 G2<a class="headerlink" href="#f2-g2" title="Permalink to this headline"></a></h2>
<p>For example, the term <code class="docutils literal notranslate"><span class="pre">F2</span> <span class="pre">G2</span> <span class="pre">=</span> <span class="pre">(\x.</span> <span class="pre">x</span> <span class="pre">(\w.</span> <span class="pre">w)</span> <span class="pre">x</span> <span class="pre">x)</span> <span class="pre">(\y.</span> <span class="pre">(\x.</span> <span class="pre">x</span> <span class="pre">x)</span> <span class="pre">(y</span> <span class="pre">z))</span></code> from page 17 of <span id="id11">[<a class="reference internal" href="../zzreferences.html#id9" title="Andrea Asperti and Stefano Guerrini. The Optimal Implementation of Functional Programming Languages. Number 45 in Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, USA, 1st edition, January 1999. ISBN 978-0-521-62112-0.">AG99</a>]</span>. To write the derivation tree we must define a recursive type; the simplest is <span class="math notranslate nohighlight">\(\Omega = \, !\Omega \to \Omega\)</span> (which is sufficient for the untyped call-by-name lambda calculus) but here we use the mutually recursive types <span class="math notranslate nohighlight">\(S,T,f\)</span> parametrized over <span class="math notranslate nohighlight">\(a\)</span> to obtain a finer scheme and make the derivation tree less ambiguous.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}S &amp;= \, \left(!T \to !T \right) \to f\\T &amp;= \, !T \to f\\f &amp;= \, !S \to !S \to a\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}F2 &amp;: \, !S \to a\\G2 &amp;: \, !T \to S\end{aligned}\end{align} \]</div>
<img alt="../_images/Stroscot_F2G2_Proof_Tree.svg" src="../_images/Stroscot_F2G2_Proof_Tree.svg" /><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Root</span> <span class="n">z</span> <span class="n">ret</span>
  <span class="kt">Cut</span> <span class="n">f2r</span> <span class="n">f2l</span>
    <span class="n">f2r</span><span class="o">/</span><span class="kt">[]</span><span class="o">/</span><span class="kt">[]</span> <span class="ow">=</span> <span class="kt">PiRight</span> <span class="o">^</span><span class="n">func</span><span class="p">,</span> <span class="p">[</span><span class="n">x_f2</span><span class="p">],</span> <span class="p">[</span><span class="n">ret_f2</span><span class="p">],</span> <span class="kt">[]</span><span class="p">,</span> <span class="kt">[]</span> <span class="ow">-&gt;</span>
      <span class="n">x_f2</span> <span class="ow">=</span> <span class="kt">BangC</span> <span class="n">x1_f2</span> <span class="n">x23_f2</span>
        <span class="n">x23_f2</span> <span class="ow">=</span> <span class="kt">BangC</span> <span class="n">x2_f2</span> <span class="n">x3_f2</span>
          <span class="kt">Cut</span> <span class="n">id_r</span> <span class="n">id_l</span>
            <span class="n">id_r</span><span class="o">/</span><span class="kt">[]</span><span class="o">/</span><span class="kt">[]</span> <span class="ow">=</span> <span class="kt">PiRight</span> <span class="o">^</span><span class="n">func</span><span class="p">,</span> <span class="p">[</span><span class="n">al</span><span class="p">],</span> <span class="p">[</span><span class="n">ar</span><span class="p">],</span> <span class="kt">[]</span><span class="p">,</span> <span class="kt">[]</span> <span class="ow">-&gt;</span>
              <span class="n">al</span><span class="o">/</span><span class="n">ar</span> <span class="ow">=</span> <span class="kt">Identity</span>
            <span class="n">x1_f2</span> <span class="ow">=</span> <span class="kt">BangD</span> <span class="n">x1i_f2</span>
              <span class="n">x1i_f2</span> <span class="ow">=</span> <span class="kt">PiLeft</span> <span class="o">^</span><span class="n">func</span> <span class="p">[(</span><span class="n">id_r2</span><span class="p">,</span> <span class="n">id_l</span><span class="o">/</span><span class="n">id_r2</span> <span class="ow">=</span> <span class="kt">Identity</span><span class="p">)]</span> <span class="p">[(</span><span class="n">ssa</span><span class="p">,</span>
                <span class="n">ssa</span> <span class="ow">=</span> <span class="kt">PiLeft</span> <span class="o">^</span><span class="n">func</span> <span class="p">[(</span><span class="n">x2r_f2</span><span class="p">,</span> <span class="n">x2_f2</span><span class="o">/</span><span class="n">x2r_f2</span> <span class="ow">=</span> <span class="kt">Identity</span><span class="p">)]</span> <span class="p">[(</span><span class="n">sa</span><span class="p">,</span>
                  <span class="n">sa</span> <span class="ow">=</span> <span class="kt">PiLeft</span> <span class="o">^</span><span class="n">func</span> <span class="p">[(</span><span class="n">x3r_f2</span><span class="p">,</span> <span class="n">x3_f2</span><span class="o">/</span><span class="n">x3r_f2</span> <span class="ow">=</span> <span class="kt">Identity</span><span class="p">)]</span> <span class="p">[(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a1</span><span class="o">/</span><span class="n">ret_f2</span> <span class="ow">=</span> <span class="kt">Identity</span><span class="p">)])])]</span>
    <span class="n">f2l</span> <span class="ow">=</span> <span class="kt">PiLeft</span> <span class="o">^</span><span class="n">func</span> <span class="p">[(</span><span class="n">g2</span><span class="p">,</span>
      <span class="n">g2</span> <span class="ow">=</span> <span class="kt">Bang</span> <span class="n">g2s</span>
        <span class="n">g2s</span><span class="o">/</span><span class="kt">[]</span><span class="o">/</span><span class="kt">[]</span> <span class="ow">=</span> <span class="kt">PiRight</span> <span class="o">^</span><span class="n">func</span><span class="p">,</span> <span class="p">[</span><span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">ret_g2</span><span class="p">],</span> <span class="kt">[]</span><span class="p">,</span> <span class="kt">[]</span> <span class="ow">-&gt;</span>
          <span class="n">y</span> <span class="ow">=</span> <span class="kt">PiLeft</span> <span class="o">^</span><span class="n">func</span> <span class="p">[(</span><span class="n">y_arg</span><span class="p">,</span>
            <span class="kt">Cut</span> <span class="n">o</span> <span class="n">o_app</span>
              <span class="n">o</span><span class="o">/</span><span class="kt">[]</span><span class="o">/</span><span class="kt">[]</span> <span class="ow">=</span> <span class="kt">PiRight</span> <span class="o">^</span><span class="n">func</span><span class="p">,</span> <span class="p">[</span><span class="n">x_g2</span><span class="p">],</span> <span class="p">[</span><span class="n">ret_o</span><span class="p">],</span> <span class="kt">[]</span><span class="p">,</span> <span class="kt">[]</span> <span class="ow">-&gt;</span>
                <span class="n">x_g2</span> <span class="ow">=</span> <span class="kt">BangC</span> <span class="n">x1_g2</span> <span class="n">x2_g2</span>
                  <span class="n">x1_g2</span> <span class="ow">=</span> <span class="kt">BangD</span> <span class="n">x1i_g2</span>
                    <span class="n">x1i_g2</span> <span class="ow">=</span> <span class="kt">PiLeft</span> <span class="o">^</span><span class="n">func</span> <span class="p">[(</span><span class="n">x2r_g2</span><span class="p">,</span> <span class="n">x2_g2</span><span class="o">/</span><span class="n">x2r_g2</span> <span class="ow">=</span> <span class="kt">Identity</span> <span class="kt">Bool</span><span class="p">)]</span> <span class="p">[(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="o">/</span><span class="n">ret_o</span> <span class="ow">=</span> <span class="kt">Identity</span><span class="p">)]</span>
              <span class="n">o_app</span> <span class="ow">=</span> <span class="kt">PiLeft</span> <span class="o">^</span><span class="n">func</span> <span class="p">[(</span><span class="n">tr</span><span class="p">,</span> <span class="n">y_arg</span><span class="o">/</span><span class="n">tr</span> <span class="ow">=</span> <span class="kt">Identity</span><span class="p">)]</span> <span class="p">[(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="o">/</span><span class="n">ret_g2</span> <span class="ow">=</span> <span class="kt">Identity</span><span class="p">)]</span>
          <span class="p">)]</span> <span class="p">[(</span><span class="n">zr</span><span class="p">,</span> <span class="n">z</span><span class="o">/</span><span class="n">zr</span> <span class="ow">=</span> <span class="kt">Identity</span><span class="p">)]</span>
    <span class="p">)]</span> <span class="p">[(</span><span class="n">a2</span><span class="p">,</span> <span class="n">a2</span><span class="o">/</span><span class="n">ret</span> <span class="ow">=</span> <span class="kt">Identity</span><span class="p">)]</span>
</pre></div>
</div>
<div class="graphviz"><object data="../_images/graphviz-d61d658265c886ed0aabfe844eaa90a45bf94629.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {

Root -&gt; c1 [style=invis]
y -&gt; c2 [style=invis]
x23_f2 -&gt; c3 [style=invis]

Root -&gt; ret [color=&quot;red&quot;]

c1 [label=&quot;Cut&quot;]
c1 -&gt; f2r [color=&quot;red&quot;]
c1 -&gt; f2l [color=&quot;blue&quot;]

f2r [label=&quot;PiR&quot;]
f2r -&gt; x_f2 [color=&quot;blue&quot;]
f2r -&gt; ret_f2 [color=&quot;red&quot;]

x_f2 [label=&quot;!c&quot;]
x_f2 -&gt; x1_f2 [color=&quot;blue&quot;]
x_f2 -&gt; x23_f2 [color=&quot;blue&quot;]

x23_f2 [label=&quot;!c&quot;]
x23_f2 -&gt; x2_f2 [color=&quot;blue&quot;]
x23_f2 -&gt; x3_f2 [color=&quot;blue&quot;]

c2 [label=&quot;Cut&quot;]
c2 -&gt; id_r [color=&quot;red&quot;]
c2 -&gt; id_l [color=&quot;blue&quot;]

id_r [label=&quot;PiR&quot;]
id_r -&gt; al [color=&quot;blue&quot;]
id_r -&gt; al /* ar */ [color=&quot;red&quot;]

al [label=&quot;I&quot;]

x1_f2 [label=&quot;!d&quot;]
x1_f2 -&gt; x1i_f2 [color=&quot;blue&quot;]

x1i_f2 [label=&quot;PiL&quot;]
x1i_f2 -&gt; id_l /* id_r2 */ [color=&quot;red&quot;]
x1i_f2 -&gt; ssa [color=&quot;blue&quot;]

id_l [label=&quot;I&quot;]

ssa [label=&quot;PiL&quot;]
ssa -&gt; x2_f2 /* x2r_f2 */ [color=&quot;red&quot;]
ssa -&gt; sa [color=&quot;blue&quot;]

x2_f2 [label=&quot;I&quot;]

sa [label=&quot;PiL&quot;]
sa -&gt; x3_f2 /* x3r_f2 */ [color=&quot;red&quot;]
sa -&gt; ret_f2 /* a1 */ [color=&quot;blue&quot;]

x3_f2 [label=&quot;I&quot;]
ret_f2  [label=&quot;I&quot;]

f2l [label=&quot;PiL&quot;]
f2l -&gt; g2 [color=&quot;red&quot;]
f2l -&gt; ret /* a2 */ [color=&quot;blue&quot;]

ret [label=&quot;I&quot;]

g2 [label=&quot;!&quot;]
g2 -&gt; g2s [color=&quot;red&quot;]

g2s [label=&quot;PiR&quot;]
g2s -&gt; y [color=&quot;blue&quot;]
g2s -&gt; ret_g2 [color=&quot;red&quot;]

y [label=&quot;PiL&quot;]
y -&gt; y_arg [color=&quot;blue&quot;]
Root -&gt; y /* z/zr */ [dir=&quot;back&quot;] [color=&quot;red&quot;]

c3 [label=&quot;Cut&quot;]
c3 -&gt; o [color=&quot;red&quot;]
c3 -&gt; o_app [color=&quot;blue&quot;]

o [label=&quot;PiR&quot;]
o -&gt; x_g2 [color=&quot;blue&quot;]
o -&gt; ret_o [color=&quot;red&quot;]

x_g2 [label=&quot;!c&quot;]
x_g2 -&gt; x1_g2 [color=&quot;blue&quot;]
x_g2 -&gt; x2_g2 [color=&quot;blue&quot;]

x1_g2 [label=&quot;!d&quot;]
x1_g2 -&gt; x1i_g2 [color=&quot;blue&quot;]

x1i_g2 [label=&quot;PiL&quot;]
x1i_g2 -&gt; x2_g2 /* x2r_g2 */ [color=&quot;red&quot;]
x1i_g2 -&gt; ret_o /* f */ [color=&quot;blue&quot;]

x2_g2 [label=&quot;I&quot;]
ret_o [label=&quot;I&quot;]

o_app [label=&quot;PiL&quot;]
o_app -&gt; y_arg /* tr */ [color=&quot;red&quot;]
o_app -&gt; ret_g2 /* f */ [color=&quot;blue&quot;]

y_arg [label=&quot;I&quot;]
ret_g2 [label=&quot;I&quot;]

}</p></object></div>
<p>We want this to reduce without duplicating a cut. So first we reduce everything except the contraction:</p>
<div class="graphviz"><object data="../_images/graphviz-330c7f7a785b8c3f7de933b661773707cad71106.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {

Root -&gt; ret [color=&quot;red&quot;]

c2 [label=&quot;Cut&quot;]
c2 -&gt; x_f2 [color=&quot;blue&quot;]
c2 -&gt; g2 [color=&quot;red&quot;]

x_f2 [label=&quot;!c&quot;]
x_f2 -&gt; x1_f2 [color=&quot;blue&quot;]
x_f2 -&gt; x23_f2 [color=&quot;blue&quot;]

x23_f2 [label=&quot;!c&quot;]
x23_f2 -&gt; x2_f2 [color=&quot;blue&quot;]
x23_f2 -&gt; x3_f2 [color=&quot;blue&quot;]

id_r [label=&quot;PiR&quot;]
id_r -&gt; al [color=&quot;blue&quot;]
id_r -&gt; al /* ar */ [color=&quot;red&quot;]

al [label=&quot;I&quot;]

x1_f2 [label=&quot;!d&quot;]
x1_f2 -&gt; x1i_f2 [color=&quot;blue&quot;]

x1i_f2 [label=&quot;PiL&quot;]
x1i_f2 -&gt; id_r [color=&quot;red&quot;]
x1i_f2 -&gt; ssa [color=&quot;blue&quot;]

ssa [label=&quot;PiL&quot;]
ssa -&gt; x2_f2 /* x2r_f2 */ [color=&quot;red&quot;]
ssa -&gt; sa [color=&quot;blue&quot;]

x2_f2 [label=&quot;I&quot;]

sa [label=&quot;PiL&quot;]
sa -&gt; x3_f2 /* x3r_f2 */ [color=&quot;red&quot;]
sa -&gt; ret /* a2 */ [color=&quot;blue&quot;]

x3_f2 [label=&quot;I&quot;]
ret [label=&quot;I&quot;]

g2 [label=&quot;!&quot;]
g2 -&gt; g2s [color=&quot;red&quot;]

g2s [label=&quot;PiR&quot;]
g2s -&gt; y [color=&quot;blue&quot;]
g2s -&gt; ret_g2 [color=&quot;red&quot;]

y [label=&quot;PiL&quot;]
y -&gt; x_g2 [color=&quot;blue&quot;]
Root -&gt; y /* z/zr */ [dir=&quot;back&quot;] [color=&quot;red&quot;]

x_g2 [label=&quot;!c&quot;]
x_g2 -&gt; x1_g2 [color=&quot;blue&quot;]
x_g2 -&gt; x2_g2 [color=&quot;blue&quot;]

x1_g2 [label=&quot;!d&quot;]
x1_g2 -&gt; x1i_g2 [color=&quot;blue&quot;]

x1i_g2 [label=&quot;PiL&quot;]
x1i_g2 -&gt; x2_g2 /* x2r_g2 */ [color=&quot;red&quot;]
x1i_g2 -&gt; ret_g2 /* f */ [color=&quot;blue&quot;]

x2_g2 [label=&quot;I&quot;]

ret_g2 [label=&quot;I&quot;]

}</p></object></div>
<p>Next we move the !c over to a duplication node:</p>
<div class="graphviz"><object data="../_images/graphviz-f71f3516077cae8b53f8157babe2f718e8a74658.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {

Root -&gt; ret [color=&quot;red&quot;]

c2 [label=&quot;Cut&quot;]
c2 -&gt; x23_f2 [color=&quot;blue&quot;]
c2 -&gt; d1 [color=&quot;red&quot;]

c1 [label=&quot;Cut&quot;]
c1 -&gt; x1_f2 [color=&quot;blue&quot;]
c1 -&gt; d1 [color=&quot;red&quot;]

d1 [label=&quot;Dup&quot;]
d1 -&gt; g2 [color=&quot;red&quot;]

x23_f2 [label=&quot;!c&quot;]
x23_f2 -&gt; x2_f2 [color=&quot;blue&quot;]
x23_f2 -&gt; x3_f2 [color=&quot;blue&quot;]

id_r [label=&quot;PiR&quot;]
id_r -&gt; al [color=&quot;blue&quot;]
id_r -&gt; al /* ar */ [color=&quot;red&quot;]

al [label=&quot;I&quot;]

x1_f2 [label=&quot;!d&quot;]
x1_f2 -&gt; x1i_f2 [color=&quot;blue&quot;]

x1i_f2 [label=&quot;PiL&quot;]
x1i_f2 -&gt; id_r [color=&quot;red&quot;]
x1i_f2 -&gt; ssa [color=&quot;blue&quot;]

ssa [label=&quot;PiL&quot;]
ssa -&gt; x2_f2 /* x2r_f2 */ [color=&quot;red&quot;]
ssa -&gt; sa [color=&quot;blue&quot;]

x2_f2 [label=&quot;I&quot;]

sa [label=&quot;PiL&quot;]
sa -&gt; x3_f2 /* x3r_f2 */ [color=&quot;red&quot;]
sa -&gt; ret /* a2 */ [color=&quot;blue&quot;]

x3_f2 [label=&quot;I&quot;]
ret [label=&quot;I&quot;]

g2 [label=&quot;!&quot;]
g2 -&gt; g2s [color=&quot;red&quot;]

g2s [label=&quot;PiR&quot;]
g2s -&gt; y [color=&quot;blue&quot;]
g2s -&gt; ret_g2 [color=&quot;red&quot;]

y [label=&quot;PiL&quot;]
y -&gt; x_g2 [color=&quot;blue&quot;]
Root -&gt; y /* z/zr */ [dir=&quot;back&quot;] [color=&quot;red&quot;]

x_g2 [label=&quot;!c&quot;]
x_g2 -&gt; x1_g2 [color=&quot;blue&quot;]
x_g2 -&gt; x2_g2 [color=&quot;blue&quot;]

x1_g2 [label=&quot;!d&quot;]
x1_g2 -&gt; x1i_g2 [color=&quot;blue&quot;]

x1i_g2 [label=&quot;PiL&quot;]
x1i_g2 -&gt; x2_g2 /* x2r_g2 */ [color=&quot;red&quot;]
x1i_g2 -&gt; ret_g2 /* f */ [color=&quot;blue&quot;]

x2_g2 [label=&quot;I&quot;]

ret_g2 [label=&quot;I&quot;]

}</p></object></div>
<p>Then we incrementally move the duplication node down and do cut elimination:</p>
<div class="graphviz"><object data="../_images/graphviz-c44d9f48da2cfd828edbb0981f63579c8ed2b429.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {

Root -&gt; ret [color=&quot;red&quot;]

c2 [label=&quot;Cut&quot;]
c2 -&gt; x23_f2 [color=&quot;blue&quot;]
c2 -&gt; g2b [color=&quot;red&quot;]

c1 [label=&quot;Cut&quot;]
c1 -&gt; x1i_f2 [color=&quot;blue&quot;]
c1 -&gt; d1 [color=&quot;red&quot;]

d1 [label=&quot;Dup&quot;]
d1 -&gt; g2s [color=&quot;red&quot;]

x23_f2 [label=&quot;!c&quot;]
x23_f2 -&gt; x2_f2 [color=&quot;blue&quot;]
x23_f2 -&gt; x3_f2 [color=&quot;blue&quot;]

id_r [label=&quot;PiR&quot;]
id_r -&gt; al [color=&quot;blue&quot;]
id_r -&gt; al /* ar */ [color=&quot;red&quot;]

al [label=&quot;I&quot;]

x1i_f2 [label=&quot;PiL&quot;]
x1i_f2 -&gt; id_r [color=&quot;red&quot;]
x1i_f2 -&gt; ssa [color=&quot;blue&quot;]

ssa [label=&quot;PiL&quot;]
ssa -&gt; x2_f2 /* x2r_f2 */ [color=&quot;red&quot;]
ssa -&gt; sa [color=&quot;blue&quot;]

x2_f2 [label=&quot;I&quot;]

sa [label=&quot;PiL&quot;]
sa -&gt; x3_f2 /* x3r_f2 */ [color=&quot;red&quot;]
sa -&gt; ret /* a2 */ [color=&quot;blue&quot;]

x3_f2 [label=&quot;I&quot;]
ret [label=&quot;I&quot;]

g2b [label=&quot;!&quot;]
g2b -&gt; d1 [color=&quot;red&quot;]

g2s [label=&quot;PiR&quot;]
g2s -&gt; y [color=&quot;blue&quot;]
g2s -&gt; ret_g2 [color=&quot;red&quot;]

y [label=&quot;PiL&quot;]
y -&gt; x_g2 [color=&quot;blue&quot;]
Root -&gt; y /* z/zr */ [dir=&quot;back&quot;] [color=&quot;red&quot;]

x_g2 [label=&quot;!c&quot;]
x_g2 -&gt; x1_g2 [color=&quot;blue&quot;]
x_g2 -&gt; x2_g2 [color=&quot;blue&quot;]

x1_g2 [label=&quot;!d&quot;]
x1_g2 -&gt; x1i_g2 [color=&quot;blue&quot;]

x1i_g2 [label=&quot;PiL&quot;]
x1i_g2 -&gt; x2_g2 /* x2r_g2 */ [color=&quot;red&quot;]
x1i_g2 -&gt; ret_g2 /* f */ [color=&quot;blue&quot;]

x2_g2 [label=&quot;I&quot;]

ret_g2 [label=&quot;I&quot;]

}</p></object></div>
<div class="graphviz"><object data="../_images/graphviz-b268c2961bc0e502767d97e3097a379b09bb0947.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {

Root -&gt; ret [color=&quot;red&quot;]

c1 [label=&quot;Cut&quot;]
c1 -&gt; x1i_f2 [color=&quot;blue&quot;]
c1 -&gt; d1 [color=&quot;red&quot;]

d1 [label=&quot;Dup&quot;]
d1 -&gt; g2s [color=&quot;red&quot;]

d2 [label=&quot;Dup&quot;]
d2 -&gt; d1 [color=&quot;red&quot;]

g2a [label=&quot;!&quot;]
g2a -&gt; d2 [color=&quot;red&quot;]

g2b [label=&quot;!&quot;]
g2b -&gt; d2 [color=&quot;red&quot;]

id_r [label=&quot;PiR&quot;]
id_r -&gt; al [color=&quot;blue&quot;]
id_r -&gt; al /* ar */ [color=&quot;red&quot;]

al [label=&quot;I&quot;]

x1i_f2 [label=&quot;PiL&quot;]
x1i_f2 -&gt; id_r [color=&quot;red&quot;]
x1i_f2 -&gt; ssa [color=&quot;blue&quot;]

ssa [label=&quot;PiL&quot;]
ssa -&gt; g2a [color=&quot;red&quot;]
ssa -&gt; sa [color=&quot;blue&quot;]

sa [label=&quot;PiL&quot;]
sa -&gt; g2b [color=&quot;red&quot;]
sa -&gt; ret /* a2 */ [color=&quot;blue&quot;]

ret [label=&quot;I&quot;]

g2s [label=&quot;PiR&quot;]
g2s -&gt; y [color=&quot;blue&quot;]
g2s -&gt; ret_g2 [color=&quot;red&quot;]

y [label=&quot;PiL&quot;]
y -&gt; x_g2 [color=&quot;blue&quot;]
Root -&gt; y /* z/zr */ [dir=&quot;back&quot;] [color=&quot;red&quot;]

x_g2 [label=&quot;!c&quot;]
x_g2 -&gt; x1_g2 [color=&quot;blue&quot;]
x_g2 -&gt; x2_g2 [color=&quot;blue&quot;]

x1_g2 [label=&quot;!d&quot;]
x1_g2 -&gt; x1i_g2 [color=&quot;blue&quot;]

x1i_g2 [label=&quot;PiL&quot;]
x1i_g2 -&gt; x2_g2 /* x2r_g2 */ [color=&quot;red&quot;]
x1i_g2 -&gt; ret_g2 /* f */ [color=&quot;blue&quot;]

x2_g2 [label=&quot;I&quot;]

ret_g2 [label=&quot;I&quot;]

}</p></object></div>
<div class="graphviz"><object data="../_images/graphviz-113e9b89ec6b732fca3994875d23da1984262e04.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {

Root -&gt; ret [color=&quot;red&quot;]

c1 [label=&quot;Cut&quot;]
c1 -&gt; x1i_f2 [color=&quot;blue&quot;]
c1 -&gt; g2sb [color=&quot;red&quot;]

d2 [label=&quot;Dup&quot;]
d2 -&gt; g2sa [color=&quot;red&quot;]

g2a [label=&quot;!&quot;]
g2a -&gt; d2 [color=&quot;red&quot;]

g2b [label=&quot;!&quot;]
g2b -&gt; d2 [color=&quot;red&quot;]

id_r [label=&quot;PiR&quot;]
id_r -&gt; al [color=&quot;blue&quot;]
id_r -&gt; al /* ar */ [color=&quot;red&quot;]

al [label=&quot;I&quot;]

x1i_f2 [label=&quot;PiL&quot;]
x1i_f2 -&gt; id_r [color=&quot;red&quot;]
x1i_f2 -&gt; ssa [color=&quot;blue&quot;]

ssa [label=&quot;PiL&quot;]
ssa -&gt; g2a [color=&quot;red&quot;]
ssa -&gt; sa [color=&quot;blue&quot;]

sa [label=&quot;PiL&quot;]
sa -&gt; g2b [color=&quot;red&quot;]
sa -&gt; ret /* a2 */ [color=&quot;blue&quot;]

ret [label=&quot;I&quot;]

dy [label=&quot;Dup&quot;]
dy -&gt; y [color=&quot;blue&quot;]

dr [label=&quot;Dup&quot;]
dr -&gt; ret_g2 [color=&quot;red&quot;]

g2sa [label=&quot;PiR&quot;]
g2sa -&gt; dy [color=&quot;blue&quot;]
g2sa -&gt; dr [color=&quot;red&quot;]

g2sb [label=&quot;PiR&quot;]
g2sb -&gt; dy [color=&quot;blue&quot;]
g2sb -&gt; dr [color=&quot;red&quot;]

y [label=&quot;PiL&quot;]
y -&gt; x_g2 [color=&quot;blue&quot;]
Root -&gt; y /* z/zr */ [dir=&quot;back&quot;] [color=&quot;red&quot;]

x_g2 [label=&quot;!c&quot;]
x_g2 -&gt; x1_g2 [color=&quot;blue&quot;]
x_g2 -&gt; x2_g2 [color=&quot;blue&quot;]

x1_g2 [label=&quot;!d&quot;]
x1_g2 -&gt; x1i_g2 [color=&quot;blue&quot;]

x1i_g2 [label=&quot;PiL&quot;]
x1i_g2 -&gt; x2_g2 /* x2r_g2 */ [color=&quot;red&quot;]
x1i_g2 -&gt; ret_g2 /* f */ [color=&quot;blue&quot;]

x2_g2 [label=&quot;I&quot;]

ret_g2 [label=&quot;I&quot;]

}</p></object></div>
<div class="graphviz"><object data="../_images/graphviz-113e9b89ec6b732fca3994875d23da1984262e04.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {

Root -&gt; ret [color=&quot;red&quot;]

c1 [label=&quot;Cut&quot;]
c1 -&gt; x1i_f2 [color=&quot;blue&quot;]
c1 -&gt; g2sb [color=&quot;red&quot;]

d2 [label=&quot;Dup&quot;]
d2 -&gt; g2sa [color=&quot;red&quot;]

g2a [label=&quot;!&quot;]
g2a -&gt; d2 [color=&quot;red&quot;]

g2b [label=&quot;!&quot;]
g2b -&gt; d2 [color=&quot;red&quot;]

id_r [label=&quot;PiR&quot;]
id_r -&gt; al [color=&quot;blue&quot;]
id_r -&gt; al /* ar */ [color=&quot;red&quot;]

al [label=&quot;I&quot;]

x1i_f2 [label=&quot;PiL&quot;]
x1i_f2 -&gt; id_r [color=&quot;red&quot;]
x1i_f2 -&gt; ssa [color=&quot;blue&quot;]

ssa [label=&quot;PiL&quot;]
ssa -&gt; g2a [color=&quot;red&quot;]
ssa -&gt; sa [color=&quot;blue&quot;]

sa [label=&quot;PiL&quot;]
sa -&gt; g2b [color=&quot;red&quot;]
sa -&gt; ret /* a2 */ [color=&quot;blue&quot;]

ret [label=&quot;I&quot;]

dy [label=&quot;Dup&quot;]
dy -&gt; y [color=&quot;blue&quot;]

dr [label=&quot;Dup&quot;]
dr -&gt; ret_g2 [color=&quot;red&quot;]

g2sa [label=&quot;PiR&quot;]
g2sa -&gt; dy [color=&quot;blue&quot;]
g2sa -&gt; dr [color=&quot;red&quot;]

g2sb [label=&quot;PiR&quot;]
g2sb -&gt; dy [color=&quot;blue&quot;]
g2sb -&gt; dr [color=&quot;red&quot;]

y [label=&quot;PiL&quot;]
y -&gt; x_g2 [color=&quot;blue&quot;]
Root -&gt; y /* z/zr */ [dir=&quot;back&quot;] [color=&quot;red&quot;]

x_g2 [label=&quot;!c&quot;]
x_g2 -&gt; x1_g2 [color=&quot;blue&quot;]
x_g2 -&gt; x2_g2 [color=&quot;blue&quot;]

x1_g2 [label=&quot;!d&quot;]
x1_g2 -&gt; x1i_g2 [color=&quot;blue&quot;]

x1i_g2 [label=&quot;PiL&quot;]
x1i_g2 -&gt; x2_g2 /* x2r_g2 */ [color=&quot;red&quot;]
x1i_g2 -&gt; ret_g2 /* f */ [color=&quot;blue&quot;]

x2_g2 [label=&quot;I&quot;]

ret_g2 [label=&quot;I&quot;]

}</p></object></div>
<section id="readback">
<h3>Readback<a class="headerlink" href="#readback" title="Permalink to this headline"></a></h3>
<p>The real hard part is doing “readback”, i.e. proving that all of these transformations are either no-ops on the original lambda term or valid beta reductions. Since there is so much scope popping and pushing and varianting it is definitely a little complex. Also I decided to keep the levels from the original Lambdascope implementation for correctness verification purposes, so there is twice the work. But if you read Ian Mackie’s paper on efficient interaction nets implementation you will see that this “readback” algorithm also provides a way to directly execute the proof net / graph with call-by-value semantics at each reduction step. So it also has a close connection with how to compile the graph to machine code. Since our scopes are unique and the “stack” stores only one director index for a scope at a time, the scopes can correspond directly to machine registers or memory locations.</p>
<p>Scopes are nested, forming a simple tree hierarchy. When an opening head delimiter of scope A encounters a closing full or empty delimiter of scope B, then A is reparented under B. In particular the one closing delimiter of scope B vanishes, and duplicates of it are propagated to the outside of all other delimiters of A.</p>
<p>It should be possible to avoid this <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> operation by keeping a depth counter in the scope and each delimiter, with the total number of scopes that the delimiter enters/exit being the sum of the scope’s depth and the delimiter’s depth. Then the interaction would decrement the A scope delimiter’s local depth counter by 1, increment A’s scope-wide depth counter by 1, and vanish B’s delimiter as before. But this hasn’t been implemented yet.</p>
<p>First we reduce the top cut:</p>
<div class="graphviz"><object data="../_images/graphviz-0520734c6f5ac42b72c6a3b18d69422d583f40ee.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1a
Root -&gt; c1b
f -&gt; c2
h_di -&gt; c3

Root -&gt; ret [color=&quot;red&quot;,penwidth=2]

c1a [label=&quot;Cut&quot;]
c1a -&gt; ret_o1 [color=&quot;red&quot;]
c1a -&gt; ret [color=&quot;blue&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; fp [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; x_o1 [color=&quot;blue&quot;]

x_o1 [label=&quot;!c&quot;]
x_o1 -&gt; x1_o1 [color=&quot;blue&quot;]
x_o1 -&gt; x2_o1 [color=&quot;blue&quot;]

x2_o1 [label=&quot;!d&quot;]
x2_o1 -&gt; x2i_o1 [color=&quot;blue&quot;]

x2i_o1 [label=&quot;PiL&quot;]
x2i_o1 -&gt; x1_o1 /* x1_o1r */ [color=&quot;red&quot;]
x2i_o1 -&gt; ret_o1 /* ret_o1l */ [color=&quot;blue&quot;]

fp [label=&quot;!p&quot;]
fp -&gt; f [color=&quot;red&quot;,label=&quot;1&quot;]

f [label=&quot;PiR&quot;]
f -&gt; hi_retp /* h_d */ [color=&quot;blue&quot;,label=&quot;1&quot;]
f -&gt; f_ret [color=&quot;red&quot;]

c2 [label=&quot;Cut&quot;,shape=doublecircle]
c2 -&gt; o2 [color=&quot;red&quot;]
c2 -&gt; o2l [color=&quot;blue&quot;]

o2 [label=&quot;PiR&quot;]
o2 -&gt; x_o2 [color=&quot;blue&quot;]
o2 -&gt; ret_o2 [color=&quot;red&quot;]

x_o2 [label=&quot;!c&quot;]
x_o2 -&gt; x1_o2 [color=&quot;blue&quot;]
x_o2 -&gt; x2_o2 [color=&quot;blue&quot;]

x2_o2 [label=&quot;!d&quot;]
x2_o2 -&gt; x2i_o2 [color=&quot;blue&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; x1_o2 /* x1_o2r */ [color=&quot;red&quot;]
x2i_o2 -&gt; ret_o2 /* ret_o2l */ [color=&quot;blue&quot;]

o2l [label=&quot;PiL&quot;]
o2l -&gt; hi_retp [color=&quot;red&quot;,label=&quot;1&quot;]
o2l -&gt; f_ret /* f_retl */ [color=&quot;blue&quot;]

hi_retp [label=&quot;!p&quot;]
hi_retp -&gt; hi_ret [color=&quot;red&quot;,label=&quot;2&quot;]
hi_retp -&gt; h_di [color=&quot;blue&quot;,label=&quot;1&quot;]

h_di [label=&quot;!d&quot;]
h_di -&gt; h [color=&quot;blue&quot;,label=&quot;2&quot;]

c3 [label=&quot;Cut&quot;]
c3 -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]
c3 -&gt; h_app [color=&quot;blue&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

h [label=&quot;PiL&quot;]
h -&gt; h_app /* h_appr */ [color=&quot;red&quot;]
h -&gt; hi_ret /* hi_retl */ [color=&quot;blue&quot;]

x1_o1 [label=&quot;I&quot;]
ret_o1 [label=&quot;I&quot;]
x1_o2 [label=&quot;I&quot;]
ret_o2 [label=&quot;I&quot;]
i_ret [label=&quot;I&quot;]
h_app [label=&quot;I&quot;]
hi_ret [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]
ret [label=&quot;I&quot;]

}</p></object></div>
<p>Next the other PiR-PiL cut:</p>
<div class="graphviz"><object data="../_images/graphviz-22d08ae0263bdf55e87f9cbadd8cc0162b66c293.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1a
Root -&gt; c1b
f -&gt; c2a
f -&gt; c2b
h_di -&gt; c3

Root -&gt; ret [color=&quot;red&quot;,penwidth=2]

c1a [label=&quot;Cut&quot;,shape=doublecircle]
c1a -&gt; ret_o1 [color=&quot;red&quot;]
c1a -&gt; ret [color=&quot;blue&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; fp [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; x_o1 [color=&quot;blue&quot;]

x_o1 [label=&quot;!c&quot;]
x_o1 -&gt; x1_o1 [color=&quot;blue&quot;]
x_o1 -&gt; x2_o1 [color=&quot;blue&quot;]

x2_o1 [label=&quot;!d&quot;]
x2_o1 -&gt; x2i_o1 [color=&quot;blue&quot;]

x2i_o1 [label=&quot;PiL&quot;]
x2i_o1 -&gt; x1_o1 /* x1_o1r */ [color=&quot;red&quot;]
x2i_o1 -&gt; ret_o1 /* ret_o1l */ [color=&quot;blue&quot;]

fp [label=&quot;!p&quot;]
fp -&gt; f [color=&quot;red&quot;,label=&quot;1&quot;]

f [label=&quot;PiR&quot;]
f -&gt; hi_retp /* h_d */ [color=&quot;blue&quot;,label=&quot;1&quot;]
f -&gt; f_ret [color=&quot;red&quot;]

c2a [label=&quot;Cut&quot;,shape=doublecircle]
c2a -&gt; ret_o2 [color=&quot;red&quot;]
c2a -&gt; f_ret [color=&quot;blue&quot;]

c2b [label=&quot;Cut&quot;]
c2b -&gt; hi_retp [color=&quot;red&quot;,label=&quot;1&quot;]
c2b -&gt; x_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

x_o2 [label=&quot;!c&quot;]
x_o2 -&gt; x1_o2 [color=&quot;blue&quot;]
x_o2 -&gt; x2_o2 [color=&quot;blue&quot;]

x2_o2 [label=&quot;!d&quot;]
x2_o2 -&gt; x2i_o2 [color=&quot;blue&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; x1_o2 /* x1_o2r */ [color=&quot;red&quot;]
x2i_o2 -&gt; ret_o2 /* ret_o2l */ [color=&quot;blue&quot;]

hi_retp [label=&quot;!p&quot;]
hi_retp -&gt; hi_ret [color=&quot;red&quot;,label=&quot;2&quot;]
hi_retp -&gt; h_di [color=&quot;blue&quot;,label=&quot;1&quot;]

h_di [label=&quot;!d&quot;]
h_di -&gt; h [color=&quot;blue&quot;,label=&quot;2&quot;]

c3 [label=&quot;Cut&quot;,shape=doublecircle]
c3 -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]
c3 -&gt; h_app [color=&quot;blue&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

h [label=&quot;PiL&quot;]
h -&gt; h_app /* h_appr */ [color=&quot;red&quot;]
h -&gt; hi_ret /* hi_retl */ [color=&quot;blue&quot;]

x1_o1 [label=&quot;I&quot;]
ret_o1 [label=&quot;I&quot;]
x1_o2 [label=&quot;I&quot;]
ret_o2 [label=&quot;I&quot;]
i_ret [label=&quot;I&quot;]
h_app [label=&quot;I&quot;]
hi_ret [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]
ret [label=&quot;I&quot;]

}</p></object></div>
<p>Then, to clean up the graph, the trivial cuts:</p>
<div class="graphviz"><object data="../_images/graphviz-32aa25981818d7f65b674070512f2ebfebca67fc.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1b
f -&gt; c2b

Root -&gt; ret [color=&quot;red&quot;,penwidth=2]

c1b [label=&quot;Cut&quot;,shape=doublecircle]
c1b -&gt; fp [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; x_o1 [color=&quot;blue&quot;]

x_o1 [label=&quot;!c&quot;]
x_o1 -&gt; x1_o1 [color=&quot;blue&quot;]
x_o1 -&gt; x2_o1 [color=&quot;blue&quot;]

x2_o1 [label=&quot;!d&quot;]
x2_o1 -&gt; x2i_o1 [color=&quot;blue&quot;]

x2i_o1 [label=&quot;PiL&quot;]
x2i_o1 -&gt; x1_o1 /* x1_o1r */ [color=&quot;red&quot;]
x2i_o1 -&gt; ret [color=&quot;blue&quot;]

fp [label=&quot;!p&quot;]
fp -&gt; f [color=&quot;red&quot;,label=&quot;1&quot;]

f [label=&quot;PiR&quot;]
f -&gt; hi_retp /* h_d */ [color=&quot;blue&quot;,label=&quot;1&quot;]
f -&gt; f_ret [color=&quot;red&quot;]

c2b [label=&quot;Cut&quot;]
c2b -&gt; hi_retp [color=&quot;red&quot;,label=&quot;1&quot;]
c2b -&gt; x_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

x_o2 [label=&quot;!c&quot;]
x_o2 -&gt; x1_o2 [color=&quot;blue&quot;]
x_o2 -&gt; x2_o2 [color=&quot;blue&quot;]

x2_o2 [label=&quot;!d&quot;]
x2_o2 -&gt; x2i_o2 [color=&quot;blue&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; x1_o2 /* x1_o2r */ [color=&quot;red&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retp [label=&quot;!p&quot;]
hi_retp -&gt; hi_ret [color=&quot;red&quot;,label=&quot;2&quot;]
hi_retp -&gt; h_di [color=&quot;blue&quot;,label=&quot;1&quot;]

h_di [label=&quot;!d&quot;]
h_di -&gt; h [color=&quot;blue&quot;,label=&quot;2&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

h [label=&quot;PiL&quot;]
h -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]
h -&gt; hi_ret /* hi_retl */ [color=&quot;blue&quot;]

x1_o1 [label=&quot;I&quot;]
x1_o2 [label=&quot;I&quot;]
i_ret [label=&quot;I&quot;]
hi_ret [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]
ret [label=&quot;I&quot;]

}</p></object></div>
<p>To handle the duplication from the contraction we duplicate the cuts/promotion rule and introduce a duplication node Dup to incrementally duplicate the rest of the structure:</p>
<div class="graphviz"><object data="../_images/graphviz-156bcff2b46e334b84e344382c7c21c8066a5214.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1a
Root -&gt; c1b
f -&gt; c2b

Root -&gt; ret [color=&quot;red&quot;,penwidth=2]

d1 [label=&quot;Dup&quot;]
d1 -&gt; f [color=&quot;red&quot;]

c1a [label=&quot;Cut&quot;,shape=doublecircle]
c1a -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
c1a -&gt; x1_o1 [color=&quot;blue&quot;]

c1b [label=&quot;Cut&quot;,shape=doublecircle]
c1b -&gt; fpb [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; x2_o1 [color=&quot;blue&quot;]

x2_o1 [label=&quot;!d&quot;]
x2_o1 -&gt; x2i_o1 [color=&quot;blue&quot;]

x2i_o1 [label=&quot;PiL&quot;]
x2i_o1 -&gt; x1_o1 /* x1_o1r */ [color=&quot;red&quot;]
x2i_o1 -&gt; ret [color=&quot;blue&quot;]

fpb [label=&quot;!p&quot;]
fpb -&gt; d1 [color=&quot;red&quot;,label=&quot;1&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;,label=&quot;1&quot;]

f [label=&quot;PiR&quot;]
f -&gt; hi_retp /* h_d */ [color=&quot;blue&quot;,label=&quot;1&quot;]
f -&gt; f_ret [color=&quot;red&quot;]

c2b [label=&quot;Cut&quot;]
c2b -&gt; hi_retp [color=&quot;red&quot;,label=&quot;1&quot;]
c2b -&gt; x_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

x_o2 [label=&quot;!c&quot;]
x_o2 -&gt; x1_o2 [color=&quot;blue&quot;]
x_o2 -&gt; x2_o2 [color=&quot;blue&quot;]

x2_o2 [label=&quot;!d&quot;]
x2_o2 -&gt; x2i_o2 [color=&quot;blue&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; x1_o2 /* x1_o2r */ [color=&quot;red&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retp [label=&quot;!p&quot;]
hi_retp -&gt; hi_ret [color=&quot;red&quot;,label=&quot;2&quot;]
hi_retp -&gt; h_di [color=&quot;blue&quot;,label=&quot;1&quot;]

h_di [label=&quot;!d&quot;]
h_di -&gt; h [color=&quot;blue&quot;,label=&quot;2&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

h [label=&quot;PiL&quot;]
h -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]
h -&gt; hi_ret /* hi_retl */ [color=&quot;blue&quot;]

x1_o1 [label=&quot;I&quot;]
x1_o2 [label=&quot;I&quot;]
i_ret [label=&quot;I&quot;]
hi_ret [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]
ret [label=&quot;I&quot;]

}</p></object></div>
<p>Then we do cut elimination on what remains. Cut/id is trivial.</p>
<div class="graphviz"><object data="../_images/graphviz-62c76eb32b8db3c507af2c90f08946f4f0e81807.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1b
f -&gt; c2b

Root -&gt; ret [color=&quot;red&quot;,penwidth=2]

d1 [label=&quot;Dup&quot;,shape=doublecircle]
d1 -&gt; f [color=&quot;red&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; d1 [color=&quot;red&quot;,label=&quot;1&quot;]
c1b -&gt; x2i_o1 [color=&quot;blue&quot;,label=&quot;0&quot;]

x2i_o1 [label=&quot;PiL&quot;]
x2i_o1 -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
x2i_o1 -&gt; ret [color=&quot;blue&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;,label=&quot;1&quot;]

f [label=&quot;PiR&quot;]
f -&gt; hi_retp /* h_d */ [color=&quot;blue&quot;,label=&quot;1&quot;]
f -&gt; f_ret [color=&quot;red&quot;]

c2b [label=&quot;Cut&quot;]
c2b -&gt; hi_retp [color=&quot;red&quot;,label=&quot;1&quot;]
c2b -&gt; x_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

x_o2 [label=&quot;!c&quot;]
x_o2 -&gt; x1_o2 [color=&quot;blue&quot;]
x_o2 -&gt; x2_o2 [color=&quot;blue&quot;]

x2_o2 [label=&quot;!d&quot;]
x2_o2 -&gt; x2i_o2 [color=&quot;blue&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; x1_o2 /* x1_o2r */ [color=&quot;red&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retp [label=&quot;!p&quot;]
hi_retp -&gt; hi_ret [color=&quot;red&quot;,label=&quot;2&quot;]
hi_retp -&gt; h_di [color=&quot;blue&quot;,label=&quot;1&quot;]

h_di [label=&quot;!d&quot;]
h_di -&gt; h [color=&quot;blue&quot;,label=&quot;2&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

h [label=&quot;PiL&quot;]
h -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]
h -&gt; hi_ret /* hi_retl */ [color=&quot;blue&quot;]

x1_o2 [label=&quot;I&quot;]
i_ret [label=&quot;I&quot;]
hi_ret [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]
ret [label=&quot;I&quot;]

}</p></object></div>
<div class="graphviz"><object data="../_images/graphviz-113584a948acbfba815c4f2b717b5ff5b108cb50.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1b
fa -&gt; c2b
fb -&gt; c2b
d1 -&gt; d2 [dir=none,style=dashed,constraint=false]

Root -&gt; ret [color=&quot;red&quot;,penwidth=2]

d1 [label=&quot;Dup&quot;]
d1 -&gt; f_ret [color=&quot;red&quot;]

d2 [label=&quot;Dup&quot;]
d2 -&gt; hi_retp /* h_d */ [color=&quot;blue&quot;,label=&quot;1&quot;]

c1b [label=&quot;Cut&quot;,shape=doublecircle]
c1b -&gt; fb [color=&quot;red&quot;,label=&quot;1&quot;]
c1b -&gt; x2i_o1 [color=&quot;blue&quot;,label=&quot;0&quot;]

x2i_o1 [label=&quot;PiL&quot;]
x2i_o1 -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
x2i_o1 -&gt; ret [color=&quot;blue&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; fa [color=&quot;red&quot;,label=&quot;1&quot;]

fa [label=&quot;PiR&quot;]
fa -&gt; d2 [color=&quot;blue&quot;,arrowhead=&quot;odot&quot;]
fa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;]

fb [label=&quot;PiR&quot;]
fb -&gt; d2 [color=&quot;blue&quot;]
fb -&gt; d1 [color=&quot;red&quot;]

c2b [label=&quot;Cut&quot;]
c2b -&gt; hi_retp [color=&quot;red&quot;,label=&quot;1&quot;]
c2b -&gt; x_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

x_o2 [label=&quot;!c&quot;]
x_o2 -&gt; x1_o2 [color=&quot;blue&quot;]
x_o2 -&gt; x2_o2 [color=&quot;blue&quot;]

x2_o2 [label=&quot;!d&quot;]
x2_o2 -&gt; x2i_o2 [color=&quot;blue&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; x1_o2 /* x1_o2r */ [color=&quot;red&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retp [label=&quot;!p&quot;]
hi_retp -&gt; hi_ret [color=&quot;red&quot;,label=&quot;2&quot;]
hi_retp -&gt; h_di [color=&quot;blue&quot;,label=&quot;1&quot;]

h_di [label=&quot;!d&quot;]
h_di -&gt; h [color=&quot;blue&quot;,label=&quot;2&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

h [label=&quot;PiL&quot;]
h -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]
h -&gt; hi_ret /* hi_retl */ [color=&quot;blue&quot;]

x1_o2 [label=&quot;I&quot;]
i_ret [label=&quot;I&quot;]
hi_ret [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]
ret [label=&quot;I&quot;]

}</p></object></div>
<p>Then the 3rd PiL-PiR cut / beta reduction, corresponding to Fig 2.14 (4) / (5) on page 31 of <span id="id12">[<a class="reference internal" href="../zzreferences.html#id9" title="Andrea Asperti and Stefano Guerrini. The Optimal Implementation of Functional Programming Languages. Number 45 in Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, USA, 1st edition, January 1999. ISBN 978-0-521-62112-0.">AG99</a>]</span>:</p>
<div class="graphviz"><object data="../_images/graphviz-adf7617ed0b13647f3297a7a25c8929390c48f99.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1a
Root -&gt; c1b
fa -&gt; c2b
c1b -&gt; c2b
d1 -&gt; d2 [dir=none,style=dashed,constraint=false]

Root -&gt; ret [color=&quot;red&quot;,penwidth=2]

d1 [label=&quot;Dup&quot;]
d1 -&gt; f_ret [color=&quot;red&quot;]

d2 [label=&quot;Dup&quot;]
d2 -&gt; hi_retp /* h_d */ [color=&quot;blue&quot;,label=&quot;1&quot;]

c1a [label=&quot;Cut&quot;,shape=doublecircle]
c1a -&gt; d1 [color=&quot;red&quot;,label=&quot;1&quot;]
c1a -&gt; ret [color=&quot;blue&quot;,label=&quot;0&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; d2 [color=&quot;blue&quot;,label=&quot;1&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; fa [color=&quot;red&quot;,label=&quot;1&quot;]

fa [label=&quot;PiR&quot;]
fa -&gt; d2 [color=&quot;blue&quot;,arrowhead=&quot;odot&quot;]
fa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;]

c2b [label=&quot;Cut&quot;]
c2b -&gt; hi_retp [color=&quot;red&quot;,label=&quot;1&quot;]
c2b -&gt; x_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

x_o2 [label=&quot;!c&quot;]
x_o2 -&gt; x1_o2 [color=&quot;blue&quot;]
x_o2 -&gt; x2_o2 [color=&quot;blue&quot;]

x2_o2 [label=&quot;!d&quot;]
x2_o2 -&gt; x2i_o2 [color=&quot;blue&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; x1_o2 /* x1_o2r */ [color=&quot;red&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retp [label=&quot;!p&quot;]
hi_retp -&gt; hi_ret [color=&quot;red&quot;,label=&quot;2&quot;]
hi_retp -&gt; h_di [color=&quot;blue&quot;,label=&quot;1&quot;]

h_di [label=&quot;!d&quot;]
h_di -&gt; h [color=&quot;blue&quot;,label=&quot;2&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

h [label=&quot;PiL&quot;]
h -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]
h -&gt; hi_ret /* hi_retl */ [color=&quot;blue&quot;]

x1_o2 [label=&quot;I&quot;]
i_ret [label=&quot;I&quot;]
hi_ret [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]
ret [label=&quot;I&quot;]

}</p></object></div>
<div class="graphviz"><object data="../_images/graphviz-1ea669753510c862d8c6290c2275b0f816adaf2b.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1b
fa -&gt; c2b
c1b -&gt; c2b
d1 -&gt; d2 [dir=none,style=dashed,constraint=false]

Root -&gt; d1 [color=&quot;red&quot;,label=&quot;0-&gt;1&quot;]

d1 [label=&quot;Dup&quot;]
d1 -&gt; f_ret [color=&quot;red&quot;]

d2 [label=&quot;Dup&quot;]
d2 -&gt; hi_retp /* h_d */ [color=&quot;blue&quot;,label=&quot;1&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; d2 [color=&quot;blue&quot;,label=&quot;1&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; fa [color=&quot;red&quot;,label=&quot;1&quot;]

fa [label=&quot;PiR&quot;]
fa -&gt; d2 [color=&quot;blue&quot;,arrowhead=&quot;odot&quot;]
fa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;]

c2b [label=&quot;Cut&quot;,shape=doublecircle]
c2b -&gt; hi_retp [color=&quot;red&quot;,label=&quot;1&quot;]
c2b -&gt; x_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

x_o2 [label=&quot;!c&quot;]
x_o2 -&gt; x1_o2 [color=&quot;blue&quot;]
x_o2 -&gt; x2_o2 [color=&quot;blue&quot;]

x2_o2 [label=&quot;!d&quot;]
x2_o2 -&gt; x2i_o2 [color=&quot;blue&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; x1_o2 /* x1_o2r */ [color=&quot;red&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retp [label=&quot;!p&quot;]
hi_retp -&gt; hi_ret [color=&quot;red&quot;,label=&quot;2&quot;]
hi_retp -&gt; h_di [color=&quot;blue&quot;,label=&quot;1&quot;]

h_di [label=&quot;!d&quot;]
h_di -&gt; h [color=&quot;blue&quot;,label=&quot;2&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

h [label=&quot;PiL&quot;]
h -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]
h -&gt; hi_ret /* hi_retl */ [color=&quot;blue&quot;]

x1_o2 [label=&quot;I&quot;]
i_ret [label=&quot;I&quot;]
hi_ret [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]

}</p></object></div>
<p>At this stage we can’t duplicate any more because of the !p box. So we do the other cut.</p>
<div class="graphviz"><object data="../_images/graphviz-ec6485cafca5eebf4e9248008113a7468291d06a.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1b
fa -&gt; c2b
c1b -&gt; c2b
fa -&gt; c2a
c1b -&gt; c2a
d1 -&gt; d2 [dir=none,style=dashed,constraint=false]
d3 -&gt; d4 [dir=none,style=dashed,constraint=false]

Root -&gt; d1 [color=&quot;red&quot;,label=&quot;0-&gt;1&quot;]

d1 [label=&quot;Dup&quot;]
d1 -&gt; f_ret [color=&quot;red&quot;]

d2 [label=&quot;Dup&quot;]
d2 -&gt; hi_retpc [color=&quot;blue&quot;]

hi_retpc [label=&quot;!c&quot;]
hi_retpc -&gt; hi_retpa [color=&quot;blue&quot;,label=&quot;1&quot;]
hi_retpc -&gt; hi_retpb [color=&quot;blue&quot;,label=&quot;1&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; d2 [color=&quot;blue&quot;,label=&quot;1&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; fa [color=&quot;red&quot;,label=&quot;1&quot;]

fa [label=&quot;PiR&quot;]
fa -&gt; d2 [color=&quot;blue&quot;,arrowhead=&quot;odot&quot;]
fa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;]

c2a [label=&quot;Cut&quot;,shape=doublecircle]
c2a -&gt; hi_retpa [color=&quot;red&quot;,label=&quot;1&quot;]
c2a -&gt; x1_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

c2b [label=&quot;Cut&quot;,shape=doublecircle]
c2b -&gt; hi_retpb [color=&quot;red&quot;,label=&quot;1&quot;]
c2b -&gt; x2_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

x2_o2 [label=&quot;!d&quot;]
x2_o2 -&gt; x2i_o2 [color=&quot;blue&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; x1_o2 /* x1_o2r */ [color=&quot;red&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retpb [label=&quot;!p&quot;]
hi_retpb -&gt; d3 [color=&quot;red&quot;,label=&quot;2&quot;]
hi_retpb -&gt; d4 [color=&quot;blue&quot;,label=&quot;1&quot;]

hi_retpa [label=&quot;!p&quot;]
hi_retpa -&gt; d3 [color=&quot;red&quot;,label=&quot;2&quot;,arrowhead=&quot;odot&quot;]
hi_retpa -&gt; d4 [color=&quot;blue&quot;,label=&quot;1&quot;,arrowhead=&quot;odot&quot;]

d3 [label=&quot;Dup&quot;]
d3 -&gt; hi_ret [color=&quot;red&quot;]

d4 [label=&quot;Dup&quot;]
d4 -&gt; h_di [color=&quot;blue&quot;,label=&quot;1&quot;]

h_di [label=&quot;!d&quot;]
h_di -&gt; h [color=&quot;blue&quot;,label=&quot;2&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

h [label=&quot;PiL&quot;]
h -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]
h -&gt; hi_ret /* hi_retl */ [color=&quot;blue&quot;]

x1_o2 [label=&quot;I&quot;]
i_ret [label=&quot;I&quot;]
hi_ret [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]

}</p></object></div>
<div class="graphviz"><object data="../_images/graphviz-41227d9ffc7615fd9e25cf7b8a4736d26b1f6793.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1b
fa -&gt; c2b
c1b -&gt; c2b
d1 -&gt; d2 [dir=none,style=dashed,constraint=false]
d3 -&gt; d4 [dir=none,style=dashed,constraint=false]

Root -&gt; d1 [color=&quot;red&quot;,label=&quot;0-&gt;1&quot;]

d1 [label=&quot;Dup&quot;]
d1 -&gt; f_ret [color=&quot;red&quot;]

d2 [label=&quot;Dup&quot;,shape=doublecircle]
d2 -&gt; hi_retpc [color=&quot;blue&quot;]

hi_retpc [label=&quot;!c&quot;]
hi_retpc -&gt; hi_retpa [color=&quot;blue&quot;,label=&quot;1&quot;]
hi_retpc -&gt; d4 [color=&quot;blue&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; d2 [color=&quot;blue&quot;,label=&quot;1&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; fa [color=&quot;red&quot;,label=&quot;1&quot;]

fa [label=&quot;PiR&quot;]
fa -&gt; d2 [color=&quot;blue&quot;,arrowhead=&quot;odot&quot;]
fa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;]

c2b [label=&quot;Cut&quot;]
c2b -&gt; d3 [color=&quot;red&quot;,label=&quot;2&quot;]
c2b -&gt; x2i_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; hi_retpa [color=&quot;red&quot;,label=&quot;1&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retpa [label=&quot;!p&quot;]
hi_retpa -&gt; d3 [color=&quot;red&quot;,label=&quot;2&quot;,arrowhead=&quot;odot&quot;]
hi_retpa -&gt; d4 [color=&quot;blue&quot;,label=&quot;1&quot;,arrowhead=&quot;odot&quot;]

d3 [label=&quot;Dup&quot;]
d3 -&gt; hi_ret [color=&quot;red&quot;]

d4 [label=&quot;Dup&quot;]
d4 -&gt; h_di [color=&quot;blue&quot;,label=&quot;1&quot;]

h_di [label=&quot;!d&quot;]
h_di -&gt; h [color=&quot;blue&quot;,label=&quot;2&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

h [label=&quot;PiL&quot;]
h -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]
h -&gt; hi_ret /* hi_retl */ [color=&quot;blue&quot;]

i_ret [label=&quot;I&quot;]
hi_ret [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]

}</p></object></div>
<p>The !c is exposed so we can create another duplication.</p>
<div class="graphviz"><object data="../_images/graphviz-684b2fc234ab708fdb3af6875678a2f6f78ea4c3.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1b
fa -&gt; c2b
c1b -&gt; c2b
d1 -&gt; d2b [dir=none,style=dashed,constraint=false]
d2a -&gt; d2b [dir=none,style=dashed,constraint=false]
d3 -&gt; d4 [dir=none,style=dashed,constraint=false]

Root -&gt; d1 [color=&quot;red&quot;,label=&quot;0-&gt;1&quot;]

d1 [label=&quot;Dup&quot;]
d1 -&gt; f_ret [color=&quot;red&quot;]

d2a [label=&quot;Dup&quot;]
d2a -&gt; hi_retpa [color=&quot;blue&quot;,label=&quot;1&quot;]

d2b [label=&quot;Dup&quot;]
d2b -&gt; d4 [color=&quot;blue&quot;]

hi_retpc1 [label=&quot;!c&quot;]
hi_retpc1 -&gt; d2a [color=&quot;blue&quot;,arrowhead=odot]
hi_retpc1 -&gt; d2b [color=&quot;blue&quot;,arrowhead=odot]

hi_retpc2 [label=&quot;!c&quot;]
hi_retpc2 -&gt; d2a [color=&quot;blue&quot;]
hi_retpc2 -&gt; d2b [color=&quot;blue&quot;]

c1b [label=&quot;Cut&quot;,shape=doublecircle]
c1b -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; hi_retpc2 [color=&quot;blue&quot;,label=&quot;1&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; fa [color=&quot;red&quot;,label=&quot;1&quot;]

fa [label=&quot;PiR&quot;]
fa -&gt; hi_retpc1 [color=&quot;blue&quot;]
fa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;]

c2b [label=&quot;Cut&quot;]
c2b -&gt; d3 [color=&quot;red&quot;,label=&quot;2&quot;]
c2b -&gt; x2i_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; hi_retpa [color=&quot;red&quot;,label=&quot;1&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retpa [label=&quot;!p&quot;]
hi_retpa -&gt; d3 [color=&quot;red&quot;,label=&quot;2&quot;,arrowhead=&quot;odot&quot;]
hi_retpa -&gt; d4 [color=&quot;blue&quot;,label=&quot;1&quot;,arrowhead=&quot;odot&quot;]

d3 [label=&quot;Dup&quot;]
d3 -&gt; hi_ret [color=&quot;red&quot;]

d4 [label=&quot;Dup&quot;]
d4 -&gt; h_di [color=&quot;blue&quot;,label=&quot;1&quot;]

h_di [label=&quot;!d&quot;]
h_di -&gt; h [color=&quot;blue&quot;,label=&quot;2&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

h [label=&quot;PiL&quot;]
h -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]
h -&gt; hi_ret /* hi_retl */ [color=&quot;blue&quot;]

i_ret [label=&quot;I&quot;]
hi_ret [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]

}</p></object></div>
<div class="graphviz"><object data="../_images/graphviz-8bd2acc718e8b771c4655e579c20c5fded350808.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1a
Root -&gt; c1b
fa -&gt; c2b
c1a -&gt; c2b
c1b -&gt; c2b
d1 -&gt; d2a [dir=none,style=dashed,constraint=false]
d1 -&gt; d2b [dir=none,style=dashed,constraint=false]
d3 -&gt; d4 [dir=none,style=dashed,constraint=false]

Root -&gt; d1 [color=&quot;red&quot;,label=&quot;0-&gt;1&quot;]

d1 [label=&quot;Dup&quot;]
d1 -&gt; f_ret [color=&quot;red&quot;]

d2a [label=&quot;Dup&quot;]
d2a -&gt; hi_retpa [color=&quot;blue&quot;,label=&quot;1&quot;]

d2b [label=&quot;Dup&quot;]
d2b -&gt; d4 [color=&quot;blue&quot;]

hi_retpc1 [label=&quot;!c&quot;]
hi_retpc1 -&gt; d2a [color=&quot;blue&quot;,arrowhead=odot]
hi_retpc1 -&gt; d2b [color=&quot;blue&quot;,arrowhead=odot]

c1a [label=&quot;Cut&quot;]
c1a -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
c1a -&gt; d2a [color=&quot;blue&quot;,label=&quot;1&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; fpb [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; d2b [color=&quot;blue&quot;,label=&quot;1&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

fpb [label=&quot;!p&quot;]
fpb -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

d5 [label=&quot;Dup&quot;]
d5 -&gt; fa [color=&quot;red&quot;]

fa [label=&quot;PiR&quot;]
fa -&gt; hi_retpc1 [color=&quot;blue&quot;]
fa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;]

c2b [label=&quot;Cut&quot;]
c2b -&gt; d3 [color=&quot;red&quot;,label=&quot;2&quot;]
c2b -&gt; x2i_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; hi_retpa [color=&quot;red&quot;,label=&quot;1&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retpa [label=&quot;!p&quot;]
hi_retpa -&gt; d3 [color=&quot;red&quot;,label=&quot;2&quot;,arrowhead=&quot;odot&quot;]
hi_retpa -&gt; d4 [color=&quot;blue&quot;,label=&quot;1&quot;,arrowhead=&quot;odot&quot;]

d3 [label=&quot;Dup&quot;]
d3 -&gt; hi_ret [color=&quot;red&quot;]

d4 [label=&quot;Dup&quot;,shape=doublecircle]
d4 -&gt; h_di [color=&quot;blue&quot;,label=&quot;1&quot;]

h_di [label=&quot;!d&quot;]
h_di -&gt; h [color=&quot;blue&quot;,label=&quot;2&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

h [label=&quot;PiL&quot;]
h -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]
h -&gt; hi_ret /* hi_retl */ [color=&quot;blue&quot;]

i_ret [label=&quot;I&quot;]
hi_ret [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]

}</p></object></div>
<p>More duplication</p>
<div class="graphviz"><object data="../_images/graphviz-7d7795be436f235204c8df97b626d7ca103010e9.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1a
Root -&gt; c1b
fa -&gt; c2b
c1a -&gt; c2b
c1b -&gt; c2b
d1 -&gt; d2a [dir=none,style=dashed,constraint=false]
d1 -&gt; d2b [dir=none,style=dashed,constraint=false]
d3 -&gt; d4 [dir=none,style=dashed,constraint=false]

Root -&gt; d1 [color=&quot;red&quot;,label=&quot;0-&gt;1&quot;]

d1 [label=&quot;Dup&quot;]
d1 -&gt; f_ret [color=&quot;red&quot;]

d2a [label=&quot;Dup&quot;]
d2a -&gt; hi_retpa [color=&quot;blue&quot;,label=&quot;1&quot;]

d2b [label=&quot;Dup&quot;]
d2b -&gt; h_dib [color=&quot;blue&quot;,label=&quot;1&quot;]

hi_retpc1 [label=&quot;!c&quot;]
hi_retpc1 -&gt; d2a [color=&quot;blue&quot;,arrowhead=odot]
hi_retpc1 -&gt; d2b [color=&quot;blue&quot;,arrowhead=odot]

c1a [label=&quot;Cut&quot;]
c1a -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
c1a -&gt; d2a [color=&quot;blue&quot;,label=&quot;1&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; fpb [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; d2b [color=&quot;blue&quot;,label=&quot;1&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

fpb [label=&quot;!p&quot;]
fpb -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

d5 [label=&quot;Dup&quot;]
d5 -&gt; fa [color=&quot;red&quot;]

fa [label=&quot;PiR&quot;]
fa -&gt; hi_retpc1 [color=&quot;blue&quot;]
fa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;]

c2b [label=&quot;Cut&quot;]
c2b -&gt; d3 [color=&quot;red&quot;,label=&quot;2&quot;]
c2b -&gt; x2i_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; hi_retpa [color=&quot;red&quot;,label=&quot;1&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retpa [label=&quot;!p&quot;]
hi_retpa -&gt; d3 [color=&quot;red&quot;,label=&quot;2&quot;,arrowhead=&quot;odot&quot;]
hi_retpa -&gt; h_dia [color=&quot;blue&quot;,label=&quot;1&quot;,arrowhead=&quot;odot&quot;]

d3 [label=&quot;Dup&quot;]
d3 -&gt; hi_ret [color=&quot;red&quot;]

d4 [label=&quot;Dup&quot;,shape=doublecircle]
d4 -&gt; h [color=&quot;blue&quot;]

h_dia [label=&quot;!d&quot;]
h_dia -&gt; d4 [color=&quot;blue&quot;,label=&quot;2&quot;,arrowhead=odot]

h_dib [label=&quot;!d&quot;]
h_dib -&gt; d4 [color=&quot;blue&quot;,label=&quot;2&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

h [label=&quot;PiL&quot;]
h -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]
h -&gt; hi_ret /* hi_retl */ [color=&quot;blue&quot;]

i_ret [label=&quot;I&quot;]
hi_ret [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]

}</p></object></div>
<div class="graphviz"><object data="../_images/graphviz-280015d14b50d8ea5dd2c8bbd9ae090f5a7db74c.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1a
Root -&gt; c1b
fa -&gt; c2b
c1a -&gt; c2b
c1b -&gt; c2b
d1 -&gt; d2a [dir=none,style=dashed,constraint=false]
d1 -&gt; d2b [dir=none,style=dashed,constraint=false]
d3 -&gt; d4a [dir=none,style=dashed,constraint=false]
d4a -&gt; d4b [dir=none,style=dashed,constraint=false]

Root -&gt; d1 [color=&quot;red&quot;,label=&quot;0-&gt;1&quot;]

d1 [label=&quot;Dup&quot;]
d1 -&gt; f_ret [color=&quot;red&quot;]

d2a [label=&quot;Dup&quot;]
d2a -&gt; hi_retpa [color=&quot;blue&quot;,label=&quot;1&quot;]

d2b [label=&quot;Dup&quot;]
d2b -&gt; h_dib [color=&quot;blue&quot;,label=&quot;1&quot;]

hi_retpc1 [label=&quot;!c&quot;]
hi_retpc1 -&gt; d2a [color=&quot;blue&quot;,arrowhead=odot]
hi_retpc1 -&gt; d2b [color=&quot;blue&quot;,arrowhead=odot]

c1a [label=&quot;Cut&quot;]
c1a -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
c1a -&gt; d2a [color=&quot;blue&quot;,label=&quot;1&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; fpb [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; d2b [color=&quot;blue&quot;,label=&quot;1&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

fpb [label=&quot;!p&quot;]
fpb -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

d5 [label=&quot;Dup&quot;]
d5 -&gt; fa [color=&quot;red&quot;]

fa [label=&quot;PiR&quot;]
fa -&gt; hi_retpc1 [color=&quot;blue&quot;]
fa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;]

c2b [label=&quot;Cut&quot;]
c2b -&gt; d3 [color=&quot;red&quot;,label=&quot;2&quot;]
c2b -&gt; x2i_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; hi_retpa [color=&quot;red&quot;,label=&quot;1&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retpa [label=&quot;!p&quot;]
hi_retpa -&gt; d3 [color=&quot;red&quot;,label=&quot;2&quot;,arrowhead=&quot;odot&quot;]
hi_retpa -&gt; h_dia [color=&quot;blue&quot;,label=&quot;1&quot;,arrowhead=&quot;odot&quot;]

d3 [label=&quot;Dup&quot;,shape=doublecircle]
d3 -&gt; hi_ret [color=&quot;red&quot;]

d4a [label=&quot;Dup&quot;]
d4a -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]

d4b [label=&quot;Dup&quot;,shape=doublecircle]
d4b -&gt; hi_ret /* hi_retl */ [color=&quot;blue&quot;]

h_dia [label=&quot;!d&quot;]
h_dia -&gt; ha [color=&quot;blue&quot;,label=&quot;2&quot;]

h_dib [label=&quot;!d&quot;]
h_dib -&gt; hb [color=&quot;blue&quot;,label=&quot;2&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

ha [label=&quot;PiL&quot;]
ha -&gt; d4a [color=&quot;red&quot;,arrowhead=odot]
ha -&gt; d4b [color=&quot;blue&quot;,arrowhead=odot]

hb [label=&quot;PiL&quot;]
hb -&gt; d4a [color=&quot;red&quot;]
hb -&gt; d4b [color=&quot;blue&quot;]

i_ret [label=&quot;I&quot;]
hi_ret [label=&quot;I&quot;,shape=doublecircle]
f_ret [label=&quot;I&quot;]

}</p></object></div>
<p>Up until now we have avoided duplicating identity nodes; this is because duplicating an identity node from only one side would require creating an up-moving duplicator; since cuts reduce downwards this would break the reduction semantics and possibly lead to work duplication. But here we have duplicators on both sides of the identity node, and can duplicate it without reversing directions.</p>
<div class="graphviz"><object data="../_images/graphviz-0602803b8c87134fe3fb2029fac58d3a01bd036a.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1a
Root -&gt; c1b
fa -&gt; c2b
c1a -&gt; c2b
c1b -&gt; c2b
d1 -&gt; d2a [dir=none,style=dashed,constraint=false]
d1 -&gt; d2b [dir=none,style=dashed,constraint=false]

Root -&gt; d1 [color=&quot;red&quot;,label=&quot;0-&gt;1&quot;]

d1 [label=&quot;Dup&quot;]
d1 -&gt; f_ret [color=&quot;red&quot;]

d2a [label=&quot;Dup&quot;]
d2a -&gt; hi_retpa [color=&quot;blue&quot;,label=&quot;1&quot;]

d2b [label=&quot;Dup&quot;]
d2b -&gt; h_dib [color=&quot;blue&quot;,label=&quot;1&quot;]

hi_retpc1 [label=&quot;!c&quot;]
hi_retpc1 -&gt; d2a [color=&quot;blue&quot;,arrowhead=odot]
hi_retpc1 -&gt; d2b [color=&quot;blue&quot;,arrowhead=odot]

c1a [label=&quot;Cut&quot;]
c1a -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
c1a -&gt; d2a [color=&quot;blue&quot;,label=&quot;1&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; fpb [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; d2b [color=&quot;blue&quot;,label=&quot;1&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

fpb [label=&quot;!p&quot;]
fpb -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

d5 [label=&quot;Dup&quot;]
d5 -&gt; fa [color=&quot;red&quot;]

fa [label=&quot;PiR&quot;]
fa -&gt; hi_retpc1 [color=&quot;blue&quot;]
fa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;]

c2b [label=&quot;Cut&quot;,shape=doublecircle]
c2b -&gt; hi_retb [color=&quot;red&quot;,label=&quot;2&quot;]
c2b -&gt; x2i_o2 [color=&quot;blue&quot;,label=&quot;1&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; hi_retpa [color=&quot;red&quot;,label=&quot;1&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retpa [label=&quot;!p&quot;]
hi_retpa -&gt; hi_reta [color=&quot;red&quot;,label=&quot;2&quot;]
hi_retpa -&gt; h_dia [color=&quot;blue&quot;,label=&quot;1&quot;,arrowhead=&quot;odot&quot;]

d4a [label=&quot;Dup&quot;]
d4a -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]

h_dia [label=&quot;!d&quot;]
h_dia -&gt; ha [color=&quot;blue&quot;,label=&quot;2&quot;]

h_dib [label=&quot;!d&quot;]
h_dib -&gt; hb [color=&quot;blue&quot;,label=&quot;2&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

ha [label=&quot;PiL&quot;]
ha -&gt; d4a [color=&quot;red&quot;,arrowhead=odot]
ha -&gt; hi_reta [color=&quot;blue&quot;]

hb [label=&quot;PiL&quot;]
hb -&gt; d4a [color=&quot;red&quot;]
hb -&gt; hi_retb [color=&quot;blue&quot;]

i_ret [label=&quot;I&quot;]
hi_reta [label=&quot;I&quot;]
hi_retb [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]

}</p></object></div>
<div class="graphviz"><object data="../_images/graphviz-db36d08c32035716b9a6a78f36ecc5ac8afbb81f.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1a
Root -&gt; c1b
d1 -&gt; d2a [dir=none,style=dashed,constraint=false]
d1 -&gt; d2b [dir=none,style=dashed,constraint=false]

Root -&gt; d1 [color=&quot;red&quot;,label=&quot;0-&gt;1&quot;]

d1 [label=&quot;Dup&quot;]
d1 -&gt; f_ret [color=&quot;red&quot;]

d2a [label=&quot;Dup&quot;]
d2a -&gt; hi_retpa [color=&quot;blue&quot;,label=&quot;1&quot;]

d2b [label=&quot;Dup&quot;]
d2b -&gt; h_dib [color=&quot;blue&quot;,label=&quot;1&quot;]

hi_retpc1 [label=&quot;!c&quot;]
hi_retpc1 -&gt; d2a [color=&quot;blue&quot;,arrowhead=odot]
hi_retpc1 -&gt; d2b [color=&quot;blue&quot;,arrowhead=odot]

c1a [label=&quot;Cut&quot;]
c1a -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
c1a -&gt; d2a [color=&quot;blue&quot;,label=&quot;1&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; fpb [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; d2b [color=&quot;blue&quot;,label=&quot;1&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

fpb [label=&quot;!p&quot;]
fpb -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

d5 [label=&quot;Dup&quot;]
d5 -&gt; fa [color=&quot;red&quot;]

fa [label=&quot;PiR&quot;]
fa -&gt; hi_retpc1 [color=&quot;blue&quot;]
fa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; hi_retpa [color=&quot;red&quot;,label=&quot;1&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retpa [label=&quot;!p&quot;]
hi_retpa -&gt; hi_reta [color=&quot;red&quot;,label=&quot;2&quot;]
hi_retpa -&gt; h_dia [color=&quot;blue&quot;,label=&quot;1&quot;,arrowhead=&quot;odot&quot;]

d4a [label=&quot;Dup&quot;,shape=doublecircle]
d4a -&gt; i [color=&quot;red&quot;,label=&quot;2&quot;]

h_dia [label=&quot;!d&quot;]
h_dia -&gt; ha [color=&quot;blue&quot;,label=&quot;2&quot;]

h_dib [label=&quot;!d&quot;]
h_dib -&gt; hb [color=&quot;blue&quot;,label=&quot;2&quot;]

i [label=&quot;!p&quot;]
i -&gt; i_i [color=&quot;red&quot;,label=&quot;3&quot;]

i_i [label=&quot;PiR&quot;]
i_i -&gt; il [color=&quot;blue&quot;]
i_i -&gt; i_ret [color=&quot;red&quot;]

il [label=&quot;!d&quot;]
il -&gt; i_ret /* ild */ [color=&quot;blue&quot;]

ha [label=&quot;PiL&quot;]
ha -&gt; d4a [color=&quot;red&quot;,arrowhead=odot]
ha -&gt; hi_reta [color=&quot;blue&quot;]

hb [label=&quot;PiL&quot;]
hb -&gt; d4a [color=&quot;red&quot;]
hb -&gt; x2i_o2 [color=&quot;blue&quot;,label=&quot;2-&gt;1&quot;]

i_ret [label=&quot;I&quot;]
hi_reta [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]

}</p></object></div>
<p>At this point we finish out the duplication of the identity function, similar to Fig 2.19(8).</p>
<div class="graphviz"><object data="../_images/graphviz-e9432c866752e4f5e9c33e5062a9d3f81f1ed34f.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1a
Root -&gt; c1b
d1 -&gt; d2a [dir=none,style=dashed,constraint=false]
d1 -&gt; d2b [dir=none,style=dashed,constraint=false]

Root -&gt; d1 [color=&quot;red&quot;,label=&quot;0-&gt;1&quot;]

d1 [label=&quot;Dup&quot;]
d1 -&gt; f_ret [color=&quot;red&quot;]

d2a [label=&quot;Dup&quot;]
d2a -&gt; hi_retpa [color=&quot;blue&quot;,label=&quot;1&quot;]

d2b [label=&quot;Dup&quot;,shape=doublecircle]
d2b -&gt; h_dib [color=&quot;blue&quot;,label=&quot;1&quot;]

hi_retpc1 [label=&quot;!c&quot;]
hi_retpc1 -&gt; d2a [color=&quot;blue&quot;,arrowhead=odot]
hi_retpc1 -&gt; d2b [color=&quot;blue&quot;,arrowhead=odot]

c1a [label=&quot;Cut&quot;]
c1a -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
c1a -&gt; d2a [color=&quot;blue&quot;,label=&quot;1&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; fpb [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; d2b [color=&quot;blue&quot;,label=&quot;1&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

fpb [label=&quot;!p&quot;]
fpb -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

d5 [label=&quot;Dup&quot;]
d5 -&gt; fa [color=&quot;red&quot;]

fa [label=&quot;PiR&quot;]
fa -&gt; hi_retpc1 [color=&quot;blue&quot;]
fa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;]

x2i_o2 [label=&quot;PiL&quot;]
x2i_o2 -&gt; hi_retpa [color=&quot;red&quot;,label=&quot;1&quot;]
x2i_o2 -&gt; f_ret [color=&quot;blue&quot;]

hi_retpa [label=&quot;!p&quot;]
hi_retpa -&gt; hi_reta [color=&quot;red&quot;,label=&quot;2&quot;]
hi_retpa -&gt; h_dia [color=&quot;blue&quot;,label=&quot;1&quot;,arrowhead=&quot;odot&quot;]

h_dia [label=&quot;!d&quot;]
h_dia -&gt; ha [color=&quot;blue&quot;,label=&quot;2&quot;]

h_dib [label=&quot;!d&quot;]
h_dib -&gt; hb [color=&quot;blue&quot;,label=&quot;2&quot;]

ha [label=&quot;PiL&quot;]
ha -&gt; i1 [color=&quot;red&quot;,label=&quot;2&quot;]
ha -&gt; hi_reta [color=&quot;blue&quot;]

hb [label=&quot;PiL&quot;]
hb -&gt; i2 [color=&quot;red&quot;,label=&quot;2&quot;]
hb -&gt; x2i_o2 [color=&quot;blue&quot;,label=&quot;2-&gt;1&quot;]

hi_reta [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;]

i1 [label=&quot;!p&quot;]
i1 -&gt; i_i1 [color=&quot;red&quot;,label=&quot;3&quot;]

i_i1 [label=&quot;PiR&quot;]
i_i1 -&gt; il1 [color=&quot;blue&quot;]
i_i1 -&gt; i_ret1 [color=&quot;red&quot;]

il1 [label=&quot;!d&quot;]
il1 -&gt; i_ret1 [color=&quot;blue&quot;]

i_ret1 [label=&quot;I&quot;]

i2 [label=&quot;!p&quot;]
i2 -&gt; i_i2 [color=&quot;red&quot;,label=&quot;3&quot;]

i_i2 [label=&quot;PiR&quot;]
i_i2 -&gt; il2 [color=&quot;blue&quot;]
i_i2 -&gt; i_ret2 [color=&quot;red&quot;]

il2 [label=&quot;!d&quot;]
il2 -&gt; i_ret2 [color=&quot;blue&quot;]

i_ret2 [label=&quot;I&quot;]
}</p></object></div>
<p>Now we can do the other duplication. Duplicating the !p requires all inputs to be covered. similar to identity nodes.</p>
<div class="graphviz"><object data="../_images/graphviz-34a9c82590232aec918f0a1c9d7fea4b379974f8.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1a
Root -&gt; c1b
d1 -&gt; d2a [dir=none,style=dashed,constraint=false]
d1 -&gt; d2ba [dir=none,style=dashed,constraint=false]
d1 -&gt; d2bb [dir=none,style=dashed,constraint=false]

Root -&gt; d1 [color=&quot;red&quot;,label=&quot;0-&gt;1&quot;]

d1 [label=&quot;Dup&quot;,shape=doublecircle]
d1 -&gt; f_ret [color=&quot;red&quot;]

d2a [label=&quot;Dup&quot;]
d2a -&gt; hi_retpa [color=&quot;blue&quot;,label=&quot;1&quot;]

h_dib1 [label=&quot;!d&quot;]
h_dib1 -&gt; hb1 [color=&quot;blue&quot;,label=&quot;2&quot;]

h_dib2 [label=&quot;!d&quot;]
h_dib2 -&gt; hb2 [color=&quot;blue&quot;,label=&quot;2&quot;]

hb1 [label=&quot;PiL&quot;]
hb1 -&gt; i2a [color=&quot;red&quot;,label=&quot;2&quot;]
hb1 -&gt; x2i_o2a [color=&quot;blue&quot;,label=&quot;2-&gt;1&quot;]

hb2 [label=&quot;PiL&quot;]
hb2 -&gt; i2b [color=&quot;red&quot;,label=&quot;2&quot;]
hb2 -&gt; x2i_o2b [color=&quot;blue&quot;,label=&quot;2-&gt;1&quot;]

i2a [label=&quot;!p&quot;]
i2a -&gt; i_i2a [color=&quot;red&quot;,label=&quot;3&quot;]

i_i2a [label=&quot;PiR&quot;]
i_i2a -&gt; il2a [color=&quot;blue&quot;]
i_i2a -&gt; i_ret2a [color=&quot;red&quot;]

il2a [label=&quot;!d&quot;]
il2a -&gt; i_ret2a [color=&quot;blue&quot;]

i_ret2a [label=&quot;I&quot;]

i2b [label=&quot;!p&quot;]
i2b -&gt; i_i2b [color=&quot;red&quot;,label=&quot;3&quot;]

i_i2b [label=&quot;PiR&quot;]
i_i2b -&gt; il2b [color=&quot;blue&quot;]
i_i2b -&gt; i_ret2b [color=&quot;red&quot;]

il2b [label=&quot;!d&quot;]
il2b -&gt; i_ret2b [color=&quot;blue&quot;]

i_ret2b [label=&quot;I&quot;]

d2ba [label=&quot;Dup&quot;]
d2ba -&gt; hi_retpa [color=&quot;red&quot;,label=&quot;1&quot;]

d2bb [label=&quot;Dup&quot;,shape=doublecircle]
d2bb -&gt; f_ret [color=&quot;blue&quot;]

x2i_o2a [label=&quot;PiL&quot;]
x2i_o2a -&gt; d2ba [color=&quot;red&quot;,arrowhead=odot]
x2i_o2a -&gt; d2bb [color=&quot;blue&quot;,arrowhead=odot]

x2i_o2b [label=&quot;PiL&quot;]
x2i_o2b -&gt; d2ba [color=&quot;red&quot;]
x2i_o2b -&gt; d2bb [color=&quot;blue&quot;]

hi_retpc1 [label=&quot;!c&quot;]
hi_retpc1 -&gt; d2a [color=&quot;blue&quot;,arrowhead=odot]
hi_retpc1 -&gt; h_dib1 [color=&quot;blue&quot;,label=&quot;1&quot;]

c1a [label=&quot;Cut&quot;]
c1a -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
c1a -&gt; d2a [color=&quot;blue&quot;,label=&quot;1&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; fpb [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; h_dib2 [color=&quot;blue&quot;,label=&quot;1&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

fpb [label=&quot;!p&quot;]
fpb -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

d5 [label=&quot;Dup&quot;]
d5 -&gt; fa [color=&quot;red&quot;]

fa [label=&quot;PiR&quot;]
fa -&gt; hi_retpc1 [color=&quot;blue&quot;]
fa -&gt; d1 [color=&quot;red&quot;,arrowhead=&quot;odot&quot;]

hi_retpa [label=&quot;!p&quot;]
hi_retpa -&gt; hi_reta [color=&quot;red&quot;,label=&quot;2&quot;]
hi_retpa -&gt; h_dia [color=&quot;blue&quot;,label=&quot;1&quot;,arrowhead=&quot;odot&quot;]

h_dia [label=&quot;!d&quot;]
h_dia -&gt; ha [color=&quot;blue&quot;,label=&quot;2&quot;]

ha [label=&quot;PiL&quot;]
ha -&gt; i1 [color=&quot;red&quot;,label=&quot;2&quot;]
ha -&gt; hi_reta [color=&quot;blue&quot;]

hi_reta [label=&quot;I&quot;]
f_ret [label=&quot;I&quot;,shape=doublecircle]

i1 [label=&quot;!p&quot;]
i1 -&gt; i_i1 [color=&quot;red&quot;,label=&quot;3&quot;]

i_i1 [label=&quot;PiR&quot;]
i_i1 -&gt; il1 [color=&quot;blue&quot;]
i_i1 -&gt; i_ret1 [color=&quot;red&quot;]

il1 [label=&quot;!d&quot;]
il1 -&gt; i_ret1 [color=&quot;blue&quot;]

i_ret1 [label=&quot;I&quot;]

}</p></object></div>
<div class="graphviz"><object data="../_images/graphviz-85ab27874a1ce58961c8b56e352e842c14e1a695.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph {
Root -&gt; c1a
Root -&gt; c1b
d2a -&gt; d2ba [dir=none,style=dashed,constraint=false]

Root -&gt; f_ret1 [color=&quot;red&quot;,label=&quot;0-&gt;1&quot;]

f_ret1 [label=&quot;I&quot;]
f_ret2 [label=&quot;I&quot;]

d2a [label=&quot;Dup&quot;]
d2a -&gt; hi_retpa [color=&quot;blue&quot;,label=&quot;1&quot;]

h_dib1 [label=&quot;!d&quot;]
h_dib1 -&gt; hb1 [color=&quot;blue&quot;,label=&quot;2&quot;]

h_dib2 [label=&quot;!d&quot;]
h_dib2 -&gt; hb2 [color=&quot;blue&quot;,label=&quot;2&quot;]

hb1 [label=&quot;PiL&quot;]
hb1 -&gt; i2a [color=&quot;red&quot;,label=&quot;2&quot;]
hb1 -&gt; x2i_o2a [color=&quot;blue&quot;,label=&quot;2-&gt;1&quot;]

hb2 [label=&quot;PiL&quot;]
hb2 -&gt; i2b [color=&quot;red&quot;,label=&quot;2&quot;]
hb2 -&gt; x2i_o2b [color=&quot;blue&quot;,label=&quot;2-&gt;1&quot;]

i2a [label=&quot;!p&quot;]
i2a -&gt; i_i2a [color=&quot;red&quot;,label=&quot;3&quot;]

i_i2a [label=&quot;PiR&quot;]
i_i2a -&gt; il2a [color=&quot;blue&quot;]
i_i2a -&gt; i_ret2a [color=&quot;red&quot;]

il2a [label=&quot;!d&quot;]
il2a -&gt; i_ret2a [color=&quot;blue&quot;]

i_ret2a [label=&quot;I&quot;]

i2b [label=&quot;!p&quot;]
i2b -&gt; i_i2b [color=&quot;red&quot;,label=&quot;3&quot;]

i_i2b [label=&quot;PiR&quot;]
i_i2b -&gt; il2b [color=&quot;blue&quot;]
i_i2b -&gt; i_ret2b [color=&quot;red&quot;]

il2b [label=&quot;!d&quot;]
il2b -&gt; i_ret2b [color=&quot;blue&quot;]

i_ret2b [label=&quot;I&quot;]

d2ba [label=&quot;Dup&quot;]
d2ba -&gt; hi_retpa [color=&quot;red&quot;,label=&quot;1&quot;]

x2i_o2a [label=&quot;PiL&quot;]
x2i_o2a -&gt; d2ba [color=&quot;red&quot;,arrowhead=odot]
x2i_o2a -&gt; f_ret2 [color=&quot;blue&quot;]

x2i_o2b [label=&quot;PiL&quot;]
x2i_o2b -&gt; d2ba [color=&quot;red&quot;]
x2i_o2b -&gt; f_ret1 [color=&quot;blue&quot;]

hi_retpc1 [label=&quot;!c&quot;]
hi_retpc1 -&gt; d2a [color=&quot;blue&quot;,arrowhead=odot]
hi_retpc1 -&gt; h_dib1 [color=&quot;blue&quot;,label=&quot;1&quot;]

c1a [label=&quot;Cut&quot;]
c1a -&gt; fpa [color=&quot;red&quot;,label=&quot;0&quot;]
c1a -&gt; d2a [color=&quot;blue&quot;,label=&quot;1&quot;]

c1b [label=&quot;Cut&quot;]
c1b -&gt; fpb [color=&quot;red&quot;,label=&quot;0&quot;]
c1b -&gt; h_dib2 [color=&quot;blue&quot;,label=&quot;1&quot;]

fpa [label=&quot;!p&quot;]
fpa -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

fpb [label=&quot;!p&quot;]
fpb -&gt; d5 [color=&quot;red&quot;,label=&quot;1&quot;]

d5 [label=&quot;Dup&quot;]
d5 -&gt; fa [color=&quot;red&quot;]

fa [label=&quot;PiR&quot;]
fa -&gt; hi_retpc1 [color=&quot;blue&quot;]
fa -&gt; f_ret2 [color=&quot;red&quot;]

hi_retpa [label=&quot;!p&quot;]
hi_retpa -&gt; hi_reta [color=&quot;red&quot;,label=&quot;2&quot;]
hi_retpa -&gt; h_dia [color=&quot;blue&quot;,label=&quot;1&quot;,arrowhead=&quot;odot&quot;]

h_dia [label=&quot;!d&quot;]
h_dia -&gt; ha [color=&quot;blue&quot;,label=&quot;2&quot;]

ha [label=&quot;PiL&quot;]
ha -&gt; i1 [color=&quot;red&quot;,label=&quot;2&quot;]
ha -&gt; hi_reta [color=&quot;blue&quot;]

hi_reta [label=&quot;I&quot;]

i1 [label=&quot;!p&quot;]
i1 -&gt; i_i1 [color=&quot;red&quot;,label=&quot;3&quot;]

i_i1 [label=&quot;PiR&quot;]
i_i1 -&gt; il1 [color=&quot;blue&quot;]
i_i1 -&gt; i_ret1 [color=&quot;red&quot;]

il1 [label=&quot;!d&quot;]
il1 -&gt; i_ret1 [color=&quot;blue&quot;]

i_ret1 [label=&quot;I&quot;]

}</p></object></div>
</section>
</section>
<section id="junk">
<h2>Junk<a class="headerlink" href="#junk" title="Permalink to this headline"></a></h2>
<p>Our 4th beta reduction</p>
<p>Duplicate more</p>
<p>Add the last duplication node and reduce, for consistency with figure 2.17 (7)</p>
<p>2.17(7) has 5 duplicator nodes, 3 app nodes, and 3 lambda nodes. In comparison, our graph has 5 duplicators, 4 cuts, 3 identities, and one each of PiL, PiR, !p, and !d. So there are still the two pairs of fans but the nodes otherwise look completely different.</p>
<p>Anyway, for the pair on the right, if we scroll up a bit we can see that we were duplicating a single PiR-!d-I loop, the identity function. So the duplication of the I must resolve to another identity function, with the two connecting.</p>
<p>stack machines: waste of time. the stack manipulation takes up more resources than register allocation.</p>
<p>The implementation of overloading is similar to that used for checking equality of dependent types, i.e. it does a lot of normalization but isn’t omniscient. The optimizer decides which case is dead code and will be dropped.
The <code class="docutils literal notranslate"><span class="pre">lub</span></code> operation is implemented as a primitive that desugars in the middle of compilation, in a deterministic manner based on termination checking.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Programs.html" class="btn btn-neutral float-left" title="Exemplary programs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Reduction-Example.html" class="btn btn-neutral float-right" title="Reduction example" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2020 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>