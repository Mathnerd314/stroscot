<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Other programming languages &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=db2ac877" />

  
    <link rel="shortcut icon" href="../../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=7f41d439"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="References" href="../../zzreferences.html" />
    <link rel="prev" title="Meta" href="Meta.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../Language/index.html">Language specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Implementation/index.html">Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Libraries/index.html">Libraries</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Meta</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="Code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l3"><a class="reference internal" href="Community.html">Community</a></li>
<li class="toctree-l3"><a class="reference internal" href="Documentation.html">Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="Funding.html">Funding</a></li>
<li class="toctree-l3"><a class="reference internal" href="Guidelines.html">Guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l3"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Other programming languages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pypl-index-top-28">PyPL index (top 28)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tiobe-next-22">TIOBE Next 22</a></li>
<li class="toctree-l4"><a class="reference internal" href="#next-50-in-alphabetical-order">Next 50 in alphabetical order</a></li>
<li class="toctree-l4"><a class="reference internal" href="#languages-not-in-tiobe">Languages not in TIOBE</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Commentary</a></li>
          <li class="breadcrumb-item"><a href="index.html">Meta</a></li>
      <li class="breadcrumb-item active">Other programming languages</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Meta/OtherPL.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="other-programming-languages">
<h1>Other programming languages<a class="headerlink" href="#other-programming-languages" title="Link to this heading"></a></h1>
<p>There are many existing programming languages to learn from. All of them have had effort put into their design so their features should be considered. Unfortunately there is not enough time to learn every language in depth and use it for 10 years to get an idea of its strengths and weaknesses, so we must rely on reports of other users on the web. Also even searching on the web for detailed reports of complexities encountered in large software projects is quite time-consuming, so we mainly examine popular languages.</p>
<p>Since we aim to be a popular language, we list the languages in order of popularity, so that more attention is focused on the earlier languages. There are several indexes with different measures of popularity (as of January 2023):</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.tiobe.com/tiobe-index/">TIOBE</a> measures the quantity of search engine hits for “X programming”</p></li>
<li><p><a class="reference external" href="http://pypl.github.io/PYPL.html">PYPL</a> measures how often language tutorials are Googled.</p></li>
<li><p><a class="reference external" href="https://github.com/collections/programming-languages">Github Collection</a> measures stars and forks of implementation</p></li>
<li><p><cite>GitHut 2.0 &lt;https://madnight.github.io/githut/&gt;</cite> measures GitHub PRs, stars, forks, issues of language-detected repos</p></li>
<li><p><a class="reference external" href="https://tjpalmer.github.io/languish/">Languish</a> measures Github and Stackoverflow metrics</p></li>
<li><p><a class="reference external" href="https://octoverse.github.com/2022/top-programming-languages">Github Octoverse</a> measures amount of Github code written</p></li>
<li><p><a class="reference external" href="https://redmonk.com/sogrady/2022/10/20/language-rankings-6-22/">RedMonk</a> measures Github repositories and StackOverflow questions</p></li>
<li><p>StackOverflow survey measures</p></li>
<li><p><a class="reference external" href="https://spectrum.ieee.org/top-programming-languages-2022">IEEE Spectrum</a> ranks 57 languages by 9 different measurements</p></li>
<li><p>Google Trends</p></li>
</ul>
<p>Out of these the PYPL index is probably most suited for designing a new language, because the tutorial measurement approximates the new PLs with features that programmers want. But it only has 28 languages - the TIOBE index is more complete with 50 languages ranked and 50 more languages listed. We also want to check that the top 20 PLs from the other rankings are also included.</p>
<section id="pypl-index-top-28">
<h2>PyPL index (top 28)<a class="headerlink" href="#pypl-index-top-28" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>Python</p></li>
</ol>
<ul class="simple">
<li><p>Most popular on TIOBE index, said to be “easy to learn for beginners”, “easy to write”, “simple and elegant syntax” “similar to English”.</p></li>
<li><p>brevity, readability, developer-friendliness make it 5-10x more productive than Java</p></li>
<li><p>“Batteries included” standard libraries, such as lists and dictionaries, numpy (BLAS wrapper) and scipy</p></li>
<li><p>Twisted web framework, TensorFlow machine learning framework</p></li>
<li><p>Mixed reference counting / tracing GC memory management</p></li>
<li><p>Significant indentation - still a point of contention, e.g. whether it makes copy pasting code harder</p></li>
<li><p>C++ interpreter CPython, slow performance. PyPy exists but has’t been widely adopted due to incompatibilities.</p></li>
<li><p>unintuitive “double underscore”/”dunder” method names like <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> and <code class="docutils literal notranslate"><span class="pre">__str__</span></code>, C++’s <code class="docutils literal notranslate"><span class="pre">operator[]</span></code> and Java’s <code class="docutils literal notranslate"><span class="pre">toString</span></code> are clearer</p></li>
<li><p>paradigm: impure functional</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p>Java</p></li>
</ol>
<ul class="simple">
<li><p>Baroque type system, many types of class-like thing (interfaces, enumerations, anonymous adapters), with generics on top. Many compromises/holes such as covariant arrays</p></li>
<li><p>Verbose. But there is a book on design patterns, which can be used to identify areas needing explicit syntax. The class-based syntax for the patterns is not worth emulating.</p></li>
<li><p>try-finally and checked exceptions have wasted the time of many programmers.</p></li>
<li><p>Keyword soup for declarations, such as “public static void main”.</p></li>
<li><p>Lack of operator overloading such as <code class="docutils literal notranslate"><span class="pre">+</span></code> for <code class="docutils literal notranslate"><span class="pre">BigInteger</span></code></p></li>
<li><p>Every object has a 4-byte header and identity using <code class="docutils literal notranslate"><span class="pre">==</span></code>. No value types besides primitives.</p></li>
<li><p>Requirement that the class name must match the directory name.  When moving functionality around this implies a lot of changes inside source files. Led to IDEs with extensive support for refactoring.</p></li>
<li><p>Static methods. Scoped to a class, but not related to objects. Can be very confusing.</p></li>
<li><p>fulfils “compile once, run anywhere” promise at the expense of a huge runtime</p></li>
<li><p>JIT is probably best in the world for throughput. Startup is slow but throughput matches C performance in many cases.</p></li>
<li><p>Garbage collector takes big chunks of CPU time at irregular intervals. Low-pause GCs trade this for continuous overhead. Still not solved, around 15% overhead on wall clock time. <span id="id1">[<a class="reference internal" href="../../zzreferences.html#id48" title="Zixian Cai, Stephen M Blackburn, Michael D Bond, and Martin Maas. Distilling the real cost of production garbage collectors. IEEE International Symposium on Performance Analysis of Systems and Software, pages 12, 2022. URL: https://users.cecs.anu.edu.au/~steveb/pubs/papers/lbo-ispass-2022.pdf.">CBBM22</a>]</span></p></li>
<li><p>paradigm: OO</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p>JavaScript</p></li>
</ol>
<ul class="simple">
<li><p>second-best JIT after Java, optimized for startup time - fast bytecode interpreters</p></li>
<li><p>many strange features such as implicit type conversion, <code class="docutils literal notranslate"><span class="pre">with</span></code> statement, and <code class="docutils literal notranslate"><span class="pre">eval</span></code></p></li>
<li><p>paradigm: impure functional</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p>C#</p></li>
</ol>
<ul class="simple">
<li><p>best designed C-style syntax - e.g. introduced async/await</p></li>
<li><p>wide usage - desktop software (Windows), games (MonoGame, Unity), web development (ASP.NET Core), mobile (Xamarin)</p></li>
<li><p>paradigm: OO</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>C</p></li>
</ol>
<ul class="simple">
<li><p>most portable/widespread language. runs on just about every piece of silicon (although some require specialized compilers)</p></li>
<li><p>language of most OS’s, hence used for FFI stuff</p></li>
<li><p>statically compiled, compilers are very efficient.</p></li>
<li><p>difficult to work with -  unsafe pointers, common to see memory corruption and security vulnerabilities. valgrind, smart fuzzing, and static analysis have allowed catching these with great difficulty. Also there is the Boehm GC, used by many people who don’t want to deal with memory management.</p></li>
<li><p>header files slow down compilation as they have to be read many times during compilation</p></li>
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p>C++</p></li>
</ol>
<ul class="simple">
<li><p>many features, which interact in messy/complex ways making C++ take a long time to learn</p></li>
<li><p>fast, efficient standard libraries similar to hand-tuned code (but missing many features, see also Boost)</p></li>
<li><p>templates, efficient at runtime but slow at compile time</p></li>
<li><p>memory unsafe like C, although smart pointers and RAII make this a little better.</p></li>
<li><p>Hard to debug, there is GDB, valgrind but really rr is the only way to track some errors down</p></li>
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="6">
<li><p>PHP</p></li>
</ol>
<ul class="simple">
<li><p>Initial design was hacked together quickly, inconsistent API design. Could be fixed but backwards compatibility was held to be more important.</p></li>
<li><p>Like JS, several features with huge security or performance impact: eval, weak typing</p></li>
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="7">
<li><p>R</p></li>
</ol>
<ul class="simple">
<li><p>numerous libraries for statistics and data analysis</p></li>
<li><p>lazy evaluation</p></li>
<li><p>paradigm: functional</p></li>
</ul>
<ol class="arabic simple" start="8">
<li><p>TypeScript</p></li>
</ol>
<ul class="simple">
<li><p><a class="reference external" href="https://stackoverflow.com/questions/29918324/is-typescript-really-a-superset-of-javascript">near superset</a> of JavaScript with an unsound type system</p></li>
<li><p>doesn’t really add anything besides the types, so only useful for ideas on gradual typing. Also the type inference is not too good.</p></li>
<li><p>paradigm: OO</p></li>
</ul>
<ol class="arabic simple" start="9">
<li><p>Swift</p></li>
</ol>
<ul class="simple">
<li><p>Automatic reference counting, interesting but not something I want to copy</p></li>
<li><p>syntax for exception handling, if let/guard let</p></li>
<li><p><a class="reference external" href="https://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html">exponentially slow</a> type inference for numeric expressions, with bad heuristics</p></li>
<li><p>paradigm: OO</p></li>
</ul>
<ol class="arabic simple" start="10">
<li><p>Objective C</p></li>
</ol>
<ul class="simple">
<li><p>deprecated by Apple in favor of Swift, but good to compare against C++</p></li>
<li><p>paradigm: OO</p></li>
</ul>
<ol class="arabic simple" start="11">
<li><p>Go</p></li>
</ol>
<ul class="simple">
<li><p>opinionated design, touts meaningless features such as “strong typing”</p></li>
<li><p>goroutines, killer feature - but stackless continuations are better</p></li>
<li><p>finally added generics after a long time</p></li>
<li><p>supposedly a Python replacement, but TensorFlow is mainly in Python and the Go binding <a class="reference external" href="https://github.com/tensorflow/build/tree/master/golang_install_guide">isn’t officially supported</a></p></li>
<li><p>paradigm: actor model</p></li>
</ul>
<ol class="arabic simple" start="12">
<li><p>Rust</p></li>
</ol>
<ul class="simple">
<li><p>good standard library design and documentation, probably worth copying</p></li>
<li><p>voted “most loved” by StackOverflow</p></li>
<li><p>ownership model/borrow checker has been found difficult to use by several studies (<a class="reference external" href="https://arxiv.org/pdf/1901.01001.pdf">1</a>, <a class="reference external" href="https://arxiv.org/pdf/2011.06171.pdf">2</a>, <a class="reference external" href="https://dl.acm.org/doi/pdf/10.1145/3510003.3510107">3</a>). Also it is incomplete - can’t even write linked lists without <a class="reference external" href="https://rcoh.me/posts/rust-linked-list-basically-impossible/">endless pain</a>. In practice Rust programmers <a class="reference external" href="https://rust-unofficial.github.io/too-many-lists/third-layout.html">end up</a>  using reference counting or GC to ensure memory safety in complex cases</p></li>
<li><p>concurrency safe, but async suffers from “borrow checker”-itis and uses atomic reference counting</p></li>
<li><p>learning experience circa 2015 was “rough”</p></li>
<li><p>compatibility pendulum has swung towards “too stable” - many changes that “should” be made for a better language that can’t be</p></li>
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="13">
<li><p>Kotlin</p></li>
</ol>
<ul class="simple">
<li><p>JVM language with features tastefully copied from Groovy and Scala</p></li>
<li><p>val keyword instead of final, null safety, extension methods, first-class type parameters</p></li>
<li><p>coroutines</p></li>
<li><p>mainly getting traction due to Google pushing it for Android</p></li>
<li><p>paradigm: OO</p></li>
</ul>
<ol class="arabic simple" start="14">
<li><p>MATLAB</p></li>
</ol>
<ul class="simple">
<li><p>extensive numerical libraries</p></li>
<li><p>array syntax confuses people, <code class="docutils literal notranslate"><span class="pre">[1</span> <span class="pre">[2</span> <span class="pre">3]]</span></code> is a flat array because <code class="docutils literal notranslate"><span class="pre">[A</span> <span class="pre">B]</span></code> means concatenate A&amp;B. there is <a class="reference external" href="https://www.mathworks.com/help/matlab/math/multidimensional-arrays.html">no literal syntax</a> for 3D or higher dimension arrays.</p></li>
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="15">
<li><p>Ruby</p></li>
</ol>
<ul class="simple">
<li><p>weird syntax, e.g. expression by itself is return value - causes mistakes. Per Matsumoto <a class="reference external" href="https://www.artima.com/articles/the-philosophy-of-ruby">interview</a>, Ruby was designed for <em>his</em> least surprise, and maybe for least surprise after memorizing the language, not for novice programmers or programmers familiar with other languages, so has many idiosyncrasies.</p></li>
<li><p>complex library, e.g. both find_all and select methods that do the exact same thing</p></li>
<li><p>Rails is <a class="reference external" href="https://www.jetbrains.com/lp/devecosystem-2021/ruby/#Ruby_what-web-development-tools-and-or-frameworks-do-you-regularly-use-if-any">(still)</a> the most popular framework. Requires reading the Rails guide to learn things like models having singular class names with capitals and no underscores but db tables with plurals, lower case and underscores. Or how in controllers you just reference params without anything suggesting if params is a variable, method, how its populated, where its scoped, etc. As compared to Django where novices can figure out the basics easily without needing a guide.</p></li>
<li><p>slow, <a class="reference external" href="https://github.com/ruby/ruby/blob/master/doc/yjit/yjit.md">YJIT</a> added in 3.1</p></li>
<li><p>paradigm: OO</p></li>
</ul>
<ol class="arabic simple" start="16">
<li><p>(also 21) VBA / Visual Basic</p></li>
</ol>
<ul class="simple">
<li><p>“mentally mutilates” programmers (according to Dijkstra)</p></li>
<li><p>runs on .NET, so very similar to C# in semantics. There is also “Classic Visual Basic” but the differences are small.</p></li>
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="17">
<li><p>Ada</p></li>
</ol>
<ul>
<li><p>Still in use in aviation and DoD applications</p></li>
<li><p>Considered somewhat legacy, but has many useful features (“C++98 with a design review”)</p></li>
<li><p>SPARK language is a dialect which extends contract support</p></li>
<li><p>interesting design process (<a class="reference external" href="https://en.wikipedia.org/wiki/Ada_(programming_language)#History">Wikipedia</a>):  committee gathered requirements and revised them several times (resulting in the Steelman report). 4 contractors put forward proposals - after two rounds, one was selected. The reference manual was written, and comments and corrections were received. The specification was then frozen and implementations were designed and validated. So far I have gone through</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.adahome.com/History/Steelman/steelman.htm">Steelman report</a></p></li>
<li><p><a class="reference external" href="http://iment.com/maida/computer/requirements/tinman.htm">Tinman report</a></p></li>
<li><p>GREEN rationale</p></li>
<li><p><span id="id2">[<a class="reference internal" href="../../zzreferences.html#id94">Fis76</a>]</span></p></li>
</ul>
<p>Eventually I would also like to go through:</p>
<ul class="simple">
<li><p>Full set of earlier requirements such as Strawman, Woodenman, Ironman, and Revised Ironman, linked <a class="reference external" href="https://dwheeler.com/steelman/">here</a> under “History”</p></li>
<li><p>Stoneman support requirements</p></li>
<li><p>RED rationale</p></li>
<li><p>83, 95, 05, 2012 rationales</p></li>
<li><p>83/95 style guides</p></li>
<li><p>Dijkstra’s comments on the requirements and designs</p></li>
<li><p>Annotated 2012 reference manual</p></li>
</ul>
</li>
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="18">
<li><p>Dart</p></li>
</ol>
<ul class="simple">
<li><p>targets JS, WASM (in progress), and native ARM/x86 with AOT and JIT, a pretty reasonable set of targets</p></li>
<li><p>tied to Flutter UI framework, which is mostly for creating mobile apps but also supports desktop and web</p></li>
<li><p>main advantage is sharing code between client and server</p></li>
<li><p>sentiment seems to be that Kotlin is about the same language-wise and the JVM is better for enterprise work</p></li>
<li><p>they have a package manager, but it doesn’t support automatic vendoring so there are many version solving conflicts</p></li>
<li><p>concurrency model is an async-await event loop similar to node plus actor-style “isolates”</p></li>
<li><p>Google has been funding it, FUD about whether Google will kill it. It is an Ecma <a class="reference external" href="https://dart.dev/guides/language/spec">standard</a> though, probably will stick around for a decade regardless.</p></li>
<li><p>paradigm: OO</p></li>
</ul>
<ol class="arabic simple" start="19">
<li><p>Scala</p></li>
</ol>
<ul class="simple">
<li><p>Type inference, allows avoiding repetition of Java such as <code class="docutils literal notranslate"><span class="pre">SomeModule.MyClass</span> <span class="pre">v</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">SomeModule.MyClass();</span></code></p></li>
<li><p>complex type system: implicit conversions, subtyping.</p></li>
<li><p>complex syntax: scares off newbies, steep learning curve, not recommended. Scala 3 has 3 ways to end blocks (end, braces, indentation) and everyone is confused as to which one they should use.</p></li>
<li><p>paradigm: impure functional</p></li>
</ul>
<ol class="arabic simple" start="20">
<li><p>Lua</p></li>
</ol>
<ul class="simple">
<li><p>Use of “tables” for everything is interesting</p></li>
<li><p>LuaJIT was fast but the main developer left due to lack of income. Stroscot needs to avoid the same fate.</p></li>
<li><p>paradigm: impure functional</p></li>
</ul>
<ol class="arabic simple" start="22">
<li><p>ABAP (Advanced Business Application Programming)</p></li>
</ol>
<ul class="simple">
<li><p>proprietary PL developed by SAP in 1983, only available as part of NetWeaver ERP suite.</p></li>
<li><p>“German COBOL”, popular in Eastern Europe / Germany.</p></li>
<li><p>odd niche language, but with even bigger footprint than COBOL, gradually being phased out with Java/JS/etc.</p></li>
<li><p>weird combination of BASIC and SQL. Built-in SQL syntax.</p></li>
<li><p>all code is stored in databases, thousands of tables</p></li>
<li><p>OOP extensions that make everything terrible to maintain</p></li>
<li><p>good debugger</p></li>
<li><p>paradigm: procedural/imperative</p></li>
</ul>
<ol class="arabic simple" start="23">
<li><p>Julia</p></li>
</ol>
<ul class="simple">
<li><p>good support for concurrency/parallelism</p></li>
<li><p>C+Fortran+Python FFIs and syntax</p></li>
<li><p>JIT design goes through LLVM and requires trampolines between functions, performance barrier</p></li>
<li><p>paradigm: multiple dispatch</p></li>
</ul>
<ol class="arabic simple" start="24">
<li><p>Groovy</p></li>
</ol>
<ul class="simple">
<li><p>most “batteries included” JVM language… even has YAML support in the standard library.</p></li>
<li><p>“kitchen sink” approach to language design, e.g. can declare variable bare, with var, or typed</p></li>
<li><p>scripting language feel, more dynamic than Kotlin, also older</p></li>
<li><p>good at DSLs, e.g. SQL DSL, used as Grails/Gradle configuration language</p></li>
<li><p>starting to decline in popularity, even though it’s still active</p></li>
<li><p>paradigm: OO</p></li>
</ul>
<ol class="arabic simple" start="25">
<li><p>Haskell</p></li>
</ol>
<ul class="simple">
<li><p>“finest imperative programming language”</p></li>
<li><p>small community, few core/maintenance developers (mainly SPJ) compared to size of codebase</p></li>
<li><p>good in benchmarks and scripting but GC is still not usable in production</p></li>
<li><p>poor library design, e.g. verbose naming conventions</p></li>
<li><p>paradigm: pure functional</p></li>
</ul>
<ol class="arabic simple" start="26">
<li><p>Perl</p></li>
</ol>
<ul class="simple">
<li><p>A mess with the Raku split</p></li>
<li><p>Various libraries on CPAN are good</p></li>
<li><p>Contexts and sigils, terrible syntax for beginners</p></li>
<li><p>paradigm: impure functional</p></li>
</ul>
<ol class="arabic simple" start="27">
<li><p>COBOL</p></li>
</ol>
<ul class="simple">
<li><p>most hated programming language per StackOverflow survey</p></li>
<li><p>C2 wiki list: <a class="reference external" href="https://wiki.c2.com/?WhyWeHateCobol">why we hate COBOL</a></p></li>
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="28">
<li><p>Delphi / Object Pascal</p></li>
</ol>
<ul class="simple">
<li><p>still kicking, but proprietary</p></li>
<li><p>paradigm: OO</p></li>
</ul>
</section>
<section id="tiobe-next-22">
<h2>TIOBE Next 22<a class="headerlink" href="#tiobe-next-22" title="Link to this heading"></a></h2>
<ol class="arabic simple" start="8">
<li><p>SQL</p></li>
</ol>
<ul class="simple">
<li><p>DSL used for databases, common enough that finding a good way to embed it is necessary</p></li>
<li><p>query compilers do a lot of interesting data structure traversal optimizations</p></li>
<li><p>PL/SQL is Oracle’s extension which allows procedures, functions, and triggers; other databases have similar things</p></li>
<li><p>paradigm: declarative</p></li>
</ul>
<ol class="arabic simple" start="9">
<li><p>Assembly language</p></li>
</ol>
<ul class="simple">
<li><p>Generally the last stage before a binary in any compilation pipeline</p></li>
<li><p>full access to ISA and thus machine resources</p></li>
<li><p>Intel and AT&amp;T syntaxes for x86. <a class="reference external" href="https://blog.reverberate.org/2009/07/giving-up-on-at-style-assembler-syntax.html">Several</a> <a class="reference external" href="https://outerproduct.net/2021-02-13_att-asm.html">posts</a> say to use Intel.</p></li>
<li><p>repetitive and tedious, too many side effects, not at all intuitive, full of many inconsistencies</p></li>
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="18">
<li><p>Scratch</p></li>
</ol>
<ul class="simple">
<li><p>Block-black visual programming language for children</p></li>
<li><p>Essentially procedural, it has conditionals, loops, and functions</p></li>
<li><p>paradigm: block-based</p></li>
</ul>
<ol class="arabic simple" start="21">
<li><p>SAS</p></li>
</ol>
<ul class="simple">
<li><p>Another statistics language, less popular than R and proprietary</p></li>
<li><p>paradigm: data-driven</p></li>
</ul>
<ol class="arabic simple" start="22">
<li><p>(Visual) FoxPro</p></li>
</ol>
<ul class="simple">
<li><p>commercial language, don’t know much about it</p></li>
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="24">
<li><p>Fortran</p></li>
</ol>
<ul class="simple">
<li><p>call-by-reference calling convention, avoids copying arrays but hard to program with</p></li>
<li><p>still used for some numerical code</p></li>
<li><p>handles floating point exceptions via signals</p></li>
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="25">
<li><p>Lisp</p></li>
</ol>
<ul class="simple">
<li><p>Easily parsable syntax, originator of macros</p></li>
<li><p>Error messages involving macros are probably more confusing than the macros themselves</p></li>
<li><p>Racket is probably the most popular Lisp now. Uses Chez Scheme’s work on the nanopass framework.</p></li>
<li><p>paradigm: functional</p></li>
</ul>
<ol class="arabic simple" start="33">
<li><p>Prolog</p></li>
</ol>
<ul class="simple">
<li><p>old language, dead/resting</p></li>
<li><p>Few industrial-sized (&gt;100k LOC) applications. Tends to be used as a DSL, e.g. IBM Watson uses it for pattern matching over natural language parse trees, but the rest of the application is written in C++ and Java.</p></li>
<li><p>Blamed for contributing to the failure of Japan’s <a class="reference external" href="https://en.wikipedia.org/wiki/Fifth_Generation_Computer_Systems">Fifth Generation Computer Systems</a> (FGCS) effort.</p></li>
<li><p>great for querying relational databases, actually sort of a superset of SQL. You just load the relations and go.</p></li>
<li><p>not well standardized - many implementations with different module systems/standard libraries</p></li>
<li><p>What is standardized/hardcoded is the DFS search order, which for naive programs is often slow. Simply reordering the goals or clauses can give significant speedups. miniKanren uses a “fair” search strategy that avoids non-termination due to clause order, and it should be possible for a compiler to optimize the search even better with heuristics and profiling. Datalog restricts some features and has more efficient strategies.</p></li>
<li><p>Prolog does not really have a way to examine or manipulate mid-level IR, e.g. something comparable to SQL EXPLAIN.</p></li>
<li><p>Implementing speedups generally requires non-declarative workarounds that break the logical semantics. And e.g. cut is really hard to reason about. Mercury has “modes”, not well-explored.</p></li>
<li><p>Constraints allow avoiding cut in some cases, very powerful but not well explained in beginner courses</p></li>
<li><p>paradigm: logic. generally agreed to be the highest-level paradigm.</p></li>
</ul>
<ol class="arabic simple" start="34">
<li><p>D</p></li>
</ol>
<ul class="simple">
<li><p>C/C++ style but different.</p></li>
<li><p>Never really took off AFAICT - rift caused by the differences between D version 1 and 2, a general lack of learning resources and packages</p></li>
<li><p>garbage collected</p></li>
<li><p>many features that have been incorporated into C++, others that haven’t like scope guards</p></li>
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="35">
<li><p>PL/SQL is a dialect of of SQL</p></li>
<li><p>Bash shell</p></li>
</ol>
<ul class="simple">
<li><p>Common on Unix systems, but I think Python is more useful when you’re doing anything complex</p></li>
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="37">
<li><p>Powershell</p></li>
</ol>
<ul class="simple">
<li><p>Equivalent of Bash on Windows - I don’t think there’s much inspiring</p></li>
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="39">
<li><p>Logo</p></li>
</ol>
<ul class="simple">
<li><p>There is no official Logo implementation, but UCBLogo is popular.</p></li>
<li><p>Simple procedural commands, functions, and Lisp-like linked lists</p></li>
<li><p>Turtle graphics</p></li>
<li><p>Personally I like the game <a class="reference external" href="https://en.wikipedia.org/wiki/RoboWar">RoboWar</a> better, which is based on Forth</p></li>
<li><p>paradigm: block-based</p></li>
</ul>
<ol class="arabic simple" start="40">
<li><p>Transact-SQL is a dialect of SQL</p></li>
</ol>
<ol class="arabic simple" start="43">
<li><p>F#</p></li>
</ol>
<ul class="simple">
<li><p>Mixture of C# and Haskell, not really as interesting as either</p></li>
<li><p>paradigm: impure functional</p></li>
</ul>
<ol class="arabic simple" start="44">
<li><p>OCaml</p></li>
</ol>
<ul class="simple">
<li><p>paradigm: impure functional</p></li>
</ul>
<ol class="arabic simple" start="45">
<li><p>CFML (ColdFusion Markup Language)</p></li>
</ol>
<ul class="simple">
<li><p>paradigm: imperative</p></li>
</ul>
<ol class="arabic simple" start="46">
<li><p>Scheme - discussed under Lisp</p></li>
<li><p>Erlang</p></li>
</ol>
<ul class="simple">
<li><p>has a well-tested distributed, fault-tolerant, reliable, soft real-time, concurrent database</p></li>
<li><p>designed to be crash-only, restart tolerant</p></li>
<li><p>not used much outside Ericsson</p></li>
<li><p>Per roastedby.ai, written by drunk masochistic Swedes. Just watch <a class="reference external" href="https://www.youtube.com/watch?v=xrIjfIjssLE">Erlang: the movie</a> and tell me they aren’t drunk.</p></li>
<li><p>paradigm: actor model</p></li>
</ul>
<ol class="arabic simple" start="48">
<li><p>LabVIEW</p></li>
</ol>
<ul class="simple">
<li><p>Pretty nice GUI approach to programming</p></li>
<li><p>Lots of wires, and if you get a complicated enough program the auto wire layout command gives up</p></li>
<li><p>paradigm: dataflow</p></li>
</ul>
<ol class="arabic simple" start="50">
<li><p>ML</p></li>
</ol>
<ul class="simple">
<li><p>paradigm: impure functional</p></li>
</ul>
</section>
<section id="next-50-in-alphabetical-order">
<h2>Next 50 in alphabetical order<a class="headerlink" href="#next-50-in-alphabetical-order" title="Link to this heading"></a></h2>
<p>ABC</p>
<p>ActionScript</p>
<ul class="simple">
<li><p>basically JS but with a different standard library</p></li>
</ul>
<p>Alice</p>
<p>Apex</p>
<p>APL</p>
<p>AutoLISP</p>
<p>Awk</p>
<p>B4X</p>
<p>C shell</p>
<p>CL (OS/400)</p>
<p>CLIPS</p>
<p>Clojure</p>
<ul class="simple">
<li><p>one of few languages to use software transactional memory, custom implementation “MVCC”</p></li>
<li><p><a class="reference external" href="https://github.com/matthiasn/talk-transcripts/tree/master/Hickey_Rich">interesting talks</a> on functional programming and language design</p></li>
<li><p>runs well on JVM</p></li>
<li><p>slow</p></li>
<li><p>never seen it used for anything performance-critical or that substantially affects a business</p></li>
</ul>
<p>Common Lisp - discussed under Lisp</p>
<p>Crystal</p>
<ul class="simple">
<li><p>Ruby-like syntax - attracts Ruby programmers, but too complex for anyone else</p></li>
<li><p>statically compiled with LLVM - the usual story of fast binaries but slow compile times</p></li>
<li><p>HM-style type inference, the usual caveats</p></li>
</ul>
<p>Elixir</p>
<ul class="simple">
<li><p>based on Erlang, new and supposedly great syntax</p></li>
</ul>
<p>Emacs Lisp - discussed under Lisp</p>
<p>Forth</p>
<ul class="simple">
<li><p>Minimal design, almost as portable as C</p></li>
<li><p>stack-based paradigm leads to annoying shuffling (dup, swap, etc.) to get anything done</p></li>
<li><p>extended by Factor, Joy, and other “concatenative languages”</p></li>
</ul>
<p>Hack</p>
<p>Icon</p>
<p>Io</p>
<p>J#</p>
<p>JScript</p>
<p>Korn shell</p>
<p>Ladder Logic</p>
<p>LPC</p>
<p>Modula-2</p>
<p>MQL5</p>
<p>MUMPS</p>
<p>NATURAL</p>
<p>Occam</p>
<p>OpenCL</p>
<p>OpenEdge ABL</p>
<p>PL/I</p>
<ul class="simple">
<li><p>Ye olde IBM language</p></li>
<li><p>Weird exception handling style - “ON &lt;EXCEPTION&gt; GOTO &lt;LABEL&gt;”, very similar to hardware implementation</p></li>
</ul>
<p>Q</p>
<p>Racket - discussed under Lisp</p>
<p>Raku</p>
<ul class="simple">
<li><p>Perl 6, yay</p></li>
</ul>
<p>Ring</p>
<p>RPG</p>
<p>S</p>
<p>Smalltalk</p>
<p>Solidity</p>
<p>SPARK - discussed under Ada</p>
<p>Stata</p>
<p>Tcl</p>
<p>VBScript</p>
<p>Verilog</p>
<ul class="simple">
<li><p>Two languages: a general purpose specification language, and a poorly-defined hardware synthesis language. Basically you have to run the synthesizer and see if it complains or generates a circuit.</p></li>
</ul>
<p>VHDL</p>
<ul class="simple">
<li><p>also a hardware synthesis language</p></li>
</ul>
<p>WebAssembly</p>
<p>X++</p>
<p>Xojo</p>
</section>
<section id="languages-not-in-tiobe">
<h2>Languages not in TIOBE<a class="headerlink" href="#languages-not-in-tiobe" title="Link to this heading"></a></h2>
<p>Austral</p>
<ul class="simple">
<li><p>Has a <a class="reference external" href="https://austral-lang.org/spec/spec.html">spec</a> with rationales for some of its design decisions</p></li>
</ul>
<p>Elm</p>
<ul class="simple">
<li><p>small ecosystem</p></li>
<li><p>derivative of OCaml</p></li>
<li><p>no substantial commits in main repo since 2019</p></li>
<li><p>BDFL doing “exploratory work” closed-repo, most recently described in a 2021 <a class="reference external" href="https://discourse.elm-lang.org/t/status-update-3-nov-2021/7870">status update</a></p></li>
</ul>
<p>Flix</p>
<ul class="simple">
<li><p>Long list of principles, most of which I disagree with. The corresponding Stroscot opinions are expressed on their respective pages.</p></li>
</ul>
<p>Oz</p>
<ul class="simple">
<li><p>multi-paradigm, I don’t like the way they integrated logic programming though</p></li>
</ul>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/cheery/lever/">Lever</a></p></li>
<li><p><a class="reference external" href="https://github.com/BSVino/JaiPrimer/blob/4a2d14f3e1c8e82a4ba68b81d3fd7d8d438e955c/JaiPrimer.md">Jai</a></p></li>
<li><p><a class="reference external" href="https://pinafore.info/">Pinafore</a></p></li>
<li><p><a class="reference external" href="http://github.com/codedot/lambda">Macro Lambda Calculus</a></p></li>
<li><p><a class="reference external" href="https://github.com/manuel/wat-js">Wat</a></p></li>
<li><p><a class="reference external" href="https://github.com/vito/atomo">Atomo</a> / <a class="reference external" href="https://github.com/vito/atomy">Atomy</a></p></li>
</ul>
<p>REXX</p>
<ul class="simple">
<li><p>old, somewhat interesting</p></li>
<li><p><a class="reference external" href="https://smartbear.com/blog/7-reasons-that-rexx-still-matters/">blog post</a>: peaked around 1995, major scripting language before Python came along</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Meta.html" class="btn btn-neutral float-left" title="Meta" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../zzreferences.html" class="btn btn-neutral float-right" title="References" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>