<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Logic &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Logic programming" href="LogicProgramming.html" />
    <link rel="prev" title="Learning" href="Learning.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler-Library.html">Compiler library</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Intrinsics.html">Intrinsics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Logic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#logic-style">Logic style</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-annotations">Type annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#jumbo-connectives">Jumbo connectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#common-connectives">Common connectives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#programming-types">Programming types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exponentials">Exponentials</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#contraction">Contraction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#subexponentials">Subexponentials</a></li>
<li class="toctree-l4"><a class="reference internal" href="#modalities">Modalities</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#classification-of-sequents">Classification of sequents</a></li>
<li class="toctree-l3"><a class="reference internal" href="#polarized-logic">Polarized logic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cartesian-types">Cartesian types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tangent-reversible-computing">Tangent: Reversible computing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#structural-rules">Structural rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quantifiers">Quantifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logic-translations">Logic translations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#set-theory">Set theory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#paradoxes">Paradoxes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#equality">Equality</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#recursion-and-infinite-structures">Recursion and infinite structures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#graph-reduction">Graph reduction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hashing">Hashing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#primitives">Primitives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#confluent-reduction">Confluent reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#levels">Levels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#resources">Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#metrics">Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#methods">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#action">Action</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard-Library.html">Standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Logic</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Logic.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="logic">
<h1>Logic<a class="headerlink" href="#logic" title="Permalink to this heading"></a></h1>
<div class="math notranslate nohighlight">
\[\newcommand{\rule}[3]{ \dfrac{\displaystyle ~~#1~~ }{\displaystyle ~~#2~~ } \  (#3)}
\newcommand{\defeq}{\overset{\text{def}}{=}}
\newcommand{\with}{\mathbin{\mathrm{\&amp;}}}
\newcommand{\par}{\mathbin{\mathrm{⅋}}}
\newcommand{\multimapboth}{\mathbin{\mathrm{⧟}}}
\newcommand{\bang}{{\mathrm{!}}}
\newcommand{\whim}{{\mathrm{?}}}
\newcommand{\bangc}{{\mathrm{!}}}
\newcommand{\whimc}{{\mathrm{?}}}
\newcommand{\ocin}{\mathrel{\raise{-1pt}{\mathrm{!}}\mathord{\in}}}
\definecolor{mygray}{RGB}{156,156,156}
\newcommand{\sk}[1]{{\color{mygray} #1}}\]</div>
<p>The Curry-Howard correspondence maps logic to programming. A logical system specifies well-formed proofs of propositions. These correspond to well-formed programs in a simple type system. By proving the logic sound and complete, we get an expressive programming language.</p>
<section id="logic-style">
<h2>Logic style<a class="headerlink" href="#logic-style" title="Permalink to this heading"></a></h2>
<p>The use of sequent calculus is inspired by <span id="id1">[<a class="reference internal" href="../zzreferences.html#id48" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span>. Whereas a natural deduction logic results in reduction patterns similar to the lambda-calculus, sequent calculus divides the program into values and continuations. Reduction always takes place at a cut point with a value and a continuation. Continuations are exposed as first-class manipulable variables, similar to CPS, but as discussed in IR, CPS-based IRs have drawbacks that sequent calculus-style IRs do not.</p>
<p>Between classical, intuitionistic, and linear logic, I went with linear logic. It’s the most expressive, in that intuitionistic and classical logic can be encoded fairly naturally, but linear logic has more operators. Intuitionistic logic is traditional and has a direct machine implementation, but there is an operational semantics for linear logic <span id="id2">[]</span> and linear logic makes the expensive “copy term” operation more explicit. In intuitionistic logic, copying can happen anywhere in the reduction, which is harder to handle. The “boxes” of linear logic which demarcate copying boundaries are supposedly the basis of optimal reduction <span id="id3">[<a class="reference internal" href="../zzreferences.html#id68" title="Stefano Guerrini. Theoretical and Practical Issues of Optimal Implementations of Functional Languages. PhD thesis, Università di Pisa. Dipartimento di Informatica, 1996. URL: https://www-lipn.univ-paris13.fr/~guerrini/mysite/sites/default/files/biblio/PhDThesis.pdf.">Gue96</a>]</span>.</p>
<p><span id="id4">[<a class="reference internal" href="../zzreferences.html#id48" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span>  say “Sequent Core lies in between [intuitionistic and classical logic]: sometimes there can only be one conclusion, and sometimes there can be many.” Specifically, terms and types are intuitionistic (single conclusion), but commands, continuations and bindings are written to allow multiple propositions. Ret/Ax, WR/Name, and Jump/Label all introduce right-weakening. Linear logic seems a lot cleaner than this mess, but also lies between intuitionistic and classical logic, in that (like intuitionistic) there is no excluded middle, but also (like classical) there is duality and no limitation on the number of conclusions.</p>
<p>Linear logic can be formulated as two-sided, one-sided, or intuitionistic. I chose two-sided because again, it’s the most expressive. Intuitionistic logic doesn’t typically have negation, but it can be encoded as <span class="math notranslate nohighlight">\(A \to \bot\)</span>, pretty bad for trying to simplify connectives. One-sided might seem attractive, as on first glance it makes formulas more uniform, but it actually doesn’t really improve complexity because the one-sided logic has the same number of connectives, and the duals require special handling - e.g. an application of identity looks like <span class="math notranslate nohighlight">\(\vdash \Sigma X^\bot, \Pi X\)</span> instead of <span class="math notranslate nohighlight">\(\Pi X \vdash \Pi X\)</span>. So we end up with a representation of a connective as having a boolean for polarity, whereupon there is not much issue with adding a boolean for side as well to obtain the two-sided sequent. The two-sided sequent formulation preserves intent, e.g. the definition of refutations as sequents <span class="math notranslate nohighlight">\(A \vdash\)</span> is not distinct from that of a proof in the one-sided calculus. Taking the two-sided logic as basic, the one sided logic can be formulated as a transformation that moves everything to the right side with negation and pushes down negations to atomic statements by applying duality. Such a transformation is of course useful, but forcing it to be applied from the start does not seem to serve much purpose.</p>
<p>There are also other logics similar to Girard’s linear logic, like deep inference. Most papers on deep inference seem to add the <a class="reference external" href="https://ncatlab.org/nlab/show/mix+rule">mix rule</a> which corresponds to assuming <span class="math notranslate nohighlight">\(1 \leftrightarrow \bot\)</span>. This doesn’t seem attractive compared to plain linear logic - it proves contradiction as a theorem, hence loses the embedding of classical logic. <a class="reference external" href="https://www.pls-lab.org/en/Mix_rule">This page</a> mentions that mix holds in various models of linear logic such as coherent spaces and the game-theoretic semantics, but models are usually a simplification and there are models such as the syntactic model where mix doesn’t hold. <span id="id5">[<a class="reference internal" href="../zzreferences.html#id153" title="Lutz STRAßBURGER. Deep inference and expansion trees for second-order multiplicative linear logic. Mathematical Structures in Computer Science, 29(8):1030–1060, September 2019. URL: https://www.cambridge.org/core/product/identifier/S0960129518000385/type/journal_article (visited on 2022-08-11), doi:10.1017/S0960129518000385.">STR19</a>]</span> presents a deep inference system for non-mix MLL but says extending it to full LL is future work.</p>
<p>There is also the question of if, having removed weakening and contraction, the remaining structural rules, exchange and associativity, should be dropped. Linear logic gives the idea of the propositions being in named slots, as e.g. <span class="math notranslate nohighlight">\(\vdash A^a, B^b`\)</span> is for almost all purposes the same as <span class="math notranslate nohighlight">\(\vdash B^b, A^a`\)</span>, and only in some narrow cases would we want to differentiate them. This associative array semantics corresponds well to the RAM model. In contrast, dropping exchange gives non-commutative or ordered logic, leading to a stack or list on each side. But <span id="id6">[<a class="reference internal" href="../zzreferences.html#id142" title="Yunhe Shi, David Gregg, Andrew Beatty, and M. Anton Ertl. Virtual machine showdown: stack versus registers. In Proceedings of the 1st ACM/USENIX International Conference on Virtual Execution Environments, VEE '05, 153–163. New York, NY, USA, June 2005. Association for Computing Machinery. URL: https://dl.acm.org/doi/10.1145/1328195.1328197 (visited on 2021-06-29), doi:10.1145/1064979.1065001.">SGBE05</a>]</span> shows that a register model is much better for an implementation - the extra stack swapping instructions are more overhead than the additional register names. Stack-like access is just too restrictive. Similarly, dropping associativity gives a tree-like semantics, and trees are not iterable in constant time. The number of operators would explode because every tree structure / stack index would create a new operator. Hence linear logic is the clear winner. But, there seem to be reasonable ways of embedding linear logic in non-associative / non-commutative logic by adding associative / commutative modalities. <span id="id7">[<a class="reference internal" href="../zzreferences.html#id20" title="Eben Blaisdell, Max Kanovich, Stepan L. Kuznetsov, Elaine Pimentel, and Andre Scedrov. Non-associative, Non-commutative Multi-modal Linear Logic. In Jasmin Blanchette, Laura Kovács, and Dirk Pattinson, editors, Automated Reasoning, Lecture Notes in Computer Science, 449–467. Cham, 2022. Springer International Publishing. doi:10.1007/978-3-031-10769-6_27.">BKK+22</a>]</span> If there was a popular logic with such an embedding, then we could switch from linear logic to that. But per <span id="id8">[<a class="reference internal" href="../zzreferences.html#id111" title="Dale Miller. An Overview of Linear Logic Programming. In Thomas Ehrhard, Jean-Yves Girard, Paul Ruet, and Philip Scott, editors, Linear Logic in Computer Science, pages 119–150. Cambridge University Press, first edition, November 2004. URL: https://www.cambridge.org/core/product/identifier/CBO9780511550850A013/type/book_part (visited on 2021-04-02), doi:10.1017/CBO9780511550850.004.">Mil04</a>]</span> “no single [non-commutative] proposal seems to be canonical at this point.”</p>
</section>
<section id="type-annotations">
<h2>Type annotations<a class="headerlink" href="#type-annotations" title="Permalink to this heading"></a></h2>
<p>In <span id="id9">[<a class="reference internal" href="../zzreferences.html#id48" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span>, TyApp is written in natural deduction style. Actually, it seeems type annotations just sort of float around, they should not be part of the sequents at all. In my presentation of logic, terms are the proof trees, and propositions the types. So when it is written that ∀ and ∃ consume terms with types, like ∀R <span class="math notranslate nohighlight">\((\Gamma, a : \kappa \to v : \tau) \vdash (\Gamma \to \Lambda a : \kappa. v : \forall a : \kappa . \tau)\)</span>, <span class="math notranslate nohighlight">\(a : \kappa\)</span> is just an assertion, and I would instead just write <span class="math notranslate nohighlight">\((\Gamma \to \tau) \vdash (\Gamma \to \forall a : \kappa . \tau)\)</span>, where <span class="math notranslate nohighlight">\(a\)</span> has no free occurrence in <span class="math notranslate nohighlight">\(\Gamma\)</span> and is ambiently assumed to be of some type. Stroscot is a unityped language, so the types can just be ignored for now.</p>
</section>
<section id="jumbo-connectives">
<h2>Jumbo connectives<a class="headerlink" href="#jumbo-connectives" title="Permalink to this heading"></a></h2>
<p>Based on <span id="id10">[<a class="reference internal" href="../zzreferences.html#id102" title="Paul Blain Levy. Jumbo λ-calculus. In Michele Bugliesi, Bart Preneel, Vladimiro Sassone, and Ingo Wegener, editors, Automata, Languages and Programming, Lecture Notes in Computer Science, 444–455. Berlin, Heidelberg, 2006. Springer. URL: https://www.cs.bham.ac.uk/~pbl/papers/jumboicalp.pdf, doi:10.1007/11787006_38.">Lev06</a>]</span>, Stroscot aims for the largest allowable set of operators. In particular we generalize into two jumbo operators, <span class="math notranslate nohighlight">\(\Sigma\)</span> (sigma) and <span class="math notranslate nohighlight">\(\Pi\)</span> (pi). The generalized <span class="math notranslate nohighlight">\(\Pi\)</span> rule is similar to Levy’s rule except it allows multiple conclusion propositions. The generalized <span class="math notranslate nohighlight">\(\Sigma\)</span> rule is the dual of <span class="math notranslate nohighlight">\(\Pi\)</span>. We have indexed variables <span class="math notranslate nohighlight">\(A_{ij}\)</span> and <span class="math notranslate nohighlight">\(B_{ik}\)</span> where <span class="math notranslate nohighlight">\(0 \leq i &lt; N, 0 \leq j &lt; m_i, 0 \leq k &lt; n_i\)</span>. We call <span class="math notranslate nohighlight">\(N\)</span> the length of the jumbo type and the list <span class="math notranslate nohighlight">\([(m_i,n_i)]\)</span> the jumbo-arity.</p>
<p>In <span id="id11">[<a class="reference internal" href="../zzreferences.html#id48" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span>, TLK/TRK correspond to the intuitionistic jumbo-style Sigma operator. But they have no corresponding Pi operator, but rather Case/Deflt, which have no effect on the sequent type, hence no logical meaning. They say they considered adding “general existential types” which seems to be a Pi operator in disguise, but mapping to GHC Core was too difficult and required a “heavy-handed encoding”. Since  Stroscot is a new language, we can have a full set of jumbo operators to do all sorts of case-matching.</p>
<p>When the RHS of <span class="math notranslate nohighlight">\(\Sigma\)</span> is nonempty we get terms with holes, that can be pattern-matched by filling the holes, e.g. <a class="reference external" href="https://en.wikipedia.org/wiki/Difference_list">difference lists</a>. (TODO: check that this actually gives efficient concatenation)</p>
<p>The dual of implication is called “subtraction” or “difference” and is denoted <span class="math notranslate nohighlight">\(-\)</span>. For an ADT, the RHS of the difference is empty, i.e. <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">A</span> <span class="pre">|</span> <span class="pre">b</span> <span class="pre">B1</span> <span class="pre">B2</span> <span class="pre">|</span> <span class="pre">C</span></code> looks like <span class="math notranslate nohighlight">\(\Sigma [(a, [A]-[]),(b, [B_1, B_2]-[]), (c,[]-[])]\)</span>. This follows <span id="id12">[<a class="reference internal" href="../zzreferences.html#id162" title="Philip Wadler. Call-by-value is dual to call-by-name. In Proceedings of the Eighth ACM SIGPLAN International Conference on Functional Programming, ICFP '03, 189–201. Uppsala, Sweden, August 2003. Association for Computing Machinery. URL: http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf (visited on 2020-06-17), doi:10.1145/944705.944723.">Wad03</a>]</span> and <span id="id13">[<a class="reference internal" href="../zzreferences.html#id38" title="Tristan Crolard. A formulae-as-types interpretation of subtractive logic. Journal of Logic and Computation, 14(4):529–570, August 2004. URL: https://academic.oup.com/logcom/article/14/4/529/933555 (visited on 2020-06-18), doi:10.1093/logcom/14.4.529.">Cro04</a>]</span> but is flipped compared to Pi’s implication.</p>
<p>The jumbo connectives have the nice “unpacking” property that any combination of <span class="math notranslate nohighlight">\(\Sigma\)</span> connectives is equivalent to a single <span class="math notranslate nohighlight">\(\Sigma\)</span> connective, and likewise for <span class="math notranslate nohighlight">\(\Pi\)</span>.</p>
<p>The index <span class="math notranslate nohighlight">\(i\)</span> in Levy’s presentation is a tag drawn from a finite subset of a countable set of labels. But we can draw it from a subset of the universal set and hence get dependent types that depend on terms. In particular <span class="math notranslate nohighlight">\(\Pi\)</span> gives a dependent function type and <span class="math notranslate nohighlight">\(\Sigma\)</span> gives a dependent pair type.</p>
</section>
<section id="common-connectives">
<h2>Common connectives<a class="headerlink" href="#common-connectives" title="Permalink to this heading"></a></h2>
<p>Girard chose his notation mainly for convenience, in particular he avoided the common symbols of logical connectives so that he didn’t have to mark classical logical connectives vs. linear logic connectives. Since Stroscot only uses one logic style, we aren’t limited by such considerations.</p>
<p>Per the structure-preserving “plethoric” translation in <span id="id14">[<a class="reference internal" href="../zzreferences.html#id43" title="Roberto Di Cosmo. Introduction to Linear Logic. MPRI course notes, 2015. URL: https://www.dicosmo.org/CourseNotes/LinLog/IntroductionLinearLogic.pdf (visited on 2020-05-13).">DC15</a>]</span>, section 2.1, PDF page 30, the linear logic operators that correspond to intuitionistic logic’s conjunction/disjunction are the additive binary connectives, Girard’s <span class="math notranslate nohighlight">\(\with\)</span> and <span class="math notranslate nohighlight">\(\oplus\)</span>. Girard’s notation doesn’t express their duality at all so it has to be replaced. Per Wikipedia, the customary symbols are <span class="math notranslate nohighlight">\(\land / \lor\)</span>, programming uses <span class="math notranslate nohighlight">\(\with / \vert\)</span>, and there is also the electronics notation <span class="math notranslate nohighlight">\(\cdot / +\)</span>. ChatGPT says <span class="math notranslate nohighlight">\(\land / \lor\)</span> is 80% of usage so that’s what I went with.</p>
<p>For <span class="math notranslate nohighlight">\(\otimes\)</span>, it is a <a class="reference external" href="https://en.wikipedia.org/wiki/Monoidal_category">tensor/monoidal product</a> so the symbol is natural. Technically <span class="math notranslate nohighlight">\(\par\)</span> is a tensor product too, but the fact that tuples are typically positive data leads us to privilege one over the other. And it agrees with Girard, although I think he chose <span class="math notranslate nohighlight">\(\otimes\)</span> to go with <span class="math notranslate nohighlight">\(\oplus\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\par\)</span> is the dual of <span class="math notranslate nohighlight">\(\otimes\)</span> in the sense that <span class="math notranslate nohighlight">\(A \par B \equiv \neg (\neg A \otimes \neg B)\)</span>; unfortunately for deciding a notation, this seems to be its only useful property. Looking at the literature, <span class="math notranslate nohighlight">\(\oplus, \odot ,\Box,\sharp, \bullet\)</span> and <span class="math notranslate nohighlight">\(*\)</span> have meanings (direct sum/coproduct, Hadamard product/XNOR gate/symmetric product, modal operator, music, multiplication/logical and, convolution) dissimilar from the function of <span class="math notranslate nohighlight">\(\par\)</span>. <span class="math notranslate nohighlight">\(\mathbin{{\scriptstyle+}\mkern-0.522em\raise{-0.077em}{\diamond}},\mathbin{{\vee}\mkern-0.815em\raise{0.09em}{\bigcirc}}\)</span> don’t have Unicode symbols so are hard to use. In the end none of the operators seems particularly evocative. <span class="math notranslate nohighlight">\(\par\)</span> on the other hand redirects to linear logic on Wikipedia. So again we follow Girard.</p>
<p>Then we have the units for each of these connectives. I’m most confident in my choice of <span class="math notranslate nohighlight">\(\bot\)</span> as the unit for <span class="math notranslate nohighlight">\(\par\)</span>. It is usually used for denoting the absurdity derived from a contradiction, and indeed we can prove <span class="math notranslate nohighlight">\(A, \neg A \vdash \bot\)</span> and <span class="math notranslate nohighlight">\(\neg A \equiv A \to \bot\)</span> starting from the identity rule. It also agrees with Girard.</p>
<p>For the unit of the tensor product, it’s the standard unit type in programming, so <code class="docutils literal notranslate"><span class="pre">()</span></code> is a possibility, but in the math-style semantics the unit type is traditionally represented as <span class="math notranslate nohighlight">\(\mathbb{1}\)</span>, matching Girard. I went with an unstyled <span class="math notranslate nohighlight">\(1\)</span> for ease of input. Another choice would be the tee symbol <span class="math notranslate nohighlight">\(\top\)</span> to be the dual of <span class="math notranslate nohighlight">\(\bot\)</span>, but this conflicts with Girard’s usage of that symbol.</p>
<p>The units of <span class="math notranslate nohighlight">\(\lor / \land\)</span> are logical false / logical true. Looking at choices, <span class="math notranslate nohighlight">\(\bot / \top\)</span> is out because <span class="math notranslate nohighlight">\(\bot\)</span> is already taken. IMO it’s pretty confusing that in Girard’s notation <span class="math notranslate nohighlight">\(\bot\)</span> is not the dual of <span class="math notranslate nohighlight">\(\top\)</span>. <span class="math notranslate nohighlight">\(0/1\)</span> is pretty common, but conflicts with using <span class="math notranslate nohighlight">\(1\)</span> for the unit of <span class="math notranslate nohighlight">\(\otimes\)</span>. <span class="math notranslate nohighlight">\(T/F\)</span> is clear enough and doesn’t conflict, so that’s what I went with.</p>
<p>The negations and shifts show up in polarized / focused linear logic. We use the convention that an up shift raises a negative to positive (increases the value, hence points up). This is the original definition of <a class="reference external" href="https://www.seas.upenn.edu/~sweirich/types/archive/1991/msg00123.html">Girard’s</a>, <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">up</span> <span class="pre">N</span></code>. More recent papers such as <span id="id15">[<a class="reference internal" href="../zzreferences.html#id65" title="Jean-Yves Girard. Locus Solum: From the rules of logic to the logic of rules. Mathematical Structures in Computer Science, 11(3):301–506, June 2001. URL: https://www.cambridge.org/core/journals/mathematical-structures-in-computer-science/article/abs/locus-solum-from-the-rules-of-logic-to-the-logic-of-rules/6318E18EA633F9692D9CDBA9DE4438C9 (visited on 2022-03-27), doi:10.1017/S096012950100336X.">Gir01</a>]</span> and <span id="id16">[<a class="reference internal" href="../zzreferences.html#id169" title="Noam Zeilberger. The Logical Basis of Evaluation Order and Pattern-Matching. PhD thesis, Carnegie Mellon University, Pittsburgh, PA, April 2009. URL: https://software.imdea.org/~noam.zeilberger/thesis.pdf.">Zei09</a>]</span> seem to have lost this convention and use definitions of up-shift and down-shift reversed from ours. <span id="id17">[<a class="reference internal" href="../zzreferences.html#id115" title="Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Proceedings of the 11th ACM SIGPLAN Conference on Principles and Practice of Declarative Programming - PPDP '09, 129. Coimbra, Portugal, 2009. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1599410.1599427 (visited on 2021-03-26), doi:10.1145/1599410.1599427.">NM09</a>]</span> uses an alternate notation of delay operators <span class="math notranslate nohighlight">\(\delta^\pm(\cdot)\)</span> instead of shifts.</p>
<section id="programming-types">
<h3>Programming types<a class="headerlink" href="#programming-types" title="Permalink to this heading"></a></h3>
<p>With the programming types we see the justification for the jumbo types: they can represent abstract data types (ADTs). Even though we can encode <span class="math notranslate nohighlight">\(\Pi,\Sigma\)</span> using the common connectives:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\Pi [(\#t_1,[A_{1,1},A_{1,2},\ldots] \multimap [B_{1,1},B_{1,2},\ldots]),\ldots] \equiv (\smash{\stackrel{-}{\neg}} A_{1,1} \par \smash{\stackrel{-}{\neg}} A_{1,2} \par \ldots \par B_{1,1} \par \ldots) \land \ldots\\\Sigma [(\#t_1,[A_{1,1},A_{1,2},\ldots] \multimap [B_{1,1},B_{1,2},\ldots]),\ldots] \equiv (A_{1,1} \otimes A_{1,2} \otimes \ldots \otimes \smash{\stackrel{+}{\neg}} B_{1,1} \otimes \ldots) \lor \ldots\end{aligned}\end{align} \]</div>
<p>With the encoding, we lose the free-form tags and have to use strings like “RRRRRL”. This leads to unbalanced proof trees and a general lack of expressiveness of the proof language.</p>
<p>Lambdas have several conflicting definitions, so I have left them out. <span id="id18">[<a class="reference internal" href="../zzreferences.html#id103" title="John Maraist, Martin Odersky, David N. Turner, and Philip Wadler. Call-by-name, call-by-value, call-by-need, and the linear lambda calculus. Electronic Notes in Theoretical Computer Science, 1:370–392, January 1995. URL: http://www.sciencedirect.com/science/article/pii/S1571066104000222 (visited on 2020-08-23), doi:10.1016/S1571-0661(04)00022-2.">MOTW95</a>]</span> says call by name lambdas are <span class="math notranslate nohighlight">\(\Omega_N = \bang \Omega_N \to \Omega_N\)</span>, and call by value lambdas are <span class="math notranslate nohighlight">\(\Omega_V = \bang (\Omega_V \to \Omega_V)\)</span>. <span id="id19">[<a class="reference internal" href="../zzreferences.html#id60" title="Andrzej Filinski. Linear continuations. In Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL '92, 27–38. Albuquerque, New Mexico, USA, February 1992. Association for Computing Machinery. URL: https://doi.org/10.1145/143165.143174 (visited on 2020-06-19), doi:10.1145/143165.143174.">Fil92</a>]</span> agrees on call by name lambdas, but says call by value lambdas are <span class="math notranslate nohighlight">\(\Omega_V = \bang (\Omega_V \to \whim \Omega_V)\)</span>. A paper I forgot to cite says that these all expand to the same infinite type so are equivalent, making me wonder if linear logic actually represents reduction strategy at all.</p>
</section>
</section>
<section id="exponentials">
<h2>Exponentials<a class="headerlink" href="#exponentials" title="Permalink to this heading"></a></h2>
<p>There are two S4 modalities !/bang/”of course” (positive/affirmative) and the dual ?/whim/whimper/”why not” (negative).</p>
<section id="contraction">
<h3>Contraction<a class="headerlink" href="#contraction" title="Permalink to this heading"></a></h3>
<p>Instead of binary contraction we allow <span class="math notranslate nohighlight">\(n\)</span>-ary contraction for <span class="math notranslate nohighlight">\(n\geq 2\)</span>. This is equivalent to binary contraction but makes the proof trees a little more compact.</p>
</section>
<section id="subexponentials">
<h3>Subexponentials<a class="headerlink" href="#subexponentials" title="Permalink to this heading"></a></h3>
<p>Standard linear logic only contains bang and whim. But per <span id="id20">[<a class="reference internal" href="../zzreferences.html#id115" title="Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Proceedings of the 11th ACM SIGPLAN Conference on Principles and Practice of Declarative Programming - PPDP '09, 129. Coimbra, Portugal, 2009. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1599410.1599427 (visited on 2021-03-26), doi:10.1145/1599410.1599427.">NM09</a>]</span> these are not “canonical” - if we introduce two modalities <span class="math notranslate nohighlight">\(\bang_1, \bang_2\)</span> with distinct but identical rules, we cannot prove <span class="math notranslate nohighlight">\(\bang_1 A \equiv \bang_2 A\)</span>. So in keeping with the maximalist approach we present here the logic with subexponentials. The subexponentials function as annotations on exponentials, in that we can erase all the subexponential labels to a single standard exponential, and we can infer subexponential labels, computing the minimal subexponential structure necessary for the program to work. Subexponentials whose only operations are promotion/dereliction can be deleted from the program. <span id="id21">[]</span></p>
<p>For notation, there’s a lot of choices. I propose the following:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\bang^x_m,\whim^x_m\)</span>, <span class="math notranslate nohighlight">\(\bang_{(m,x)},\whim_{(m,x)}\)</span>, or more simply <span class="math notranslate nohighlight">\(\bang_S,\whim_S\)</span> (with <span class="math notranslate nohighlight">\(S = (m,x) \in (M,X)\)</span>) is the full notation for a subexponential, where <span class="math notranslate nohighlight">\(m\)</span> is in an index set <span class="math notranslate nohighlight">\(M\)</span> and <span class="math notranslate nohighlight">\(x \in X, X = P(\{c, w\})\)</span>.</p></li>
<li><p>The “well-known” subexponentials are <span class="math notranslate nohighlight">\(\bang^x,\whim^x\)</span>, where the index <span class="math notranslate nohighlight">\(m=\cdot \in M\)</span> is omitted. These allow easily omitting various operations.</p></li>
<li><p>The “full” subexponentials are <span class="math notranslate nohighlight">\(\bang_m,\whim_m\)</span>, and have <span class="math notranslate nohighlight">\(x=\{c,w,d\}\)</span> - this allows easily writing distinguished subexponentials.</p></li>
<li><p>Combining these conventions, <span class="math notranslate nohighlight">\(\bang,\whim\)</span> are the well-known full exponentials <span class="math notranslate nohighlight">\(m=\cdot,x=\{c,w,d\}\)</span>, as is standard.</p></li>
</ul>
<p>To use these we must define a relation <span class="math notranslate nohighlight">\(\leq\)</span> on <span class="math notranslate nohighlight">\((M,X)\)</span> such that <span class="math notranslate nohighlight">\(((M,X),\leq)\)</span> is a poset abd satisfies two more requirements:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\((m,x) \leq (n,y)\)</span> implies <span class="math notranslate nohighlight">\(x\subseteq y\)</span>.</p></li>
<li><p>if <span class="math notranslate nohighlight">\(x \subseteq y\)</span>, then <span class="math notranslate nohighlight">\((m,x) \leq (m,y)\)</span> for all <span class="math notranslate nohighlight">\(m\)</span>.</p></li>
</ol>
<p>Justifying these:</p>
<ul class="simple">
<li><p>Reflexivity ensures the identity theorem.</p></li>
<li><p>Transitivity and the first requirement ensure cut elimination.</p></li>
<li><p>Antisymmetry ensures that if <span class="math notranslate nohighlight">\(\bang^x_m A \equiv \bang^y_n A\)</span> then <span class="math notranslate nohighlight">\(m=n\)</span> and <span class="math notranslate nohighlight">\(x=y\)</span>, so that we do not have duplicate notation for a particular modality.</p></li>
<li><p>The second requirement is not strictly necessary, but makes the notation more coherent. If it is not satisfied we can simply split the index <span class="math notranslate nohighlight">\(m\)</span> into two or more indexes <span class="math notranslate nohighlight">\(m_i\)</span>.</p></li>
</ul>
<p>The rule for promotion requires that <span class="math notranslate nohighlight">\((z,o)\leq (x_i,m_i)\)</span> and <span class="math notranslate nohighlight">\((z,o)\leq (y_i,n_i)\)</span> for the elements of the context.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
  \rule{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i } \vdash A, \overrightarrow{\whim^{y_i}_{n_i}\Delta_i} }{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i } \vdash \bang^z_o A, \overrightarrow{\whim^{y_i}_{n_i}\Delta_i}}{\bang}
  &amp;
  \rule{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i } , A\vdash \overrightarrow{\whim^{y_i}_{n_i}\Delta_i} }{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i }, \whim^z_o A \vdash \overrightarrow{\whim^{y_i}_{n_i}\Delta_i}}{\whim}

\end{array}</div><p>Dereliction must be allowed, otherwise the identity rule does not hold.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
  \rule{\sk{\Gamma}, A \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^x_m A \vdash \sk{\Delta}}{\bang d}
&amp; \rule{\sk{\Gamma} \vdash A, \sk{\Delta} }{\sk{\Gamma} \vdash \whim^x_m A, \sk{\Delta}}{\whim d}
\end{array}</div><p>Weakening requires <span class="math notranslate nohighlight">\(w \in x\)</span>.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
    \rule{\sk{\Gamma} \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^x_m A \vdash \sk{\Delta}}{\bang w}
  &amp; \rule{\sk{\Gamma} \vdash \sk{\Delta} }{\sk{\Gamma} \vdash \whim^x_m A, \sk{\Delta}}{\whim w}
  \end{array}</div><p>Contraction requires <span class="math notranslate nohighlight">\(c \in x\)</span></p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
    \rule{\sk{\Gamma}, \overrightarrow{\bang^x_m A, \bang^x_m A, \cdots} \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^x_m A \vdash \sk{\Delta}}{\bang c_n}
  &amp; \rule{\sk{\Gamma} \vdash \overrightarrow{\whim^x_m A, \whim^x_m A, \cdots}, \sk{\Delta} }{\sk{\Gamma} \vdash \whim^x_m A, \sk{\Delta}}{\whim c_n}
\end{array}</div><p>We also allow quantification over subexponentials, as in <span id="id22">[<a class="reference internal" href="../zzreferences.html#id115" title="Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Proceedings of the 11th ACM SIGPLAN Conference on Principles and Practice of Declarative Programming - PPDP '09, 129. Coimbra, Portugal, 2009. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1599410.1599427 (visited on 2021-03-26), doi:10.1145/1599410.1599427.">NM09</a>]</span>.</p>
</section>
<section id="modalities">
<h3>Modalities<a class="headerlink" href="#modalities" title="Permalink to this heading"></a></h3>
<p>Because of the equivalences <span class="math notranslate nohighlight">\(\bang \bang A \equiv \bang A, \whim\whim A \equiv \whim A, \bang \whim \bang \whim A \equiv \bang \whim A, \whim \bang \whim \bang A \equiv \whim \bang A\)</span>, there are only 7 modalities created from combining exponentials. They have the relationships as follows, where an arrow <span class="math notranslate nohighlight">\(A \to B\)</span> means <span class="math notranslate nohighlight">\(\vdash A \to B\)</span> is provable:  <span id="id23">[<a class="reference internal" href="../zzreferences.html#id33" title="Marcelo Coniglio and Francisco Miraglia. Equality in linear logic. Logique et Analyse, 39(153/154):113–151, January 2002. URL: https://www.researchgate.net/profile/Marcelo-Coniglio/publication/2387274_Equality_In_Linear_Logic/links/0deec5165a6babbd8a000000/Equality-In-Linear-Logic.pdf.">CM02</a>]</span></p>
<div class="graphviz"><object data="../_images/graphviz-8434b84e3ec932c372f6234328dc7cbfc0b0023b.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph G {
  rankdir=LR
  &quot;!A&quot; -&gt; &quot;A&quot;
  &quot;A&quot; -&gt;&quot;?A&quot;
  &quot;!A&quot; -&gt; &quot;!?!A&quot; -&gt; {&quot;!?A&quot;,&quot;?!A&quot;} -&gt; &quot;?!?A&quot; -&gt; &quot;?A&quot;
  subgraph C {
    rank=same
    &quot;A&quot;,&quot;!?A&quot;,&quot;?!A&quot;
  }
}</p></object></div>
<p>More generally with subexponentials:</p>
<ul class="simple">
<li><p>For <span class="math notranslate nohighlight">\((x,m)\geq(y,n)\)</span>, <span class="math notranslate nohighlight">\(\bang^x_m \bang^y_n A \equiv \bang^x_m A \equiv \bang^y_n \bang^x_m A\)</span>, and identically with <span class="math notranslate nohighlight">\(\whim\)</span>.</p></li>
<li><p>For <span class="math notranslate nohighlight">\((x,n)\leq(z,p)\)</span> and <span class="math notranslate nohighlight">\((y,o)\leq(w,m)\)</span> we can prove <span class="math notranslate nohighlight">\(\bang^w_m \whim^x_n \bang^y_o \whim^z_p A \equiv \bang^w_m \whim^z_p A\)</span>.</p></li>
</ul>
<p>With distinguished subexponentials the possible modalities become infinite, for example alternating patterns like <span class="math notranslate nohighlight">\(\bang_1 \bang_2 \bang_1 \bang_2\)</span> cannot be simplified unless there is a relation in the poset between 1 and 2. But of course if we erase the index labels then <span class="math notranslate nohighlight">\(\bang \bang \bang \bang A \equiv \bang A\)</span>. Due to this, I think keeping the “well-known” subexponentials in the IR is fine and informative, but distinguished subexponentials should be avoided except during a pass that reduces exponential strength and eliminates unnecessary exponentials.</p>
</section>
</section>
<section id="classification-of-sequents">
<h2>Classification of sequents<a class="headerlink" href="#classification-of-sequents" title="Permalink to this heading"></a></h2>
<p><span id="id24">[<a class="reference internal" href="../zzreferences.html#id48" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span> splits the space of sequents into four sets: commands <span class="math notranslate nohighlight">\(\Gamma \vdash \Delta\)</span>, terms <span class="math notranslate nohighlight">\(\Gamma \vdash \tau\)</span>, continuations <span class="math notranslate nohighlight">\(\Gamma, \tau \vdash \Delta\)</span>, and bindings <span class="math notranslate nohighlight">\(\Gamma, \Delta' \vdash \Gamma', \Delta\)</span> (noting that <span class="math notranslate nohighlight">\(\mid\)</span> is synonymous with “,”). These clearly overlap, and the restrictions on what can be used where seem arbitrary.</p>
<p>It seems easier to follow <span id="id25">[<a class="reference internal" href="../zzreferences.html#id100" title="Yves Lafont. Linear logic pages. URL: http://iml.univ-mrs.fr/~lafont/pub/llpages.pdf.">Laf</a>]</span> and classify proofs by properties of their sequent:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\vdash A\)</span> is a proof of <span class="math notranslate nohighlight">\(A\)</span>. <span class="math notranslate nohighlight">\(A\)</span> is said to be a theorem or tautology. The theorem <span class="math notranslate nohighlight">\(\vdash A \leftrightarrow B\)</span> shows equivalence <span class="math notranslate nohighlight">\(A\equiv B\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(A \vdash\)</span> or <span class="math notranslate nohighlight">\(A \vdash \bot\)</span> is a refutation of <span class="math notranslate nohighlight">\(A\)</span>. <span class="math notranslate nohighlight">\(A\)</span> is said to be an absurdity.</p></li>
<li><p><span class="math notranslate nohighlight">\(\Gamma \vdash\)</span> or <span class="math notranslate nohighlight">\(\Gamma \vdash \bot\)</span> derives a contradiction from <span class="math notranslate nohighlight">\(\Gamma\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(x, \ldots, z \vdash A\)</span>, where <span class="math notranslate nohighlight">\(x,\ldots,z\)</span> are free variables representing propositions (most likely appearing in <span class="math notranslate nohighlight">\(A`\)</span>), is a proof pattern of <span class="math notranslate nohighlight">\(A\)</span>. Similarly :math:<a href="#id26"><span class="problematic" id="id27">`</span></a>x, ldots, z, A vdash ` is a refutation pattern.</p></li>
<li><p><span class="math notranslate nohighlight">\(\Gamma \vdash A\)</span> is a term with result type <span class="math notranslate nohighlight">\(A\)</span></p></li>
</ul>
<p><span class="math notranslate nohighlight">\(\Sigma_R\)</span> constructs a proof from a collection of proofs and refutations, while <span class="math notranslate nohighlight">\(\Pi_L\)</span> constructs a refutation from a collection of proofs and refutations.</p>
</section>
<section id="polarized-logic">
<h2>Polarized logic<a class="headerlink" href="#polarized-logic" title="Permalink to this heading"></a></h2>
<p>Following <span id="id28">[<a class="reference internal" href="../zzreferences.html#id100" title="Yves Lafont. Linear logic pages. URL: http://iml.univ-mrs.fr/~lafont/pub/llpages.pdf.">Laf</a>]</span> we say a proposition <span class="math notranslate nohighlight">\(A\)</span> is positive if <span class="math notranslate nohighlight">\(A \equiv \bang A\)</span>. Of course the direction <span class="math notranslate nohighlight">\(\bang A \vdash A\)</span> is trivial by dereliction.</p>
<p>Going through the rules on <span class="math notranslate nohighlight">\(A \vdash \bang A\)</span>:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(F,1\)</span> are positive</p></li>
<li><p><span class="math notranslate nohighlight">\(\bang A\)</span> is positive for any <span class="math notranslate nohighlight">\(A\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(A \lor B,A \otimes B\)</span> are positive if <span class="math notranslate nohighlight">\(A,B\)</span> are positive</p></li>
<li><p><span class="math notranslate nohighlight">\(T,\bot\)</span> are not positive</p></li>
<li><p><span class="math notranslate nohighlight">\(A \land B\)</span> is positive if <span class="math notranslate nohighlight">\(A\)</span> is positive and <span class="math notranslate nohighlight">\(\bang A \vdash B\)</span>, e.g. if <span class="math notranslate nohighlight">\(B\)</span> is a theorem</p></li>
<li><p><span class="math notranslate nohighlight">\(A \par \bot\)</span> is positive if <span class="math notranslate nohighlight">\(A\)</span> is positive. More generally, <span class="math notranslate nohighlight">\(A \par B\)</span> is positive if <span class="math notranslate nohighlight">\(A\)</span> is positive, <span class="math notranslate nohighlight">\(B \vdash \bot\)</span> (i.e., <span class="math notranslate nohighlight">\(B\)</span> is a refutation), and <span class="math notranslate nohighlight">\(A\vdash A,B\)</span>.</p></li>
</ul>
<p>Dually we say <span class="math notranslate nohighlight">\(A\)</span> is negative if <span class="math notranslate nohighlight">\(A \equiv \whim A\)</span>. <span class="math notranslate nohighlight">\(A\)</span> is positive iff <span class="math notranslate nohighlight">\(\neg A\)</span> is negative, and vice-versa. In general, <span class="math notranslate nohighlight">\(\Sigma [ \vec A_i - \vec B_i]\)</span> is positive and <span class="math notranslate nohighlight">\(\Pi [ \vec A_i \multimap \vec B_i ]\)</span> is negative if <span class="math notranslate nohighlight">\(A_i\)</span> are all positive and <span class="math notranslate nohighlight">\(B_i\)</span> are all negative.</p>
<p>We say that a proposition is polarized if it is either positive or negative. Unpolarized propositions such as <span class="math notranslate nohighlight">\(T \otimes \bot\)</span> exist, although every tautology is positive and every absurdity is negative. By strong consistency, no proposition can be both negative and positive.</p>
<p>Girard defined a syntactic rather than semantic notion of polarity, based on classifying connectives. By his definitions, <span class="math notranslate nohighlight">\(A \par \bot\)</span> and <span class="math notranslate nohighlight">\(A\otimes 1\)</span> remove polarity from a positive resp. negative proposition. But the semantic definition seems more useful.</p>
<p>Lafont also defines regular types <span class="math notranslate nohighlight">\(A \equiv \whim \bang A\)</span>, but considering that there are 6 non-trivial modalities including a dual modality <span class="math notranslate nohighlight">\(\bang \whim\)</span> this seems too limited. There is not a clear justification for this definition; maybe some paper in the literature explains it, but a simple search “regular linear logic” didn’t uncover it.</p>
<section id="cartesian-types">
<h3>Cartesian types<a class="headerlink" href="#cartesian-types" title="Permalink to this heading"></a></h3>
<p><span id="id29">[<a class="reference internal" href="../zzreferences.html#id60" title="Andrzej Filinski. Linear continuations. In Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL '92, 27–38. Albuquerque, New Mexico, USA, February 1992. Association for Computing Machinery. URL: https://doi.org/10.1145/143165.143174 (visited on 2020-06-19), doi:10.1145/143165.143174.">Fil92</a>]</span> observes in section 3.1 that, even in the absence of exponentials, we can actually copy and discard data of certain “cartesian” types in a linear fashion. This is quite similar to positivity. However, positivity is not necessary or sufficient to be cartesian - <span class="math notranslate nohighlight">\(BB = \text{Bool} \to \text{Bool}\)</span> is positive, but the proof does not actually make a copy of the function, because it can only evaluate the function at one value. Also, as exponentials are non-canonical, per <span id="id30">[<a class="reference internal" href="../zzreferences.html#id100" title="Yves Lafont. Linear logic pages. URL: http://iml.univ-mrs.fr/~lafont/pub/llpages.pdf.">Laf</a>]</span> a formula <span class="math notranslate nohighlight">\(C = \alpha \otimes \bang(\alpha \ to \alpha \otimes \alpha) \otimes \bang(\alpha \to 1)\)</span> can be copied and discarded but does not satisfy <span class="math notranslate nohighlight">\(C \vdash \bang \alpha\)</span> hence is not positive.</p>
<p>Formally, cartesian types are defined as commutative co-monoids. In terms of sequent proofs, this means we have a
proposition <span class="math notranslate nohighlight">\(A\)</span>, with theorems <span class="math notranslate nohighlight">\(w : A \vdash 1\)</span> and <span class="math notranslate nohighlight">\(c : A \vdash A \otimes A\)</span>. There are then 3 laws that these theorems must satisfy, equivalences under cut elimination:</p>
<ul class="simple">
<li><p>unit:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\rule{c : A \vdash A \otimes A \quad (w \otimes \text{id}) : A \otimes A \vdash A \otimes 1}{A \vdash A \otimes 1}{\text{cut}} = \rule{\text{id} : A \vdash A \quad \vdash 1}{A \vdash A\otimes 1}{\otimes_R}\]</div>
<ul class="simple">
<li><p>commutativity:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\rule{c : A \vdash A \otimes A \quad swap : A_1 \otimes A_2 \vdash A_2 \otimes A_1}{A \vdash A \otimes A}{\text{cut}} = \text{c} : A \vdash A \otimes A\]</div>
<ul class="simple">
<li><p>associativity:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\rule{c : A \vdash A \otimes A \quad (id \otimes c) : A \otimes A \vdash A \otimes (A \otimes A) \quad A\otimes (B \otimes C) \vdash (A \otimes B) \otimes C}{A \vdash (A\otimes A) \otimes A}{\text{cut x2}} = \rule{c : A \vdash A \otimes A \quad (c \otimes id) : A \otimes A \vdash (A \otimes A) \otimes A}{A \vdash (A\otimes A) \otimes A}{\text{cut}}\]</div>
<p>In addition, Filinski adds uniqueness: <span class="math notranslate nohighlight">\(w : A \vdash 1\)</span> and <span class="math notranslate nohighlight">\(c : A \vdash A \otimes A\)</span> must each have only one unique cut-free proof.</p>
<p>We can similarly define co-cartesian types <span class="math notranslate nohighlight">\(A\)</span> that can be copied and discarded on the right with theorems <span class="math notranslate nohighlight">\(w : 1 \vdash A\)</span> and <span class="math notranslate nohighlight">\(c : A \otimes A \vdash A\)</span> and are a commutative monoid.</p>
<p>I’m not sure if there is a simple description of all cartesian types, but of course <span class="math notranslate nohighlight">\(\bang/\whim\)</span> are cartesian/co-cartesian, and <span class="math notranslate nohighlight">\(Sigma [ \vec A_i - \vec B_i]\)</span> and and <span class="math notranslate nohighlight">\(\Pi [ \vec A_i \multimap \vec B_i ]\)</span> are cartesian/co-cartesian if <span class="math notranslate nohighlight">\(A_i\)</span> are all cartesian and <span class="math notranslate nohighlight">\(B_i\)</span> are all co-cartesian. So ADTs in general - booleans, integers, lists, trees - are all cartesian. Our earlier example <span class="math notranslate nohighlight">\(C\)</span> is in general not cartesian because, although copy and discard can be proven, it uses the included functions and those won’t necessarily satisfy the laws.</p>
<p>Filinski says in 3.2 that all cartesian types are positive. Hence, for cartesian / co-cartesian types, because the proof of polarity is natural, we can be generous with exponentials and use them whenever we have such a type, without fear of changing the program semantics. This allows a more faithful representation of copy operations in the proof structure, avoiding implicit copying such as <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">case</span> <span class="pre">x</span> <span class="pre">of</span> <span class="pre">True</span> <span class="pre">-&gt;</span> <span class="pre">(True,True);</span> <span class="pre">False</span> <span class="pre">-&gt;</span> <span class="pre">(False,False)</span></code>.</p>
<p>But, if we start with a plethoric translation to begin with and only remove unnecessary exponentials, probably cartesian types don’t matter, because all the copy operations are explicitly represented using exponentials to begin with.</p>
</section>
<section id="tangent-reversible-computing">
<h3>Tangent: Reversible computing<a class="headerlink" href="#tangent-reversible-computing" title="Permalink to this heading"></a></h3>
<p>Another approach to duplication is “superstructural reversible logic” <span id="id31">[<a class="reference internal" href="../zzreferences.html#id148" title="Z A Sparks and Amr Sabry. Superstructural Reversible Logic. In 3rd International Workshop on Linearity. 2014. URL: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.720.5692&amp;rep=rep1&amp;type=pdf.">SS14</a>]</span>. In their calculus, duplicating any type (cartesian or not) is impossible, without using non-reversible rules. The non-reversible structural rules could be restricted to a modality similarly to how linear logic restricts contraction/weakening. But in Theseus <span id="id32">[<a class="reference internal" href="../zzreferences.html#id81" title="Roshan P James and Amr Sabry. Theseus: A High Level Language for Reversible Computing. In Work-in-Progress Report at Conference on Reversible Computation, 12. 2014. URL: https://legacy.cs.indiana.edu/~sabry/papers/theseus.pdf.">JS14</a>]</span> and even in the latest publication <span id="id33">[<a class="reference internal" href="../zzreferences.html#id29" title="Chao-Hong Chen and Amr Sabry. A computational interpretation of compact closed categories: reversible programming with negative and fractional types. Proceedings of the ACM on Programming Languages, 5(POPL):1–29, January 2021. URL: https://dl.acm.org/doi/10.1145/3434290 (visited on 2021-08-04), doi:10.1145/3434290.">CS21</a>]</span> they use standard higher-order functions to do most of the programming. So really a reversible program is a data type <code class="docutils literal notranslate"><span class="pre">Rev</span></code>, similar to how a normal program is a data type <code class="docutils literal notranslate"><span class="pre">Task</span></code>. The difference is that <code class="docutils literal notranslate"><span class="pre">Rev</span></code> contains isomorphisms rather than continuations.</p>
<p>In terms of support, I don’t think there’s much needed at present. With the DSL support Stroscot should be able to write isomorphisms similar to Theseus, and run them forwards/backwards like the <a class="reference external" href="https://github.com/DreamLinuxer/popl21-artifact">Agda code</a>. Once there is hardware/an ISA/an OS to target it should be straightforward to extend this basic support to a compiler.</p>
</section>
</section>
<section id="structural-rules">
<h2>Structural rules<a class="headerlink" href="#structural-rules" title="Permalink to this heading"></a></h2>
<p>As is usual for linear logic there are no structural rules for weakening or contraction (they are restricted to the exponentials above). And in Core we use a graph representation that internalizes the exchange rule, so there is not really an exchange rule either.</p>
<p>The cut rule is technically a theorem; we can prove that any proof using cut can be reformulated to be cut-free. But the expansion may result in exponentially more rule applications.</p>
<p>Similarly the identity rule is a theorem for propositional logic: we can produce a proof tree for <span class="math notranslate nohighlight">\(A \vdash A\)</span> for any finite proposition <span class="math notranslate nohighlight">\(A\)</span> via expansion of all the cases. Using the identity rule speeds up reduction because it skips iterating through the structure, and it also allows manipulating (prefixes of) <a class="reference internal" href="../Reference/Logic.html#infinite"><span class="std std-ref">infinite</span></a> trees.</p>
</section>
<section id="quantifiers">
<h2>Quantifiers<a class="headerlink" href="#quantifiers" title="Permalink to this heading"></a></h2>
<p>To move from propositional to first-order logic we must extend the identity rule to allow terms. Some presentations call the identity rule “ax”, for identity axiom, but in general the identity rule is a theorem so this seems foolish. Instead we call it “id”.</p>
<p>We explicitly list the identity theorem where it is needed:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://ncatlab.org/nlab/show/sequent+calculus">nLab</a> defines a substitution rule/theorem. There is a theorem that substitution rules can be eliminated from the proof tree, proven by taking the proof tree for <span class="math notranslate nohighlight">\(\Gamma \vdash \Delta\)</span> and replacing all its identities <span class="math notranslate nohighlight">\(x \vdash x\)</span> with identities <span class="math notranslate nohighlight">\(t \vdash t\)</span>. This requires <span class="math notranslate nohighlight">\(t \vdash t\)</span> to hold, hence we include it. If the identity rule is not used with <code class="docutils literal notranslate"><span class="pre">x</span></code> in the proof tree, then the identity rule is not needed for the substitution, but such a situation is unlikely.</p></li>
<li><p>Quantifiers also require the identity rule, because cut elimination applies substitution of <code class="docutils literal notranslate"><span class="pre">x</span></code> for <code class="docutils literal notranslate"><span class="pre">t</span></code> in the proof tree where <code class="docutils literal notranslate"><span class="pre">x</span></code> is a variable.</p></li>
</ul>
<p>Cut elimination for quantifiers is sound because the number of quantifiers in the sequent decreases.</p>
</section>
<section id="logic-translations">
<h2>Logic translations<a class="headerlink" href="#logic-translations" title="Permalink to this heading"></a></h2>
<p>First we must define classical and intuitionistic logic. To define classical logic we simply add standard structural weakening and contraction rules to our linear logic. Then <span class="math notranslate nohighlight">\(A\otimes B \equiv A \land B\)</span>, <span class="math notranslate nohighlight">\(A\par B \equiv A \lor B\)</span>, and we obtain the usual classical logic with modalities <span id="id34">[<a class="reference internal" href="../zzreferences.html#id100" title="Yves Lafont. Linear logic pages. URL: http://iml.univ-mrs.fr/~lafont/pub/llpages.pdf.">Laf</a>]</span>; all the connectives decompose into or are equivalent to the standard ones. To define intuitionistic logic we take classical logic and restrict the right hand side of all sequents to have at most one consequent; various pi/sigma connectives cannot be used as they would create multiple consequents, and similarly right contraction cannot be used. We allow disallow right weakening to make the translation easier.</p>
<p>The translation from intuitionistic logic to linear logic decorates every proposition and subproposition with !. <span id="id35">[<a class="reference internal" href="../zzreferences.html#id43" title="Roberto Di Cosmo. Introduction to Linear Logic. MPRI course notes, 2015. URL: https://www.dicosmo.org/CourseNotes/LinLog/IntroductionLinearLogic.pdf (visited on 2020-05-13).">DC15</a>]</span></p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\left[\prod \limits_{i} \left(\overrightarrow{A_i} \multimap \overrightarrow{B_i}\right)\right]_I &amp;= \prod \limits_{i} \left(\overrightarrow{\bang\left[A_i\right]_I} \multimap \overrightarrow{\bang\left[B_i\right]_I}\right)\\\left[\sum \limits_{i} \left(\overrightarrow{A_i} - \overrightarrow{B_i}\right)\right]_I &amp;= \sum \limits_{i} \left(\overrightarrow{\bang\left[A_i\right]_I} - \overrightarrow{\bang\left[B_i\right]_I}\right)\end{aligned}\end{align} \]</div>
<p>We can translate classical logic into intuitionistic logic by decorating every proposition and subproposition with <span class="math notranslate nohighlight">\(\neg\neg\)</span> and moving the right to the left with another negation, i.e. <span class="math notranslate nohighlight">\(\Gamma \vdash \Delta \Rightarrow \Gamma', \neg \Delta' \vdash\)</span>. Thus the translation of classical logic into linear logic decorates like <span class="math notranslate nohighlight">\(\neg \bang (\neg \bang A) \equiv \whim \bang A\)</span>.</p>
<p>These two decoration translations preserve proof structure, in the sense that every intuitionistic/classical proof tree can be converted to a linear logic proof tree, and the reverse as well if the linear logic proof tree’s sequent is the result of the proposition translation. There are other “uniform” translations, like in <span id="id36">[]</span>, but they aren’t as simple.</p>
</section>
<section id="definitions">
<h2>Definitions<a class="headerlink" href="#definitions" title="Permalink to this heading"></a></h2>
<p>I didn’t find any relevant papers on defining new notation for expressions in the sequent calculus. So we have to prove consistency ourselves. But I think the cut elimination theorem poses no problem, the key and commutative cases are trivial.</p>
<p>The identity rule fails if the notation expands via an infinite chain of definitions <span class="math notranslate nohighlight">\(A_1 = \ldots A_2 \ldots, A_2 = \ldots A_3 \ldots = \ldots\)</span>. For example for Russell’s paradox and the related <span class="math notranslate nohighlight">\(\{x : x \in x\}  \in \{x : x \in x\} = \{x : x \in x\}  \in \{x : x \in x\} = \ldots\)</span>. Hence we exclude such circular definitions by requiring the identity theorem to complete for all notations.</p>
<p>For the substitution theorem goes through with the same restriction on notation. The proof works by replacing variable identities <span class="math notranslate nohighlight">\(x \vdash x\)</span> with more complex identities <span class="math notranslate nohighlight">\(A \vdash A\)</span>.</p>
<p>Non-circularity is a pretty loose restriction. If we know a definition is size-decreasing, we can induct as usual to prove the identity theorem: use the basic identity theorem on non-definition subtrees, use the definition rule on both sides for each definition, and continue switching between the two until it’s built up. Hence we only have to be careful for definitions like sets that can increase size when expanded.</p>
</section>
<section id="set-theory">
<h2>Set theory<a class="headerlink" href="#set-theory" title="Permalink to this heading"></a></h2>
<p>The naive set theory definition comes from <span id="id37">[<a class="reference internal" href="../zzreferences.html#id140" title="Masaru Shirahata. Linear Set Theory. PhD thesis, Stanford University, February 1994. URL: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.29.7077&amp;rep=rep1&amp;type=pdf.">Shi94</a>]</span> (page 10). The rest of the definitions are similar to the ones in <span id="id38">[<a class="reference internal" href="../zzreferences.html#id143" title="Michael Shulman. Linear logic for constructive mathematics. arXiv:1805.07518 [math], May 2018. Comment: 39 pages. URL: http://arxiv.org/abs/1805.07518 (visited on 2021-03-04), arXiv:1805.07518.">Shu18</a>]</span> except <span class="math notranslate nohighlight">\(\in\)</span> is not affirmative.</p>
<section id="paradoxes">
<span id="id39"></span><h3>Paradoxes<a class="headerlink" href="#paradoxes" title="Permalink to this heading"></a></h3>
<p>It seems from playing with some examples that forbidding circular definitions is sufficient to prevent Russell’s paradox and Curry’s paradox. For example with <span class="math notranslate nohighlight">\(R = \{x\mid \whim \neg(x \in x)\}\)</span>, <span class="math notranslate nohighlight">\(\{x\mid F \} \in R\)</span> is defined (and provable) but <span class="math notranslate nohighlight">\(R \in R\)</span> is circular hence not defined. So we cannot write the premise of Russell’s paradox. We could try to work around this with a proposition like <span class="math notranslate nohighlight">\(t\in R \land t= R\)</span>. This is not circular, but it is not sufficient to derive a paradox, as in order to apply contraction we have to use a substitution that produces <span class="math notranslate nohighlight">\(R \in R\)</span>. Curry’s paradox <span class="math notranslate nohighlight">\(X=\{x\mid x\in x \to Y\}\)</span> similarly contains <span class="math notranslate nohighlight">\(x\in x\)</span> and hence the notation <span class="math notranslate nohighlight">\(X \in X\)</span> is circular and therefore forbidden as well.</p>
<p>More formally, suppose the logic is inconsistent, i.e. there is a derivation <span class="math notranslate nohighlight">\(\vdash \bot\)</span>. This must be derived from the empty sequent. Then what does cut elimination do? Either it completes, in which case we get a contradiction because no rule derives the empty sequent, or there’s some infinite chain of cut elimination. I claim the infinite chain only happens if there is a circular definition involved and the identity or substitution rules are on the sides. Hence, forbidding circular definitions in the identity and cut rules solves the issue.</p>
<p>The question of whether a given set comprehension is defined is undecidable, as we can encode the lambda calculus and hence the halting problem - the beta rule <span class="math notranslate nohighlight">\((\lambda x. A) t\)</span> does the same substitution as <span class="math notranslate nohighlight">\(t\in\{x\mid A\}\)</span>. We can approximate definedness with a termination checking algorithm, type system, or syntactic check:</p>
<ul class="simple">
<li><p>Strict comprehension, i.e. the bound variable can only appear once in the formula <span id="id40">[<a class="reference internal" href="../zzreferences.html#id141" title="Masaru Shirahata. Linear set theory with strict comprehension. In Proceedings of the Sixth Asian Logic Conference, 223–245. Beijing, China, April 1998. WORLD SCIENTIFIC / S'PORE UNIV PRESS (PTE) LTD. URL: http://www.worldscientific.com/doi/abs/10.1142/9789812812940_0013 (visited on 2021-03-06), doi:10.1142/9789812812940_0013.">Shi98</a>]</span> Very restrictive.</p></li>
<li><p>New Foundations’s stratified formulas <span id="id41">[<a class="reference internal" href="../zzreferences.html#id62" title="Thomas Forster. Quine’s New Foundations. In Edward N. Zalta, editor, The Stanford Encyclopedia of Philosophy. Metaphysics Research Lab, Stanford University, summer 2019 edition, 2019. URL: https://plato.stanford.edu/archives/sum2019/entries/quine-nf/ (visited on 2021-03-04).">For19</a>]</span> <span id="id42">[<a class="reference internal" href="../zzreferences.html#id76" title="M. Randall Holmes. Elementary Set Theory with a Universal Set. Bruylant-Academia, 1998. ISBN 978-2-87209-488-2. URL: https://randall-holmes.github.io/head.pdf.">Hol98</a>]</span> NFU + Infinity + Choice is known to be consistent with the theory of types with the Axiom of Infinity, and is a subtheory of ZFC + “there is an n-Mahlo cardinal for each concrete natural number n”. But the stratification is restrictive, e.g. we cannot define a set of sets that contain themselves even though this definition is well-founded.</p></li>
<li><p>Hindley-Milner type inference (since the simply typed lambda calculus terminates). Seems like a reasonable check.</p></li>
<li><p>A size-checking algorithm like in <span id="id43">[<a class="reference internal" href="../zzreferences.html#id82" title="Neil D. Jones and Nina Bohr. Call-by-value termination in the untyped lambda-calculus. Logical Methods in Computer Science, 4(1):3, March 2008. URL: http://arxiv.org/abs/0801.0882 (visited on 2021-03-06), arXiv:0801.0882, doi:10.2168/LMCS-4(1:3)2008.">JB08</a>]</span>. Seems to have unpredictable behavior, but may solve some things HM can’t.</p></li>
<li><p>Brute-force expansion. Also somewhat unpredictable.</p></li>
<li><p>Intersection type system. Typeable iff terminating, but undecidable in general and tricky to approximate. But should be strictly better than HM.</p></li>
</ul>
<p>There is also <span id="id44">[<a class="reference internal" href="../zzreferences.html#id139" title="Masaru Shirahata. A linear conservative extension of Zermelo-Fraenkel set theory. Studia Logica, 56(3):361–392, May 1996. URL: http://link.springer.com/10.1007/BF00372772 (visited on 2021-03-06), doi:10.1007/BF00372772.">Shi96</a>]</span> which allows sets built from ZF’s axioms.</p>
</section>
<section id="equality">
<h3>Equality<a class="headerlink" href="#equality" title="Permalink to this heading"></a></h3>
<p>The axioms of reflexivity, substitution, etc. can take a variety of modalities as in <span id="id45">[<a class="reference internal" href="../zzreferences.html#id33" title="Marcelo Coniglio and Francisco Miraglia. Equality in linear logic. Logique et Analyse, 39(153/154):113–151, January 2002. URL: https://www.researchgate.net/profile/Marcelo-Coniglio/publication/2387274_Equality_In_Linear_Logic/links/0deec5165a6babbd8a000000/Equality-In-Linear-Logic.pdf.">CM02</a>]</span>, some of them corresponding with intuitionistic and classical notions of equality. For sets we use linear weak extensional equality. Alternatively we could use intuitionistic equality <span class="math notranslate nohighlight">\(A\overset{!}{=}B \defeq !(A=B)\)</span>, then substitution is <span class="math notranslate nohighlight">\(A\overset{!}{=}B, \phi \vdash \phi[A/B]\)</span>. But the linear equality seems more useful.</p>
<p>Proof of the substitution property: For <span class="math notranslate nohighlight">\(\Pi\)</span> we use the right rule to split into cases for each tag, then we use contraction/weakening on <span class="math notranslate nohighlight">\(\bang(A=B)\)</span> to match the number of A’s/B’s in the case, then the left rule to split into each A and B, giving each branch a copy of the hypothesis. <span class="math notranslate nohighlight">\(\Sigma\)</span> is similar but with the left first. For exponentials, quantifiers, and set comprehension we simply do left/right in the correct order. Then at the end we use the hypothesis to change <span class="math notranslate nohighlight">\(A[x/a]\)</span> on the left or right to <span class="math notranslate nohighlight">\(B[x/b]\)</span>, or else weakening to remove the hypothesis followed by the identity.</p>
</section>
</section>
<section id="recursion-and-infinite-structures">
<h2>Recursion and infinite structures<a class="headerlink" href="#recursion-and-infinite-structures" title="Permalink to this heading"></a></h2>
<p>There is the question of representing recursion, as standard derivations only allow finite (well-founded) proofs.Sequent Core <span id="id46">[<a class="reference internal" href="../zzreferences.html#id48" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span> introduces Let/MultiCut and Rec, which “serve two purposes: to give a shared name to the result of some computation, and to express (mutual) recursion.”</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cc}
  \rule
    {\Gamma, \Theta \vdash \Delta, \Lambda \quad \Gamma', \Lambda \vdash \Theta, \Delta' }
    {\Gamma, \Gamma' \vdash \Delta, \Delta' }{\text{multicut}}
  &amp;
  \rule
    { \overrightarrow{\Gamma, \vec \Lambda, \Theta_i \vdash \Lambda_i, \vec \Theta, \Delta }}
    {\Gamma, \overrightarrow{\Theta_i} \vdash \overrightarrow{\Lambda_i}, \Delta }{\text{rec}}
\end{array}\]</div>
<p>But these rules are illogical and inadmissible. For example with Let/MultiCut, one can conclude from <span class="math notranslate nohighlight">\(A,B \vdash B,C\)</span> and <span class="math notranslate nohighlight">\(A,B \vdash B,C\)</span> (provable via Ax) that <span class="math notranslate nohighlight">\(A \vdash C\)</span>. Similarly Rec concludes from <span class="math notranslate nohighlight">\(A,B,C,D \vdash B, D, E, F\)</span> and <span class="math notranslate nohighlight">\(A,B,C,E \vdash C, D, E, F\)</span> (again provable via Ax) that <span class="math notranslate nohighlight">\(A,D,E \vdash B,C,F\)</span>.</p>
<p>Alternately let can be encoded as a record and recursion via a fixed-point combinator or a cycle in the graph. In particular <span id="id47">[<a class="reference internal" href="../zzreferences.html#id96" title="Oleg Kiselyov. Many faces of the fixed-point combinator. August 2013. URL: http://okmij.org/ftp/Computation/fixed-point-combinators.html (visited on 2020-07-31).">Kis13</a>]</span> outline a polyvariadic combinator:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fix_poly</span><span class="w"> </span><span class="n">fl</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fix</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">self</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="w"> </span><span class="n">self</span><span class="p">)</span><span class="w"> </span><span class="n">fl</span><span class="p">)</span>
</pre></div>
</div>
<p>To implement <code class="docutils literal notranslate"><span class="pre">fix</span></code> we can use the variant of the Y combinator <span class="math notranslate nohighlight">\(\lambda f.(\lambda x.x x) (\lambda x.f (x x))\)</span>. To type it we need the cyclic/recursive type <span class="math notranslate nohighlight">\(Wr = \Pi[(^w, Wr, r)]\)</span> (in the sense of an infinite, regular tree). BOHM uses a fan/duplication node combined with a loop.</p>
<section id="graph-reduction">
<h3>Graph reduction<a class="headerlink" href="#graph-reduction" title="Permalink to this heading"></a></h3>
<p>A better method, following <span id="id48">[<a class="reference internal" href="../zzreferences.html#id83" title="Simon Peyton Jones. The Implementation of Functional Programming Languages. Prentice-Hall, 1987. \textbf Errata  \begin itemize \item Section 5.2.4, p87.  We need an extra rule \end itemize  match us [] E = E  This accounts for the possibility that in the constructor rule (Section 5.2.4) there may be some non-nullary constructors for which there are no equations.  \begin itemize \item P168, line 2, “VAR” should be “TVAR”. \end itemize. URL: https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/ (visited on 2020-08-02).">Jon87</a>]</span> chapter 12, is to
In Stroscot, we instead simply allow (regular) infinite proof trees. We construct “infinite” as a terminal coalgebra - our proof trees turn into fixed points of systems of formal equations <span id="id49">[<a class="reference internal" href="../zzreferences.html#id89" title="Panagis Karazeris, Apostolos Matzaris, and Jiří Velebil. Final coalgebras in accessible categories. Mathematical Structures in Computer Science, 21(5):1067–1108, October 2011. URL: https://www.cambridge.org/core/product/identifier/S0960129511000351/type/journal_article (visited on 2021-03-11), doi:10.1017/S0960129511000351.">KMV11</a>]</span>, as opposed to actually being infinite. We represent the system of equations explicitly with the use-def rules, which also allow naming computations. Although the regular restriction means we can’t represent some values directly such as the Fibonacci sequence, most of the types we care about are regular, like the lambda calculus or lists, and similarly some infinite values like <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">x</span></code>.</p>
<p>Infinite structures can be paradoxical, e.g. we can prove <span class="math notranslate nohighlight">\(\vdash\bot\)</span> using cut on the proposition <span class="math notranslate nohighlight">\(A=\neg A\)</span>. Cut elimination will often fail to complete, but there is a progress property in the sense that the cut can always be pushed down and eliminate an identity rule or two matching logical rules.</p>
<blockquote>
<div><p>is better than  because it allows the graph reduction method used in GHC to work.</p>
</div></blockquote>
<p>These probably aren’t needed, the use-def and infinite structures and types encode recursion better and we can use GHC’s graph reduction model (below).</p>
<blockquote>
<div><p>give each definition node a static integer. Then the root is a distinguished definition. Assuming the static data is stored on disk and paged in/out as needed, we can minimize runtime memory use in a compiler pass by introducing as many use-def indirections as possible, one for every sequent in the derivation. This also makes the connections between rules uniform. But having lots of indirections is inefficient so a later pass would remove indirections that will be immediately used (chunkification).</p>
</div></blockquote>
<p>The optimal fixedpoint algorithm outlined in <span id="id50">[<a class="reference internal" href="../zzreferences.html#id137" title="Adi Shamir. The Fixedpoints of Recursive Definitions. PhD thesis, Weizmann Institute of Science, Rehovot, October 1976. URL: https://weizmann.primo.exlibrisgroup.com/permalink/972WIS_INST/1d4esio/alma990002185270203596.">Sha76</a>]</span> (10.18, PDF pages 240-242) is a variation of Tarjan’s strongly connected component algorithm. Cuts between two definitions <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> are memoized in a list, and if the SCC algorithm finds a component <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">let</span> <span class="pre">g</span> <span class="pre">=</span> <span class="pre">...</span> <span class="pre">in</span> <span class="pre">g</span> <span class="pre">(f</span> <span class="pre">x)</span></code> then this component is solved. If it has a unique solution then that’s the answer, otherwise <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> diverges and is replaced with a <code class="docutils literal notranslate"><span class="pre">RecursionError</span></code> or <code class="docutils literal notranslate"><span class="pre">AmbiguousError</span></code>. We assume the solver allows uninterpreted “holes”, so that the SCC can be solved before its sub-computations.</p>
<p>For comparison, to compute the least fixed point we would maintain a “working graph” and incrementally unfold the definition when encountered. But with the optimal fixed point we first reduce the definition to a value while copying other definitions in.</p>
<p>The solver is an SMT solver on the predicate <code class="docutils literal notranslate"><span class="pre">SAT(y</span> <span class="pre">==</span> <span class="pre">g</span> <span class="pre">y)</span></code>, and for uniqueness <code class="docutils literal notranslate"><span class="pre">UNSAT(y</span> <span class="pre">==</span> <span class="pre">g</span> <span class="pre">y</span> <span class="pre">&amp;&amp;</span> <span class="pre">y</span> <span class="pre">!=</span> <span class="pre">y0)</span></code> where <code class="docutils literal notranslate"><span class="pre">y0</span></code> is the first solution found. We exclude error values as possible solutions since the recursion error will be more informative.</p>
<p>The posets the paper uses appear to be pointed directed-complete partial orders <a class="reference external" href="https://en.wikipedia.org/wiki/Complete_partial_order">(cppo’s)</a>.</p>
</section>
</section>
<section id="hashing">
<h2>Hashing<a class="headerlink" href="#hashing" title="Permalink to this heading"></a></h2>
<p>To hash the graphs we can use the tree structure of the sequent derivations. Each upward slot in a node is hashed with a fixed value and each downward slot is hashed with a value corresponding to the path through the derivation tree followed by the label of the upward slot. It is written as a single DFS traversal with the leaves as base case that stores the hashed subtree and a map from edge name to partial path.</p>
<p>Hashing infinite graphs is harder, we have to hash each SCC as a unit. See <span id="id51">[<a class="reference internal" href="../zzreferences.html#id107" title="Laurent Mauborgne. An incremental unique representation for regular trees. Nordic Journal of Computing, 7(4):290–311, December 2000.">Mau00</a>]</span>.</p>
</section>
<section id="primitives">
<h2>Primitives<a class="headerlink" href="#primitives" title="Permalink to this heading"></a></h2>
<p>Primitives (integers) can be handled by hacking special cases into Cut; we add primitive functions of type PiR that use the arguments provided by PiL during a cut, and also literals, special values of type SigmaR. Alternately we can use a specialized proof trees: 64-bit integers are represented as a sigma type with 2^64 possibilities. So addition is represented as a case expression, where each case contains another case expression, and then each case constructs the integer corresponding to the addition. There is a lot of fan-out at each step, which would require 2^128 values to represent, clearly infeasible. So although this is the conceptual representation, the actual representation has no fan-out for the cases - instead the case nodes create symbolic variables <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, and the constructed value has the tag <code class="docutils literal notranslate"><span class="pre">a+b</span></code>.</p>
</section>
<section id="confluent-reduction">
<h2>Confluent reduction<a class="headerlink" href="#confluent-reduction" title="Permalink to this heading"></a></h2>
<p>Reduction of our linear logic trees is not confluent, but only because of commuting cuts. If we drop the black edges and only consider proof nets, then the system is confluent. A cut only interacts with other cuts at identity rules, but with a cut-identity-cut pattern it doesn’t matter which cut reduces with the identity. (TODO: prove this formally)</p>
<p>Since reduction is confluent, it does not change anything to reduce in non-normal order for a time. The reduction will still terminate when going back to normal order. So terminating reductions can always be performed and even non-terminating reductions can be reduced somewhat. Hence during compilation we want to reduce the program as much as possible - ideally the compiled core should be cut-free. We can detect diverging terms and replace them with error terms. But we can’t eliminate cuts involving complex recursion, so have to create a heap or a stack allocation. For example the Fibonacci list <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">fibs</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">::</span> <span class="pre">1</span> <span class="pre">::</span> <span class="pre">zipWith</span> <span class="pre">(+)</span> <span class="pre">fibs</span> <span class="pre">(tail</span> <span class="pre">fibs)</span> <span class="pre">in</span> <span class="pre">{</span> <span class="pre">repeat</span> <span class="pre">forever</span> <span class="pre">{</span> <span class="pre">n</span> <span class="pre">&lt;-</span> <span class="pre">readInt;</span> <span class="pre">print</span> <span class="pre">(fibs</span> <span class="pre">!!</span> <span class="pre">n)</span> <span class="pre">}</span> <span class="pre">}</span></code>, this needs some kind of reduction graph or memo stack involved.</p>
</section>
<section id="levels">
<h2>Levels<a class="headerlink" href="#levels" title="Permalink to this heading"></a></h2>
<p>For the implementation of optimal reduction we can add level indices to the terms in the promotion and dereliction rules of <span class="math notranslate nohighlight">\(\bangc/\whimc\)</span>, as in <span id="id52">[<a class="reference internal" href="../zzreferences.html#id106" title="S. Martini and A. Masini. On the fine structure of the exponential rule. In Jean-Yves Girard, Yves Lafont, and Laurent Regnier, editors, Advances in Linear Logic, pages 197–210. Cambridge University Press, Cambridge, 1995. URL: https://pdfs.semanticscholar.org/b2cb/538c8ef21af42e48134a17a3c62ce5167837.pdf (visited on 2020-08-01), doi:10.1017/CBO9780511629150.010.">MM95</a>]</span> and <span id="id53">[<a class="reference internal" href="../zzreferences.html#id68" title="Stefano Guerrini. Theoretical and Practical Issues of Optimal Implementations of Functional Languages. PhD thesis, Università di Pisa. Dipartimento di Informatica, 1996. URL: https://www-lipn.univ-paris13.fr/~guerrini/mysite/sites/default/files/biblio/PhDThesis.pdf.">Gue96</a>]</span>. Conceptually all terms have indices, but we can recover the indices in a proof tree by propagating the indices from the promotion/dereliction rules up/down according to the criteria that the indices involved in all non-<span class="math notranslate nohighlight">\(\bangc/\whimc\)</span> promotion/dereliction rules must be the same.</p>
<p>To handle level indices in infinite trees, we store the difference function <code class="docutils literal notranslate"><span class="pre">\a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">(j-i)</span></code> and recover the levels by tracing from the root of the derivation tree (which is always level 0) and applying the difference function when encountered.</p>
<p>The level of a context is the maximum of the levels of its terms, 0 if it is empty.</p>
<div class="math notranslate nohighlight">
\[\begin{array}{ccc}
  \rule{\bangc\Gamma^i \vdash A^j, \whimc\Delta^i }{\bangc\Gamma^i \vdash \bangc A^i, \whimc\Delta^i}{\bangc}_{j = i+1}
  &amp; \rule{\sk{\Gamma^i}, A^i \vdash \sk{\Delta^i} }{\sk{\Gamma^i}, \bangc A^j \vdash \sk{\Delta^i}}{\bangc d}_{j\leq i}
  &amp; \rule{\sk{\Gamma}, \overrightarrow{\bangc A, \bangc A, \cdots} \vdash \sk{\Delta} }{\sk{\Gamma}, \bangc A \vdash \sk{\Delta}}{\bangc c_n}
\end{array}\]</div>
<div class="math notranslate nohighlight">
\[\begin{array}{ccc}
  \rule{\bangc\Gamma^i, A^j \vdash \whimc\Delta^i }{\bangc\Gamma^i, \whimc A^i \vdash \whimc\Delta^i}{\whimc}_{j = i+1}
  &amp; \rule{\sk{\Gamma^i} \vdash A^i, \sk{\Delta^i} }{\sk{\Gamma^i} \vdash \whimc A^j, \sk{\Delta^i}}{\whimc d}_{j \leq i}
  &amp; \rule{\sk{\Gamma} \vdash \overrightarrow{\whimc A, \whimc A, \cdots}, \sk{\Delta} }{\sk{\Gamma} \vdash \whimc A, \sk{\Delta}}{\whimc c_n}
\end{array}\]</div>
<p>To handle level mismatches we might also need lifting operators. The conditions are unclear.</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cc}
  \rule{\Gamma^i \vdash A^j, \Delta^i }{\Gamma^i \vdash A^i, \Delta^i}{\text{lift}_R}_{j &gt; i}
  &amp;
  \rule{\Gamma^i, A^j \vdash \Delta^i }{\Gamma^i, A^i \vdash \Delta^i}{\text{lift}_L}_{j &gt; i}
\end{array}\]</div>
<p>In practice I went with a different approach that generates matching <code class="docutils literal notranslate"><span class="pre">Dup</span></code> nodes, so the levels aren’t needed.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Learning.html" class="btn btn-neutral float-left" title="Learning" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="LogicProgramming.html" class="btn btn-neutral float-right" title="Logic programming" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>