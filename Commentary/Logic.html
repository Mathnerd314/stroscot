<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Logic &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Memory management" href="Memory-Management.html" />
    <link rel="prev" title="Macros" href="Fexprs.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fexprs.html">Macros</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Logic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-logic-proper">The logic proper</a></li>
<li class="toctree-l3"><a class="reference internal" href="#jumbo-connectives">Jumbo connectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exponentials">Exponentials</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#contraction">Contraction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#subexponentials">Subexponentials</a></li>
<li class="toctree-l4"><a class="reference internal" href="#modalities">Modalities</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#polarized-logic">Polarized logic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cartesian-types">Cartesian types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tangent-reversible-computing">Tangent: Reversible computing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#structural-rules">Structural rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quantifiers">Quantifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logic-translations">Logic translations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#patterns">Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#set-theory">Set theory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#paradoxes">Paradoxes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#equality">Equality</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#infinite-structures">Infinite structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hashing">Hashing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#common-connectives">Common connectives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#programming-types">Programming types</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">About</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html#random-old-junk">Random old junk</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Imperative programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Commentary</a> &raquo;</li>
      <li>Logic</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Logic.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="logic">
<h1>Logic<a class="headerlink" href="#logic" title="Permalink to this headline"></a></h1>
<section id="the-logic-proper">
<h2>The logic proper<a class="headerlink" href="#the-logic-proper" title="Permalink to this headline"></a></h2>
<p>The sequent calculus idea is inspired by <span id="id1">[<a class="reference internal" href="../zzreferences.html#id25" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span>. But they use a weird nonstandard logic (Figures 4/5) to match GHC Core and its syntax. In a new language it seems better to use the standard logical derivation rules without messing with them, and worry about the syntax second. Stroscot’s infinite tree representation with use-def is better than the MultiCut / Rec rules because it allows the graph reduction method used in GHC to work.</p>
<p>For the base logic I went with linear logic because optimal reduction <span id="id2">[<a class="reference internal" href="../zzreferences.html#id37" title="Stefano Guerrini. Theoretical and Practical Issues of Optimal Implementations of Functional Languages. PhD thesis, Università di Pisa. Dipartimento di Informatica, 1996. URL: https://www-lipn.univ-paris13.fr/~guerrini/mysite/sites/default/files/biblio/PhDThesis.pdf.">Gue96</a>]</span> is based on using the boxes of linear logic as markers. Without linear logic every sequent would be its own box, IDK if it could be made to work reasonably.</p>
<p>The logic is two-sided because it’s more expressive to have the duals as part of the language. The one-sided logic with the duals and non-duals just seems like a way of encoding the left/right sides as a single list.</p>
</section>
<section id="jumbo-connectives">
<h2>Jumbo connectives<a class="headerlink" href="#jumbo-connectives" title="Permalink to this headline"></a></h2>
<p>Based on <span id="id3">[<a class="reference internal" href="../zzreferences.html#id50" title="Paul Blain Levy. Jumbo λ-calculus. In Michele Bugliesi, Bart Preneel, Vladimiro Sassone, and Ingo Wegener, editors, Automata, Languages and Programming, Lecture Notes in Computer Science, 444–455. Berlin, Heidelberg, 2006. Springer. URL: https://www.cs.bham.ac.uk/~pbl/papers/jumboicalp.pdf, doi:10.1007/11787006_38.">Lev06</a>]</span>, Stroscot aims for the largest allowable set of operators. In particular we generalize into two jumbo operators, <span class="math notranslate nohighlight">\(\Sigma\)</span> (sigma) and <span class="math notranslate nohighlight">\(\Pi\)</span> (pi). The generalized <span class="math notranslate nohighlight">\(\Pi\)</span> rule is similar to Levy’s rule except it allows multiple conclusion propositions. The generalized <span class="math notranslate nohighlight">\(\Sigma\)</span> rule is the dual of <span class="math notranslate nohighlight">\(\Pi\)</span>.</p>
<p>We have indexed variables <span class="math notranslate nohighlight">\(A_{ij}\)</span> and <span class="math notranslate nohighlight">\(B_{ik}\)</span> where <span class="math notranslate nohighlight">\(0 \leq i &lt; N, 0 \leq j &lt; m_i, 0 \leq k &lt; n_i\)</span>. We call <span class="math notranslate nohighlight">\(N\)</span> the length of the jumbo type and the list <span class="math notranslate nohighlight">\([(m_i,n_i)]\)</span> the jumbo-arity.</p>
<p>The dual of implication is called “subtraction” or “difference” and is denoted <span class="math notranslate nohighlight">\(-\)</span>. For an ADTs, the RHS of the difference is empty, i.e. <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">A</span> <span class="pre">|</span> <span class="pre">b</span> <span class="pre">B1</span> <span class="pre">B2</span> <span class="pre">|</span> <span class="pre">C</span></code> looks like <span class="math notranslate nohighlight">\(\Sigma [(a, [A]-[]),(b, [B_1, B_2]-[]), (c,[]-[])]\)</span>. This follows <span id="id4">[<a class="reference internal" href="../zzreferences.html#id76" title="Philip Wadler. Call-by-value is dual to call-by-name. In Proceedings of the Eighth ACM SIGPLAN International Conference on Functional Programming, ICFP '03, 189–201. Uppsala, Sweden, August 2003. Association for Computing Machinery. URL: http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf (visited on 2020-06-17), doi:10.1145/944705.944723.">Wad03</a>]</span> <span id="id5">[<a class="reference internal" href="../zzreferences.html#id19" title="Tristan Crolard. A formulae-as-types interpretation of subtractive logic. Journal of Logic and Computation, 14(4):529–570, August 2004. URL: https://academic.oup.com/logcom/article/14/4/529/933555 (visited on 2020-06-18), doi:10.1093/logcom/14.4.529.">Cro04</a>]</span>.</p>
<p>When the RHS of <span class="math notranslate nohighlight">\(\Sigma\)</span> is nonempty we get terms with holes, that can be pattern-matched by filling the holes, e.g. <a class="reference external" href="https://en.wikipedia.org/wiki/Difference_list">difference lists</a>. (TODO: check that this actually gives efficient concatenation)</p>
<p>The jumbo connectives have the nice “unpacking” property that any combination of <span class="math notranslate nohighlight">\(\Sigma\)</span> connectives is equivalent to a single <span class="math notranslate nohighlight">\(\Sigma\)</span> connective, and likewise for <span class="math notranslate nohighlight">\(\Pi\)</span>.</p>
</section>
<section id="exponentials">
<h2>Exponentials<a class="headerlink" href="#exponentials" title="Permalink to this headline"></a></h2>
<p>There are two S4 modalities !/bang/”of course” (positive) and the dual ?/whim/whimper/”why not” (negative).</p>
<section id="contraction">
<h3>Contraction<a class="headerlink" href="#contraction" title="Permalink to this headline"></a></h3>
<p>Instead of binary contraction we allow <span class="math notranslate nohighlight">\(n\)</span>-ary contraction for <span class="math notranslate nohighlight">\(n\geq 2\)</span>. This is equivalent to binary contraction but makes the proof trees a little more compact.</p>
</section>
<section id="subexponentials">
<h3>Subexponentials<a class="headerlink" href="#subexponentials" title="Permalink to this headline"></a></h3>
<p>In standard linear logic there are two S4 modalities !/bang/”of course” (positive) and the dual ?/whim/whimper/”why not” (negative). But if we introduce two modalities <span class="math notranslate nohighlight">\(\bang_1, \bang_2\)</span> with separate rules we cannot prove <span class="math notranslate nohighlight">\(\bang_1 A \equiv \bang_2 A\)</span>. So in keeping with the maximalist approach we present the logic with subexponentials. The subexponentials are like type annotations, in that we can erase all the subexponentials to a single standard exponential, and we can infer subexponentials, computing the minimal subexponential structure necessary for the program to work. Subexponentials whose only operations are promotion/dereliction can be deleted from the program.</p>
<p>For notation, subexponentials look like <span class="math notranslate nohighlight">\(\bang^x_m,\whim^x_m\)</span> where <span class="math notranslate nohighlight">\(m\)</span> is in an index set <span class="math notranslate nohighlight">\(M \supseteq \{\cdot\}\)</span> and <span class="math notranslate nohighlight">\(x \in X, X = P(\{c, w, d\})\)</span>. <span class="math notranslate nohighlight">\(m=\cdot\)</span> is written <span class="math notranslate nohighlight">\(\bang^x,\whim^x\)</span>, and similarly <span class="math notranslate nohighlight">\(x=\{\}\)</span> is written as <span class="math notranslate nohighlight">\(\bang_m,\whim_m\)</span>, so that we recover the standard notation <span class="math notranslate nohighlight">\(\bang,\whim\)</span> for <span class="math notranslate nohighlight">\(m=\cdot,x=\{\}\)</span>. We can also write <span class="math notranslate nohighlight">\(\bang_{(m,x)},\whim_{(m,x)}\)</span>, or more simply <span class="math notranslate nohighlight">\(\bang_{m}\)</span> if the available operations are clear.</p>
<p>To use these we must define a relation <span class="math notranslate nohighlight">\(\leq\)</span> on <span class="math notranslate nohighlight">\((M,X)\)</span> such that <span class="math notranslate nohighlight">\(((M,X),\leq)\)</span> is a poset. <span class="math notranslate nohighlight">\(\leq\)</span> must have that <span class="math notranslate nohighlight">\((m,x) \leq (n,y)\)</span> only if <span class="math notranslate nohighlight">\(x\subseteq y\)</span>. Reflexivity ensures the identity theorem. Transitivity and the subset relation on <span class="math notranslate nohighlight">\(X\)</span> ensure cut elimination. Antisymmetry ensures that if <span class="math notranslate nohighlight">\(\bang^x_m A \equiv \bang^y_n A\)</span> then <span class="math notranslate nohighlight">\(m=n\)</span> and <span class="math notranslate nohighlight">\(x=y\)</span>, so that we do not have duplicate notation for a particular modality. We require <span class="math notranslate nohighlight">\((m,x) \leq (m,y)\)</span> for <span class="math notranslate nohighlight">\(x \subseteq y\)</span>, but the relation between different modalities may not be so simple.</p>
<p>The rule for promotion requires that <span class="math notranslate nohighlight">\((z,o)\leq (x_i,m_i)\)</span> and <span class="math notranslate nohighlight">\((z,o)\leq (y_i,n_i)\)</span> for the elements of the context.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
  \rule{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i } \vdash A, \overrightarrow{\whim^{y_i}_{n_i}\Delta_i} }{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i } \vdash \bang^z_o A, \overrightarrow{\whim^{y_i}_{n_i}\Delta_i}}{\bang}
  &amp;
  \rule{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i } , A\vdash \overrightarrow{\whim^{y_i}_{n_i}\Delta_i} }{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i }, \whim^z_o A \vdash \overrightarrow{\whim^{y_i}_{n_i}\Delta_i}}{\whim}

\end{array}</div><p>Dereliction requires <span class="math notranslate nohighlight">\(d \in x\)</span>.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
  \rule{\sk{\Gamma}, A \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^x_m A \vdash \sk{\Delta}}{\bang d}
&amp; \rule{\sk{\Gamma} \vdash A, \sk{\Delta} }{\sk{\Gamma} \vdash \whim^x_m A, \sk{\Delta}}{\whim d}
\end{array}</div><p>Weakening requires <span class="math notranslate nohighlight">\(w \in x\)</span>.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
    \rule{\sk{\Gamma} \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^x_m A \vdash \sk{\Delta}}{\bang w}
  &amp; \rule{\sk{\Gamma} \vdash \sk{\Delta} }{\sk{\Gamma} \vdash \whim^x_m A, \sk{\Delta}}{\whim w}
  \end{array}</div><p>Contraction requires <span class="math notranslate nohighlight">\(c \in x\)</span></p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
    \rule{\sk{\Gamma}, \overrightarrow{\bang^x_m A, \bang^x_m A, \cdots} \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^x_m A \vdash \sk{\Delta}}{\bang c_n}
  &amp; \rule{\sk{\Gamma} \vdash \overrightarrow{\whim^x_m A, \whim^x_m A, \cdots}, \sk{\Delta} }{\sk{\Gamma} \vdash \whim^x_m A, \sk{\Delta}}{\whim c_n}
\end{array}</div><p>We also allow quantification over subexponentials, as in <span id="id6">[<a class="reference internal" href="../zzreferences.html#id59" title="Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Proceedings of the 11th ACM SIGPLAN Conference on Principles and Practice of Declarative Programming - PPDP '09, 129. Coimbra, Portugal, 2009. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1599410.1599427 (visited on 2021-03-26), doi:10.1145/1599410.1599427.">NM09</a>]</span>.</p>
</section>
<section id="modalities">
<h3>Modalities<a class="headerlink" href="#modalities" title="Permalink to this headline"></a></h3>
<p>Because of the equivalences <span class="math notranslate nohighlight">\(\bang \bang A \equiv \bang A, \bang \whim \bang \whim A \equiv \bang \whim A\)</span>, there are only 7 modalities created from combining exponentials. They have the relationships as follows, where an arrow <span class="math notranslate nohighlight">\(A \to B\)</span> means <span class="math notranslate nohighlight">\(\vdash A \to B\)</span> is provable:  <span id="id7">[<a class="reference internal" href="../zzreferences.html#id16" title="Marcelo Coniglio and Francisco Miraglia. Equality in linear logic. Logique et Analyse, 39(153/154):113–151, January 2002. URL: https://www.researchgate.net/profile/Marcelo-Coniglio/publication/2387274_Equality_In_Linear_Logic/links/0deec5165a6babbd8a000000/Equality-In-Linear-Logic.pdf.">CM02</a>]</span></p>
<div class="graphviz"><object data="../_images/graphviz-8434b84e3ec932c372f6234328dc7cbfc0b0023b.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph G {
  rankdir=LR
  &quot;!A&quot; -&gt; &quot;A&quot;
  &quot;A&quot; -&gt;&quot;?A&quot;
  &quot;!A&quot; -&gt; &quot;!?!A&quot; -&gt; {&quot;!?A&quot;,&quot;?!A&quot;} -&gt; &quot;?!?A&quot; -&gt; &quot;?A&quot;
  subgraph C {
    rank=same
    &quot;A&quot;,&quot;!?A&quot;,&quot;?!A&quot;
  }
}</p></object></div>
<p>More generally with subexponentials:</p>
<ul class="simple">
<li><p>For <span class="math notranslate nohighlight">\((x,m)\geq(y,n)\)</span>, <span class="math notranslate nohighlight">\(\bang^x_m \bang^y_n A \equiv \bang^x_m A \equiv \bang^y_n \bang^x_m A\)</span>, and similarly for <span class="math notranslate nohighlight">\(\whim\)</span>.</p></li>
<li><p>For <span class="math notranslate nohighlight">\((x,n)\leq(z,p)\)</span> and <span class="math notranslate nohighlight">\((y,o)\leq(w,m)\)</span> we can prove <span class="math notranslate nohighlight">\(\bang^w_m \whim^x_n \bang^y_o \whim^z_p A \equiv \bang^w_m \whim^z_p A\)</span>.</p></li>
</ul>
<p>With subexponentials the possible combinations become infinite, for example alternating patterns like <span class="math notranslate nohighlight">\(\bang_1 \bang_2 \bang_1 \bang_2\)</span> cannot be simplified unless there is a relation in the poset between 1 and 2.</p>
</section>
</section>
<section id="polarized-logic">
<h2>Polarized logic<a class="headerlink" href="#polarized-logic" title="Permalink to this headline"></a></h2>
<p>Following <span id="id8">[<a class="reference internal" href="../zzreferences.html#id48" title="Yves Lafont. Linear logic pages. URL: http://iml.univ-mrs.fr/~lafont/pub/llpages.pdf.">Laf</a>]</span> we say a proposition <span class="math notranslate nohighlight">\(A\)</span> is positive if <span class="math notranslate nohighlight">\(A \leftrightarrow \bang A\)</span> and negative if <span class="math notranslate nohighlight">\(A \leftrightarrow \whim A\)</span>, and that is is polarized if it is either positive or negative. We can forget negative polarity by forming <span class="math notranslate nohighlight">\(A\otimes 1\)</span>, and positive polarity by <span class="math notranslate nohighlight">\(A \par \bot\)</span>, and ensure a proposition has no polarity by using both.</p>
<p><span class="math notranslate nohighlight">\(\Sigma\)</span> forms positive propositions and <span class="math notranslate nohighlight">\(\Pi\)</span> forms negative propositions, where in each case, the clauses <span class="math notranslate nohighlight">\(\vec A - \vec B\)</span> or <span class="math notranslate nohighlight">\(\vec A \multimap \vec B\)</span> are formed from positive subformulas <span class="math notranslate nohighlight">\(A_j\)</span> and negative subformulas <span class="math notranslate nohighlight">\(B_k\)</span>. Formulas <span class="math notranslate nohighlight">\(\bang A\)</span> are always positive while formulas <span class="math notranslate nohighlight">\(\whim A\)</span> are always negative.</p>
<p><span class="math notranslate nohighlight">\(BB = \text{Bool} \to \text{Bool}\)</span> is positive and doesn’t conform to the above rules.</p>
<p>The polarized negations and shifts show up in polarized linear logic. <span id="id9">[<a class="reference internal" href="../zzreferences.html#id80" title="Noam Zeilberger. The Logical Basis of Evaluation Order and Pattern-Matching. PhD thesis, Carnegie Mellon University, Pittsburgh, PA, April 2009. URL: https://software.imdea.org/~noam.zeilberger/thesis.pdf.">Zei09</a>]</span> We use the opposite direction for shifts from <span id="id10">[<a class="reference internal" href="../zzreferences.html#id80" title="Noam Zeilberger. The Logical Basis of Evaluation Order and Pattern-Matching. PhD thesis, Carnegie Mellon University, Pittsburgh, PA, April 2009. URL: https://software.imdea.org/~noam.zeilberger/thesis.pdf.">Zei09</a>]</span> with the mnemonic that an up shift converts from negative to positive, hence increases the value. <span id="id11">[<a class="reference internal" href="../zzreferences.html#id59" title="Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Proceedings of the 11th ACM SIGPLAN Conference on Principles and Practice of Declarative Programming - PPDP '09, 129. Coimbra, Portugal, 2009. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1599410.1599427 (visited on 2021-03-26), doi:10.1145/1599410.1599427.">NM09</a>]</span> uses delay operators <span class="math notranslate nohighlight">\(\delta^\pm(\cdot)\)</span> instead of shifts.</p>
<section id="cartesian-types">
<h3>Cartesian types<a class="headerlink" href="#cartesian-types" title="Permalink to this headline"></a></h3>
<p>Certain “cartesian” types, like booleans, integers, lists, and in general ADTs of cartesian types using <span class="math notranslate nohighlight">\(\Sigma\)</span>, have a “natural” proof of positivity that preserves the value. This is an extension of <span id="id12">[<a class="reference internal" href="../zzreferences.html#id32" title="Andrzej Filinski. Linear continuations. In Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL '92, 27–38. Albuquerque, New Mexico, USA, February 1992. Association for Computing Machinery. URL: https://doi.org/10.1145/143165.143174 (visited on 2020-06-19), doi:10.1145/143165.143174.">Fil92</a>]</span>’s observation in section 3.1 - we destruct the value, then use bang, then construct the same value. But <span class="math notranslate nohighlight">\(BB\)</span> from above can’t be cartesian because we cannot evaluate a function twice.</p>
<p>There’s similarly negative types with a “natural” proof using <span class="math notranslate nohighlight">\(\Pi\)</span>, e.g. for <span class="math notranslate nohighlight">\(D=\Pi[(#l,[]\multimap []),(#r,[]\multimap [])]\)</span>. We could call these co-cartesian types.</p>
<p>The conclusion is to be generous with exponentials and use them whenever you have a cartesian / co-cartesian type, so that the proof structure identifies those operations.</p>
</section>
<section id="tangent-reversible-computing">
<h3>Tangent: Reversible computing<a class="headerlink" href="#tangent-reversible-computing" title="Permalink to this headline"></a></h3>
<p>Another approach to duplication is “superstructural reversible logic” <span id="id13">[<a class="reference internal" href="../zzreferences.html#id72" title="missing journal in sparksSuperstructuralReversibleLogic2014">SS14</a>]</span>. In their calculus, duplicating any type (cartesian or not) is impossible, without using non-reversible rules. The non-reversible structural rules could be restricted to a modality similarly to how linear logic restricts contraction/weakening. But in Theseus <span id="id14">[<a class="reference internal" href="../zzreferences.html#id40" title="missing journal in jamesTheseusHighLevel2014">JS14</a>]</span> and even in the latest publication <span id="id15">[<a class="reference internal" href="../zzreferences.html#id15" title="Chao-Hong Chen and Amr Sabry. A computational interpretation of compact closed categories: reversible programming with negative and fractional types. Proceedings of the ACM on Programming Languages, 5(POPL):1–29, January 2021. URL: https://dl.acm.org/doi/10.1145/3434290 (visited on 2021-08-04), doi:10.1145/3434290.">CS21</a>]</span> they use standard higher-order functions to do most of the programming. So really a reversible program is a data type <code class="docutils literal notranslate"><span class="pre">Rev</span></code>, similar to how a normal program is a data type <code class="docutils literal notranslate"><span class="pre">Task</span></code>. The difference is that <code class="docutils literal notranslate"><span class="pre">Rev</span></code> contains isomorphisms rather than continuations.</p>
<p>In terms of support, I don’t think there’s much needed at present. With the DSL support Stroscot should be able to write isomorphisms similar to Theseus, and run them forwards/backwards like the <a class="reference external" href="https://github.com/DreamLinuxer/popl21-artifact">Agda code</a>. Once there is hardware/an ISA/an OS to target it should be straightforward to extend this basic support to a compiler.</p>
</section>
</section>
<section id="structural-rules">
<h2>Structural rules<a class="headerlink" href="#structural-rules" title="Permalink to this headline"></a></h2>
<p>As is usual for linear logic there are no structural rules for weakening or contraction (they are restricted to the exponentials above). And in Core we use a graph representation that internalizes the exchange rule, so there is not really an exchange rule either.</p>
<p>Restricting the exchange rule would result in an ordered type system / noncommutative logic, similar to a stack machine. But <span id="id16">[<a class="reference internal" href="../zzreferences.html#id69" title="Yunhe Shi, David Gregg, Andrew Beatty, and M. Anton Ertl. Virtual machine showdown: stack versus registers. In Proceedings of the 1st ACM/USENIX International Conference on Virtual Execution Environments, VEE '05, 153–163. New York, NY, USA, June 2005. Association for Computing Machinery. URL: https://dl.acm.org/doi/10.1145/1328195.1328197 (visited on 2021-06-29), doi:10.1145/1064979.1065001.">SGBE05</a>]</span> shows that a register model is much better for an implementation - the extra stack swapping instructions give no benefit. Similarly restricting associativity would turn sequent lists into a binary tree - but this also has no benefit, it would just be a lot of shuffling operations. The number of operators would explode because every tree structure / stack index would create a new operator. Overall messing with the exchange rule seems like a nothing burger - some theoretical papers, but no real meat.</p>
<p>The cut rule is technically a theorem; we can prove that any proof using cut can be reformulated to be cut-free. But the expansion may result in exponentially more rule applications.</p>
<p>Similarly the identity rule is a theorem for propositional logic: we can produce a proof tree for <span class="math notranslate nohighlight">\(A \vdash A\)</span> for any finite proposition <span class="math notranslate nohighlight">\(A\)</span> via expansion of all the cases. Using the identity rule speeds up reduction because it skips iterating through the structure, and it also allows manipulating (prefixes of) <a class="reference internal" href="../Reference/Logic.html#infinite"><span class="std std-ref">infinite</span></a> trees.</p>
</section>
<section id="quantifiers">
<h2>Quantifiers<a class="headerlink" href="#quantifiers" title="Permalink to this headline"></a></h2>
<p>To move from propositional to first-order logic we must extend the identity rule to include axioms for terms. Some presentations therefore call the identity rule “ax”, for axiom, but in general the identity rule is a theorem so this is foolish IMO.</p>
<p><a class="reference external" href="https://ncatlab.org/nlab/show/sequent+calculus">nLab</a> defines a substitution rule/theorem. There is a theorem that substitution rules can be eliminated from the proof tree, proven by taking the proof tree for <span class="math notranslate nohighlight">\(\Gamma \vdash \Delta\)</span> and replacing all its identities <span class="math notranslate nohighlight">\(x \vdash x\)</span> with identities <span class="math notranslate nohighlight">\(t\ vdash t\)</span>.</p>
<p>Unlike with sets, quantifiers have no problem with identity expansion because the substitution is always for a variable and hence the number of quantifiers decreases.</p>
</section>
<section id="logic-translations">
<h2>Logic translations<a class="headerlink" href="#logic-translations" title="Permalink to this headline"></a></h2>
<p>First we must define classical and intuitionistic logic. To define classical logic we simply add standard structural weakening and contraction rules to our linear logic. Then <span class="math notranslate nohighlight">\(A\otimes B \equiv A \land B\)</span>, <span class="math notranslate nohighlight">\(A\par B \equiv A \lor B\)</span>, and we obtain the usual classical logic with modalities <span id="id17">[<a class="reference internal" href="../zzreferences.html#id48" title="Yves Lafont. Linear logic pages. URL: http://iml.univ-mrs.fr/~lafont/pub/llpages.pdf.">Laf</a>]</span>; all the connectives decompose into or are equivalent to the standard ones. To define intuitionistic logic we take classical logic and restrict the right hand side of all sequents to have at most one consequent; various pi/sigma connectives cannot be used as they would create multiple consequents, and similarly right contraction cannot be used. We allow disallow right weakening to make the translation easier.</p>
<p>The translation from intuitionistic logic to linear logic decorates every proposition and subproposition with !. <span id="id18">[<a class="reference internal" href="../zzreferences.html#id21" title="Roberto Di Cosmo. Introduction to Linear Logic. MPRI course notes, 2015. URL: https://www.dicosmo.org/CourseNotes/LinLog/IntroductionLinearLogic.pdf (visited on 2020-05-13).">DC15</a>]</span></p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\left[\prod \limits_{i} \left(\overrightarrow{A_i} \multimap \overrightarrow{B_i}\right)\right]_I &amp;= \prod \limits_{i} \left(\overrightarrow{\bang\left[A_i\right]_I} \multimap \overrightarrow{\bang\left[B_i\right]_I}\right)\\\left[\sum \limits_{i} \left(\overrightarrow{A_i} - \overrightarrow{B_i}\right)\right]_I &amp;= \sum \limits_{i} \left(\overrightarrow{\bang\left[A_i\right]_I} - \overrightarrow{\bang\left[B_i\right]_I}\right)\end{aligned}\end{align} \]</div>
<p>We can translate classical logic into intuitionistic logic by decorating every proposition and subproposition with <span class="math notranslate nohighlight">\(\neg\neg\)</span> and moving the right to the left with another negation, i.e. <span class="math notranslate nohighlight">\(\Gamma \vdash \Delta \Rightarrow \Gamma', \neg \Delta' \vdash\)</span>. Thus the translation of classical logic into linear logic decorates like <span class="math notranslate nohighlight">\(\neg \bang (\neg \bang A) \equiv \whim \bang A\)</span>.</p>
<p>These two decoration translations preserve proof structure, in the sense that every intuitionistic/classical proof tree can be converted to a linear logic proof tree, and the reverse as well if the linear logic proof tree’s sequent is the result of the proposition translation.</p>
</section>
<section id="patterns">
<h2>Patterns<a class="headerlink" href="#patterns" title="Permalink to this headline"></a></h2>
<p>We call sequents of the form <span class="math notranslate nohighlight">\(\vdash A\)</span> proofs of <span class="math notranslate nohighlight">\(A\)</span>. Similarly sequents <span class="math notranslate nohighlight">\(A \vdash\)</span> are refutations of <span class="math notranslate nohighlight">\(A\)</span>. <span class="math notranslate nohighlight">\(\Sigma_R\)</span> constructs a proof from a collection of proofs and refutations, while <span class="math notranslate nohighlight">\(\Pi_L\)</span> constructs a refutation from a collection of proofs and refutations. We can similarly consider proof patterns <span class="math notranslate nohighlight">\(x, \ldots, z \vdash A\)</span> / refutation patterns <span class="math notranslate nohighlight">\(x,\ldots,z, A \vdash\)</span> where <span class="math notranslate nohighlight">\(x,\ldots,z\)</span> are free variables.</p>
<p>If we have a proof of <span class="math notranslate nohighlight">\(A\)</span> then <span class="math notranslate nohighlight">\(A\)</span> is a theorem (also called a tautology). If we prove a sequent <span class="math notranslate nohighlight">\(\Gamma \vdash\)</span> then <span class="math notranslate nohighlight">\(\Gamma\)</span> is a contradiction. We define equivalence <span class="math notranslate nohighlight">\(A\equiv B\)</span> as the theorem <span class="math notranslate nohighlight">\(\vdash A \leftrightarrow B\)</span>.</p>
</section>
<section id="definitions">
<h2>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline"></a></h2>
<p>I didn’t find any relevant papers on defining new notation for expressions in the sequent calculus. So we have to prove consistency ourselves. But I think the cut elimination theorem poses no problem, the key and commutative cases are trivial.</p>
<p>The identity theorem fails to complete if there is an infinite chain of definitions <span class="math notranslate nohighlight">\(A_1 \defeq \ldots A_2 \ldots, A_2 \defeq \ldots A_3 \ldots, \ldots\)</span>. Hence we exclude that from the syntax. Then we can induct as usual: use the normal identity theorem on non-definition subtrees, then use the definition rule on both sides for each definition, and continue alternating until it’s built up. For the substitution theorem we must also limit our substitution to non-circular definitions.</p>
<p>For the parts of the proof tree not using the identity or substitution theorems the definition chain is always finite, hence it’s not a huge restriction. In general it is undecidable if a particular definition usage is circular (see <a class="reference internal" href="#paradoxes"><span class="std std-ref">discussion of set paradoxes</span></a>). But most definitions don’t have a definition on the RHS hence are easy to check for circularity.</p>
</section>
<section id="set-theory">
<h2>Set theory<a class="headerlink" href="#set-theory" title="Permalink to this headline"></a></h2>
<p>The naive set theory definition comes from <span id="id19">[<a class="reference internal" href="../zzreferences.html#id67" title="Masaru Shirahata. Linear Set Theory. PhD thesis, Stanford University, February 1994. URL: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.29.7077&amp;rep=rep1&amp;type=pdf.">Shi94</a>]</span> (page 10). The rest of the definitions are similar to the ones in <span id="id20">[<a class="reference internal" href="../zzreferences.html#id70" title="Michael Shulman. Linear logic for constructive mathematics. arXiv:1805.07518 [math], May 2018. URL: http://arxiv.org/abs/1805.07518 (visited on 2021-03-04), arXiv:1805.07518.">Shu18</a>]</span> except <span class="math notranslate nohighlight">\(\in\)</span> is not affirmative.</p>
<section id="paradoxes">
<span id="id21"></span><h3>Paradoxes<a class="headerlink" href="#paradoxes" title="Permalink to this headline"></a></h3>
<p>It seems from playing with some examples that forbidding circular definitions is sufficient to prevent Russell’s paradox and Curry’s paradox. For example with <span class="math notranslate nohighlight">\(R = \{x\mid \whim \neg(x \in x)\}\)</span>, <span class="math notranslate nohighlight">\(\{x\mid F \} \in R\)</span> is defined (and provable) but <span class="math notranslate nohighlight">\(R \in R\)</span> is circular hence not defined. So we cannot write the premise of Russell’s paradox. We could try to work around this with a proposition like <span class="math notranslate nohighlight">\(t\in R \land t= R\)</span>. This is not circular, but it is not sufficient to derive a paradox, as in order to apply contraction we have to use a substitution that produces <span class="math notranslate nohighlight">\(R \in R\)</span>. Curry’s paradox <span class="math notranslate nohighlight">\(X=\{x\mid x\in x \to Y\}\)</span> similarly contains <span class="math notranslate nohighlight">\(x\in x\)</span> and hence the notation <span class="math notranslate nohighlight">\(X \in X\)</span> is circular and therefore forbidden as well.</p>
<p>More formally, suppose the logic is inconsistent, i.e. there is a derivation <span class="math notranslate nohighlight">\(\vdash \bot\)</span>. This must be derived from the empty sequent. Then what does cut elimination do? Either it completes, in which case we get a contradiction because no rule derives the empty sequent, or there’s some infinite chain of cut elimination. I claim the infinite chain only happens if there is a circular definition involved and the identity or substitution rules are on the sides. Hence, forbidding infinitely expanding definitions in these solves the issue.</p>
<p>The question of whether a given set comprehension is defined is undecidable, as we can encode the lambda calculus and hence the halting problem - the beta rule <span class="math notranslate nohighlight">\((\lambda x. A) t\)</span> does the same substitution as <span class="math notranslate nohighlight">\(t\in\{x\mid A\}\)</span>. We can approximate definedness with a termination checking algorithm or syntactic check:</p>
<ul class="simple">
<li><p>Strict comprehension, i.e. the bound variable can only appear once in the formula <span id="id22">[<a class="reference internal" href="../zzreferences.html#id68" title="Masaru Shirahata. Linear set theory with strict comprehension. In Proceedings of the Sixth Asian Logic Conference, 223–245. Beijing, China, April 1998. WORLD SCIENTIFIC / S'PORE UNIV PRESS (PTE) LTD. URL: http://www.worldscientific.com/doi/abs/10.1142/9789812812940_0013 (visited on 2021-03-06), doi:10.1142/9789812812940_0013.">Shi98</a>]</span></p></li>
<li><p>New Foundations’s stratified formulas <span id="id23">[<a class="reference internal" href="../zzreferences.html#id33" title="Thomas Forster. Quine’s New Foundations. In Edward N. Zalta, editor, The Stanford Encyclopedia of Philosophy. Metaphysics Research Lab, Stanford University, summer 2019 edition, 2019. URL: https://plato.stanford.edu/archives/sum2019/entries/quine-nf/ (visited on 2021-03-04).">For19</a>]</span> <span id="id24">[<a class="reference internal" href="../zzreferences.html#id38" title="M. Randall Holmes. Elementary Set Theory with a Universal Set. Bruylant-Academia, 1998. ISBN 978-2-87209-488-2. URL: https://randall-holmes.github.io/head.pdf.">Hol98</a>]</span></p></li>
<li><p>Hindley-Milner type inference (since the simply typed lambda calculus terminates)</p></li>
<li><p>A size-checking algorithm like in <span id="id25">[<a class="reference internal" href="../zzreferences.html#id41" title="Neil D. Jones and Nina Bohr. Call-by-value termination in the untyped lambda-calculus. Logical Methods in Computer Science, 4(1):3, March 2008. URL: http://arxiv.org/abs/0801.0882 (visited on 2021-03-06), arXiv:0801.0882, doi:10.2168/LMCS-4(1:3)2008.">JB08</a>]</span></p></li>
<li><p>Brute-force expansion</p></li>
</ul>
<p>There is also <span id="id26">[<a class="reference internal" href="../zzreferences.html#id66" title="Masaru Shirahata. A linear conservative extension of Zermelo-Fraenkel set theory. Studia Logica, 56(3):361–392, May 1996. URL: http://link.springer.com/10.1007/BF00372772 (visited on 2021-03-06), doi:10.1007/BF00372772.">Shi96</a>]</span> which allows sets built from ZF’s axioms.</p>
</section>
<section id="equality">
<h3>Equality<a class="headerlink" href="#equality" title="Permalink to this headline"></a></h3>
<p>The axioms of reflexivity, substitution, etc. can take a variety of modalities as in <span id="id27">[<a class="reference internal" href="../zzreferences.html#id16" title="Marcelo Coniglio and Francisco Miraglia. Equality in linear logic. Logique et Analyse, 39(153/154):113–151, January 2002. URL: https://www.researchgate.net/profile/Marcelo-Coniglio/publication/2387274_Equality_In_Linear_Logic/links/0deec5165a6babbd8a000000/Equality-In-Linear-Logic.pdf.">CM02</a>]</span>, some of them corresponding with intuitionistic and classical notions of equality. For sets we use linear weak extensional equality. Alternatively we could use intuitionistic equality <span class="math notranslate nohighlight">\(A\overset{!}{=}B \defeq !(A=B)\)</span>, then substitution is <span class="math notranslate nohighlight">\(A\overset{!}{=}B, \phi \vdash \phi[A/B]\)</span>. But the linear equality seems more useful.</p>
<p>Proof of the substitution property: For <span class="math notranslate nohighlight">\(\Pi\)</span> we use the right rule to split into cases for each tag, then we use contraction/weakening on <span class="math notranslate nohighlight">\(\bang(A=B)\)</span> to match the number of A’s/B’s in the case, then the left rule to split into each A and B, giving each branch a copy of the hypothesis. <span class="math notranslate nohighlight">\(\Sigma\)</span> is similar but with the left first. For exponentials, quantifiers, and set comprehension we simply do left/right in the correct order. Then at the end we use the hypothesis to change <span class="math notranslate nohighlight">\(A[x/a]\)</span> on the left or right to <span class="math notranslate nohighlight">\(B[x/b]\)</span>, or else weakening to remove the hypothesis followed by the identity.</p>
</section>
</section>
<section id="infinite-structures">
<h2>Infinite structures<a class="headerlink" href="#infinite-structures" title="Permalink to this headline"></a></h2>
<p>These are used to support infinite types like the lambda calculus or lists, and similarly infinite expressions like <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">x</span></code>. We construct “infinite” as a terminal coalgebra - our proof trees turn into fixed points of systems of formal equations <span id="id28">[<a class="reference internal" href="../zzreferences.html#id45" title="Panagis Karazeris, Apostolos Matzaris, and Jiří Velebil. Final coalgebras in accessible categories. Mathematical Structures in Computer Science, 21(5):1067–1108, October 2011. URL: https://www.cambridge.org/core/product/identifier/S0960129511000351/type/journal_article (visited on 2021-03-11), doi:10.1017/S0960129511000351.">KMV11</a>]</span>.</p>
<p>Infinite structures can be paradoxical, e.g. we can prove <span class="math notranslate nohighlight">\(\vdash\bot\)</span> using cut on the proposition <span class="math notranslate nohighlight">\(A=\neg A\)</span>. Cut elimination will often fail to complete, but there is a progress property in the sense that the cut can always be pushed down and eliminate an identity rule or two matching logical rules.</p>
</section>
<section id="hashing">
<h2>Hashing<a class="headerlink" href="#hashing" title="Permalink to this headline"></a></h2>
<p>To hash the graphs we can use the tree structure of the sequent derivations. Each upward slot in a node is hashed with a fixed value and each downward slot is hashed with a value corresponding to the path through the derivation tree followed by the label of the upward slot. It is written as a single DFS traversal from the leaves upwards that stores the hashed subtree and a map from edge name to partial path.</p>
</section>
<section id="common-connectives">
<h2>Common connectives<a class="headerlink" href="#common-connectives" title="Permalink to this headline"></a></h2>
<p>The idea behind <span class="math notranslate nohighlight">\(\bot\)</span> as contradiction is as follows: if we have a sequent <span class="math notranslate nohighlight">\(\Gamma \vdash A\otimes \neg A\)</span>, we can decompose this into sequents <span class="math notranslate nohighlight">\(\Gamma_1 \vdash A\)</span> and <span class="math notranslate nohighlight">\(\Gamma_2, A \vdash\)</span> where <span class="math notranslate nohighlight">\(\Gamma = \Gamma_1, \Gamma_2\)</span>. Then we can cut to derive the sequent <span class="math notranslate nohighlight">\(\Gamma \vdash\)</span>, and hence derive <span class="math notranslate nohighlight">\(\Gamma \vdash \bot\)</span>.</p>
<p>The notation <span class="math notranslate nohighlight">\(\land,\lor\)</span> is chosen because the structure-preserving translation from intuitionistic logic preserves the logical operators <span id="id29">[<a class="reference internal" href="../zzreferences.html#id21" title="Roberto Di Cosmo. Introduction to Linear Logic. MPRI course notes, 2015. URL: https://www.dicosmo.org/CourseNotes/LinLog/IntroductionLinearLogic.pdf (visited on 2020-05-13).">DC15</a>]</span>, hence some intuition arises from using it. The notation for times and par is trickier; times and par are both <a class="reference external" href="https://en.wikipedia.org/wiki/Monoidal_category">tensor/monoidal products</a> (identities <span class="math notranslate nohighlight">\(1,\bot\)</span>), and do not appear in classical logic. The fact that tuples are typically positive data leads us to privilege <span class="math notranslate nohighlight">\(\otimes\)</span> as the default product, agreeing with Girard.</p>
<p><span class="math notranslate nohighlight">\(\par\)</span> is the dual of <span class="math notranslate nohighlight">\(\otimes\)</span> in the sense that <span class="math notranslate nohighlight">\(A \par B \equiv \neg (\neg A \otimes \neg B)\)</span>; unfortunately for deciding a notation, this seems to be its only useful property. <span class="math notranslate nohighlight">\(\oplus, \odot ,\Box,\sharp, \bullet\)</span> and <span class="math notranslate nohighlight">\(*\)</span> have meanings (direct sum/coproduct, Hadamard product/XNOR gate/symmetric product, modal operator, music, multiplication/logical and, convolution) dissimilar from the function of <span class="math notranslate nohighlight">\(\par\)</span>. <span class="math notranslate nohighlight">\(\mathbin{{\scriptstyle+}\mkern-0.522em\raise{-0.077em}{\diamond}},\mathbin{{\vee}\mkern-0.815em\raise{0.09em}{\bigcirc}}\)</span> don’t have Unicode symbols so are hard to use. In the end none of the operators seems particularly evocative. <span class="math notranslate nohighlight">\(\par\)</span> on the other hand redirects to linear logic on Wikipedia. So we follow Girard.</p>
<section id="programming-types">
<h3>Programming types<a class="headerlink" href="#programming-types" title="Permalink to this headline"></a></h3>
<p>With the programming types we see the justification for the jumbo types: they can represent abstract data types (ADTs). Even though we can encode <span class="math notranslate nohighlight">\(\Pi,\Sigma\)</span> using the common connectives:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\Pi [(\#t_1,[A_{1,1},A_{1,2},\ldots] \multimap [B_{1,1},B_{1,2},\ldots]),\ldots] \equiv (\smash{\stackrel{-}{\neg}} A_{1,1} \par \smash{\stackrel{-}{\neg}} A_{1,2} \par \ldots \par B_{1,1} \par \ldots) \land \ldots\\\Sigma [(\#t_1,[A_{1,1},A_{1,2},\ldots] \multimap [B_{1,1},B_{1,2},\ldots]),\ldots] \equiv (A_{1,1} \otimes A_{1,2} \otimes \ldots \otimes \smash{\stackrel{+}{\neg}} B_{1,1} \otimes \ldots) \lor \ldots\end{aligned}\end{align} \]</div>
<p>With the encoding, we lose the free-form tags and have to use strings like “RRRRRL”. This leads to unbalanced proof trees and a general lack of expressiveness of the proof language.</p>
<p>The lambdas are from <span id="id30">[<a class="reference internal" href="../zzreferences.html#id51" title="John Maraist, Martin Odersky, David N. Turner, and Philip Wadler. Call-by-name, call-by-value, call-by-need, and the linear lambda calculus. Electronic Notes in Theoretical Computer Science, 1:370–392, January 1995. URL: http://www.sciencedirect.com/science/article/pii/S1571066104000222 (visited on 2020-08-23), doi:10.1016/S1571-0661(04)00022-2.">MOTW95</a>]</span>, but honestly I’m not sure about the definition.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Fexprs.html" class="btn btn-neutral float-left" title="Macros" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Memory-Management.html" class="btn btn-neutral float-right" title="Memory management" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2020 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>