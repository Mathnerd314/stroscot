<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Logic &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Logic programming" href="LogicProgramming.html" />
    <link rel="prev" title="Library" href="Library.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Intrinsics.html">Intrinsics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Logic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-logic-proper">The logic proper</a></li>
<li class="toctree-l3"><a class="reference internal" href="#jumbo-connectives">Jumbo connectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#common-connectives">Common connectives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#programming-types">Programming types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exponentials">Exponentials</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#contraction">Contraction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#subexponentials">Subexponentials</a></li>
<li class="toctree-l4"><a class="reference internal" href="#modalities">Modalities</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#polarized-logic">Polarized logic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cartesian-types">Cartesian types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tangent-reversible-computing">Tangent: Reversible computing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#structural-rules">Structural rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quantifiers">Quantifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logic-translations">Logic translations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#patterns">Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#set-theory">Set theory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#paradoxes">Paradoxes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#equality">Equality</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#infinite-structures">Infinite structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hashing">Hashing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#recursion">Recursion</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#graph-reduction">Graph reduction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#primitives">Primitives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#compressed-graphs">Compressed graphs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#confluent-reduction">Confluent reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#levels">Levels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Logic</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Logic.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="logic">
<h1>Logic<a class="headerlink" href="#logic" title="Permalink to this heading"></a></h1>
<div class="math notranslate nohighlight">
\[\newcommand{\rule}[3]{ \dfrac{\displaystyle ~~#1~~ }{\displaystyle ~~#2~~ } \  (#3)}
\newcommand{\defeq}{\overset{\text{def}}{=}}
\newcommand{\with}{\mathbin{\mathrm{\&amp;}}}
\newcommand{\par}{\mathbin{\mathrm{⅋}}}
\newcommand{\multimapboth}{\mathbin{\mathrm{⧟}}}
\newcommand{\bang}{{\mathrm{!}}}
\newcommand{\whim}{{\mathrm{?}}}
\newcommand{\bangc}{{\mathrm{!}}}
\newcommand{\whimc}{{\mathrm{?}}}
\newcommand{\ocin}{\mathrel{\raise{-1pt}{\mathrm{!}}\mathord{\in}}}
\definecolor{mygray}{RGB}{156,156,156}
\newcommand{\sk}[1]{{\color{mygray} #1}}\]</div>
<section id="the-logic-proper">
<h2>The logic proper<a class="headerlink" href="#the-logic-proper" title="Permalink to this heading"></a></h2>
<p>The sequent calculus instead of natural deduction is inspired by <span id="id1">[<a class="reference internal" href="../zzreferences.html#id47" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span>. But they use a weird nonstandard logic (Figures 4/5) to match GHC Core and its syntax. In a new language it seems better to use standard logical derivation rules, and worry about the syntax second. Stroscot’s infinite tree representation with use-def is better than the MultiCut / Rec rules because it allows the graph reduction method used in GHC to work.</p>
<p>For the deduction system I went with linear logic because optimal reduction <span id="id2">[<a class="reference internal" href="../zzreferences.html#id67" title="Stefano Guerrini. Theoretical and Practical Issues of Optimal Implementations of Functional Languages. PhD thesis, Università di Pisa. Dipartimento di Informatica, 1996. URL: https://www-lipn.univ-paris13.fr/~guerrini/mysite/sites/default/files/biblio/PhDThesis.pdf.">Gue96</a>]</span> is based on using the boxes of linear logic as markers and classical / intuitionistic logic can be encoded in linear logic hence are special cases. Without linear logic every sequent would be its own box, which would be harder to handle.</p>
<p>The logic is two-sided because that’s more expressive than one-sided. Omitting the left side reduces code verbosity, because a sequent is one list instead of a pair of lists, but the one-sided logic has the same number of connectives, and it’s IMO confusing to always have to remember the duals - e.g. an application of identity looks like <span class="math notranslate nohighlight">\(\vdash \Sigma X^\bot, \Pi X\)</span> instead of <span class="math notranslate nohighlight">\(\Pi X \vdash \Pi X\)</span>. Taking the two-sided logic as basic, the one sided logic can still be formulated as a transformation of the two-sided logic that moves everything to the right side with negation and pushes down negations to atomic statements by applying duality theorems (inserted with cuts).</p>
<p>There are also other presentations like deep inference. In one paper on deep inference they ended up adding the <a class="reference external" href="https://ncatlab.org/nlab/show/mix+rule">mix rule</a> which corresponds to assuming <span class="math notranslate nohighlight">\(1 \leftrightarrow \bot\)</span>. This doesn’t seem attractive compared to plain linear logic - it proves contradiction as a theorem, hence loses the embedding of classical logic. <a class="reference external" href="https://www.pls-lab.org/en/Mix_rule">This page</a> mentions that mix holds in various models of linear logic such as coherent spaces and the game-theoretic semantics, but models are usually a simplification and there are models such as the syntactic model where mix doesn’t hold. <span id="id3">[<a class="reference internal" href="../zzreferences.html#id152" title="Lutz STRAßBURGER. Deep inference and expansion trees for second-order multiplicative linear logic. Mathematical Structures in Computer Science, 29(8):1030–1060, September 2019. URL: https://www.cambridge.org/core/product/identifier/S0960129518000385/type/journal_article (visited on 2022-08-11), doi:10.1017/S0960129518000385.">STR19</a>]</span> presents a deep inference system for non-mix MLL but says extending it to full LL is future work.</p>
<p>There is also the question of if the last remaining structural rules, the exchange and associativity rules, should be dropped, to obtain non-commutative or ordered logic and non-associative logic. Noncommutativity leads to a stack or list, and non-associativity leads to a tree-like semantics which can be quite complicated. Contrast this with the idea of the propositions being in named slots, where associativity and commutativity seem natural - e.g. <code class="docutils literal notranslate"><span class="pre">{a</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">2}</span></code> is for almost all purposes the same as <code class="docutils literal notranslate"><span class="pre">{b</span> <span class="pre">=</span> <span class="pre">2,</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">1}</span></code>, and only in some narrow cases would we want to differentiate them. But, there seem to be reasonable ways of embedding linear logic in non-associative / non-commutative logic by adding associative / commutative modalities. <span id="id4">[<a class="reference internal" href="../zzreferences.html#id20" title="Eben Blaisdell, Max Kanovich, Stepan L. Kuznetsov, Elaine Pimentel, and Andre Scedrov. Non-associative, Non-commutative Multi-modal Linear Logic. In Jasmin Blanchette, Laura Kovács, and Dirk Pattinson, editors, Automated Reasoning, Lecture Notes in Computer Science, 449–467. Cham, 2022. Springer International Publishing. doi:10.1007/978-3-031-10769-6_27.">BKK+22</a>]</span> If there was a popular logic with such an embedding, then we could switch from linear logic to that. But per <span id="id5">[<a class="reference internal" href="../zzreferences.html#id111" title="Dale Miller. An Overview of Linear Logic Programming. In Thomas Ehrhard, Jean-Yves Girard, Paul Ruet, and Philip Scott, editors, Linear Logic in Computer Science, pages 119–150. Cambridge University Press, first edition, November 2004. URL: https://www.cambridge.org/core/product/identifier/CBO9780511550850A013/type/book_part (visited on 2021-04-02), doi:10.1017/CBO9780511550850.004.">Mil04</a>]</span> “no single [non-commutative] proposal seems to be canonical at this point.”</p>
</section>
<section id="jumbo-connectives">
<h2>Jumbo connectives<a class="headerlink" href="#jumbo-connectives" title="Permalink to this heading"></a></h2>
<p>Based on <span id="id6">[<a class="reference internal" href="../zzreferences.html#id102" title="Paul Blain Levy. Jumbo λ-calculus. In Michele Bugliesi, Bart Preneel, Vladimiro Sassone, and Ingo Wegener, editors, Automata, Languages and Programming, Lecture Notes in Computer Science, 444–455. Berlin, Heidelberg, 2006. Springer. URL: https://www.cs.bham.ac.uk/~pbl/papers/jumboicalp.pdf, doi:10.1007/11787006_38.">Lev06</a>]</span>, Stroscot aims for the largest allowable set of operators. In particular we generalize into two jumbo operators, <span class="math notranslate nohighlight">\(\Sigma\)</span> (sigma) and <span class="math notranslate nohighlight">\(\Pi\)</span> (pi). The generalized <span class="math notranslate nohighlight">\(\Pi\)</span> rule is similar to Levy’s rule except it allows multiple conclusion propositions. The generalized <span class="math notranslate nohighlight">\(\Sigma\)</span> rule is the dual of <span class="math notranslate nohighlight">\(\Pi\)</span>.</p>
<p>We have indexed variables <span class="math notranslate nohighlight">\(A_{ij}\)</span> and <span class="math notranslate nohighlight">\(B_{ik}\)</span> where <span class="math notranslate nohighlight">\(0 \leq i &lt; N, 0 \leq j &lt; m_i, 0 \leq k &lt; n_i\)</span>. We call <span class="math notranslate nohighlight">\(N\)</span> the length of the jumbo type and the list <span class="math notranslate nohighlight">\([(m_i,n_i)]\)</span> the jumbo-arity.</p>
<p>The dual of implication is called “subtraction” or “difference” and is denoted <span class="math notranslate nohighlight">\(-\)</span>. For an ADT, the RHS of the difference is empty, i.e. <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">A</span> <span class="pre">|</span> <span class="pre">b</span> <span class="pre">B1</span> <span class="pre">B2</span> <span class="pre">|</span> <span class="pre">C</span></code> looks like <span class="math notranslate nohighlight">\(\Sigma [(a, [A]-[]),(b, [B_1, B_2]-[]), (c,[]-[])]\)</span>. This follows <span id="id7">[<a class="reference internal" href="../zzreferences.html#id161" title="Philip Wadler. Call-by-value is dual to call-by-name. In Proceedings of the Eighth ACM SIGPLAN International Conference on Functional Programming, ICFP '03, 189–201. Uppsala, Sweden, August 2003. Association for Computing Machinery. URL: http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf (visited on 2020-06-17), doi:10.1145/944705.944723.">Wad03</a>]</span> and <span id="id8">[<a class="reference internal" href="../zzreferences.html#id37" title="Tristan Crolard. A formulae-as-types interpretation of subtractive logic. Journal of Logic and Computation, 14(4):529–570, August 2004. URL: https://academic.oup.com/logcom/article/14/4/529/933555 (visited on 2020-06-18), doi:10.1093/logcom/14.4.529.">Cro04</a>]</span> but is flipped compared to Pi.</p>
<p>When the RHS of <span class="math notranslate nohighlight">\(\Sigma\)</span> is nonempty we get terms with holes, that can be pattern-matched by filling the holes, e.g. <a class="reference external" href="https://en.wikipedia.org/wiki/Difference_list">difference lists</a>. (TODO: check that this actually gives efficient concatenation)</p>
<p>The jumbo connectives have the nice “unpacking” property that any combination of <span class="math notranslate nohighlight">\(\Sigma\)</span> connectives is equivalent to a single <span class="math notranslate nohighlight">\(\Sigma\)</span> connective, and likewise for <span class="math notranslate nohighlight">\(\Pi\)</span>.</p>
<p>The index <span class="math notranslate nohighlight">\(i\)</span> in Levy’s presentation is a tag drawn from a finite subset of a countable set of labels. But we can draw it from a subset of the universal set and hence get dependent types that depend on terms. In particular <span class="math notranslate nohighlight">\(\Pi\)</span> gives a dependent function type and <span class="math notranslate nohighlight">\(\Sigma\)</span> gives a dependent pair type.</p>
</section>
<section id="common-connectives">
<h2>Common connectives<a class="headerlink" href="#common-connectives" title="Permalink to this heading"></a></h2>
<p>The idea behind <span class="math notranslate nohighlight">\(\bot\)</span> as contradiction is as follows: if we have a sequent <span class="math notranslate nohighlight">\(\Gamma \vdash A\otimes \neg A\)</span>, we can decompose this into sequents <span class="math notranslate nohighlight">\(\Gamma_1 \vdash A\)</span> and <span class="math notranslate nohighlight">\(\Gamma_2, A \vdash\)</span> where <span class="math notranslate nohighlight">\(\Gamma = \Gamma_1, \Gamma_2\)</span>. Then we can cut to derive the sequent <span class="math notranslate nohighlight">\(\Gamma \vdash\)</span>, and hence derive <span class="math notranslate nohighlight">\(\Gamma \vdash \bot\)</span>.</p>
<p>The notation <span class="math notranslate nohighlight">\(\land,\lor\)</span> is chosen because the structure-preserving translation from intuitionistic logic preserves the logical operators <span id="id9">[<a class="reference internal" href="../zzreferences.html#id42" title="Roberto Di Cosmo. Introduction to Linear Logic. MPRI course notes, 2015. URL: https://www.dicosmo.org/CourseNotes/LinLog/IntroductionLinearLogic.pdf (visited on 2020-05-13).">DC15</a>]</span>, hence some intuition arises from using it. The notation for times and par is trickier; times and par are both <a class="reference external" href="https://en.wikipedia.org/wiki/Monoidal_category">tensor/monoidal products</a> (identities <span class="math notranslate nohighlight">\(1,\bot\)</span>), and do not appear in classical logic. The fact that tuples are typically positive data leads us to privilege <span class="math notranslate nohighlight">\(\otimes\)</span> as the default product, agreeing with Girard.</p>
<p><span class="math notranslate nohighlight">\(\par\)</span> is the dual of <span class="math notranslate nohighlight">\(\otimes\)</span> in the sense that <span class="math notranslate nohighlight">\(A \par B \equiv \neg (\neg A \otimes \neg B)\)</span>; unfortunately for deciding a notation, this seems to be its only useful property. <span class="math notranslate nohighlight">\(\oplus, \odot ,\Box,\sharp, \bullet\)</span> and <span class="math notranslate nohighlight">\(*\)</span> have meanings (direct sum/coproduct, Hadamard product/XNOR gate/symmetric product, modal operator, music, multiplication/logical and, convolution) dissimilar from the function of <span class="math notranslate nohighlight">\(\par\)</span>. <span class="math notranslate nohighlight">\(\mathbin{{\scriptstyle+}\mkern-0.522em\raise{-0.077em}{\diamond}},\mathbin{{\vee}\mkern-0.815em\raise{0.09em}{\bigcirc}}\)</span> don’t have Unicode symbols so are hard to use. In the end none of the operators seems particularly evocative. <span class="math notranslate nohighlight">\(\par\)</span> on the other hand redirects to linear logic on Wikipedia. So we follow Girard.</p>
<section id="programming-types">
<h3>Programming types<a class="headerlink" href="#programming-types" title="Permalink to this heading"></a></h3>
<p>With the programming types we see the justification for the jumbo types: they can represent abstract data types (ADTs). Even though we can encode <span class="math notranslate nohighlight">\(\Pi,\Sigma\)</span> using the common connectives:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\Pi [(\#t_1,[A_{1,1},A_{1,2},\ldots] \multimap [B_{1,1},B_{1,2},\ldots]),\ldots] \equiv (\smash{\stackrel{-}{\neg}} A_{1,1} \par \smash{\stackrel{-}{\neg}} A_{1,2} \par \ldots \par B_{1,1} \par \ldots) \land \ldots\\\Sigma [(\#t_1,[A_{1,1},A_{1,2},\ldots] \multimap [B_{1,1},B_{1,2},\ldots]),\ldots] \equiv (A_{1,1} \otimes A_{1,2} \otimes \ldots \otimes \smash{\stackrel{+}{\neg}} B_{1,1} \otimes \ldots) \lor \ldots\end{aligned}\end{align} \]</div>
<p>With the encoding, we lose the free-form tags and have to use strings like “RRRRRL”. This leads to unbalanced proof trees and a general lack of expressiveness of the proof language.</p>
<p>Lambdas are in <span id="id10">[<a class="reference internal" href="../zzreferences.html#id103" title="John Maraist, Martin Odersky, David N. Turner, and Philip Wadler. Call-by-name, call-by-value, call-by-need, and the linear lambda calculus. Electronic Notes in Theoretical Computer Science, 1:370–392, January 1995. URL: http://www.sciencedirect.com/science/article/pii/S1571066104000222 (visited on 2020-08-23), doi:10.1016/S1571-0661(04)00022-2.">MOTW95</a>]</span>: Call by name lambdas are <span class="math notranslate nohighlight">\(\Omega_N = \bang \Omega_N \to \Omega_N\)</span>, Call by value or optimal lambdas are <span class="math notranslate nohighlight">\(\Omega_V = \bang (\Omega_V \to \Omega_V)\)</span>. But honestly I’m not sure about the definition, I found another paper that says these all expand to the same thing. So for now the definitions are here rather than in the reference.</p>
</section>
</section>
<section id="exponentials">
<h2>Exponentials<a class="headerlink" href="#exponentials" title="Permalink to this heading"></a></h2>
<p>There are two S4 modalities !/bang/”of course” (positive/affirmative) and the dual ?/whim/whimper/”why not” (negative).</p>
<section id="contraction">
<h3>Contraction<a class="headerlink" href="#contraction" title="Permalink to this heading"></a></h3>
<p>Instead of binary contraction we allow <span class="math notranslate nohighlight">\(n\)</span>-ary contraction for <span class="math notranslate nohighlight">\(n\geq 2\)</span>. This is equivalent to binary contraction but makes the proof trees a little more compact.</p>
</section>
<section id="subexponentials">
<h3>Subexponentials<a class="headerlink" href="#subexponentials" title="Permalink to this heading"></a></h3>
<p>In standard linear logic there are two S4 modalities !/bang/”of course” (positive) and the dual ?/whim/whimper/”why not” (negative). But if we introduce two modalities <span class="math notranslate nohighlight">\(\bang_1, \bang_2\)</span> with separate rules we cannot prove <span class="math notranslate nohighlight">\(\bang_1 A \equiv \bang_2 A\)</span>. So in keeping with the maximalist approach we present the logic with subexponentials. The subexponentials are like type annotations, in that we can erase all the subexponential labels to a single standard exponential, and we can infer subexponentials, computing the minimal subexponential structure necessary for the program to work. Subexponentials whose only operations are promotion/dereliction can be deleted from the program.</p>
<p>For notation, subexponentials look like <span class="math notranslate nohighlight">\(\bang^x_m,\whim^x_m\)</span> where <span class="math notranslate nohighlight">\(m\)</span> is in an index set <span class="math notranslate nohighlight">\(M \supseteq \{\cdot\}\)</span> and <span class="math notranslate nohighlight">\(x \in X, X = P(\{c, w, d\})\)</span>. <span class="math notranslate nohighlight">\(m=\cdot\)</span> is written <span class="math notranslate nohighlight">\(\bang^x,\whim^x\)</span>, and similarly <span class="math notranslate nohighlight">\(x=\{\}\)</span> is written as <span class="math notranslate nohighlight">\(\bang_m,\whim_m\)</span>, so that we recover the standard notation <span class="math notranslate nohighlight">\(\bang,\whim\)</span> for <span class="math notranslate nohighlight">\(m=\cdot,x=\{\}\)</span>. We can also write <span class="math notranslate nohighlight">\(\bang_{(m,x)},\whim_{(m,x)}\)</span>, or more simply <span class="math notranslate nohighlight">\(\bang_{m}\)</span> if the available operations are clear.</p>
<p>To use these we must define a relation <span class="math notranslate nohighlight">\(\leq\)</span> on <span class="math notranslate nohighlight">\((M,X)\)</span> such that <span class="math notranslate nohighlight">\(((M,X),\leq)\)</span> is a poset. <span class="math notranslate nohighlight">\(\leq\)</span> must have that <span class="math notranslate nohighlight">\((m,x) \leq (n,y)\)</span> only if <span class="math notranslate nohighlight">\(x\subseteq y\)</span>. Reflexivity ensures the identity theorem. Transitivity and the subset relation on <span class="math notranslate nohighlight">\(X\)</span> ensure cut elimination. Antisymmetry ensures that if <span class="math notranslate nohighlight">\(\bang^x_m A \equiv \bang^y_n A\)</span> then <span class="math notranslate nohighlight">\(m=n\)</span> and <span class="math notranslate nohighlight">\(x=y\)</span>, so that we do not have duplicate notation for a particular modality. We require <span class="math notranslate nohighlight">\((m,x) \leq (m,y)\)</span> for <span class="math notranslate nohighlight">\(x \subseteq y\)</span>, but the relation between different modalities may not be so simple.</p>
<p>The rule for promotion requires that <span class="math notranslate nohighlight">\((z,o)\leq (x_i,m_i)\)</span> and <span class="math notranslate nohighlight">\((z,o)\leq (y_i,n_i)\)</span> for the elements of the context.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
  \rule{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i } \vdash A, \overrightarrow{\whim^{y_i}_{n_i}\Delta_i} }{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i } \vdash \bang^z_o A, \overrightarrow{\whim^{y_i}_{n_i}\Delta_i}}{\bang}
  &amp;
  \rule{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i } , A\vdash \overrightarrow{\whim^{y_i}_{n_i}\Delta_i} }{\overrightarrow{\bang^{x_i}_{m_i} \Gamma_i }, \whim^z_o A \vdash \overrightarrow{\whim^{y_i}_{n_i}\Delta_i}}{\whim}

\end{array}</div><p>Dereliction requires <span class="math notranslate nohighlight">\(d \in x\)</span>.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
  \rule{\sk{\Gamma}, A \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^x_m A \vdash \sk{\Delta}}{\bang d}
&amp; \rule{\sk{\Gamma} \vdash A, \sk{\Delta} }{\sk{\Gamma} \vdash \whim^x_m A, \sk{\Delta}}{\whim d}
\end{array}</div><p>Weakening requires <span class="math notranslate nohighlight">\(w \in x\)</span>.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
    \rule{\sk{\Gamma} \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^x_m A \vdash \sk{\Delta}}{\bang w}
  &amp; \rule{\sk{\Gamma} \vdash \sk{\Delta} }{\sk{\Gamma} \vdash \whim^x_m A, \sk{\Delta}}{\whim w}
  \end{array}</div><p>Contraction requires <span class="math notranslate nohighlight">\(c \in x\)</span></p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
    \rule{\sk{\Gamma}, \overrightarrow{\bang^x_m A, \bang^x_m A, \cdots} \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^x_m A \vdash \sk{\Delta}}{\bang c_n}
  &amp; \rule{\sk{\Gamma} \vdash \overrightarrow{\whim^x_m A, \whim^x_m A, \cdots}, \sk{\Delta} }{\sk{\Gamma} \vdash \whim^x_m A, \sk{\Delta}}{\whim c_n}
\end{array}</div><p>We also allow quantification over subexponentials, as in <span id="id11">[<a class="reference internal" href="../zzreferences.html#id115" title="Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Proceedings of the 11th ACM SIGPLAN Conference on Principles and Practice of Declarative Programming - PPDP '09, 129. Coimbra, Portugal, 2009. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1599410.1599427 (visited on 2021-03-26), doi:10.1145/1599410.1599427.">NM09</a>]</span>.</p>
</section>
<section id="modalities">
<h3>Modalities<a class="headerlink" href="#modalities" title="Permalink to this heading"></a></h3>
<p>Because of the equivalences <span class="math notranslate nohighlight">\(\bang \bang A \equiv \bang A, \bang \whim \bang \whim A \equiv \bang \whim A\)</span>, there are only 7 modalities created from combining exponentials. They have the relationships as follows, where an arrow <span class="math notranslate nohighlight">\(A \to B\)</span> means <span class="math notranslate nohighlight">\(\vdash A \to B\)</span> is provable:  <span id="id12">[<a class="reference internal" href="../zzreferences.html#id32" title="Marcelo Coniglio and Francisco Miraglia. Equality in linear logic. Logique et Analyse, 39(153/154):113–151, January 2002. URL: https://www.researchgate.net/profile/Marcelo-Coniglio/publication/2387274_Equality_In_Linear_Logic/links/0deec5165a6babbd8a000000/Equality-In-Linear-Logic.pdf.">CM02</a>]</span></p>
<div class="graphviz"><object data="../_images/graphviz-8434b84e3ec932c372f6234328dc7cbfc0b0023b.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph G {
  rankdir=LR
  &quot;!A&quot; -&gt; &quot;A&quot;
  &quot;A&quot; -&gt;&quot;?A&quot;
  &quot;!A&quot; -&gt; &quot;!?!A&quot; -&gt; {&quot;!?A&quot;,&quot;?!A&quot;} -&gt; &quot;?!?A&quot; -&gt; &quot;?A&quot;
  subgraph C {
    rank=same
    &quot;A&quot;,&quot;!?A&quot;,&quot;?!A&quot;
  }
}</p></object></div>
<p>More generally with subexponentials:</p>
<ul class="simple">
<li><p>For <span class="math notranslate nohighlight">\((x,m)\geq(y,n)\)</span>, <span class="math notranslate nohighlight">\(\bang^x_m \bang^y_n A \equiv \bang^x_m A \equiv \bang^y_n \bang^x_m A\)</span>, and similarly for <span class="math notranslate nohighlight">\(\whim\)</span>.</p></li>
<li><p>For <span class="math notranslate nohighlight">\((x,n)\leq(z,p)\)</span> and <span class="math notranslate nohighlight">\((y,o)\leq(w,m)\)</span> we can prove <span class="math notranslate nohighlight">\(\bang^w_m \whim^x_n \bang^y_o \whim^z_p A \equiv \bang^w_m \whim^z_p A\)</span>.</p></li>
</ul>
<p>With subexponentials the possible combinations become infinite, for example alternating patterns like <span class="math notranslate nohighlight">\(\bang_1 \bang_2 \bang_1 \bang_2\)</span> cannot be simplified unless there is a relation in the poset between 1 and 2.</p>
</section>
</section>
<section id="polarized-logic">
<h2>Polarized logic<a class="headerlink" href="#polarized-logic" title="Permalink to this heading"></a></h2>
<p>Following <span id="id13">[<a class="reference internal" href="../zzreferences.html#id100" title="Yves Lafont. Linear logic pages. URL: http://iml.univ-mrs.fr/~lafont/pub/llpages.pdf.">Laf</a>]</span> we say a proposition <span class="math notranslate nohighlight">\(A\)</span> is positive if <span class="math notranslate nohighlight">\(A \leftrightarrow \bang A\)</span> and negative if <span class="math notranslate nohighlight">\(A \leftrightarrow \whim A\)</span>, and that is is polarized if it is either positive or negative. We can forget negative polarity by forming <span class="math notranslate nohighlight">\(A\otimes 1\)</span>, and positive polarity by <span class="math notranslate nohighlight">\(A \par \bot\)</span>, and ensure a proposition has no polarity by using both.</p>
<p><span class="math notranslate nohighlight">\(\Sigma\)</span> forms positive propositions and <span class="math notranslate nohighlight">\(\Pi\)</span> forms negative propositions, where in each case, the clauses <span class="math notranslate nohighlight">\(\vec A - \vec B\)</span> or <span class="math notranslate nohighlight">\(\vec A \multimap \vec B\)</span> are formed from positive subformulas <span class="math notranslate nohighlight">\(A_j\)</span> and negative subformulas <span class="math notranslate nohighlight">\(B_k\)</span>. Formulas <span class="math notranslate nohighlight">\(\bang A\)</span> are always positive while formulas <span class="math notranslate nohighlight">\(\whim A\)</span> are always negative.</p>
<p><span class="math notranslate nohighlight">\(BB = \text{Bool} \to \text{Bool}\)</span> is positive and doesn’t conform to the above rules.</p>
<p>The polarized negations and shifts show up in polarized / focused linear logic. We use the convention that an up shift raises a negative to positive (increases the value, hence points up). This is the original definition of <a class="reference external" href="https://www.seas.upenn.edu/~sweirich/types/archive/1991/msg00123.html">Girard’s</a>, <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">up</span> <span class="pre">N</span></code>. More recent papers such as <span id="id14">[<a class="reference internal" href="../zzreferences.html#id64" title="Jean-Yves Girard. Locus Solum: From the rules of logic to the logic of rules. Mathematical Structures in Computer Science, 11(3):301–506, June 2001. URL: https://www.cambridge.org/core/journals/mathematical-structures-in-computer-science/article/abs/locus-solum-from-the-rules-of-logic-to-the-logic-of-rules/6318E18EA633F9692D9CDBA9DE4438C9 (visited on 2022-03-27), doi:10.1017/S096012950100336X.">Gir01</a>]</span> and <span id="id15">[<a class="reference internal" href="../zzreferences.html#id168" title="Noam Zeilberger. The Logical Basis of Evaluation Order and Pattern-Matching. PhD thesis, Carnegie Mellon University, Pittsburgh, PA, April 2009. URL: https://software.imdea.org/~noam.zeilberger/thesis.pdf.">Zei09</a>]</span> seem to have lost this convention and use definitions of up-shift and down-shift reversed from ours. <span id="id16">[<a class="reference internal" href="../zzreferences.html#id115" title="Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Proceedings of the 11th ACM SIGPLAN Conference on Principles and Practice of Declarative Programming - PPDP '09, 129. Coimbra, Portugal, 2009. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1599410.1599427 (visited on 2021-03-26), doi:10.1145/1599410.1599427.">NM09</a>]</span> uses an alternate notation of delay operators <span class="math notranslate nohighlight">\(\delta^\pm(\cdot)\)</span> instead of shifts.</p>
<section id="cartesian-types">
<h3>Cartesian types<a class="headerlink" href="#cartesian-types" title="Permalink to this heading"></a></h3>
<p>Certain “cartesian” types, like booleans, integers, lists, and in general ADTs of cartesian types using <span class="math notranslate nohighlight">\(\Sigma\)</span>, have a “natural” proof of positivity that preserves the value. This is an extension of <span id="id17">[<a class="reference internal" href="../zzreferences.html#id59" title="Andrzej Filinski. Linear continuations. In Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL '92, 27–38. Albuquerque, New Mexico, USA, February 1992. Association for Computing Machinery. URL: https://doi.org/10.1145/143165.143174 (visited on 2020-06-19), doi:10.1145/143165.143174.">Fil92</a>]</span>’s observation in section 3.1 - we destruct the value, then use bang, then construct the same value. But <span class="math notranslate nohighlight">\(BB\)</span> from above can’t be cartesian because we cannot evaluate a function twice.</p>
<p>There’s similarly negative types with a “natural” proof using <span class="math notranslate nohighlight">\(\Pi\)</span>, e.g. for <span class="math notranslate nohighlight">\(D=\Pi[(\#l,[]\multimap []),(\#r,[]\multimap [])]\)</span>. We could call these co-cartesian types.</p>
<p>The conclusion is to be generous with exponentials and use them whenever you have a cartesian / co-cartesian type, so that the proof structure identifies those operations.</p>
</section>
<section id="tangent-reversible-computing">
<h3>Tangent: Reversible computing<a class="headerlink" href="#tangent-reversible-computing" title="Permalink to this heading"></a></h3>
<p>Another approach to duplication is “superstructural reversible logic” <span id="id18">[<a class="reference internal" href="../zzreferences.html#id147" title="Z A Sparks and Amr Sabry. Superstructural Reversible Logic. In 3rd International Workshop on Linearity. 2014. URL: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.720.5692&amp;rep=rep1&amp;type=pdf.">SS14</a>]</span>. In their calculus, duplicating any type (cartesian or not) is impossible, without using non-reversible rules. The non-reversible structural rules could be restricted to a modality similarly to how linear logic restricts contraction/weakening. But in Theseus <span id="id19">[<a class="reference internal" href="../zzreferences.html#id80" title="Roshan P James and Amr Sabry. Theseus: A High Level Language for Reversible Computing. In Work-in-Progress Report at Conference on Reversible Computation, 12. 2014. URL: https://legacy.cs.indiana.edu/~sabry/papers/theseus.pdf.">JS14</a>]</span> and even in the latest publication <span id="id20">[<a class="reference internal" href="../zzreferences.html#id28" title="Chao-Hong Chen and Amr Sabry. A computational interpretation of compact closed categories: reversible programming with negative and fractional types. Proceedings of the ACM on Programming Languages, 5(POPL):1–29, January 2021. URL: https://dl.acm.org/doi/10.1145/3434290 (visited on 2021-08-04), doi:10.1145/3434290.">CS21</a>]</span> they use standard higher-order functions to do most of the programming. So really a reversible program is a data type <code class="docutils literal notranslate"><span class="pre">Rev</span></code>, similar to how a normal program is a data type <code class="docutils literal notranslate"><span class="pre">Task</span></code>. The difference is that <code class="docutils literal notranslate"><span class="pre">Rev</span></code> contains isomorphisms rather than continuations.</p>
<p>In terms of support, I don’t think there’s much needed at present. With the DSL support Stroscot should be able to write isomorphisms similar to Theseus, and run them forwards/backwards like the <a class="reference external" href="https://github.com/DreamLinuxer/popl21-artifact">Agda code</a>. Once there is hardware/an ISA/an OS to target it should be straightforward to extend this basic support to a compiler.</p>
</section>
</section>
<section id="structural-rules">
<h2>Structural rules<a class="headerlink" href="#structural-rules" title="Permalink to this heading"></a></h2>
<p>As is usual for linear logic there are no structural rules for weakening or contraction (they are restricted to the exponentials above). And in Core we use a graph representation that internalizes the exchange rule, so there is not really an exchange rule either.</p>
<p>Restricting the exchange rule would result in an ordered type system / noncommutative logic, similar to a stack machine. But <span id="id21">[<a class="reference internal" href="../zzreferences.html#id141" title="Yunhe Shi, David Gregg, Andrew Beatty, and M. Anton Ertl. Virtual machine showdown: stack versus registers. In Proceedings of the 1st ACM/USENIX International Conference on Virtual Execution Environments, VEE '05, 153–163. New York, NY, USA, June 2005. Association for Computing Machinery. URL: https://dl.acm.org/doi/10.1145/1328195.1328197 (visited on 2021-06-29), doi:10.1145/1064979.1065001.">SGBE05</a>]</span> shows that a register model is much better for an implementation - the extra stack swapping instructions give no benefit. Similarly restricting associativity would turn sequent lists into a binary tree - but this also has no benefit, it would just be a lot of shuffling operations. The number of operators would explode because every tree structure / stack index would create a new operator. Overall messing with the exchange rule seems like a nothing burger - some theoretical papers, but no real meat.</p>
<p>The cut rule is technically a theorem; we can prove that any proof using cut can be reformulated to be cut-free. But the expansion may result in exponentially more rule applications.</p>
<p>Similarly the identity rule is a theorem for propositional logic: we can produce a proof tree for <span class="math notranslate nohighlight">\(A \vdash A\)</span> for any finite proposition <span class="math notranslate nohighlight">\(A\)</span> via expansion of all the cases. Using the identity rule speeds up reduction because it skips iterating through the structure, and it also allows manipulating (prefixes of) <a class="reference internal" href="../Reference/Logic.html#infinite"><span class="std std-ref">infinite</span></a> trees.</p>
</section>
<section id="quantifiers">
<h2>Quantifiers<a class="headerlink" href="#quantifiers" title="Permalink to this heading"></a></h2>
<p>To move from propositional to first-order logic we must extend the identity rule to allow terms. Some presentations call the identity rule “ax”, for identity axiom, but in general the identity rule is a theorem so this seems foolish. Instead we list the identity rule explicitly when needed.</p>
<p><a class="reference external" href="https://ncatlab.org/nlab/show/sequent+calculus">nLab</a> defines a substitution rule/theorem. There is a theorem that substitution rules can be eliminated from the proof tree, proven by taking the proof tree for <span class="math notranslate nohighlight">\(\Gamma \vdash \Delta\)</span> and replacing all its identities <span class="math notranslate nohighlight">\(x \vdash x\)</span> with identities <span class="math notranslate nohighlight">\(t \vdash t\)</span>. This requires <span class="math notranslate nohighlight">\(t \vdash t\)</span> to hold, hence we include it. If the identity rule is not used with <code class="docutils literal notranslate"><span class="pre">x</span></code> in the proof tree, then the identity rule is not needed for the substitution, but such a situation is unlikely.</p>
<p>Quantifiers also require the identity rule, because cut elimination applies substitution of <code class="docutils literal notranslate"><span class="pre">x</span></code> for <code class="docutils literal notranslate"><span class="pre">t</span></code> in the proof tree where <code class="docutils literal notranslate"><span class="pre">x</span></code> is a variable.</p>
<p>Cut elimination for quantifiers is sound because the number of quantifiers in the sequent decreases.</p>
</section>
<section id="logic-translations">
<h2>Logic translations<a class="headerlink" href="#logic-translations" title="Permalink to this heading"></a></h2>
<p>First we must define classical and intuitionistic logic. To define classical logic we simply add standard structural weakening and contraction rules to our linear logic. Then <span class="math notranslate nohighlight">\(A\otimes B \equiv A \land B\)</span>, <span class="math notranslate nohighlight">\(A\par B \equiv A \lor B\)</span>, and we obtain the usual classical logic with modalities <span id="id22">[<a class="reference internal" href="../zzreferences.html#id100" title="Yves Lafont. Linear logic pages. URL: http://iml.univ-mrs.fr/~lafont/pub/llpages.pdf.">Laf</a>]</span>; all the connectives decompose into or are equivalent to the standard ones. To define intuitionistic logic we take classical logic and restrict the right hand side of all sequents to have at most one consequent; various pi/sigma connectives cannot be used as they would create multiple consequents, and similarly right contraction cannot be used. We allow disallow right weakening to make the translation easier.</p>
<p>The translation from intuitionistic logic to linear logic decorates every proposition and subproposition with !. <span id="id23">[<a class="reference internal" href="../zzreferences.html#id42" title="Roberto Di Cosmo. Introduction to Linear Logic. MPRI course notes, 2015. URL: https://www.dicosmo.org/CourseNotes/LinLog/IntroductionLinearLogic.pdf (visited on 2020-05-13).">DC15</a>]</span></p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\left[\prod \limits_{i} \left(\overrightarrow{A_i} \multimap \overrightarrow{B_i}\right)\right]_I &amp;= \prod \limits_{i} \left(\overrightarrow{\bang\left[A_i\right]_I} \multimap \overrightarrow{\bang\left[B_i\right]_I}\right)\\\left[\sum \limits_{i} \left(\overrightarrow{A_i} - \overrightarrow{B_i}\right)\right]_I &amp;= \sum \limits_{i} \left(\overrightarrow{\bang\left[A_i\right]_I} - \overrightarrow{\bang\left[B_i\right]_I}\right)\end{aligned}\end{align} \]</div>
<p>We can translate classical logic into intuitionistic logic by decorating every proposition and subproposition with <span class="math notranslate nohighlight">\(\neg\neg\)</span> and moving the right to the left with another negation, i.e. <span class="math notranslate nohighlight">\(\Gamma \vdash \Delta \Rightarrow \Gamma', \neg \Delta' \vdash\)</span>. Thus the translation of classical logic into linear logic decorates like <span class="math notranslate nohighlight">\(\neg \bang (\neg \bang A) \equiv \whim \bang A\)</span>.</p>
<p>These two decoration translations preserve proof structure, in the sense that every intuitionistic/classical proof tree can be converted to a linear logic proof tree, and the reverse as well if the linear logic proof tree’s sequent is the result of the proposition translation.</p>
</section>
<section id="patterns">
<h2>Patterns<a class="headerlink" href="#patterns" title="Permalink to this heading"></a></h2>
<p>We call sequents of the form <span class="math notranslate nohighlight">\(\vdash A\)</span> proofs of <span class="math notranslate nohighlight">\(A\)</span>. Similarly sequents <span class="math notranslate nohighlight">\(A \vdash\)</span> are refutations of <span class="math notranslate nohighlight">\(A\)</span>. <span class="math notranslate nohighlight">\(\Sigma_R\)</span> constructs a proof from a collection of proofs and refutations, while <span class="math notranslate nohighlight">\(\Pi_L\)</span> constructs a refutation from a collection of proofs and refutations. We can similarly consider proof patterns <span class="math notranslate nohighlight">\(x, \ldots, z \vdash A\)</span> / refutation patterns <span class="math notranslate nohighlight">\(x,\ldots,z, A \vdash\)</span> where <span class="math notranslate nohighlight">\(x,\ldots,z\)</span> are free variables.</p>
<p>If we have a proof of <span class="math notranslate nohighlight">\(A\)</span> then <span class="math notranslate nohighlight">\(A\)</span> is a theorem (also called a tautology). If we prove a sequent <span class="math notranslate nohighlight">\(\Gamma \vdash\)</span> then <span class="math notranslate nohighlight">\(\Gamma\)</span> is a contradiction. We define equivalence <span class="math notranslate nohighlight">\(A\equiv B\)</span> as the theorem <span class="math notranslate nohighlight">\(\vdash A \leftrightarrow B\)</span>.</p>
</section>
<section id="definitions">
<h2>Definitions<a class="headerlink" href="#definitions" title="Permalink to this heading"></a></h2>
<p>I didn’t find any relevant papers on defining new notation for expressions in the sequent calculus. So we have to prove consistency ourselves. But I think the cut elimination theorem poses no problem, the key and commutative cases are trivial.</p>
<p>The identity rule fails if the notation expands via an infinite chain of definitions <span class="math notranslate nohighlight">\(A_1 = \ldots A_2 \ldots, A_2 = \ldots A_3 \ldots = \ldots\)</span>. For example for Russell’s paradox and the related <span class="math notranslate nohighlight">\(\{x : x \in x\}  \in \{x : x \in x\} = \{x : x \in x\}  \in \{x : x \in x\} = \ldots\)</span>. Hence we exclude such circular definitions by requiring the identity theorem to complete for all notations.</p>
<p>For the substitution theorem goes through with the same restriction on notation. The proof works by replacing variable identities <span class="math notranslate nohighlight">\(x \vdash x\)</span> with more complex identities <span class="math notranslate nohighlight">\(A \vdash A\)</span>.</p>
<p>Non-circularity is a pretty loose restriction. If we know a definition is size-decreasing, we can induct as usual to prove the identity theorem: use the basic identity theorem on non-definition subtrees, use the definition rule on both sides for each definition, and continue switching between the two until it’s built up. Hence we only have to be careful for definitions like sets that can increase size when expanded.</p>
</section>
<section id="set-theory">
<h2>Set theory<a class="headerlink" href="#set-theory" title="Permalink to this heading"></a></h2>
<p>The naive set theory definition comes from <span id="id24">[<a class="reference internal" href="../zzreferences.html#id139" title="Masaru Shirahata. Linear Set Theory. PhD thesis, Stanford University, February 1994. URL: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.29.7077&amp;rep=rep1&amp;type=pdf.">Shi94</a>]</span> (page 10). The rest of the definitions are similar to the ones in <span id="id25">[<a class="reference internal" href="../zzreferences.html#id142" title="Michael Shulman. Linear logic for constructive mathematics. arXiv:1805.07518 [math], May 2018. Comment: 39 pages. URL: http://arxiv.org/abs/1805.07518 (visited on 2021-03-04), arXiv:1805.07518.">Shu18</a>]</span> except <span class="math notranslate nohighlight">\(\in\)</span> is not affirmative.</p>
<section id="paradoxes">
<span id="id26"></span><h3>Paradoxes<a class="headerlink" href="#paradoxes" title="Permalink to this heading"></a></h3>
<p>It seems from playing with some examples that forbidding circular definitions is sufficient to prevent Russell’s paradox and Curry’s paradox. For example with <span class="math notranslate nohighlight">\(R = \{x\mid \whim \neg(x \in x)\}\)</span>, <span class="math notranslate nohighlight">\(\{x\mid F \} \in R\)</span> is defined (and provable) but <span class="math notranslate nohighlight">\(R \in R\)</span> is circular hence not defined. So we cannot write the premise of Russell’s paradox. We could try to work around this with a proposition like <span class="math notranslate nohighlight">\(t\in R \land t= R\)</span>. This is not circular, but it is not sufficient to derive a paradox, as in order to apply contraction we have to use a substitution that produces <span class="math notranslate nohighlight">\(R \in R\)</span>. Curry’s paradox <span class="math notranslate nohighlight">\(X=\{x\mid x\in x \to Y\}\)</span> similarly contains <span class="math notranslate nohighlight">\(x\in x\)</span> and hence the notation <span class="math notranslate nohighlight">\(X \in X\)</span> is circular and therefore forbidden as well.</p>
<p>More formally, suppose the logic is inconsistent, i.e. there is a derivation <span class="math notranslate nohighlight">\(\vdash \bot\)</span>. This must be derived from the empty sequent. Then what does cut elimination do? Either it completes, in which case we get a contradiction because no rule derives the empty sequent, or there’s some infinite chain of cut elimination. I claim the infinite chain only happens if there is a circular definition involved and the identity or substitution rules are on the sides. Hence, forbidding circular definitions in the identity and cut rules solves the issue.</p>
<p>The question of whether a given set comprehension is defined is undecidable, as we can encode the lambda calculus and hence the halting problem - the beta rule <span class="math notranslate nohighlight">\((\lambda x. A) t\)</span> does the same substitution as <span class="math notranslate nohighlight">\(t\in\{x\mid A\}\)</span>. We can approximate definedness with a termination checking algorithm, type system, or syntactic check:</p>
<ul class="simple">
<li><p>Strict comprehension, i.e. the bound variable can only appear once in the formula <span id="id27">[<a class="reference internal" href="../zzreferences.html#id140" title="Masaru Shirahata. Linear set theory with strict comprehension. In Proceedings of the Sixth Asian Logic Conference, 223–245. Beijing, China, April 1998. WORLD SCIENTIFIC / S'PORE UNIV PRESS (PTE) LTD. URL: http://www.worldscientific.com/doi/abs/10.1142/9789812812940_0013 (visited on 2021-03-06), doi:10.1142/9789812812940_0013.">Shi98</a>]</span> Very restrictive.</p></li>
<li><p>New Foundations’s stratified formulas <span id="id28">[<a class="reference internal" href="../zzreferences.html#id61" title="Thomas Forster. Quine’s New Foundations. In Edward N. Zalta, editor, The Stanford Encyclopedia of Philosophy. Metaphysics Research Lab, Stanford University, summer 2019 edition, 2019. URL: https://plato.stanford.edu/archives/sum2019/entries/quine-nf/ (visited on 2021-03-04).">For19</a>]</span> <span id="id29">[<a class="reference internal" href="../zzreferences.html#id75" title="M. Randall Holmes. Elementary Set Theory with a Universal Set. Bruylant-Academia, 1998. ISBN 978-2-87209-488-2. URL: https://randall-holmes.github.io/head.pdf.">Hol98</a>]</span> NFU + Infinity + Choice is known to be consistent with the theory of types with the Axiom of Infinity, and is a subtheory of ZFC + “there is an n-Mahlo cardinal for each concrete natural number n”. But the stratification is restrictive, e.g. we cannot define a set of sets that contain themselves even though this definition is well-founded.</p></li>
<li><p>Hindley-Milner type inference (since the simply typed lambda calculus terminates). Seems like a reasonable check.</p></li>
<li><p>A size-checking algorithm like in <span id="id30">[<a class="reference internal" href="../zzreferences.html#id81" title="Neil D. Jones and Nina Bohr. Call-by-value termination in the untyped lambda-calculus. Logical Methods in Computer Science, 4(1):3, March 2008. URL: http://arxiv.org/abs/0801.0882 (visited on 2021-03-06), arXiv:0801.0882, doi:10.2168/LMCS-4(1:3)2008.">JB08</a>]</span>. Seems to have unpredictable behavior, but may solve some things HM can’t.</p></li>
<li><p>Brute-force expansion. Also somewhat unpredictable.</p></li>
<li><p>Intersection type system. Typeable iff terminating, but undecidable in general and tricky to approximate. But should be strictly better than HM.</p></li>
</ul>
<p>There is also <span id="id31">[<a class="reference internal" href="../zzreferences.html#id138" title="Masaru Shirahata. A linear conservative extension of Zermelo-Fraenkel set theory. Studia Logica, 56(3):361–392, May 1996. URL: http://link.springer.com/10.1007/BF00372772 (visited on 2021-03-06), doi:10.1007/BF00372772.">Shi96</a>]</span> which allows sets built from ZF’s axioms.</p>
</section>
<section id="equality">
<h3>Equality<a class="headerlink" href="#equality" title="Permalink to this heading"></a></h3>
<p>The axioms of reflexivity, substitution, etc. can take a variety of modalities as in <span id="id32">[<a class="reference internal" href="../zzreferences.html#id32" title="Marcelo Coniglio and Francisco Miraglia. Equality in linear logic. Logique et Analyse, 39(153/154):113–151, January 2002. URL: https://www.researchgate.net/profile/Marcelo-Coniglio/publication/2387274_Equality_In_Linear_Logic/links/0deec5165a6babbd8a000000/Equality-In-Linear-Logic.pdf.">CM02</a>]</span>, some of them corresponding with intuitionistic and classical notions of equality. For sets we use linear weak extensional equality. Alternatively we could use intuitionistic equality <span class="math notranslate nohighlight">\(A\overset{!}{=}B \defeq !(A=B)\)</span>, then substitution is <span class="math notranslate nohighlight">\(A\overset{!}{=}B, \phi \vdash \phi[A/B]\)</span>. But the linear equality seems more useful.</p>
<p>Proof of the substitution property: For <span class="math notranslate nohighlight">\(\Pi\)</span> we use the right rule to split into cases for each tag, then we use contraction/weakening on <span class="math notranslate nohighlight">\(\bang(A=B)\)</span> to match the number of A’s/B’s in the case, then the left rule to split into each A and B, giving each branch a copy of the hypothesis. <span class="math notranslate nohighlight">\(\Sigma\)</span> is similar but with the left first. For exponentials, quantifiers, and set comprehension we simply do left/right in the correct order. Then at the end we use the hypothesis to change <span class="math notranslate nohighlight">\(A[x/a]\)</span> on the left or right to <span class="math notranslate nohighlight">\(B[x/b]\)</span>, or else weakening to remove the hypothesis followed by the identity.</p>
</section>
</section>
<section id="infinite-structures">
<h2>Infinite structures<a class="headerlink" href="#infinite-structures" title="Permalink to this heading"></a></h2>
<p>These are used to support infinite types like the lambda calculus or lists, and similarly infinite expressions like <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">x</span></code>. We construct “infinite” as a terminal coalgebra - our proof trees turn into fixed points of systems of formal equations <span id="id33">[<a class="reference internal" href="../zzreferences.html#id89" title="Panagis Karazeris, Apostolos Matzaris, and Jiří Velebil. Final coalgebras in accessible categories. Mathematical Structures in Computer Science, 21(5):1067–1108, October 2011. URL: https://www.cambridge.org/core/product/identifier/S0960129511000351/type/journal_article (visited on 2021-03-11), doi:10.1017/S0960129511000351.">KMV11</a>]</span>.</p>
<p>Infinite structures can be paradoxical, e.g. we can prove <span class="math notranslate nohighlight">\(\vdash\bot\)</span> using cut on the proposition <span class="math notranslate nohighlight">\(A=\neg A\)</span>. Cut elimination will often fail to complete, but there is a progress property in the sense that the cut can always be pushed down and eliminate an identity rule or two matching logical rules.</p>
</section>
<section id="hashing">
<h2>Hashing<a class="headerlink" href="#hashing" title="Permalink to this heading"></a></h2>
<p>To hash the graphs we can use the tree structure of the sequent derivations. Each upward slot in a node is hashed with a fixed value and each downward slot is hashed with a value corresponding to the path through the derivation tree followed by the label of the upward slot. It is written as a single DFS traversal with the leaves as base case that stores the hashed subtree and a map from edge name to partial path.</p>
<p>Hashing infinite graphs is harder, we have to hash each SCC as a unit. See <span id="id34">[<a class="reference internal" href="../zzreferences.html#id107" title="Laurent Mauborgne. An incremental unique representation for regular trees. Nordic Journal of Computing, 7(4):290–311, December 2000.">Mau00</a>]</span>.</p>
</section>
<section id="recursion">
<h2>Recursion<a class="headerlink" href="#recursion" title="Permalink to this heading"></a></h2>
<p>Sequent Core <span id="id35">[<a class="reference internal" href="../zzreferences.html#id47" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span> also introduces two more rules “multicut” and “rec” that are illogical but computationally useful:</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cc}
  \rule
    {\Gamma, \Theta \vdash \Delta, \Lambda \quad \Gamma', \Lambda \vdash \Theta, \Delta' }
    {\Gamma, \Gamma' \vdash \Delta, \Delta' }{\text{multicut}}
  &amp;
  \rule
    { \overrightarrow{\Gamma, \vec \Lambda, \Theta_i \vdash \Lambda_i, \vec \Theta, \Delta }}
    {\Gamma, \overrightarrow{\Theta_i} \vdash \overrightarrow{\Lambda_i}, \Delta }{\text{rec}}
\end{array}\]</div>
<p>These probably aren’t needed, the use-def and infinite structures and types encode recursion better and we can use GHC’s graph reduction model (below).</p>
<p>Alternately let can be encoded as a record and recursion via a fixed-point combinator or a cycle in the graph. In particular <span id="id36">[<a class="reference internal" href="../zzreferences.html#id96" title="Oleg Kiselyov. Many faces of the fixed-point combinator. August 2013. URL: http://okmij.org/ftp/Computation/fixed-point-combinators.html (visited on 2020-07-31).">Kis13</a>]</span> outline a polyvariadic combinator:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fix_poly</span><span class="w"> </span><span class="n">fl</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fix</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">self</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="w"> </span><span class="n">self</span><span class="p">)</span><span class="w"> </span><span class="n">fl</span><span class="p">)</span>
</pre></div>
</div>
<p>To implement <code class="docutils literal notranslate"><span class="pre">fix</span></code> we can use the variant of the Y combinator <span class="math notranslate nohighlight">\(\lambda f.(\lambda x.x x) (\lambda x.f (x x))\)</span>. To type it we need the cyclic/recursive type <span class="math notranslate nohighlight">\(Wr = \Pi[(^w, Wr, r)]\)</span> (in the sense of an infinite, regular tree).</p>
<p>BOHM uses a fan/duplication node combined with a loop.</p>
<section id="graph-reduction">
<h3>Graph reduction<a class="headerlink" href="#graph-reduction" title="Permalink to this heading"></a></h3>
<p>Following <span id="id37">[<a class="reference internal" href="../zzreferences.html#id82" title="Simon Peyton Jones. The Implementation of Functional Programming Languages. Prentice-Hall, 1987. \textbf Errata  \begin itemize \item Section 5.2.4, p87.  We need an extra rule \end itemize  match us [] E = E  This accounts for the possibility that in the constructor rule (Section 5.2.4) there may be some non-nullary constructors for which there are no equations.  \begin itemize \item P168, line 2, “VAR” should be “TVAR”. \end itemize. URL: https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/ (visited on 2020-08-02).">Jon87</a>]</span> chapter 12 we give each definition node a static integer. Then the root is a distinguished definition. Assuming the static data is stored on disk and paged in/out as needed, we can minimize runtime memory use in a compiler pass by introducing as many use-def indirections as possible, one for every sequent in the derivation. This also makes the connections between rules uniform. But having lots of indirections is inefficient so a later pass would remove indirections that will be immediately used (chunkification).</p>
<p>The optimal fixedpoint algorithm outlined in <span id="id38">[<a class="reference internal" href="../zzreferences.html#id136" title="Adi Shamir. The Fixedpoints of Recursive Definitions. PhD thesis, Weizmann Institute of Science, Rehovot, October 1976. URL: https://weizmann.primo.exlibrisgroup.com/permalink/972WIS_INST/1d4esio/alma990002185270203596.">Sha76</a>]</span> (10.18, PDF pages 240-242) is a variation of Tarjan’s strongly connected component algorithm. Cuts between two definitions <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> are memoized in a list, and if the SCC algorithm finds a component <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">let</span> <span class="pre">g</span> <span class="pre">=</span> <span class="pre">...</span> <span class="pre">in</span> <span class="pre">g</span> <span class="pre">(f</span> <span class="pre">x)</span></code> then this component is solved. If it has a unique solution then that’s the answer, otherwise <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> diverges and is replaced with a <code class="docutils literal notranslate"><span class="pre">RecursionError</span></code> or <code class="docutils literal notranslate"><span class="pre">AmbiguousError</span></code>. We assume the solver allows uninterpreted “holes”, so that the SCC can be solved before its sub-computations.</p>
<p>For comparison, to compute the least fixed point we would maintain a “working graph” and incrementally unfold the definition when encountered. But with the optimal fixed point we first reduce the definition to a value while copying other definitions in.</p>
<p>The solver is an SMT solver on the predicate <code class="docutils literal notranslate"><span class="pre">SAT(y</span> <span class="pre">==</span> <span class="pre">g</span> <span class="pre">y)</span></code>, and for uniqueness <code class="docutils literal notranslate"><span class="pre">UNSAT(y</span> <span class="pre">==</span> <span class="pre">g</span> <span class="pre">y</span> <span class="pre">&amp;&amp;</span> <span class="pre">y</span> <span class="pre">!=</span> <span class="pre">y0)</span></code> where <code class="docutils literal notranslate"><span class="pre">y0</span></code> is the first solution found. We exclude error values as possible solutions since the recursion error will be more informative.</p>
<p>The posets the paper uses appear to be pointed directed-complete partial orders <a class="reference external" href="https://en.wikipedia.org/wiki/Complete_partial_order">(cppo’s)</a>.</p>
</section>
</section>
<section id="primitives">
<h2>Primitives<a class="headerlink" href="#primitives" title="Permalink to this heading"></a></h2>
<p>Primitives (integers) can be handled by hacking special cases into Cut; we add primitive functions of type PiR that use the arguments provided by PiL during a cut, and also literals, special values of type SigmaR. Alternately we can use compressed graphs.</p>
<section id="compressed-graphs">
<h3>Compressed graphs<a class="headerlink" href="#compressed-graphs" title="Permalink to this heading"></a></h3>
<p>64-bit integers are represented as a sigma type with 2^64 possibilities. So addition is represented as a case expression, where each case contains another case expression, and then each case constructs the integer corresponding to the addition. There is a lot of fan-out at each step, which would require 2^128 values to represent, clearly infeasible. So although this is the conceptual representation, the actual representation has no fan-out for the cases - instead the case nodes create symbolic variables <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, and the constructed value has the tag <code class="docutils literal notranslate"><span class="pre">a+b</span></code>.</p>
</section>
</section>
<section id="confluent-reduction">
<h2>Confluent reduction<a class="headerlink" href="#confluent-reduction" title="Permalink to this heading"></a></h2>
<p>Reduction of our linear logic trees is not confluent, but only because of commuting cuts. If we drop the black edges and only consider proof nets, then the system is confluent. A cut only interacts with other cuts at identity rules, but with a cut-identity-cut pattern it doesn’t matter which cut reduces with the identity. (TODO: prove this formally)</p>
<p>Since reduction is confluent, it does not change anything to reduce in non-normal order for a time. The reduction will still terminate when going back to normal order. So terminating reductions can always be performed and even non-terminating reductions can be reduced somewhat. Hence during compilation we want to reduce the program as much as possible - ideally the compiled core should be cut-free. We can detect diverging terms and replace them with error terms. But we can’t eliminate cuts involving complex recursion, so have to create a heap or a stack allocation. For example the Fibonacci list <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">fibs</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">::</span> <span class="pre">1</span> <span class="pre">::</span> <span class="pre">zipWith</span> <span class="pre">(+)</span> <span class="pre">fibs</span> <span class="pre">(tail</span> <span class="pre">fibs)</span> <span class="pre">in</span> <span class="pre">{</span> <span class="pre">repeat</span> <span class="pre">forever</span> <span class="pre">{</span> <span class="pre">n</span> <span class="pre">&lt;-</span> <span class="pre">readInt;</span> <span class="pre">print</span> <span class="pre">(fibs</span> <span class="pre">!!</span> <span class="pre">n)</span> <span class="pre">}</span> <span class="pre">}</span></code>, this needs some kind of reduction graph or memo stack involved.</p>
</section>
<section id="levels">
<h2>Levels<a class="headerlink" href="#levels" title="Permalink to this heading"></a></h2>
<p>For the implementation of optimal reduction we can add level indices to the terms in the promotion and dereliction rules of <span class="math notranslate nohighlight">\(\bangc/\whimc\)</span>, as in <span id="id39">[<a class="reference internal" href="../zzreferences.html#id106" title="S. Martini and A. Masini. On the fine structure of the exponential rule. In Jean-Yves Girard, Yves Lafont, and Laurent Regnier, editors, Advances in Linear Logic, pages 197–210. Cambridge University Press, Cambridge, 1995. URL: https://pdfs.semanticscholar.org/b2cb/538c8ef21af42e48134a17a3c62ce5167837.pdf (visited on 2020-08-01), doi:10.1017/CBO9780511629150.010.">MM95</a>]</span> and <span id="id40">[<a class="reference internal" href="../zzreferences.html#id67" title="Stefano Guerrini. Theoretical and Practical Issues of Optimal Implementations of Functional Languages. PhD thesis, Università di Pisa. Dipartimento di Informatica, 1996. URL: https://www-lipn.univ-paris13.fr/~guerrini/mysite/sites/default/files/biblio/PhDThesis.pdf.">Gue96</a>]</span>. Conceptually all terms have indices, but we can recover the indices in a proof tree by propagating the indices from the promotion/dereliction rules up/down according to the criteria that the indices involved in all non-<span class="math notranslate nohighlight">\(\bangc/\whimc\)</span> promotion/dereliction rules must be the same.</p>
<p>To handle level indices in infinite trees, we store the difference function <code class="docutils literal notranslate"><span class="pre">\a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">(j-i)</span></code> and recover the levels by tracing from the root of the derivation tree (which is always level 0) and applying the difference function when encountered.</p>
<p>The level of a context is the maximum of the levels of its terms, 0 if it is empty.</p>
<div class="math notranslate nohighlight">
\[\begin{array}{ccc}
  \rule{\bangc\Gamma^i \vdash A^j, \whimc\Delta^i }{\bangc\Gamma^i \vdash \bangc A^i, \whimc\Delta^i}{\bangc}_{j = i+1}
  &amp; \rule{\sk{\Gamma^i}, A^i \vdash \sk{\Delta^i} }{\sk{\Gamma^i}, \bangc A^j \vdash \sk{\Delta^i}}{\bangc d}_{j\leq i}
  &amp; \rule{\sk{\Gamma}, \overrightarrow{\bangc A, \bangc A, \cdots} \vdash \sk{\Delta} }{\sk{\Gamma}, \bangc A \vdash \sk{\Delta}}{\bangc c_n}
\end{array}\]</div>
<div class="math notranslate nohighlight">
\[\begin{array}{ccc}
  \rule{\bangc\Gamma^i, A^j \vdash \whimc\Delta^i }{\bangc\Gamma^i, \whimc A^i \vdash \whimc\Delta^i}{\whimc}_{j = i+1}
  &amp; \rule{\sk{\Gamma^i} \vdash A^i, \sk{\Delta^i} }{\sk{\Gamma^i} \vdash \whimc A^j, \sk{\Delta^i}}{\whimc d}_{j \leq i}
  &amp; \rule{\sk{\Gamma} \vdash \overrightarrow{\whimc A, \whimc A, \cdots}, \sk{\Delta} }{\sk{\Gamma} \vdash \whimc A, \sk{\Delta}}{\whimc c_n}
\end{array}\]</div>
<p>To handle level mismatches we might also need lifting operators. The conditions are unclear.</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cc}
  \rule{\Gamma^i \vdash A^j, \Delta^i }{\Gamma^i \vdash A^i, \Delta^i}{\text{lift}_R}_{j &gt; i}
  &amp;
  \rule{\Gamma^i, A^j \vdash \Delta^i }{\Gamma^i, A^i \vdash \Delta^i}{\text{lift}_L}_{j &gt; i}
\end{array}\]</div>
<p>In practice I went with a different approach that generates matching <code class="docutils literal notranslate"><span class="pre">Dup</span></code> nodes, so the levels aren’t needed.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Library.html" class="btn btn-neutral float-left" title="Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="LogicProgramming.html" class="btn btn-neutral float-right" title="Logic programming" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>