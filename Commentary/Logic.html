<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Logic &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=7f41d439"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Logic programming" href="LogicProgramming.html" />
    <link rel="prev" title="Learning" href="Learning.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Aspects.html">Aspects</a></li>
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler-Library.html">Compiler library</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="FunctionalLogic.html">Functional logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Logic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#logic-style">Logic style</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-annotations">Type annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#jumbo-connective">Jumbo connective</a></li>
<li class="toctree-l3"><a class="reference internal" href="#common-connectives">Common connectives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#programming-types">Programming types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exponential">Exponential</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#contraction">Contraction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#subexponentials">Subexponentials</a></li>
<li class="toctree-l4"><a class="reference internal" href="#modalities">Modalities</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#classification-of-sequents">Classification of sequents</a></li>
<li class="toctree-l3"><a class="reference internal" href="#polarized-logic">Polarized logic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cartesian-types">Cartesian types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tangent-reversible-computing">Tangent: Reversible computing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#structural-rules">Structural rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quantifiers">Quantifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logic-translations">Logic translations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#set-theory">Set theory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#paradoxes">Paradoxes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#equality">Equality</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#recursion-and-infinite-structures">Recursion and infinite structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#confluent-reduction">Confluent reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#levels">Levels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="OpPrims.html">Operational primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Security.html">Security</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard-Library.html">Standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Symbolic.html">Symbolic computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Values.html">Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Logic</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Logic.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="logic">
<h1>Logic<a class="headerlink" href="#logic" title="Link to this heading"></a></h1>
<div class="math notranslate nohighlight">
\[\newcommand{\rule}[3]{ \dfrac{\displaystyle ~~#1~~ }{\displaystyle ~~#2~~ } \  (#3)}
\newcommand{\defeq}{\overset{\text{def}}{=}}
\newcommand{\with}{\mathbin{\mathrm{\&amp;}}}
\newcommand{\par}{\mathbin{\mathrm{⅋}}}
\newcommand{\multimapboth}{\mathbin{\mathrm{⧟}}}
\newcommand{\bang}{{\mathrm{!}}}
\newcommand{\whim}{{\mathrm{?}}}
\newcommand{\ocin}{\mathrel{\raise{-1pt}{\mathrm{!}}\mathord{\in}}}
\definecolor{mygray}{RGB}{156,156,156}
\newcommand{\sk}[1]{{\color{mygray} #1}}\]</div>
<p>The Curry-Howard correspondence maps logic to programming. A logical system specifies well-formed proofs of propositions. These correspond to well-formed programs in a simple type system. By proving the logic sound and complete, we get an expressive programming language.</p>
<section id="logic-style">
<h2>Logic style<a class="headerlink" href="#logic-style" title="Link to this heading"></a></h2>
<p>The use of sequent calculus is inspired by <span id="id1">[<a class="reference internal" href="../zzreferences.html#id49" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span>. Whereas a natural deduction logic results in reduction patterns similar to the lambda-calculus, sequent calculus divides the program into values and continuations. Reduction always takes place at a cut point with a value and a continuation. Continuations are exposed as first-class manipulable variables, similar to CPS, but as discussed in IR, CPS-based IRs have drawbacks that sequent calculus-style IRs do not.</p>
<p>Between classical, intuitionistic, and linear logic, I went with linear logic. It’s the most expressive, in that intuitionistic and classical logic can be encoded fairly naturally, but linear logic has more operators. Intuitionistic logic is traditional and has a direct machine implementation, but there is an operational semantics for linear logic <span id="id2">[]</span> and linear logic makes the expensive “copy term” operation more explicit. In intuitionistic logic, copying can happen anywhere in the reduction, which is harder to handle. The “boxes” of linear logic which demarcate copying boundaries are supposedly the basis of optimal reduction <span id="id3">[<a class="reference internal" href="../zzreferences.html#id69" title="Stefano Guerrini. Theoretical and Practical Issues of Optimal Implementations of Functional Languages. PhD thesis, Università di Pisa. Dipartimento di Informatica, 1996. URL: https://www-lipn.univ-paris13.fr/~guerrini/mysite/sites/default/files/biblio/PhDThesis.pdf.">Gue96</a>]</span>.</p>
<p>There are also other logics similar to Girard’s linear logic, like deep inference. Most papers on deep inference seem to add the <a class="reference external" href="https://ncatlab.org/nlab/show/mix+rule">mix rule</a> which corresponds to assuming <span class="math notranslate nohighlight">\(1 \leftrightarrow \bot\)</span>. This doesn’t seem attractive compared to plain linear logic - it proves contradiction as a theorem, hence loses the embedding of classical logic. <a class="reference external" href="https://www.pls-lab.org/en/Mix_rule">This page</a> mentions that mix holds in various models of linear logic such as coherent spaces and the game-theoretic semantics, but models are usually a simplification and there are models such as the syntactic model where mix doesn’t hold. <span id="id4">[<a class="reference internal" href="../zzreferences.html#id157" title="Lutz STRAßBURGER. Deep inference and expansion trees for second-order multiplicative linear logic. Mathematical Structures in Computer Science, 29(8):1030–1060, September 2019. URL: https://www.cambridge.org/core/product/identifier/S0960129518000385/type/journal_article (visited on 2022-08-11), doi:10.1017/S0960129518000385.">STR19</a>]</span> presents a deep inference system for non-mix MLL but says extending it to full LL is future work.</p>
<p>There is also the question of if, having removed weakening and contraction, the remaining structural rules, exchange and associativity, should be dropped. Linear logic gives the idea of the propositions being in named slots, as e.g. <span class="math notranslate nohighlight">\(\vdash A^a, B^b`\)</span> is for almost all purposes the same as <span class="math notranslate nohighlight">\(\vdash B^b, A^a`\)</span>, and only in some narrow cases would we want to differentiate them. This associative array semantics corresponds well to the RAM model. In contrast, dropping exchange gives non-commutative or ordered logic, leading to a stack or list on each side. But <span id="id5">[<a class="reference internal" href="../zzreferences.html#id146" title="Yunhe Shi, David Gregg, Andrew Beatty, and M. Anton Ertl. Virtual machine showdown: stack versus registers. In Proceedings of the 1st ACM/USENIX International Conference on Virtual Execution Environments, VEE '05, 153–163. New York, NY, USA, June 2005. Association for Computing Machinery. URL: https://dl.acm.org/doi/10.1145/1328195.1328197 (visited on 2021-06-29), doi:10.1145/1064979.1065001.">SGBE05</a>]</span> shows that a register model is much better for an implementation - the extra stack swapping instructions are more overhead than the additional register names. Stack-like access is just too restrictive. Similarly, dropping associativity gives a tree-like semantics, and trees are not iterable in constant time. The number of operators would explode because every tree structure / stack index would create a new operator. Hence linear logic is the clear winner. But, there seem to be reasonable ways of embedding linear logic in non-associative / non-commutative logic by adding associative / commutative modalities. <span id="id6">[<a class="reference internal" href="../zzreferences.html#id20" title="Eben Blaisdell, Max Kanovich, Stepan L. Kuznetsov, Elaine Pimentel, and Andre Scedrov. Non-associative, Non-commutative Multi-modal Linear Logic. In Jasmin Blanchette, Laura Kovács, and Dirk Pattinson, editors, Automated Reasoning, Lecture Notes in Computer Science, 449–467. Cham, 2022. Springer International Publishing. doi:10.1007/978-3-031-10769-6_27.">BKK+22</a>]</span> If there was a popular logic with such an embedding, then we could switch from linear logic to that. But per <span id="id7">[<a class="reference internal" href="../zzreferences.html#id114" title="Dale Miller. An Overview of Linear Logic Programming. In Thomas Ehrhard, Jean-Yves Girard, Paul Ruet, and Philip Scott, editors, Linear Logic in Computer Science, pages 119–150. Cambridge University Press, 1 edition, November 2004. URL: https://www.cambridge.org/core/product/identifier/CBO9780511550850A013/type/book_part (visited on 2021-04-02), doi:10.1017/CBO9780511550850.004.">Mil04</a>]</span> “no single [non-commutative] proposal seems to be canonical at this point.”</p>
<p><span id="id8">[<a class="reference internal" href="../zzreferences.html#id49" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span>  say “Sequent Core lies in between [intuitionistic and classical logic]: sometimes there can only be one conclusion, and sometimes there can be many.” Specifically, terms and types are intuitionistic (single conclusion), but commands, continuations and bindings are written to allow multiple propositions. Ret/Ax, WR/Name, and Jump/Label all introduce right-weakening. Linear logic seems a lot cleaner than this mess, but also lies between intuitionistic and classical logic, in that (like intuitionistic) there is no excluded middle, but also (like classical) there is duality and no limitation on the number of conclusions.</p>
<p>Linear logic can be formulated as two-sided, one-sided, or intuitionistic. I chose two-sided because again, it’s the most expressive. The two-sided sequent formulation preserves intent, e.g. the definition of proofs as sequents <span class="math notranslate nohighlight">\(\vdash A\)</span> is lost in the one-sided calculus as everything is of that form. Taking the two-sided logic as basic, the one sided logic can be formulated as a transformation that moves everything to the right side with negation and pushes down negations to atomic statements by applying duality. Such a transformation is of course useful, but forcing it to be applied from the start does not seem to serve much purpose. Intuitionistic logic doesn’t have negation - it has to be encoded as <span class="math notranslate nohighlight">\(A \to \bot\)</span>, pretty bad for trying to simplify connectives.</p>
<p>There is one advantage to one-sided, namely it reduces the number of positions, so a naive representation goes from two arrays of formulas/slots to one. But the one-sided logic still has dual connectives - for example an application of identity of par looks like <span class="math notranslate nohighlight">\(\vdash A \par B, A^\bot \otimes B^\bot\)</span> instead of <span class="math notranslate nohighlight">\(A \par B \vdash A \par B\)</span>. So we also should combine dual connectives, by adding a flag for polarity. But then we might as well adding a boolean for side as well, to recover the two-sided sequent logic. So we could represent a rule as (connective,polarity,side), where polarity is positive or negative, side is left or right, and the connectives themselves are unpolarized and unsided. This is how they are presented in the reference: the propositions are on the left and right of the sequent, and each connective is annotated with plus or minus. The only minor constraint of this notation is that left propositions are listed before right propositions, which is fine since the list of sequent propositions is unordered.</p>
<p>But polarity+side is not quite canonical as we have for example that the rule <span class="math notranslate nohighlight">\(𝕁^+_L\)</span> is the same structure as <span class="math notranslate nohighlight">\(𝕁^-_R\)</span>, and similarly <span class="math notranslate nohighlight">\(𝕁^-_L\)</span> is the same as <span class="math notranslate nohighlight">\(𝕁^+_R\)</span>. In the compiler, we would like to only have one datatype alternative for each rule structure, and then have a flag for distinguishing the remaining side/polarity bit. Looking at the rules:</p>
<ul class="simple">
<li><p>Class 1:</p>
<ul>
<li><p>J+R/J-L is a data constructor or function application</p></li>
<li><p>!+R/!-L is a box</p></li>
<li><p>Q+R/Q-L is also pretty much a box</p></li>
</ul>
</li>
<li><p>Class 2:</p>
<ul>
<li><p>!d-R/!d+L is an accessor, and weakening/contraction follow similar structure</p></li>
<li><p>J-R/J+L is a case statement</p></li>
<li><p>Q-R/Q+L is substituting a value in a derivation at the type level</p></li>
</ul>
</li>
</ul>
<p>Per ChatGPT, we can classify these as “build”/”break”, thus getting our desired bit. Actually we will use specific rule names most of the time, so we don’t need the bit. Then we can use the side as the second bit (as that is syntactic and easier to read from a sequent than polarity).</p>
</section>
<section id="type-annotations">
<h2>Type annotations<a class="headerlink" href="#type-annotations" title="Link to this heading"></a></h2>
<p>In <span id="id9">[<a class="reference internal" href="../zzreferences.html#id49" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span>, TyApp is written in natural deduction style. Actually, it seeems type annotations just sort of float around, they should not be part of the sequents at all. In my presentation of logic, terms are the proof trees, and propositions the types. So when it is written that ∀ and ∃ consume terms with types, like ∀R <span class="math notranslate nohighlight">\((\Gamma, a : \kappa \to v : \tau) \vdash (\Gamma \to \Lambda a : \kappa. v : \forall a : \kappa . \tau)\)</span>, <span class="math notranslate nohighlight">\(a : \kappa\)</span> is just an assertion, and I would instead just write <span class="math notranslate nohighlight">\((\Gamma \to \tau) \vdash (\Gamma \to \forall a : \kappa . \tau)\)</span>, where <span class="math notranslate nohighlight">\(a\)</span> has no free occurrence in <span class="math notranslate nohighlight">\(\Gamma\)</span> and is ambiently assumed to be of some type. Stroscot is a unityped language, so the types can just be ignored for now.</p>
</section>
<section id="jumbo-connective">
<h2>Jumbo connective<a class="headerlink" href="#jumbo-connective" title="Link to this heading"></a></h2>
<p>Based on <span id="id10">[<a class="reference internal" href="../zzreferences.html#id104" title="Paul Blain Levy. Jumbo λ-calculus. In Michele Bugliesi, Bart Preneel, Vladimiro Sassone, and Ingo Wegener, editors, Automata, Languages and Programming, Lecture Notes in Computer Science, 444–455. Berlin, Heidelberg, 2006. Springer. URL: https://www.cs.bham.ac.uk/~pbl/papers/jumboicalp.pdf, doi:10.1007/11787006_38.">Lev06</a>]</span>, Stroscot aims for the largest allowable set of operators. In particular we have one connective, the “jumbo” <span class="math notranslate nohighlight">\(𝕁\)</span> (double-struck capital J, decided per ChatGPT), which comes in two polarities <span class="math notranslate nohighlight">\(𝕁^+\)</span> and <span class="math notranslate nohighlight">\(𝕁^-\)</span>. <span class="math notranslate nohighlight">\(𝕁^+\)</span> is positive, and on the left (input) side it is data, like Levy’s <span class="math notranslate nohighlight">\(\Sigma\)</span> tuple rule. <span class="math notranslate nohighlight">\(𝕁^-\)</span> is negative, and on the right acts like Levy’s <span class="math notranslate nohighlight">\(\Pi\)</span> function rule. In both cases though they are more general, allowing multiple conclusions, dualization, and other features of linear logic. Each <span class="math notranslate nohighlight">\(𝕁\)</span> variant is defined relative to a case structure, like <span class="math notranslate nohighlight">\(𝕁 [(a, [A_{11},A_{12}] \vdash [B_{a1}]),(b, [A_{b1}] \vdash []), (c,[]-[B_{c1}])]\)</span>  We have a list of labels, <span class="math notranslate nohighlight">\(l_i, 1 \leq i \leq N\)</span>, and each label has left and right sequent propositions <span class="math notranslate nohighlight">\(A_{ij}\)</span> and <span class="math notranslate nohighlight">\(B_{ik}\)</span> where <span class="math notranslate nohighlight">\(1 \leq j \leq m_i, 1 \leq k \leq n_i\)</span>. Following Levy, we call <span class="math notranslate nohighlight">\(N\)</span> the length of the jumbo type and the list <span class="math notranslate nohighlight">\([(m_i,n_i)]\)</span> the jumbo-arity.</p>
<p>In <span id="id11">[<a class="reference internal" href="../zzreferences.html#id49" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span>, TLK/TRK correspond to an intuitionistic-style one-sided <span class="math notranslate nohighlight">\(𝕁^+\)</span> operator. But they have no corresponding <span class="math notranslate nohighlight">\(𝕁^-\)</span> operator, but rather Case/Deflt, which have no effect on the sequent type, hence no logical meaning. They say they considered adding “general existential types” which seems to be a <span class="math notranslate nohighlight">\(𝕁^-\)</span> operator in disguise, but mapping to GHC Core was too difficult and required a “heavy-handed encoding”. Since Stroscot is a new language, we can have a full set of jumbo operators to do all sorts of case-matching.</p>
<p>When the RHS of <span class="math notranslate nohighlight">\(𝕁^+\)</span> is nonempty we get terms with holes, that can be pattern-matched by filling the holes, e.g. <a class="reference external" href="https://en.wikipedia.org/wiki/Difference_list">difference lists</a>. (TODO: check that this actually gives efficient concatenation)</p>
<p>The dual of implication is called “subtraction” or “difference” and is denoted <span class="math notranslate nohighlight">\(-\)</span>. For an ADT, the RHS of the difference is empty, i.e. <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">A</span> <span class="pre">|</span> <span class="pre">b</span> <span class="pre">B1</span> <span class="pre">B2</span> <span class="pre">|</span> <span class="pre">C</span></code> looks like . This follows <span id="id12">[<a class="reference internal" href="../zzreferences.html#id166" title="Philip Wadler. Call-by-value is dual to call-by-name. In Proceedings of the Eighth ACM SIGPLAN International Conference on Functional Programming, ICFP '03, 189–201. Uppsala, Sweden, August 2003. Association for Computing Machinery. URL: http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf (visited on 2020-06-17), doi:10.1145/944705.944723.">Wad03</a>]</span> and <span id="id13">[<a class="reference internal" href="../zzreferences.html#id39" title="Tristan Crolard. A formulae-as-types interpretation of subtractive logic. Journal of Logic and Computation, 14(4):529–570, August 2004. URL: https://academic.oup.com/logcom/article/14/4/529/933555 (visited on 2020-06-18), doi:10.1093/logcom/14.4.529.">Cro04</a>]</span> but is flipped compared to Pi’s implication.</p>
<p>The jumbo connectives have the nice “unpacking” property that any combination of <span class="math notranslate nohighlight">\(𝕁^+\)</span> connectives is equivalent to a single <span class="math notranslate nohighlight">\(𝕁^+\)</span> connective, and likewise for <span class="math notranslate nohighlight">\(𝕁^-\)</span>.</p>
<p>The index <span class="math notranslate nohighlight">\(i\)</span> in Levy’s presentation is a tag drawn from a finite subset of a countable set of labels. But we can draw it from a subset of the universal set and hence get dependent types that depend on terms. In particular <span class="math notranslate nohighlight">\(𝕁^-\)</span> gives a dependent function type and <span class="math notranslate nohighlight">\(𝕁^+\)</span> gives a dependent pair type.</p>
</section>
<section id="common-connectives">
<h2>Common connectives<a class="headerlink" href="#common-connectives" title="Link to this heading"></a></h2>
<p>Girard chose his notation mainly for convenience, in particular he avoided the common symbols of logical connectives so that he didn’t have to mark classical logical connectives vs. linear logic connectives. Since Stroscot only uses one logic style, we aren’t limited by such considerations.</p>
<p>Per the structure-preserving “plethoric” translation in <span id="id14">[<a class="reference internal" href="../zzreferences.html#id44" title="Roberto Di Cosmo. Introduction to Linear Logic. MPRI course notes, 2015. URL: https://www.dicosmo.org/CourseNotes/LinLog/IntroductionLinearLogic.pdf (visited on 2020-05-13).">DC15</a>]</span>, section 2.1, PDF page 30, the linear logic operators that correspond to intuitionistic logic’s conjunction/disjunction are the additive binary connectives, Girard’s <span class="math notranslate nohighlight">\(\with\)</span> and <span class="math notranslate nohighlight">\(\oplus\)</span>. Girard’s notation doesn’t express their duality at all so it has to be replaced. Per Wikipedia, the customary symbols are <span class="math notranslate nohighlight">\(\land / \lor\)</span>, programming uses <span class="math notranslate nohighlight">\(\with / \vert\)</span>, and there is also the electronics notation <span class="math notranslate nohighlight">\(\cdot / +\)</span>. ChatGPT says <span class="math notranslate nohighlight">\(\land / \lor\)</span> is 80% of usage so that’s what I went with.</p>
<p>For <span class="math notranslate nohighlight">\(\otimes\)</span>, it is a <a class="reference external" href="https://en.wikipedia.org/wiki/Monoidal_category">tensor/monoidal product</a> so the symbol is natural. Technically <span class="math notranslate nohighlight">\(\par\)</span> is a tensor product too, but the fact that tuples are typically positive data leads us to privilege one over the other. And it agrees with Girard, although I think he chose <span class="math notranslate nohighlight">\(\otimes\)</span> to go with <span class="math notranslate nohighlight">\(\oplus\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\par\)</span> is the dual of <span class="math notranslate nohighlight">\(\otimes\)</span> in the sense that <span class="math notranslate nohighlight">\(A \par B \equiv \neg (\neg A \otimes \neg B)\)</span>; unfortunately for deciding a notation, this seems to be its only useful property. Looking at the literature, <span class="math notranslate nohighlight">\(\oplus, \odot ,\Box,\sharp, \bullet\)</span> and <span class="math notranslate nohighlight">\(*\)</span> have meanings (direct sum/coproduct, Hadamard product/XNOR gate/symmetric product, modal operator, music, multiplication/logical and, convolution) dissimilar from the function of <span class="math notranslate nohighlight">\(\par\)</span>. <span class="math notranslate nohighlight">\(\mathbin{{\scriptstyle+}\mkern-0.522em\raise{-0.077em}{\diamond}},\mathbin{{\vee}\mkern-0.815em\raise{0.09em}{\bigcirc}}\)</span> don’t have Unicode symbols so are hard to use. In the end none of the operators seems particularly evocative. <span class="math notranslate nohighlight">\(\par\)</span> on the other hand redirects to linear logic on Wikipedia. So again we follow Girard.</p>
<p>Then we have the units for each of these connectives. I’m most confident in my choice of <span class="math notranslate nohighlight">\(\bot\)</span> as the unit for <span class="math notranslate nohighlight">\(\par\)</span>. It is usually used for denoting the absurdity derived from a contradiction, and indeed we can prove <span class="math notranslate nohighlight">\(A, \neg A \vdash \bot\)</span> and <span class="math notranslate nohighlight">\(\neg A \equiv A \to \bot\)</span> starting from the identity rule. It also agrees with Girard.</p>
<p>For the unit of the tensor product, it’s the standard unit type in programming, so <code class="docutils literal notranslate"><span class="pre">()</span></code> is a possibility, but in the math-style semantics the unit type is traditionally represented as <span class="math notranslate nohighlight">\(\mathbb{1}\)</span>, matching Girard. I went with an unstyled <span class="math notranslate nohighlight">\(1\)</span> for ease of input. Another choice would be the tee symbol <span class="math notranslate nohighlight">\(\top\)</span> to be the dual of <span class="math notranslate nohighlight">\(\bot\)</span>, but this conflicts with Girard’s usage of that symbol.</p>
<p>The units of <span class="math notranslate nohighlight">\(\lor / \land\)</span> are logical false / logical true. Looking at choices, <span class="math notranslate nohighlight">\(\bot / \top\)</span> is out because <span class="math notranslate nohighlight">\(\bot\)</span> is already taken. IMO it’s pretty confusing that in Girard’s notation <span class="math notranslate nohighlight">\(\bot\)</span> is not the dual of <span class="math notranslate nohighlight">\(\top\)</span>. <span class="math notranslate nohighlight">\(0/1\)</span> is pretty common, but conflicts with using <span class="math notranslate nohighlight">\(1\)</span> for the unit of <span class="math notranslate nohighlight">\(\otimes\)</span>. <span class="math notranslate nohighlight">\(T/F\)</span> is clear enough and doesn’t conflict, so that’s what I went with.</p>
<p>The negations and shifts show up in polarized / focused linear logic. We use the convention that an up shift raises a negative to positive (increases the value, hence points up). This is the original definition of <a class="reference external" href="https://www.seas.upenn.edu/~sweirich/types/archive/1991/msg00123.html">Girard’s</a>, <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">up</span> <span class="pre">N</span></code>. More recent papers such as <span id="id15">[<a class="reference internal" href="../zzreferences.html#id66" title="Jean-Yves Girard. Locus Solum: From the rules of logic to the logic of rules. Mathematical Structures in Computer Science, 11(3):301–506, June 2001. URL: https://www.cambridge.org/core/journals/mathematical-structures-in-computer-science/article/abs/locus-solum-from-the-rules-of-logic-to-the-logic-of-rules/6318E18EA633F9692D9CDBA9DE4438C9 (visited on 2022-03-27), doi:10.1017/S096012950100336X.">Gir01</a>]</span> and <span id="id16">[<a class="reference internal" href="../zzreferences.html#id173" title="Noam Zeilberger. The Logical Basis of Evaluation Order and Pattern-Matching. PhD thesis, Carnegie Mellon University, Pittsburgh, PA, April 2009. URL: https://software.imdea.org/~noam.zeilberger/thesis.pdf.">Zei09</a>]</span> seem to have lost this convention and use definitions of up-shift and down-shift reversed from ours. <span id="id17">[<a class="reference internal" href="../zzreferences.html#id119" title="Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Proceedings of the 11th ACM SIGPLAN Conference on Principles and Practice of Declarative Programming - PPDP '09, 129. Coimbra, Portugal, 2009. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1599410.1599427 (visited on 2021-03-26), doi:10.1145/1599410.1599427.">NM09</a>]</span> uses an alternate notation of delay operators <span class="math notranslate nohighlight">\(\delta^\pm(\cdot)\)</span> instead of shifts.</p>
<section id="programming-types">
<h3>Programming types<a class="headerlink" href="#programming-types" title="Link to this heading"></a></h3>
<p>With the programming types we see the justification for the jumbo types: they can represent abstract data types (ADTs). Even though we can encode <span class="math notranslate nohighlight">\(𝕁\)</span> using the common connectives:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}𝕁^- [(\#t_1,[A_{1,1},A_{1,2},\ldots] \vdash [B_{1,1},B_{1,2},\ldots]),\ldots] \equiv (\smash{\stackrel{-}{\neg}} A_{1,1} \par \smash{\stackrel{-}{\neg}} A_{1,2} \par \ldots \par B_{1,1} \par \ldots) \land \ldots\\𝕁^+ [(\#t_1,[A_{1,1},A_{1,2},\ldots] \vdash [B_{1,1},B_{1,2},\ldots]),\ldots] \equiv (A_{1,1} \otimes A_{1,2} \otimes \ldots \otimes \smash{\stackrel{+}{\neg}} B_{1,1} \otimes \ldots) \lor \ldots\end{aligned}\end{align} \]</div>
<p>With the encoding, we lose the free-form tags and have to use strings like “RRRRRL”. This leads to unbalanced proof trees and a general lack of expressiveness of the proof language.</p>
<p>Lambdas have several conflicting definitions, so I have left them out. <span id="id18">[<a class="reference internal" href="../zzreferences.html#id105" title="John Maraist, Martin Odersky, David N. Turner, and Philip Wadler. Call-by-name, call-by-value, call-by-need, and the linear lambda calculus. Electronic Notes in Theoretical Computer Science, 1:370–392, January 1995. URL: http://www.sciencedirect.com/science/article/pii/S1571066104000222 (visited on 2020-08-23), doi:10.1016/S1571-0661(04)00022-2.">MOTW95</a>]</span> says call by name lambdas are <span class="math notranslate nohighlight">\(\Omega_N = \bang^+ \Omega_N \to \Omega_N\)</span>, and call by value lambdas are <span class="math notranslate nohighlight">\(\Omega_V = \bang^+ (\Omega_V \to \Omega_V)\)</span>. <span id="id19">[<a class="reference internal" href="../zzreferences.html#id61" title="Andrzej Filinski. Linear continuations. In Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL '92, 27–38. Albuquerque, New Mexico, USA, February 1992. Association for Computing Machinery. URL: https://doi.org/10.1145/143165.143174 (visited on 2020-06-19), doi:10.1145/143165.143174.">Fil92</a>]</span> agrees on call by name lambdas, but says call by value lambdas are <span class="math notranslate nohighlight">\(\Omega_V = \bang^+ (\Omega_V \to \bang^- \Omega_V)\)</span>. A paper I forgot to cite points out that most of these expand to the same infinite type so are equivalent, making me wonder if these types actually represent differing reduction strategies at all.</p>
</section>
</section>
<section id="exponential">
<h2>Exponential<a class="headerlink" href="#exponential" title="Link to this heading"></a></h2>
<p>The exponential is an S4 modality. Again it comes in two polarities. These are usually written ! (bang/”of course”, positive) and ? (whim/whimper/”why not”, negative) but to make polarity explicit we write <span class="math notranslate nohighlight">\(\bang^+\)</span> (equivalent to !) and <span class="math notranslate nohighlight">\(\bang^-\)</span> (equivalent to ?). ! was chosen as the base symbol because use of ? is rather rare.</p>
<section id="contraction">
<h3>Contraction<a class="headerlink" href="#contraction" title="Link to this heading"></a></h3>
<p>Instead of binary contraction we allow <span class="math notranslate nohighlight">\(n\)</span>-ary contraction for <span class="math notranslate nohighlight">\(n\geq 2\)</span>. This is equivalent to binary contraction but makes the proof trees a little more compact.</p>
</section>
<section id="subexponentials">
<h3>Subexponentials<a class="headerlink" href="#subexponentials" title="Link to this heading"></a></h3>
<p>Standard linear logic only contains bang and whim. But per <span id="id20">[<a class="reference internal" href="../zzreferences.html#id119" title="Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Proceedings of the 11th ACM SIGPLAN Conference on Principles and Practice of Declarative Programming - PPDP '09, 129. Coimbra, Portugal, 2009. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1599410.1599427 (visited on 2021-03-26), doi:10.1145/1599410.1599427.">NM09</a>]</span> these are not “canonical” - if we introduce two modalities <span class="math notranslate nohighlight">\(\bang_1, \bang_2\)</span> with distinct but identical rules, we cannot prove <span class="math notranslate nohighlight">\(\bang_1 A \equiv \bang_2 A\)</span>. So in keeping with the maximalist approach we present here the logic with subexponentials. The subexponentials function as annotations on exponentials, in that we can erase all the subexponential labels to a single standard exponential, and we can infer subexponential labels, computing the minimal subexponential structure necessary for the program to work. Subexponentials whose only operations are promotion/dereliction can be deleted from the program. <span id="id21">[]</span></p>
<p>For notation, there’s a lot of choices. I propose <span class="math notranslate nohighlight">\(\bang^\pm_S\)</span> (with <span class="math notranslate nohighlight">\(S = (m,x) \in (M,X)\)</span>), where <span class="math notranslate nohighlight">\(m\)</span> is in an index set <span class="math notranslate nohighlight">\(M\)</span> and <span class="math notranslate nohighlight">\(x \in X, X = P(\{c, w\})\)</span>. <span class="math notranslate nohighlight">\(\bang^\pm\)</span> are the well-known full exponentials <span class="math notranslate nohighlight">\(m=\cdot,x=\{c,w,d\}\)</span>, as is standard.</p>
<p>To use these we must define a relation <span class="math notranslate nohighlight">\(\leq\)</span> on <span class="math notranslate nohighlight">\((M,X)\)</span> such that <span class="math notranslate nohighlight">\(((M,X),\leq)\)</span> is a poset and satisfies two more requirements:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\((m,x) \leq (n,y)\)</span> implies <span class="math notranslate nohighlight">\(x\subseteq y\)</span>.</p></li>
<li><p>if <span class="math notranslate nohighlight">\(x \subseteq y\)</span>, then <span class="math notranslate nohighlight">\((m,x) \leq (m,y)\)</span> for all <span class="math notranslate nohighlight">\(m\)</span>.</p></li>
</ol>
<p>Justifying these:</p>
<ul class="simple">
<li><p>Reflexivity ensures the identity theorem.</p></li>
<li><p>Transitivity and the first requirement ensure cut elimination.</p></li>
<li><p>Antisymmetry ensures that if <span class="math notranslate nohighlight">\(\bang^+_M A \equiv \bang^+_N A\)</span> then <span class="math notranslate nohighlight">\(m=n\)</span> and <span class="math notranslate nohighlight">\(x=y\)</span>, so that we do not have duplicate notation for a particular modality.</p></li>
<li><p>The second requirement is not strictly necessary, but makes the notation more coherent. If it is not satisfied we can simply split the index <span class="math notranslate nohighlight">\(m\)</span> into two or more indexes <span class="math notranslate nohighlight">\(m_i\)</span>.</p></li>
</ul>
<p>The rule for promotion requires that <span class="math notranslate nohighlight">\(Z \leq M_i\)</span> and <span class="math notranslate nohighlight">\(Z \leq N_i\)</span> for the elements of the context.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
  \rule{\overrightarrow{\bang^+_{M_i} \Gamma_i } \vdash A, \overrightarrow{\bang^{-}_{N_i}\Delta_i} }{\overrightarrow{\bang^{+}_{M_i} \Gamma_i } \vdash \bang^{+}_Z A, \overrightarrow{\bang^{-}_{N_i}\Delta_i}}{\bang^+}
  &amp;
  \rule{\overrightarrow{\bang^+_{M_i} \Gamma_i }, A \vdash \overrightarrow{\bang^{-}_{N_i}\Delta_i} }{\overrightarrow{\bang^{+}_{M_i} \Gamma_i } ,\bang^{-}_Z A \vdash \overrightarrow{\bang^{-}_{N_i}\Delta_i}}{\bang^-}
\end{array}</div><p>Dereliction is allowed unconditionally, so that the identity rule holds.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
  \rule{\sk{\Gamma}, A \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^+_M A \vdash \sk{\Delta}}{\bang^+ d}
&amp; \rule{\sk{\Gamma} \vdash A, \sk{\Delta} }{\sk{\Gamma} \vdash \bang^-_M A, \sk{\Delta}}{\bang^- d}
\end{array}</div><p>Weakening requires <span class="math notranslate nohighlight">\(w \in \text{snd} M\)</span>.</p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
    \rule{\sk{\Gamma} \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^+_M A \vdash \sk{\Delta}}{\bang^+ w}
  &amp; \rule{\sk{\Gamma} \vdash \sk{\Delta} }{\sk{\Gamma} \vdash \bang^-_M A, \sk{\Delta}}{\bang^- w}
  \end{array}</div><p>Contraction requires <span class="math notranslate nohighlight">\(c \in \text{snd} M\)</span></p>
<div class="math notranslate nohighlight">
\begin{array}{cc}
    \rule{\sk{\Gamma}, \overrightarrow{\bang^+_M A, \bang^+_M A, \cdots} \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^+_M A \vdash \sk{\Delta}}{\bang^+ c}
  &amp; \rule{\sk{\Gamma} \vdash \overrightarrow{\bang^-_M A, \bang^-_M A, \cdots}, \sk{\Delta} }{\sk{\Gamma} \vdash \bang^-_M A, \sk{\Delta}}{\bang^- c}
\end{array}</div><p>We also allow quantification over subexponentials, as in <span id="id22">[<a class="reference internal" href="../zzreferences.html#id119" title="Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Proceedings of the 11th ACM SIGPLAN Conference on Principles and Practice of Declarative Programming - PPDP '09, 129. Coimbra, Portugal, 2009. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1599410.1599427 (visited on 2021-03-26), doi:10.1145/1599410.1599427.">NM09</a>]</span>.</p>
</section>
<section id="modalities">
<h3>Modalities<a class="headerlink" href="#modalities" title="Link to this heading"></a></h3>
<p>Because of the equivalences <span class="math notranslate nohighlight">\(\bang^\pm \bang^\pm A \equiv \bang^\pm A, \bang^\pm \bang^\mp \bang^\pm \bang^\mp A \equiv \bang^\pm \bang^\mp A\)</span>, there are only 7 modalities created from combining exponentials. They have the relationships as follows, where an arrow <span class="math notranslate nohighlight">\(A \to B\)</span> means <span class="math notranslate nohighlight">\(\vdash A \to B\)</span> is provable:  <span id="id23">[<a class="reference internal" href="../zzreferences.html#id34" title="Marcelo Coniglio and Francisco Miraglia. Equality in linear logic. Logique et Analyse, 39(153/154):113–151, January 2002. URL: https://www.researchgate.net/profile/Marcelo-Coniglio/publication/2387274_Equality_In_Linear_Logic/links/0deec5165a6babbd8a000000/Equality-In-Linear-Logic.pdf.">CM02</a>]</span></p>
<div class="graphviz"><object data="../_images/graphviz-f4da700b12f2e834866998539e17421fe1c68172.svg" type="image/svg+xml" class="graphviz">
<p class="warning">digraph G {
  rankdir=LR
  &quot;+A&quot; -&gt; &quot;A&quot;
  &quot;A&quot; -&gt;&quot;-A&quot;
  &quot;+A&quot; -&gt; &quot;+-+A&quot; -&gt; {&quot;+-A&quot;,&quot;-+A&quot;} -&gt; &quot;-+-A&quot; -&gt; &quot;-A&quot;
  subgraph C {
    rank=same
    &quot;A&quot;,&quot;+-A&quot;,&quot;-+A&quot;
  }
}</p></object></div>
<p>More generally with subexponentials:</p>
<ul class="simple">
<li><p>For <span class="math notranslate nohighlight">\(M \geq N\)</span>, <span class="math notranslate nohighlight">\(\bang^+_M \bang^+_N A \equiv \bang^+_M A \equiv \bang^+_N \bang^+_M A\)</span>, and identically with <span class="math notranslate nohighlight">\(\bang^-\)</span>.</p></li>
<li><p>For <span class="math notranslate nohighlight">\(N \leq P\)</span> and <span class="math notranslate nohighlight">\(O \leq M\)</span> we can prove <span class="math notranslate nohighlight">\(\bang^+_M \bang^-_N \bang^+_O \bang^-_P A \equiv \bang^+_M \bang^-_P A\)</span>.</p></li>
</ul>
<p>With distinguished subexponentials the possible modalities become infinite, for example alternating patterns like <span class="math notranslate nohighlight">\(\bang_1 \bang_2 \bang_1 \bang_2\)</span> cannot be simplified unless there is a relation in the poset between 1 and 2. But of course if we erase the index labels then <span class="math notranslate nohighlight">\(\bang \bang \bang \bang A \equiv \bang A\)</span>. Due to this, I think keeping the “well-known” subexponentials in the IR is fine and informative, but distinguished subexponentials should be avoided except during a pass that reduces exponential strength and eliminates unnecessary exponentials.</p>
</section>
</section>
<section id="classification-of-sequents">
<h2>Classification of sequents<a class="headerlink" href="#classification-of-sequents" title="Link to this heading"></a></h2>
<p><span id="id24">[<a class="reference internal" href="../zzreferences.html#id49" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span> splits the space of sequents into four sets: commands <span class="math notranslate nohighlight">\(\Gamma \vdash \Delta\)</span>, terms <span class="math notranslate nohighlight">\(\Gamma \vdash \tau\)</span>, continuations <span class="math notranslate nohighlight">\(\Gamma, \tau \vdash \Delta\)</span>, and bindings <span class="math notranslate nohighlight">\(\Gamma, \Delta' \vdash \Gamma', \Delta\)</span> (noting that <span class="math notranslate nohighlight">\(\mid\)</span> is synonymous with “,”). These clearly overlap, and the restrictions on what can be used where seem arbitrary.</p>
<p>It seems easier to follow <span id="id25">[<a class="reference internal" href="../zzreferences.html#id102" title="Yves Lafont. Linear logic pages. URL: http://iml.univ-mrs.fr/~lafont/pub/llpages.pdf.">Laf</a>]</span> and classify proofs by properties of their sequent:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\vdash A\)</span> is a proof of <span class="math notranslate nohighlight">\(A\)</span>. <span class="math notranslate nohighlight">\(A\)</span> is said to be a theorem or tautology. The theorem <span class="math notranslate nohighlight">\(\vdash A \leftrightarrow B\)</span> shows equivalence <span class="math notranslate nohighlight">\(A\equiv B\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(A \vdash\)</span> or <span class="math notranslate nohighlight">\(A \vdash \bot\)</span> is a refutation of <span class="math notranslate nohighlight">\(A\)</span>. <span class="math notranslate nohighlight">\(A\)</span> is said to be an absurdity.</p></li>
<li><p><span class="math notranslate nohighlight">\(\Gamma \vdash\)</span> or <span class="math notranslate nohighlight">\(\Gamma \vdash \bot\)</span> derives a contradiction from <span class="math notranslate nohighlight">\(\Gamma\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(x, \ldots, z \vdash A\)</span>, where <span class="math notranslate nohighlight">\(x,\ldots,z\)</span> are free variables representing propositions (most likely appearing in <span class="math notranslate nohighlight">\(A\)</span>), is a proof pattern of <span class="math notranslate nohighlight">\(A\)</span>. Similarly <span class="math notranslate nohighlight">\(x, \ldots, z, A \vdash\)</span> is a refutation pattern.</p></li>
<li><p><span class="math notranslate nohighlight">\(\Gamma \vdash A\)</span> is a term with result type <span class="math notranslate nohighlight">\(A\)</span></p></li>
</ul>
<p><span class="math notranslate nohighlight">\(𝕁^+_R\)</span> constructs a proof from a collection of proofs and refutations, while <span class="math notranslate nohighlight">\(𝕁^-_L\)</span> constructs a refutation from a collection of proofs and refutations.</p>
</section>
<section id="polarized-logic">
<h2>Polarized logic<a class="headerlink" href="#polarized-logic" title="Link to this heading"></a></h2>
<p>Following <span id="id26">[<a class="reference internal" href="../zzreferences.html#id102" title="Yves Lafont. Linear logic pages. URL: http://iml.univ-mrs.fr/~lafont/pub/llpages.pdf.">Laf</a>]</span> we say a proposition <span class="math notranslate nohighlight">\(A\)</span> is positive if <span class="math notranslate nohighlight">\(A \equiv \bang^+ A\)</span>. Dually we say <span class="math notranslate nohighlight">\(A\)</span> is negative if <span class="math notranslate nohighlight">\(A \equiv \bang^- A\)</span>. <span class="math notranslate nohighlight">\(A\)</span> is positive iff <span class="math notranslate nohighlight">\(\neg A\)</span> is negative, and vice-versa.</p>
<p>The direction <span class="math notranslate nohighlight">\(\bang^+ A \vdash A\)</span> is trivial by dereliction, so when considering a specific proposition we only must show <span class="math notranslate nohighlight">\(A \vdash \bang^+ A\)</span>.</p>
<p>In general, <span class="math notranslate nohighlight">\(𝕁^+ [ \vec A_i \vdash \vec B_i]\)</span> is positive, and <span class="math notranslate nohighlight">\(𝕁^- [ \vec A_i \vdash \vec B_i ]\)</span> is negative, if <span class="math notranslate nohighlight">\(A_i\)</span> are all positive and <span class="math notranslate nohighlight">\(B_i\)</span> are all negative, hence the assignment of plus and minus for <span class="math notranslate nohighlight">\(𝕁\)</span>.</p>
<p>Going through the rules on <span class="math notranslate nohighlight">\(A \vdash \bang^+ A\)</span>:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(F,1\)</span> are positive</p></li>
<li><p><span class="math notranslate nohighlight">\(\bang^+ A\)</span> is positive for any <span class="math notranslate nohighlight">\(A\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(A \lor B,A \otimes B\)</span> are positive if <span class="math notranslate nohighlight">\(A,B\)</span> are positive</p></li>
<li><p><span class="math notranslate nohighlight">\(T,\bot\)</span> are not positive</p></li>
<li><p><span class="math notranslate nohighlight">\(A \land B\)</span> is positive if <span class="math notranslate nohighlight">\(A\)</span> is positive and <span class="math notranslate nohighlight">\(\bang^+ A \vdash B\)</span>, e.g. if <span class="math notranslate nohighlight">\(B\)</span> is a theorem</p></li>
<li><p><span class="math notranslate nohighlight">\(A \par \bot\)</span> is positive if <span class="math notranslate nohighlight">\(A\)</span> is positive. More generally, <span class="math notranslate nohighlight">\(A \par B\)</span> is positive if <span class="math notranslate nohighlight">\(A\)</span> is positive, <span class="math notranslate nohighlight">\(B \vdash \bot\)</span> (i.e., <span class="math notranslate nohighlight">\(B\)</span> is a refutation), and <span class="math notranslate nohighlight">\(A\vdash A,B\)</span>.</p></li>
</ul>
<p>We say that a proposition is polarized if it is either positive or negative. Unpolarized propositions such as <span class="math notranslate nohighlight">\(T \otimes \bot\)</span> exist, although every tautology is positive and every absurdity is negative. By strong consistency, no proposition can be both negative and positive.</p>
<p>Girard defined a syntactic rather than semantic notion of polarity, based on classifying connectives. By his definitions, <span class="math notranslate nohighlight">\(A \par \bot\)</span> and <span class="math notranslate nohighlight">\(A\otimes 1\)</span> remove polarity from a positive resp. negative proposition. But the semantic definition seems more useful.</p>
<p>Lafont also defines regular types <span class="math notranslate nohighlight">\(A \equiv \bang^- \bang^+ A\)</span>, but considering that there are 6 non-trivial modalities including a dual modality <span class="math notranslate nohighlight">\(\bang^+ \bang^-\)</span> this seems too limited. There is not a clear justification for this definition; maybe some paper in the literature explains it, but a simple search “regular linear logic” didn’t uncover it.</p>
<section id="cartesian-types">
<h3>Cartesian types<a class="headerlink" href="#cartesian-types" title="Link to this heading"></a></h3>
<p><span id="id27">[<a class="reference internal" href="../zzreferences.html#id61" title="Andrzej Filinski. Linear continuations. In Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL '92, 27–38. Albuquerque, New Mexico, USA, February 1992. Association for Computing Machinery. URL: https://doi.org/10.1145/143165.143174 (visited on 2020-06-19), doi:10.1145/143165.143174.">Fil92</a>]</span> observes in section 3.1 that, even in the absence of exponentials, we can actually copy and discard data of certain “cartesian” types in a linear fashion. This is quite similar to positivity. However, positivity is not necessary or sufficient to be cartesian - <span class="math notranslate nohighlight">\(BB = \text{Bool} \to \text{Bool}\)</span> is positive, but the proof does not actually make a copy of the function, because it can only evaluate the function at one value. Also, as exponentials are non-canonical, per <span id="id28">[<a class="reference internal" href="../zzreferences.html#id102" title="Yves Lafont. Linear logic pages. URL: http://iml.univ-mrs.fr/~lafont/pub/llpages.pdf.">Laf</a>]</span> a formula <span class="math notranslate nohighlight">\(C = \alpha \otimes \bang(\alpha \ to \alpha \otimes \alpha) \otimes \bang(\alpha \to 1)\)</span> can be copied and discarded but does not satisfy <span class="math notranslate nohighlight">\(C \vdash \bang \alpha\)</span> hence is not positive.</p>
<p>Formally, cartesian types are defined as commutative co-monoids. In terms of sequent proofs, this means we have a
proposition <span class="math notranslate nohighlight">\(A\)</span>, with theorems <span class="math notranslate nohighlight">\(w : A \vdash 1\)</span> and <span class="math notranslate nohighlight">\(c : A \vdash A \otimes A\)</span>. There are then 3 laws that these theorems must satisfy, equivalences under cut elimination:</p>
<ul class="simple">
<li><p>unit:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\rule{c : A \vdash A \otimes A \quad (w \otimes \text{id}) : A \otimes A \vdash A \otimes 1}{A \vdash A \otimes 1}{\text{cut}} = \rule{\text{id} : A \vdash A \quad \vdash 1}{A \vdash A\otimes 1}{\otimes_R}\]</div>
<ul class="simple">
<li><p>commutativity:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\rule{c : A \vdash A \otimes A \quad swap : A_1 \otimes A_2 \vdash A_2 \otimes A_1}{A \vdash A \otimes A}{\text{cut}} = \text{c} : A \vdash A \otimes A\]</div>
<ul class="simple">
<li><p>associativity:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\rule{c : A \vdash A \otimes A \quad (id \otimes c) : A \otimes A \vdash A \otimes (A \otimes A) \quad A\otimes (B \otimes C) \vdash (A \otimes B) \otimes C}{A \vdash (A\otimes A) \otimes A}{\text{cut x2}} = \rule{c : A \vdash A \otimes A \quad (c \otimes id) : A \otimes A \vdash (A \otimes A) \otimes A}{A \vdash (A\otimes A) \otimes A}{\text{cut}}\]</div>
<p>In addition, Filinski adds uniqueness: <span class="math notranslate nohighlight">\(w : A \vdash 1\)</span> and <span class="math notranslate nohighlight">\(c : A \vdash A \otimes A\)</span> must each have only one unique cut-free proof.</p>
<p>We can similarly define co-cartesian types <span class="math notranslate nohighlight">\(A\)</span> that can be copied and discarded on the right with theorems <span class="math notranslate nohighlight">\(w : 1 \vdash A\)</span> and <span class="math notranslate nohighlight">\(c : A \otimes A \vdash A\)</span> and are a commutative monoid.</p>
<p>I’m not sure if there is a simple description of all cartesian types, but of course <span class="math notranslate nohighlight">\(\bang^\pm\)</span> are cartesian/co-cartesian, and <span class="math notranslate nohighlight">\(𝕁^+ [ \vec A_i \vdash \vec B_i]\)</span> and and <span class="math notranslate nohighlight">\(𝕁^- [ \vec A_i \vdash \vec B_i ]\)</span> are cartesian/co-cartesian if <span class="math notranslate nohighlight">\(A_i\)</span> are all cartesian and <span class="math notranslate nohighlight">\(B_i\)</span> are all co-cartesian. So ADTs in general - booleans, integers, lists, trees - are all cartesian. Our earlier example <span class="math notranslate nohighlight">\(C\)</span> is in general not cartesian because, although copy and discard can be proven, it uses the included functions and those won’t necessarily satisfy the laws.</p>
<p>Filinski says in 3.2 that all cartesian types are positive. Hence, for cartesian / co-cartesian types, because the proof of polarity is natural, we can be generous with exponentials and use them whenever we have such a type, without fear of changing the program semantics. This allows a more faithful representation of copy operations in the proof structure, avoiding implicit copying such as <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">case</span> <span class="pre">x</span> <span class="pre">of</span> <span class="pre">True</span> <span class="pre">-&gt;</span> <span class="pre">(True,True);</span> <span class="pre">False</span> <span class="pre">-&gt;</span> <span class="pre">(False,False)</span></code>.</p>
<p>But, if we start with a plethoric translation to begin with and only remove unnecessary exponentials, probably cartesian types don’t matter, because all the copy operations are explicitly represented using exponentials to begin with.</p>
</section>
<section id="tangent-reversible-computing">
<h3>Tangent: Reversible computing<a class="headerlink" href="#tangent-reversible-computing" title="Link to this heading"></a></h3>
<p>Another approach to duplication is “superstructural reversible logic” <span id="id29">[<a class="reference internal" href="../zzreferences.html#id152" title="Z A Sparks and Amr Sabry. Superstructural Reversible Logic. In 3rd International Workshop on Linearity. 2014. URL: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.720.5692&amp;rep=rep1&amp;type=pdf.">SS14</a>]</span>. In their calculus, duplicating any type (cartesian or not) is impossible, without using non-reversible rules. The non-reversible structural rules could be restricted to a modality similarly to how linear logic restricts contraction/weakening. But in Theseus <span id="id30">[<a class="reference internal" href="../zzreferences.html#id82" title="Roshan P James and Amr Sabry. Theseus: A High Level Language for Reversible Computing. In Work-in-Progress Report at Conference on Reversible Computation, 12. 2014. URL: https://legacy.cs.indiana.edu/~sabry/papers/theseus.pdf.">JS14</a>]</span> and even in the latest publication <span id="id31">[<a class="reference internal" href="../zzreferences.html#id30" title="Chao-Hong Chen and Amr Sabry. A computational interpretation of compact closed categories: reversible programming with negative and fractional types. Proceedings of the ACM on Programming Languages, 5(POPL):1–29, January 2021. URL: https://dl.acm.org/doi/10.1145/3434290 (visited on 2021-08-04), doi:10.1145/3434290.">CS21</a>]</span> they use standard higher-order functions to do most of the programming. So really a reversible program is a data type <code class="docutils literal notranslate"><span class="pre">Rev</span></code>, similar to how a normal program is a data type <code class="docutils literal notranslate"><span class="pre">Task</span></code>. The difference is that <code class="docutils literal notranslate"><span class="pre">Rev</span></code> contains isomorphisms rather than continuations.</p>
<p>In terms of support, I don’t think there’s much needed at present. With the DSL support Stroscot should be able to write isomorphisms similar to Theseus, and run them forwards/backwards like the <a class="reference external" href="https://github.com/DreamLinuxer/popl21-artifact">Agda code</a>. Once there is hardware/an ISA/an OS to target it should be straightforward to extend this basic support to a compiler.</p>
</section>
</section>
<section id="structural-rules">
<h2>Structural rules<a class="headerlink" href="#structural-rules" title="Link to this heading"></a></h2>
<p>As is usual for linear logic there are no structural rules for weakening or contraction (they are restricted to the exponentials above). And in Core we use a graph representation that internalizes the exchange rule, so there is not really an exchange rule either.</p>
<p>The cut rule is technically a theorem; we can prove that any proof using cut can be reformulated to be cut-free. But the expansion may result in exponentially more rule applications.</p>
<p>Similarly the identity rule is a theorem for propositional logic: we can produce a proof tree for <span class="math notranslate nohighlight">\(A \vdash A\)</span> for any finite proposition <span class="math notranslate nohighlight">\(A\)</span> via expansion of all the cases. Using the identity rule speeds up reduction because it skips iterating through the structure, and it also allows manipulating (prefixes of) <a class="reference internal" href="../Reference/Logic.html#infinite"><span class="std std-ref">infinite</span></a> trees.</p>
</section>
<section id="quantifiers">
<h2>Quantifiers<a class="headerlink" href="#quantifiers" title="Link to this heading"></a></h2>
<p>To move from propositional to first-order logic we must extend the identity rule to allow terms. Some presentations call the identity rule “ax”, for identity axiom, but in general the identity rule is a theorem so this seems foolish. Instead we call it “id”.</p>
<p>We explicitly list the identity theorem where it is needed:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://ncatlab.org/nlab/show/sequent+calculus">nLab</a> defines a substitution rule/theorem. There is a theorem that substitution rules can be eliminated from the proof tree, proven by taking the proof tree for <span class="math notranslate nohighlight">\(\Gamma \vdash \Delta\)</span> and replacing all its identities <span class="math notranslate nohighlight">\(x \vdash x\)</span> with identities <span class="math notranslate nohighlight">\(t \vdash t\)</span>. This requires <span class="math notranslate nohighlight">\(t \vdash t\)</span> to hold, hence we include it. If the identity rule is not used with <code class="docutils literal notranslate"><span class="pre">x</span></code> in the proof tree, then the identity rule is not needed for the substitution, but such a situation is unlikely.</p></li>
<li><p>Quantifiers also require the identity rule, because cut elimination applies substitution of <code class="docutils literal notranslate"><span class="pre">x</span></code> for <code class="docutils literal notranslate"><span class="pre">t</span></code> in the proof tree where <code class="docutils literal notranslate"><span class="pre">x</span></code> is a variable.</p></li>
</ul>
<p>Cut elimination for quantifiers is sound because the number of quantifiers in the sequent decreases.</p>
<p>The assignment of <span class="math notranslate nohighlight">\(\forall\)</span> as positive is logical, based on analogy with <span class="math notranslate nohighlight">\(\bang^+\)</span>. For example, we can prove <span class="math notranslate nohighlight">\(A \vdash \bang^+ \forall x. A\)</span> for closed positive propositions <span class="math notranslate nohighlight">\(A\)</span>. This is shown as a cut on the assumption <span class="math notranslate nohighlight">\(A \vdash \bang^+ A\)</span> and on the easily provable <span class="math notranslate nohighlight">\(\bang^+ A \vdash \bang^+ \forall x. A\)</span></p>
</section>
<section id="logic-translations">
<h2>Logic translations<a class="headerlink" href="#logic-translations" title="Link to this heading"></a></h2>
<p>First we must define classical and intuitionistic logic. To define classical logic we simply add standard structural weakening and contraction rules to our linear logic. Then <span class="math notranslate nohighlight">\(A\otimes B \equiv A \land B\)</span>, <span class="math notranslate nohighlight">\(A\par B \equiv A \lor B\)</span>, and we obtain the usual classical logic with modalities <span id="id32">[<a class="reference internal" href="../zzreferences.html#id102" title="Yves Lafont. Linear logic pages. URL: http://iml.univ-mrs.fr/~lafont/pub/llpages.pdf.">Laf</a>]</span>; all the connectives decompose into or are equivalent to the standard ones. To define intuitionistic logic we take classical logic and restrict the right hand side of all sequents to have at most one consequent; various pi/sigma connectives cannot be used as they would create multiple consequents, and similarly right contraction cannot be used. We allow disallow right weakening to make the translation easier.</p>
<p>The translation from intuitionistic logic to linear logic decorates every proposition and subproposition with !. <span id="id33">[<a class="reference internal" href="../zzreferences.html#id44" title="Roberto Di Cosmo. Introduction to Linear Logic. MPRI course notes, 2015. URL: https://www.dicosmo.org/CourseNotes/LinLog/IntroductionLinearLogic.pdf (visited on 2020-05-13).">DC15</a>]</span></p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\left[𝕁^- \limits_{i} \left(\overrightarrow{A_i} \multimap \overrightarrow{B_i}\right)\right]_I &amp;= \prod \limits_{i} \left(\overrightarrow{\bang\left[A_i\right]_I} \multimap \overrightarrow{\bang\left[B_i\right]_I}\right)\\\left[𝕁^+ \limits_{i} \left(\overrightarrow{A_i} - \overrightarrow{B_i}\right)\right]_I &amp;= \sum \limits_{i} \left(\overrightarrow{\bang\left[A_i\right]_I} - \overrightarrow{\bang\left[B_i\right]_I}\right)\end{aligned}\end{align} \]</div>
<p>We can translate classical logic into intuitionistic logic by decorating every proposition and subproposition with <span class="math notranslate nohighlight">\(\neg\neg\)</span> and moving the right to the left with another negation, i.e. <span class="math notranslate nohighlight">\(\Gamma \vdash \Delta \Rightarrow \Gamma', \neg \Delta' \vdash\)</span>. Thus the translation of classical logic into linear logic decorates like <span class="math notranslate nohighlight">\(\neg \bang^+ (\neg \bang^+ A) \equiv \bang^- \bang^+ A\)</span>.</p>
<p>These two decoration translations preserve proof structure, in the sense that every intuitionistic/classical proof tree can be converted to a linear logic proof tree, and the reverse as well if the linear logic proof tree’s sequent is the result of the proposition translation. There are other “uniform” translations, like in <span id="id34">[]</span>, but they aren’t as simple.</p>
</section>
<section id="definitions">
<h2>Definitions<a class="headerlink" href="#definitions" title="Link to this heading"></a></h2>
<p>I didn’t find any relevant papers on defining new notation for expressions in the sequent calculus. So we have to prove consistency ourselves. But I think the cut elimination theorem poses no problem, the key and commutative cases are trivial.</p>
<p>The identity rule fails if the notation expands via an infinite chain of definitions <span class="math notranslate nohighlight">\(A_1 = \ldots A_2 \ldots, A_2 = \ldots A_3 \ldots = \ldots\)</span>. For example for Russell’s paradox and the related <span class="math notranslate nohighlight">\(\{x : x \in x\}  \in \{x : x \in x\} = \{x : x \in x\}  \in \{x : x \in x\} = \ldots\)</span>. Hence we exclude such circular definitions by requiring the identity theorem to complete for all notations.</p>
<p>For the substitution theorem goes through with the same restriction on notation. The proof works by replacing variable identities <span class="math notranslate nohighlight">\(x \vdash x\)</span> with more complex identities <span class="math notranslate nohighlight">\(A \vdash A\)</span>.</p>
<p>Non-circularity is a pretty loose restriction. If we know a definition is size-decreasing, we can induct as usual to prove the identity theorem: use the basic identity theorem on non-definition subtrees, use the definition rule on both sides for each definition, and continue switching between the two until it’s built up. Hence we only have to be careful for definitions like sets that can increase size when expanded.</p>
</section>
<section id="set-theory">
<h2>Set theory<a class="headerlink" href="#set-theory" title="Link to this heading"></a></h2>
<p>The naive set theory definition comes from <span id="id35">[<a class="reference internal" href="../zzreferences.html#id144" title="Masaru Shirahata. Linear Set Theory. PhD thesis, Stanford University, February 1994. URL: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.29.7077&amp;rep=rep1&amp;type=pdf.">Shi94</a>]</span> (page 10). The rest of the definitions are similar to the ones in <span id="id36">[<a class="reference internal" href="../zzreferences.html#id147" title="Michael Shulman. Linear logic for constructive mathematics. arXiv:1805.07518 [math], May 2018. Comment: 39 pages. URL: http://arxiv.org/abs/1805.07518 (visited on 2021-03-04), arXiv:1805.07518.">Shu18</a>]</span> except <span class="math notranslate nohighlight">\(\in\)</span> is not affirmative.</p>
<section id="paradoxes">
<span id="id37"></span><h3>Paradoxes<a class="headerlink" href="#paradoxes" title="Link to this heading"></a></h3>
<p>It seems from playing with some examples that forbidding circular definitions is sufficient to prevent Russell’s paradox and Curry’s paradox. For example with <span class="math notranslate nohighlight">\(R = \{x\mid \bang^- \neg(x \in x)\}\)</span>, <span class="math notranslate nohighlight">\(\{x\mid F \} \in R\)</span> is defined (and provable) but <span class="math notranslate nohighlight">\(R \in R\)</span> is circular hence not defined. So we cannot write the premise of Russell’s paradox. We could try to work around this with a proposition like <span class="math notranslate nohighlight">\(t\in R \land t= R\)</span>. This is not circular, but it is not sufficient to derive a paradox, as in order to apply contraction we have to use a substitution that produces <span class="math notranslate nohighlight">\(R \in R\)</span>. Curry’s paradox <span class="math notranslate nohighlight">\(X=\{x\mid x\in x \to Y\}\)</span> similarly contains <span class="math notranslate nohighlight">\(x\in x\)</span> and hence the notation <span class="math notranslate nohighlight">\(X \in X\)</span> is circular and therefore forbidden as well.</p>
<p>More formally, suppose the logic is inconsistent, i.e. there is a derivation <span class="math notranslate nohighlight">\(\vdash \bot\)</span>. This must be derived from the empty sequent. Then what does cut elimination do? Either it completes, in which case we get a contradiction because no rule derives the empty sequent, or there’s some infinite chain of cut elimination. I claim the infinite chain only happens if there is a circular definition involved and the identity or substitution rules are on the sides. Hence, forbidding circular definitions in the identity and cut rules solves the issue.</p>
<p>The question of whether a given set comprehension is defined is undecidable, as we can encode the lambda calculus and hence the halting problem - the beta rule <span class="math notranslate nohighlight">\((\lambda x. A) t\)</span> does the same substitution as <span class="math notranslate nohighlight">\(t\in\{x\mid A\}\)</span>. We can approximate definedness with a termination checking algorithm, type system, or syntactic check:</p>
<ul class="simple">
<li><p>Strict comprehension, i.e. the bound variable can only appear once in the formula <span id="id38">[<a class="reference internal" href="../zzreferences.html#id145" title="Masaru Shirahata. Linear set theory with strict comprehension. In Proceedings of the Sixth Asian Logic Conference, 223–245. Beijing, China, April 1998. WORLD SCIENTIFIC / S'PORE UNIV PRESS (PTE) LTD. URL: http://www.worldscientific.com/doi/abs/10.1142/9789812812940_0013 (visited on 2021-03-06), doi:10.1142/9789812812940_0013.">Shi98</a>]</span> Very restrictive.</p></li>
<li><p>New Foundations’s stratified formulas <span id="id39">[<a class="reference internal" href="../zzreferences.html#id63" title="Thomas Forster. Quine’s New Foundations. In Edward N. Zalta, editor, The Stanford Encyclopedia of Philosophy. Metaphysics Research Lab, Stanford University, summer 2019 edition, 2019. URL: https://plato.stanford.edu/archives/sum2019/entries/quine-nf/ (visited on 2021-03-04).">For19</a>]</span> <span id="id40">[<a class="reference internal" href="../zzreferences.html#id77" title="M. Randall Holmes. Elementary Set Theory with a Universal Set. Bruylant-Academia, 1998. ISBN 978-2-87209-488-2. URL: https://randall-holmes.github.io/head.pdf.">Hol98</a>]</span> NFU + Infinity + Choice is known to be consistent with the theory of types with the Axiom of Infinity, and is a subtheory of ZFC + “there is an n-Mahlo cardinal for each concrete natural number n”. But the stratification is restrictive, e.g. we cannot define a set of sets that contain themselves even though this definition is well-founded.</p></li>
<li><p>Hindley-Milner type inference (since the simply typed lambda calculus terminates). Seems like a reasonable check.</p></li>
<li><p>A size-checking algorithm like in <span id="id41">[<a class="reference internal" href="../zzreferences.html#id83" title="Neil D. Jones and Nina Bohr. Call-by-value termination in the untyped lambda-calculus. Logical Methods in Computer Science, 4(1):3, March 2008. URL: http://arxiv.org/abs/0801.0882 (visited on 2021-03-06), arXiv:0801.0882, doi:10.2168/LMCS-4(1:3)2008.">JB08</a>]</span>. Seems to have unpredictable behavior, but may solve some things HM can’t.</p></li>
<li><p>Brute-force expansion. Also somewhat unpredictable.</p></li>
<li><p>Intersection type system. Typeable iff terminating, but undecidable in general and tricky to approximate. But should be strictly better than HM.</p></li>
</ul>
<p>There is also <span id="id42">[<a class="reference internal" href="../zzreferences.html#id143" title="Masaru Shirahata. A linear conservative extension of Zermelo-Fraenkel set theory. Studia Logica, 56(3):361–392, May 1996. URL: http://link.springer.com/10.1007/BF00372772 (visited on 2021-03-06), doi:10.1007/BF00372772.">Shi96</a>]</span> which allows sets built from ZF’s axioms.</p>
</section>
<section id="equality">
<h3>Equality<a class="headerlink" href="#equality" title="Link to this heading"></a></h3>
<p>The axioms of reflexivity, substitution, etc. can take a variety of modalities as in <span id="id43">[<a class="reference internal" href="../zzreferences.html#id34" title="Marcelo Coniglio and Francisco Miraglia. Equality in linear logic. Logique et Analyse, 39(153/154):113–151, January 2002. URL: https://www.researchgate.net/profile/Marcelo-Coniglio/publication/2387274_Equality_In_Linear_Logic/links/0deec5165a6babbd8a000000/Equality-In-Linear-Logic.pdf.">CM02</a>]</span>, some of them corresponding with intuitionistic and classical notions of equality. For sets we use linear weak extensional equality. Alternatively we could use intuitionistic equality <span class="math notranslate nohighlight">\(A\overset{!}{=}B \defeq !(A=B)\)</span>, then substitution is <span class="math notranslate nohighlight">\(A\overset{!}{=}B, \phi \vdash \phi[A/B]\)</span>. But the linear equality seems more useful.</p>
<p>Proof of the substitution property: For <span class="math notranslate nohighlight">\(𝕁^-\)</span> we use the right rule to split into cases for each tag, then we use contraction/weakening on <span class="math notranslate nohighlight">\(\bang(A=B)\)</span> to match the number of A’s/B’s in the case, then the left rule to split into each A and B, giving each branch a copy of the hypothesis. <span class="math notranslate nohighlight">\(𝕁^+\)</span> is similar but with the left first. For exponentials, quantifiers, and set comprehension we simply do left/right in the correct order. Then at the end we use the hypothesis to change <span class="math notranslate nohighlight">\(A[x/a]\)</span> on the left or right to <span class="math notranslate nohighlight">\(B[x/b]\)</span>, or else weakening to remove the hypothesis followed by the identity.</p>
</section>
</section>
<section id="recursion-and-infinite-structures">
<h2>Recursion and infinite structures<a class="headerlink" href="#recursion-and-infinite-structures" title="Link to this heading"></a></h2>
<p>There is the question of representing recursion, as standard derivations only allow finite (well-founded) proofs.Sequent Core <span id="id44">[<a class="reference internal" href="../zzreferences.html#id49" title="Paul Downen, Luke Maurer, Zena M. Ariola, and Simon Peyton Jones. Sequent calculus as a compiler intermediate language. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, 74–88. Nara, Japan, September 2016. Association for Computing Machinery. URL: https://www.microsoft.com/en-us/research/publication/sequent-calculus-as-a-compiler-intermediate-language/ (visited on 2020-06-14), doi:10.1145/2951913.2951931.">DMAPJ16</a>]</span> introduces Let/MultiCut and Rec, which “serve two purposes: to give a shared name to the result of some computation, and to express (mutual) recursion.”</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cc}
  \rule
    {\Gamma, \Theta \vdash \Delta, \Lambda \quad \Gamma', \Lambda \vdash \Theta, \Delta' }
    {\Gamma, \Gamma' \vdash \Delta, \Delta' }{\text{multicut}}
  &amp;
  \rule
    { \overrightarrow{\Gamma, \vec \Lambda, \Theta_i \vdash \Lambda_i, \vec \Theta, \Delta }}
    {\Gamma, \overrightarrow{\Theta_i} \vdash \overrightarrow{\Lambda_i}, \Delta }{\text{rec}}
\end{array}\]</div>
<p>But these rules are illogical and inadmissible. For example with Let/MultiCut, one can conclude from <span class="math notranslate nohighlight">\(A,B \vdash B,C\)</span> and <span class="math notranslate nohighlight">\(A,B \vdash B,C\)</span> (provable via Ax) that <span class="math notranslate nohighlight">\(A \vdash C\)</span>. Similarly Rec concludes from <span class="math notranslate nohighlight">\(A,B,C,D \vdash B, D, E, F\)</span> and <span class="math notranslate nohighlight">\(A,B,C,E \vdash C, D, E, F\)</span> (again provable via Ax) that <span class="math notranslate nohighlight">\(A,D,E \vdash B,C,F\)</span>.</p>
<p>Alternately let can be encoded as a record and recursion via a fixed-point combinator or a cycle in the graph. In particular <span id="id45">[<a class="reference internal" href="../zzreferences.html#id97" title="Oleg Kiselyov. Many faces of the fixed-point combinator. August 2013. URL: http://okmij.org/ftp/Computation/fixed-point-combinators.html (visited on 2020-07-31).">Kis13</a>]</span> outline a polyvariadic combinator:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fix_poly</span><span class="w"> </span><span class="n">fl</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fix</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">self</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="w"> </span><span class="n">self</span><span class="p">)</span><span class="w"> </span><span class="n">fl</span><span class="p">)</span>
</pre></div>
</div>
<p>To implement <code class="docutils literal notranslate"><span class="pre">fix</span></code> we can use the variant of the Y combinator <span class="math notranslate nohighlight">\(\lambda f.(\lambda x.x x) (\lambda x.f (x x))\)</span>. To type it we need the cyclic/recursive type <span class="math notranslate nohighlight">\(Wr = 𝕁^-[(^w, Wr, r)]\)</span> (in the sense of an infinite, regular tree). BOHM uses a fan/duplication node combined with a loop.</p>
<p>A better method, following <span id="id46">[<a class="reference internal" href="../zzreferences.html#id84" title="Simon Peyton Jones. The Implementation of Functional Programming Languages. Prentice-Hall, 1987. \textbf Errata  \begin itemize \item Section 5.2.4, p87.  We need an extra rule \end itemize  match us [] E = E  This accounts for the possibility that in the constructor rule (Section 5.2.4) there may be some non-nullary constructors for which there are no equations.  \begin itemize \item P168, line 2, “VAR” should be “TVAR”. \end itemize. URL: https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/ (visited on 2020-08-02).">Jon87</a>]</span> chapter 12, is to simply allow (regular) infinite proof trees. We construct “infinite” as a terminal coalgebra - our proof trees turn into fixed points of systems of formal equations <span id="id47">[<a class="reference internal" href="../zzreferences.html#id90" title="Panagis Karazeris, Apostolos Matzaris, and Jiří Velebil. Final coalgebras in accessible categories. Mathematical Structures in Computer Science, 21(5):1067–1108, October 2011. URL: https://www.cambridge.org/core/product/identifier/S0960129511000351/type/journal_article (visited on 2021-03-11), doi:10.1017/S0960129511000351.">KMV11</a>]</span>, as opposed to actually being infinite. We represent the system of equations explicitly with the use-def rules, which also allow naming computations. Although the regular restriction means we can’t represent some values directly such as the Fibonacci sequence, most of the types we care about are regular, like the lambda calculus or lists, and similarly some infinite values like <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">x</span></code>.</p>
<p>Infinite structures can be paradoxical, e.g. we can prove <span class="math notranslate nohighlight">\(\vdash\bot\)</span> using cut on the proposition <span class="math notranslate nohighlight">\(A=\neg A\)</span>. Cut elimination will often fail to complete, but there is a progress property in the sense that the cut can always be pushed down and eliminate an identity rule or two matching logical rules.</p>
</section>
<section id="confluent-reduction">
<h2>Confluent reduction<a class="headerlink" href="#confluent-reduction" title="Link to this heading"></a></h2>
<p>Reduction (cut-elimination) of our linear logic trees is not confluent, but only because of commuting cuts. If we drop the black sequent parent-child edges, and only consider proof nets, then the system is confluent. A cut only interacts with other cuts at identity rules, but with a cut-identity-cut pattern it doesn’t matter which cut reduces with the identity. (TODO: prove this formally)</p>
</section>
<section id="levels">
<h2>Levels<a class="headerlink" href="#levels" title="Link to this heading"></a></h2>
<p>For the implementation of optimal reduction we can add level indices to the terms in the promotion and dereliction rules of <span class="math notranslate nohighlight">\(\bang\)</span>, as in <span id="id48">[<a class="reference internal" href="../zzreferences.html#id108" title="S. Martini and A. Masini. On the fine structure of the exponential rule. In Jean-Yves Girard, Yves Lafont, and Laurent Regnier, editors, Advances in Linear Logic, pages 197–210. Cambridge University Press, Cambridge, 1995. URL: https://pdfs.semanticscholar.org/b2cb/538c8ef21af42e48134a17a3c62ce5167837.pdf (visited on 2020-08-01), doi:10.1017/CBO9780511629150.010.">MM95</a>]</span> and <span id="id49">[<a class="reference internal" href="../zzreferences.html#id69" title="Stefano Guerrini. Theoretical and Practical Issues of Optimal Implementations of Functional Languages. PhD thesis, Università di Pisa. Dipartimento di Informatica, 1996. URL: https://www-lipn.univ-paris13.fr/~guerrini/mysite/sites/default/files/biblio/PhDThesis.pdf.">Gue96</a>]</span>. Conceptually all terms have indices, but we can recover the indices in a proof tree by propagating the indices from the promotion/dereliction rules up/down according to the criteria that the indices involved in all non-<span class="math notranslate nohighlight">\(\bang\)</span> promotion/dereliction rules must be the same.</p>
<p>To handle level indices in infinite trees, we store the difference function <code class="docutils literal notranslate"><span class="pre">\a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">(j-i)</span></code> and recover the levels by tracing from the root of the derivation tree (which is always level 0) and applying the difference function when encountered.</p>
<p>The level of a context is the maximum of the levels of its terms, 0 if it is empty.</p>
<div class="math notranslate nohighlight">
\[\begin{array}{ccc}
  \rule{\bang^+\Gamma^i \vdash A^j, \bang^-\Delta^i }{\bang^+\Gamma^i \vdash \bang^+ A^i, \bang^-\Delta^i}{\bang^+}_{j = i+1}
  &amp; \rule{\sk{\Gamma^i}, A^i \vdash \sk{\Delta^i} }{\sk{\Gamma^i}, \bang^+ A^j \vdash \sk{\Delta^i}}{\bang^+ d}_{j\leq i}
  &amp; \rule{\sk{\Gamma}, \overrightarrow{\bang^+ A, \bang^+ A, \cdots} \vdash \sk{\Delta} }{\sk{\Gamma}, \bang^+ A \vdash \sk{\Delta}}{\bang^+ c_n}
\end{array}\]</div>
<div class="math notranslate nohighlight">
\[\begin{array}{ccc}
  \rule{\bang^+\Gamma^i, A^j \vdash \bang^-\Delta^i }{\bang^+\Gamma^i, \bang^- A^i \vdash \bang^-\Delta^i}{\bang^-}_{j = i+1}
  &amp; \rule{\sk{\Gamma^i} \vdash A^i, \sk{\Delta^i} }{\sk{\Gamma^i} \vdash \bang^- A^j, \sk{\Delta^i}}{\bang^- d}_{j \leq i}
  &amp; \rule{\sk{\Gamma} \vdash \overrightarrow{\bang^- A, \bang^- A, \cdots}, \sk{\Delta} }{\sk{\Gamma} \vdash \bang^- A, \sk{\Delta}}{\bang^- c_n}
\end{array}\]</div>
<p>To handle level mismatches we might also need lifting operators. The conditions are unclear.</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cc}
  \rule{\Gamma^i \vdash A^j, \Delta^i }{\Gamma^i \vdash A^i, \Delta^i}{\text{lift}_R}_{j &gt; i}
  &amp;
  \rule{\Gamma^i, A^j \vdash \Delta^i }{\Gamma^i, A^i \vdash \Delta^i}{\text{lift}_L}_{j &gt; i}
\end{array}\]</div>
<p>In practice I have had trouble interpreting these levels operationally, it seems the levels have no relationship to actual optimal reduction.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Learning.html" class="btn btn-neutral float-left" title="Learning" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="LogicProgramming.html" class="btn btn-neutral float-right" title="Logic programming" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>