<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sets &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Imperative programming" href="State.html" />
    <link rel="prev" title="Reduction example" href="Reduction-Example.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="F2G2_example.html">F2 G2</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fexprs.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">About</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Sets</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-are-types">What are types?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Sets</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#function-definition">Function definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-syntax-definition">Set syntax definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#element-definition">Element definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#poset-definition">Poset definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ranges">Ranges</a></li>
<li class="toctree-l4"><a class="reference internal" href="#enumeration">Enumeration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#adts">ADTs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#records">Records</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tracing">Tracing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#annotations">Annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-annotations">Function annotations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dependent-types">Dependent types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#check">Check</a></li>
<li class="toctree-l4"><a class="reference internal" href="#total-check">Total check</a></li>
<li class="toctree-l4"><a class="reference internal" href="#contracts">Contracts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-curse-of-static-typing">The curse of static typing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#type-synthesis">Type synthesis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#roles">Roles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Imperative programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Commentary</a> &raquo;</li>
      <li>Sets</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Sets.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="sets">
<h1>Sets<a class="headerlink" href="#sets" title="Permalink to this headline"></a></h1>
<p>Stroscot allows specifying properties about execution, which the compiler then attempts to prove or at least fuzz (see <a class="reference internal" href="Verification.html#verification"><span class="std std-ref">Verification</span></a>).</p>
<section id="what-are-types">
<h2>What are types?<a class="headerlink" href="#what-are-types" title="Permalink to this headline"></a></h2>
<p>Are properties types? Is Stroscot typed? These get down to a fundamental disagreement in the literature.</p>
<p>In Church style, the style present in most academic papers on type systems, a term without a type is meaningless, there is only one principal type for a given expression, and the type system is sound and decidable. Haskell is Church-style - e.g. when the type inference fails for GADTs, the type signature must be given. Harper has <a class="reference external" href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/">argued</a> that dynamic languages are unityped static languages. Instead of “proper” types, one defines an agglomerated unitype, and throws away soundness. Most languages are already unsound so this is not much of a loss, and it increases expressiveness because terms such as the Y combinator become typeable. Because the type system is trivial, properties are not part of the type system.</p>
<p>Curry style types, called sorts in <span id="id1">[<a class="reference internal" href="../zzreferences.html#id78" title="missing journal in pfenningChurchCurryCombining2012">Pfe12</a>]</span>, sorts define properties that can be checked or ignored, extrinsic to the terms themselves. A term may satisfy several sorts, or none at all. Since the sorts are optional there must necessarily be an operational semantics that does not refer to any sorts, and hence the language is dynamic. Statically verified properties are indeed sorts or “types” in the Curry sense.</p>
<p>So it comes down to definitions. Stroscot doesn’t have types in Harper’s asshole sense, but it does in the sense used by reasonable people. To avoid useless arguments we use the term “set” instead of “type” to refer to the set of values a variable may have. Constraining the set of values enables many useful optimizations to be performed, and seems to function similarly in practice to a type system. But since the “types” actually behave like sets “set” is IMO clearer.</p>
<p>Even so, there are type systems that are almost as expressive as Stroscot’s sets. Distributive lattices as used in <span id="id2">[<a class="reference internal" href="../zzreferences.html#id25" title="Stephen Dolan. Algebraic Subtyping. PhD thesis, University of Cambridge, September 2016. URL: https://www.cs.tufts.edu/~nr/cs257/archive/stephen-dolan/thesis.pdf.">Dol16</a>]</span> are isomorphic to collections of sets. Similarly <span id="id3">[<a class="reference internal" href="../zzreferences.html#id73" title="Mayur Naik and Jens Palsberg. A type system equivalent to a model checker. ACM Transactions on Programming Languages and Systems, 30(5):1–24, August 2008. URL: https://dl.acm.org/doi/10.1145/1387673.1387678 (visited on 2021-07-15), doi:10.1145/1387673.1387678.">NP08</a>]</span> provides a method to interpret the model produced by a model checker as a type derivation using flow, intersection, and union types. So in some sense all the properties Stroscot verifies are bona-fide types. But the types are complex and precise, e.g. <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">:</span> <span class="pre">(Nil--&gt;0)</span> <span class="pre">&amp;</span> <span class="pre">(Cons</span> <span class="pre">a</span> <span class="pre">b--&gt;1+(length</span> <span class="pre">b))</span></code>, and likely hard to interpret. Meanwhile errors produce a concrete program trace of a failing path, which should be easy to turn into a good error message or even allow interactive debugging.</p>
<p>Another notion of “type” is substructural typing. Stroscot’s execution model is substructural (based on linear logic), but it’s not clear how to expose this to the programmer.</p>
</section>
<section id="id4">
<h2>Sets<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2>
<p>Sets in Stroscots are defined by a predicate <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">isElementOf</span> <span class="pre">S</span> <span class="pre">:</span> <span class="pre">Value</span> <span class="pre">-&gt;</span> <span class="pre">Set</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>, where <code class="docutils literal notranslate"><span class="pre">Set</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">s</span> <span class="pre">:</span> <span class="pre">Any</span> <span class="pre">|</span> <span class="pre">forall</span> <span class="pre">a</span> <span class="pre">:</span> <span class="pre">Any.</span> <span class="pre">(a</span> <span class="pre">isElemof</span> <span class="pre">s</span> <span class="pre">:</span> <span class="pre">Bool)</span> <span class="pre">}</span></code>. The predicate can describe any side effect free computation, so a set can describe any boolean function.</p>
<p>Sets don’t contain null by default, you have to add it to the predicate as an allowed value.</p>
<section id="function-definition">
<h3>Function definition<a class="headerlink" href="#function-definition" title="Permalink to this headline"></a></h3>
<p>The usual method combination mechanisms apply. In particular you can define sets by creating a fresh symbol and overloading <code class="docutils literal notranslate"><span class="pre">isElementOf</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">symbol</span><span class="w"> </span><span class="kt">A</span><span class="w"></span>
<span class="mi">1</span><span class="w"> </span><span class="n">isElementOf</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">true</span><span class="w"></span>
<span class="mi">2</span><span class="w"> </span><span class="n">isElementOf</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">false</span><span class="w"></span>
<span class="nf">a</span><span class="w"> </span><span class="n">isElementOf</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">B</span><span class="p">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">C</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Often a set will be a fresh symbol <code class="docutils literal notranslate"><span class="pre">Constr</span></code> and a definition of <code class="docutils literal notranslate"><span class="pre">isElemOf</span></code> checking whether an element has the tag <code class="docutils literal notranslate"><span class="pre">Constr</span></code> as head and certain values as arguments. This is similar to a data type definition in other languages.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">symbol</span><span class="w"> </span><span class="kt">Foo</span><span class="w"></span>
<span class="nf">a</span><span class="w"> </span><span class="n">isElementOf</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">match</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">true</span><span class="w"></span>
<span class="w">          </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">false</span><span class="w"></span>

<span class="o">#</span><span class="w"> </span><span class="n">similar</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="kr">data</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="kt">Haskell</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="set-syntax-definition">
<h3>Set syntax definition<a class="headerlink" href="#set-syntax-definition" title="Permalink to this headline"></a></h3>
<p>You can also define sets with set-builder notation <code class="docutils literal notranslate"><span class="pre">{s</span> <span class="pre">:</span> <span class="pre">SomeSet</span> <span class="pre">|</span> <span class="pre">predicate</span> <span class="pre">s</span> <span class="pre">}</span></code>, set literals <code class="docutils literal notranslate"><span class="pre">{1,2,3}</span></code>, and set operations (union <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">intersect</span></code>, complement <code class="docutils literal notranslate"><span class="pre">not</span></code>, difference <code class="docutils literal notranslate"><span class="pre">-</span></code>, symmetric difference <code class="docutils literal notranslate"><span class="pre">symdiff</span></code>). Although it is possible to override the definitions of these sets with a definition like <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">isElementOf</span> <span class="pre">(Int|Bool)</span> <span class="pre">=</span> <span class="pre">false</span></code>, this is considered poor practice - it is better to define a fresh symbol for the set.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w"></span>
<span class="p">{</span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kt">Int</span><span class="o">-</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span><span class="w"></span>
<span class="kt">Int</span><span class="w"> </span><span class="n">intersect</span><span class="w"> </span><span class="p">(</span><span class="n">range</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">}</span><span class="w"></span>
<span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="w"> </span><span class="n">union</span><span class="w"> </span><span class="p">{</span><span class="n">b</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">}</span><span class="w"></span>
<span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="o">|</span><span class="p">{</span><span class="n">b</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">}</span><span class="w"></span>
<span class="p">{}</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">empty</span><span class="w"> </span><span class="n">set</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Void&quot;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="element-definition">
<h3>Element definition<a class="headerlink" href="#element-definition" title="Permalink to this headline"></a></h3>
<p>Because specifying a new element of a set is common, there is a special syntax using <code class="docutils literal notranslate"><span class="pre">symbol</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">symbol</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">A</span><span class="w"></span>

<span class="o">#</span><span class="w"> </span><span class="n">short</span><span class="w"> </span><span class="n">for</span><span class="w"></span>
<span class="nf">symbol</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="nf">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">true</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="poset-definition">
<h3>Poset definition<a class="headerlink" href="#poset-definition" title="Permalink to this headline"></a></h3>
<p>Sets form a poset under the subset relation (inclusion), which is called <code class="docutils literal notranslate"><span class="pre">Set</span></code>. It is possible to use the poset constraint language with this to define sets. For example this defines a set <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">{1}</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">symbol</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Set</span><span class="w"></span>
<span class="nf">elemR</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>More generally we may compute either the minimal set or the maximal set satisfying the given constraints.</p>
<p>You can assert that two sets are disjoint (empty intersection), this is useful sometimes.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">assert</span><span class="w"> </span><span class="p">(</span><span class="kt">A</span><span class="w"> </span><span class="n">disjoint</span><span class="w"> </span><span class="kt">B</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="ranges">
<h3>Ranges<a class="headerlink" href="#ranges" title="Permalink to this headline"></a></h3>
<p>The basic idea is that any numeric set of integers can be given via a lower and upper bound. In particular <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">isElementOf</span> <span class="pre">(range</span> <span class="pre">a</span> <span class="pre">b)</span> <span class="pre">=</span> <span class="pre">(n</span> <span class="pre">isElemOf</span> <span class="pre">Integer)</span> <span class="pre">and</span> <span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">b</span></code>. Many typical integral data types could be represented as ranges in this way:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">unsigned</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">range</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="nf">signed</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">range</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="w"></span>

<span class="nf">byte</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="mi">8</span><span class="w"></span>
<span class="nf">sbyte</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">signed</span><span class="w"> </span><span class="mi">8</span><span class="w"></span>
<span class="nf">short</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">signed</span><span class="w"> </span><span class="mi">16</span><span class="w"></span>
<span class="nf">ushort</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="mi">16</span><span class="w"></span>
<span class="nf">int</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">signed</span><span class="w"> </span><span class="mi">32</span><span class="w"></span>
<span class="nf">uint</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="mi">32</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="kt">And</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Dependent types are useful too with ranges. For example, say I have an array and want to pass an index whose range is guaranteed to be in-bounds. I can associate the upper bound of the number’s range with the array length directly:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">get</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="kt">T</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="n">array</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Array</span><span class="w"> </span><span class="kt">T</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">range</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"></span>
<span class="nf">get</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="enumeration">
<h3>Enumeration<a class="headerlink" href="#enumeration" title="Permalink to this headline"></a></h3>
<p>An enumeration is a set of symbols but the order of the symbols is defined.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">enum</span><span class="w"> </span><span class="kt">Doneness</span><span class="w"> </span><span class="p">{</span><span class="kt">Rare</span><span class="p">,</span><span class="w"> </span><span class="kt">MediumRare</span><span class="p">,</span><span class="w"> </span><span class="kt">Medium</span><span class="p">,</span><span class="w"> </span><span class="kt">WellDone</span><span class="p">}</span><span class="w"></span>

<span class="kt">Rare</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="kt">WellDone</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">true</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="adts">
<h3>ADTs<a class="headerlink" href="#adts" title="Permalink to this headline"></a></h3>
<p>Abstract data types are sets containing trees of uninterpreted symbols. So a datatype declaration (from <a class="reference external" href="https://github.com/UlfNorell/insane/blob/master/Context.agda">here</a>)</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Cxt</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="kt">Ty</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Cxt</span><span class="w"> </span><span class="kt">Ty</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="n">nil</span><span class="w">  </span><span class="kt">:</span><span class="w"> </span><span class="kt">Cxt</span><span class="w"> </span><span class="kt">Ty</span><span class="w"></span>
<span class="w">   </span><span class="n">snoc</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="kt">G</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Cxt</span><span class="w"> </span><span class="kt">Ty</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Ty</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Cxt</span><span class="w"> </span><span class="kt">Ty</span><span class="w"></span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">symbol</span><span class="w"> </span><span class="n">nil</span><span class="w"></span>
<span class="nf">symbol</span><span class="w"> </span><span class="n">snoc</span><span class="w"></span>
<span class="kt">Cxt</span><span class="w"> </span><span class="kt">Ty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">arbElem</span><span class="nb">()</span><span class="p">;</span><span class="w"> </span><span class="n">assume</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="n">isOfType</span><span class="w"> </span><span class="kt">Cxt</span><span class="w"> </span><span class="kt">Ty</span><span class="p">);</span><span class="w"> </span><span class="n">assert</span><span class="p">(</span><span class="kt">Ty</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">isElemOf</span><span class="w"> </span><span class="kt">Set</span><span class="p">);</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nil</span><span class="w"></span>
<span class="w">   </span><span class="n">or</span><span class="w"> </span><span class="n">exists</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="n">y</span><span class="o">.</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">snoc</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="kt">G</span><span class="w"> </span><span class="n">isElemOf</span><span class="w"> </span><span class="p">(</span><span class="kt">Cxt</span><span class="w"> </span><span class="kt">Ty</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">isElemOf</span><span class="w"> </span><span class="p">(</span><span class="kt">Ty</span><span class="w"> </span><span class="kt">G</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><span id="id5">[<a class="reference internal" href="../zzreferences.html#id26" title="Stephen Dolan and Alan Mycroft. Polymorphism, subtyping, and type inference in MLsub. In Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages, POPL 2017, 60–72. Paris, France, January 2017. Association for Computing Machinery. URL: https://doi.org/10.1145/3009837.3009882 (visited on 2020-06-15), doi:10.1145/3009837.3009882.">DM17</a>]</span> section 2.2 says the recursive appearance of <code class="docutils literal notranslate"><span class="pre">Cxt</span> <span class="pre">Ty</span></code> is interpreted using the least pre-fixed point and Bekić’s theorem, but I think any fixed point will do.</p>
</section>
<section id="records">
<h3>Records<a class="headerlink" href="#records" title="Permalink to this headline"></a></h3>
<p>Record specifications can be closed, listing all properties, or open, allowing other associations not mentioned. For example <code class="docutils literal notranslate"><span class="pre">{a:</span> <span class="pre">&quot;s&quot;,</span> <span class="pre">b:</span> <span class="pre">2}</span> <span class="pre">isElementOf</span> <span class="pre">OpenRec</span> <span class="pre">[(&quot;b&quot;,Int)]</span></code>. The fields can be ordered or unordered. Some fields can be omitted, i.e. they are optional. This is different from a <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> type because <code class="docutils literal notranslate"><span class="pre">{a:</span> <span class="pre">Nothing}</span></code> is distinct from <code class="docutils literal notranslate"><span class="pre">{}</span></code>. This can be accomplished by writing <code class="docutils literal notranslate"><span class="pre">Rec</span> <span class="pre">[(&quot;b&quot;,Int,Optional)]</span></code>.</p>
<p>Rich Hickey seems to think values like <code class="docutils literal notranslate"><span class="pre">(&quot;b&quot;,Int)</span></code> are important and should have names like <code class="docutils literal notranslate"><span class="pre">:b</span></code> and <code class="docutils literal notranslate"><span class="pre">:c</span></code>, so you can write <code class="docutils literal notranslate"><span class="pre">{b:</span> <span class="pre">2,</span> <span class="pre">c:</span> <span class="pre">3}</span> <span class="pre">isElementOf</span> <span class="pre">Rec</span> <span class="pre">[:b,opt</span> <span class="pre">:c]</span></code>. I guess? It could be useful if you use the same fields a lot, but it doesn’t save too much typing. The real optimization is defining collections of fields, so you can write <code class="docutils literal notranslate"><span class="pre">Rec</span> <span class="pre">([:b,:c]</span> <span class="pre">++</span> <span class="pre">standardfields)</span></code>.</p>
<p>Clojure also has this thing about namespace qualification for records. XML had qualified names (namespaces), JSON doesn’t. Everybody has switched from XML to JSON. So it seems like namespaces are overcomplicating the issue. Generally formats have a single domain of authority and don’t need namespacing - the interpretation of a field is a property of the schema, not the value. This can be seen in the evolution of the <code class="docutils literal notranslate"><span class="pre">&lt;svg&gt;</span></code> element from</p>
<p>If you do have user-defined fields and need some simple thing to avoid key collisions you can use long key names like “org.mycompany.thing”. This relies on the simple assumption that non-namespaced property names won’t have “.” in them. But unlike a namespace mechanism this doesn’t view unqualified names as incomplete qualified names, rather it sees qualified names as over-specialized names. “Over” is because you can’t access it like <code class="docutils literal notranslate"><span class="pre">obj.org.mycompany.thing</span></code>, you have to write <code class="docutils literal notranslate"><span class="pre">obj[&quot;org.mycompany.thing&quot;]</span></code>.</p>
</section>
<section id="tracing">
<h3>Tracing<a class="headerlink" href="#tracing" title="Permalink to this headline"></a></h3>
<p>Often when checking if a value is in a set we want a detailed explanation why a value is not in a set, e.g. <code class="docutils literal notranslate"><span class="pre">(1,&quot;a&quot;)</span> <span class="pre">isElementOf</span> <span class="pre">(Int,Int)</span></code> could output <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">element:</span> <span class="pre">second</span> <span class="pre">component</span> <span class="pre">&quot;a&quot;</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">set</span> <span class="pre">Int</span></code>. More generally the message looks like <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">element:</span> <span class="pre">$at</span> <span class="pre">$val</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">set</span> <span class="pre">$set</span></code> and there is a stack of such messages from most specific to the overall expression.</p>
<p>Alternately we could provide the reduction history, something like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">)</span><span class="w"> </span><span class="n">isElementOf</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
<span class="mi">1</span><span class="w"> </span><span class="n">isElementOf</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="n">isElementOf</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="kt">True</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="n">isElementOf</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="kt">True</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
<span class="kt">False</span><span class="w"></span>
</pre></div>
</div>
<p>But basically this is an error message and error messages are hard.</p>
</section>
</section>
<section id="annotations">
<h2>Annotations<a class="headerlink" href="#annotations" title="Permalink to this headline"></a></h2>
<p>Programmers can use annotations to say that a value is in a specific set. This restricts the possible range of values an identifier may take, allowing the compiler to optimize for a specific runtime representation.</p>
<p>Set annotations are translated to assertions, and these assertions are statically checked, meaning values outside the set will give an assertion failure.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">assert</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="n">isElemOf</span><span class="w"> </span><span class="kt">T</span><span class="p">);</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Don’t override <code class="docutils literal notranslate"><span class="pre">:</span></code>, it is intended as a no-op. For conversions use the explicit function <code class="docutils literal notranslate"><span class="pre">convert</span> <span class="pre">Int64</span> <span class="pre">2</span></code>.</p>
</section>
<section id="function-annotations">
<h2>Function annotations<a class="headerlink" href="#function-annotations" title="Permalink to this headline"></a></h2>
<p>The main function type declaration restricts the definition of the function so it is only applied on the type, i.e. without other definitions the function is not defined outside its type. You can define multiple restricted functions to obtain overloaded behavior on different types. The restriction shows up in documentation and IDE tooltips.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">A</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="c1">-- expands to</span><span class="w"></span>

<span class="kt">A</span><span class="o">$</span><span class="n">untyped</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kt">A</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="w"> </span><span class="n">isElemOf</span><span class="w"> </span><span class="p">(</span><span class="kt">S</span><span class="p">,</span><span class="kt">T</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">ret</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">A</span><span class="o">$</span><span class="n">untyped</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="w"></span>
<span class="w">   </span><span class="n">assert</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="n">isElemOf</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">ret</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This behavior seems more similar to the type declarations found in other languages, hence why it is the default. E.g. in Rust <code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">f(i32)</span></code> cannot be applied to <code class="docutils literal notranslate"><span class="pre">i64</span></code>, whereas with the <code class="docutils literal notranslate"><span class="pre">check</span></code> version <code class="docutils literal notranslate"><span class="pre">f</span></code> could be applied to <code class="docutils literal notranslate"><span class="pre">i64</span></code>.</p>
<section id="dependent-types">
<h3>Dependent types<a class="headerlink" href="#dependent-types" title="Permalink to this headline"></a></h3>
<p>The types can bind the value, so Stroscot can express dependent types. And the values are in scope in the type, so even <a class="reference external" href="https://github.com/UlfNorell/insane/">insanely dependent types</a> can be defined:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">A</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="n">s</span><span class="w"></span>
<span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="c1">-- expands to</span><span class="w"></span>
<span class="kt">A</span><span class="o">$</span><span class="n">untyped</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
<span class="kt">A</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="w"> </span><span class="n">isElemOf</span><span class="w"> </span><span class="p">(</span><span class="kt">S</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">A</span><span class="o">$</span><span class="n">untyped</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="n">isElemOf</span><span class="w"> </span><span class="p">(</span><span class="kt">T</span><span class="w"> </span><span class="n">s</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">ret</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="check">
<h3>Check<a class="headerlink" href="#check" title="Permalink to this headline"></a></h3>
<p>Another version of typing functions simply checks compatibility with a type, that the return value is in the expected set over the whole input range.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="nf">check</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>

<span class="c1">-- expands to</span><span class="w"></span>

<span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>

<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">arbElem</span><span class="nb">()</span><span class="w"></span>
<span class="w">  </span><span class="n">assume</span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="n">isElemOf</span><span class="w"> </span><span class="kt">S</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="kt">A</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">isElemOf</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="total-check">
<h3>Total check<a class="headerlink" href="#total-check" title="Permalink to this headline"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">check</span></code> allows partial functions, i.e. nonterminating behavior or throwing exceptions. With a total check all behavior must be accounted for, similar to checked exceptions.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">total_check</span><span class="w"> </span><span class="p">(</span><span class="o">/</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">DivideByZero</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>You can also specify a total type signature:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">total</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">DivideByZero</span><span class="p">)</span><span class="w"></span>
<span class="kt">A</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>This is equivalent to specifying the regular type signature and also a <code class="docutils literal notranslate"><span class="pre">total_check</span></code>.</p>
<p>Total check can be used for unit testing, just put the arguments and results in singleton sets:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">check</span><span class="w"> </span><span class="n">square</span><span class="w"> </span><span class="kt">:</span><span class="w">  </span><span class="p">{</span><span class="mi">2</span><span class="p">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="mi">4</span><span class="p">}</span><span class="w"></span>
<span class="nf">check</span><span class="w"> </span><span class="n">square</span><span class="w"> </span><span class="kt">:</span><span class="w">  </span><span class="p">{</span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="mi">9</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="contracts">
<h3>Contracts<a class="headerlink" href="#contracts" title="Permalink to this headline"></a></h3>
<p>Spec#, Eiffel, Ada SPARK, and Argus have “contracts”, requires/ensures on methods. Many checks/throws in .NET and Java can be expressed as preconditions. In Stroscot preconditions can be represented using dependent types and a refinement type on the argument before the result. E.g. a “requires notnull” is written:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">total</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="p">(</span><span class="n">null</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>And a multiple argument example, <code class="docutils literal notranslate"><span class="pre">requires</span> <span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">total</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Nat</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Nat</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Nat</span><span class="w"></span>
</pre></div>
</div>
<p>It looks a little weird, but IMO it’s fine, and macros can implement the <code class="docutils literal notranslate"><span class="pre">requires</span></code> syntax if need be.</p>
<p>Postconditions (“ensures”) can be expressed as restrictions on the return type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">total</span><span class="w"> </span><span class="n">square</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="the-curse-of-static-typing">
<h3>The curse of static typing<a class="headerlink" href="#the-curse-of-static-typing" title="Permalink to this headline"></a></h3>
<p>If a function <code class="docutils literal notranslate"><span class="pre">foo</span></code> does something unexpected, there are three possibilities:</p>
<ol class="arabic simple">
<li><p>Some unusual overloading of foo was defined. That is that clause’s problem. You shouldn’t override equals to return true only if the square root of one is the same as the other, and similarly you shouldn’t have overloaded foo and done something unexpected. Static verification can help with this by documenting the expected properties. The solutions are to verify, change the behavior, or split the behavior into a different function name.</p></li>
<li><p>foo was defined with a reasonable clause but the clause relied on a contract that wasn’t described. This is harder to catch as static verification usually only covers a subset of behavior, but the solution is to limit the clause with a signature / contract.</p></li>
<li><p>foo would work, but its signature has been defined too narrowly so is undefined</p></li>
</ol>
<p>Usually functions are clearly written and work as long as the functions they call work on the arguments. So it is this third case that bites, because you can overload the called functions but you can’t relax the signature. So restrictive signatures are a curse in this example.</p>
</section>
</section>
<section id="type-synthesis">
<h2>Type synthesis<a class="headerlink" href="#type-synthesis" title="Permalink to this headline"></a></h2>
<p>Type synthesis is tricky, but with the termination checker we don’t have any visible types. The optimizer does a form of type synthesis when it assigns formats to values, but the formats can be conditional on state, and the optimizer will use a catch-all format for hard cases, so the formats are complete but not sound. The only useful case for a complex type synthesis algorithm might be pretty-printed type signatures in documentation, but there having the developer specify type signatures is a viable option.</p>
<p>But <a class="reference external" href="https://github.com/UlfNorell/insane/">dependent</a>
<a class="reference external" href="https://github.com/gelisam/circular-sig">circular</a> dependent types will presumably ruin all the fun and require type signatures.</p>
<p>We could do synthesis at run time, e.g. the type of a list of values is the list type applied to the set of values contained in the list. This might be useful for resolving type-overloaded methods.</p>
</section>
<section id="roles">
<h2>Roles<a class="headerlink" href="#roles" title="Permalink to this headline"></a></h2>
<p>Roles are just an optimization for <code class="docutils literal notranslate"><span class="pre">coerce</span></code>, but there are better ways to implement optimizations. It seems like a dirty hack to solve a pressing problem. I think Stroscot can get by without them.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Reduction-Example.html" class="btn btn-neutral float-left" title="Reduction example" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="State.html" class="btn btn-neutral float-right" title="Imperative programming" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2020 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>