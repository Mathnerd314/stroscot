<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Syntax &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Term rewriting" href="TermRewriting.html" />
    <link rel="prev" title="Stateful programming" href="State.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Intrinsics.html">Intrinsics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Syntax</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#design-procedure">Design procedure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#survey-content">Survey content</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#text-based">Text-based</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#legibility-readability">Legibility/readability</a></li>
<li class="toctree-l4"><a class="reference internal" href="#proportional-fonts">Proportional fonts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dsls">DSLs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#learning">Learning</a></li>
<li class="toctree-l3"><a class="reference internal" href="#filenames">Filenames</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unicode">Unicode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#usability">Usability</a></li>
<li class="toctree-l4"><a class="reference internal" href="#language-fragmentation">Language fragmentation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unicode-overuse">Unicode overuse</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encoding">Encoding</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nfc">NFC</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nfkc">NFKC</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tr31">TR31</a></li>
<li class="toctree-l4"><a class="reference internal" href="#case-restrictions">Case restrictions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#confusables">Confusables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#script-restrictions">Script restrictions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bidi-attack">Bidi attack</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#parsing">Parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#blocks">Blocks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#applicativedo">ApplicativeDo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recursivedo">RecursiveDo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arrows">Arrows</a></li>
<li class="toctree-l4"><a class="reference internal" href="#idiom-brackets">Idiom brackets</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-like-reference-access">C-like reference access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#assignment">Assignment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#constructor-discipline">Constructor discipline</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recursive-definitions">Recursive definitions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#type-declarations">Type declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#namespacing">Namespacing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#partial-loading">Partial loading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#specificity">Specificity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#comments">Comments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#shebangs">Shebangs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#types">Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id17">Parsing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#whitespace">Whitespace</a></li>
<li class="toctree-l3"><a class="reference internal" href="#indentation-sensitivity">Indentation sensitivity</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#blind-community">Blind community</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#braces-and-brackets">Braces and brackets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-syntax">Function syntax</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#arguments">Arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#call-syntax">Call syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-arguments">Implicit arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#n-k-patterns">n+k patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pattern-matching-conditionals">Pattern matching / conditionals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id21">Assignment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#chained-assignment">Chained assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#embedded-assignment">Embedded assignment</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#conditionals">Conditionals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#integers">Integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tuples-and-records">Tuples and records</a></li>
<li class="toctree-l3"><a class="reference internal" href="#precedence">Precedence</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cycle">Cycle</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#logic-programming">Logic programming</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#relations">Relations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#primitives">Primitives</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#functional-programming">Functional programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="#go-syntax-notes">Go syntax notes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id28">DSLs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#identifier-conventions">Identifier conventions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#layout">Layout</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#operators">Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parentheses">Parentheses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chained-comparison">Chained Comparison</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#variables">Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id31">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#patterns">Patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#destructuring-and-function-bindings">Destructuring and function bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="#symbols">Symbols</a></li>
<li class="toctree-l4"><a class="reference internal" href="#non-linear-patterns">Non-linear patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pattern-synonyms">Pattern synonyms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variable-bindings">Variable bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inline-definitions">Inline definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#keyword-arguments">Keyword arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#positional-arguments">Positional arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id32">Implicit arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#default-arguments">Default arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#output-arguments">Output arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variadic-arguments">Variadic arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#concatenative-arguments">Concatenative arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inheritance">Inheritance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id33">Operators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#lambdas">Lambdas</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#matching">Matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operator-sections">Operator sections</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id34">Blocks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bang-notation">Bang notation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#local-definitions">Local definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#monad-comprehensions">Monad comprehensions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#control-structures">Control structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#programs">Programs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id35">Comments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id36">Type declarations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Syntax</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Syntax.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="syntax">
<h1>Syntax<a class="headerlink" href="#syntax" title="Permalink to this heading"></a></h1>
<p>In Stroscot, since syntax is pluggable, the standard syntax is really within the purview of the standard library. But a default syntax is necessary for writing the compiler, so we have to figure a syntax out first in order to bootstrap. The stuff here is mostly a dumping ground of ideas while the rest of the language is designed. No syntax choices are final. But in the end, syntax is decided by usage, so a lot of the syntax here will probably become final, unless the novice survey comes up with better choices.</p>
<section id="design-procedure">
<h2>Design procedure<a class="headerlink" href="#design-procedure" title="Permalink to this heading"></a></h2>
<p>At the end of the day syntax is about picking a choice and sticking to it. There are many ways to do this. My original plan was to go through the syntax of other languages listed on RosettaCode and <a class="reference external" href="http://rigaux.org/language-study/syntax-across-languages/">Rigaux’s list of syntax across languages</a>) and pick out the nicest/most common examples. But this is not really a scientific procedure. For example, take comments. Counting up examples on Rosetta Code’s <a class="reference external" href="https://rosettacode.org/wiki/Comments">comment page</a> showed the most common choices:</p>
<ul class="simple">
<li><p>For EOL impl, C++ style <code class="docutils literal notranslate"><span class="pre">//</span></code></p></li>
<li><p>For block impl, C style <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span></code></p></li>
<li><p>For EOL doc, D style <code class="docutils literal notranslate"><span class="pre">///</span></code>.</p></li>
<li><p>For block doc, Javadoc style <code class="docutils literal notranslate"><span class="pre">/**</span> <span class="pre">*/</span></code></p></li>
<li><p>For code comments (nesting block), Pascal style <code class="docutils literal notranslate"><span class="pre">(*</span> <span class="pre">*)</span></code></p></li>
</ul>
<p>But are these the best choices? There are lots of other options, an EOL impl comment can be <code class="docutils literal notranslate"><span class="pre">;</span></code> or <code class="docutils literal notranslate"><span class="pre">#</span></code> or  <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>. Similarly there are many choices for other syntactic elements. Quorum and its associated set of studies by Stefik provide an alternative approach - design a survey and ask novices what they think is most intuitive. As he says in the papers, choices ranked highly by experienced programmers but not chosen by novices are likely mistakes in PL design, learned helplessness since unintuitive PL syntax is hard to change.</p>
<p>Stefik used a mixture of CS university students (freshman year novices and junior/senior year programmers). But since we’re designing for novices we don’t actually care about or need to measure experienced programmers. So using a convenience sample by posting a Google Form / SurveyMonkey / LimeSurvey to r/learnprogramming isn’t that hard - polls need approval but this seems like it might be allowed. (TODO: is there a better place on the internet to find programming novices?). General outline:</p>
<ul>
<li><p>Title: “Never programmed? Help design a new programming language! (Survey)”</p></li>
<li><p>Demographics: age, gender, native English speaker. These are mentioned as questions in Stefik’s survey <span id="id1">[]</span>, but aren’t mentioned as having any statistically significant correlations, so can probably be left out or be highly stratified to make people less worried about giving out personal information. <span id="id2">[<a class="reference internal" href="../zzreferences.html#id45" title="Rodrigo Magalhães dos Santos and Marco Aurélio Gerosa. Impacts of coding practices on readability. In Proceedings of the 26th Conference on Program Comprehension, 277–285. Gothenburg Sweden, May 2018. ACM. URL: https://dl.acm.org/doi/10.1145/3196321.3196342 (visited on 2022-05-18), doi:10.1145/3196321.3196342.">dosSantosG18</a>]</span> did find statistically significant differences for females to prefer multiple statements on one line and more intermedate variable assignments, but there were only 7 females so this is probably noise. OTOH, it would be useful to have demographics to compare to large surveys like the <a class="reference external" href="https://insights.stackoverflow.com/survey/2021">Stack Overflow Developer Survey</a>.</p></li>
<li><p>programming experience. Stefik found that programmers will list experience with individual languages even when reporting no experience total, so it seems best to skip an overall experience question and ask individually with a language matrix. Since not all languages will be listed we’ll have an “All other programming languages” catch-all at the end. Stefik presumably asked an empty-box “how many years of experience do you have with X” question. But a matrix requires choices. Taking his mean experience reported as the data points, for experienced programmers, dividing into 5 buckets we have 0-0.03,0.03-0.09,0.9-0.22,0.28-0.48,0.67-1.76. For inexperienced programmers, we have 0-0 as a large bucket and then the remaining range is split into 0-0.01,0.01-0.03,0.05-0.09,0.12-0.23. Combining experienced and inexperienced, the 0-0 bucket stays and we have 4 more buckets 0.01-0.03 (±0.11-0.16), 0.03-0.09 (±0.18-0.31), 0.11-.28 (±0.41-1.06),0.39-1.76 (±.0.7-1.87) Translating into familiar units, these buckets are no experience, &lt;11 days, 11-33 days, 40-102 days (1.32-3.36 months), 4.68+ months. Given the wide uncertainties we can round to no experience, &lt; 2 weeks, 2 weeks to 1 month, &gt;1 month and &lt;4 months, or 4+ months. It’s not as accurate as the empty-box but hitting a circle on mobile is much easier. In terms of the survey of <span id="id3">[]</span>, it is a quantified version of the self-estimation that rates experience as 1-5. We can sum the (approximate) years of experience to obtain overall years of experience, which should lead to Siegmund’s “professional programming experience” factor, which IMO is the correct factor to use to measure programming experience. But we would have to do another validation study with university students to verify that this metric correlates with the ones in Siegmund’s study. In fact though I am mainly going to use the metric as a binary variable, novice vs. not, so it’s not too important.</p>
<p>As far as languages, Study 1 had HTML, C++, Java, Matlab, JavaScript, Basic, COBOL reported with experience for non-programmers and Study 2 was similar with the addition of PHP. Considering programmers among both studies, we would add C#, Python, Ruby, and COBOL as &lt;1 month languages, and Perl and FORTRAN as &lt;2 week languages. Meanwhile the SO language list top 15 is JavaScript, HTML/CSS, Python, SQL, Java, Node.js, TypeScript, C#, Bash, C++, PHP, C, Powershell, Go, Kotlin, with a clear break in popularity from C at 21% to Powershell at 10%. The question asked for “extensive development work in the past year” though so is not really a question about which languages are most likely to have beginner exposure. Contrariwise TIOBE does not consider HTML a programming language because it is not Turing complete, but does list SQL. We do not want to list too many languages, because marking lots of languages as “no experience” is tedious, but a good selection is key to defining the question and ensuring the catch-all is answered accurately. One design point would be to preselect “no experience” for all but the catch-all, solving the tedium issue, but the survey tool would have to support this.</p>
</li>
<li><p>Have you heard of the Stroscot or Quorum programming languages before this survey? Yes/no. This is a question Stefik says he wished he had asked, to avoid confounding results.</p></li>
</ul>
<p>The meat of the survey is questions of the form “how do you think &lt;english description of PL task&gt; should look?”. First we want an open-ended text field to get unprimed responses, then multiple-choice to compare against existing PL syntaxes. Stefik did individual rankings of each choice on a 0-100% scale by 10%’s, but I think “rank top 3 choices” is sufficient and less tedious.</p>
<section id="survey-content">
<h3>Survey content<a class="headerlink" href="#survey-content" title="Permalink to this heading"></a></h3>
<p>According to <span id="id4">[]</span> there are two important classes of validity. First is content: establishing the topics to be surveyed, and ensuring they have reasonable coverage of the subject area. IMO Stefik failed on this point - he just picked some basic Java-style keywords and constructs. Hence his research was quite limited - he didn’t systematically go through every design choice possible in a programming language. <span id="id5">[]</span> went through “widely adopted” introductory textbooks to select a set of CS1 topics, but ended up with more than 400 topics - they pruned them to 29 by limiting to concepts missing from at most one textbook. And with the focus on “wide adoption” they ended up including OO but not FP. The fact that Tew tested their exam only on Java, Matlab, and Python programmers is telling. Since Stroscot is a functional logic programming language, it will likely have some different fundamental concepts, and “wide adoption” is not necessarily the right inclusion criteria. I actually think ChatGPT can help a lot here - it knows the basic concepts used in programming and can devise wording that avoids prompting with the answer. The PL tasks should be a mixture of basic tasks common to all languages (operations, control, data structures) and Stroscot-specific tasks that showcase its unique features.</p>
<p>A secondary form of validity is construct validity. This ensures that the survey is actually measuring what it is designed to measure, rather than something else. Without some procedures in place, it is easy to write bad questions. They can be unclear, resulting in participants answering the wrong question. They can be biased with “leading questions”, resulting in canned answers rather than useful data. Unfortunately, some amount of priming is necessary, because novices do not know what the basic syntactic constructs of a language are. If you give novices a blank page and ask them to design a programming language, you will most likely get a simple language with glaring deficiencies. But similarly if you ask a novice “What syntax should be used for the if-else statement?” there is not much leeway in the question - most likely they will use the if and else keywords. So the wording of a question can be quite important.</p>
<p>For construct validity, Stefik showed the questionnaire to several experts and resolved all issues. He also did pilot studies with both experts and novices, and confirmed that they gave decent answers. He also submitted the study for peer review. Tew used item-response statistics and also validated their questions by conducting think-aloud interviews during pilot versions of the test, showing that correct mental models corresponded to correct answers and likewise for incorrect. For similarly validating the constructs of my survey, CCC is a forum of expert programmers, and I can post the survey to /r/ProgrammingLanguages as a trial run. The write-your-own-syntax freeform question is similar to the think-aloud study. So the only missing quality assurance factor is peer review. It seems for journals in education/UX research, around 1/3 of on-topic papers submitted get accepted. ACM publishing is free, so it could be done. I don’t really attach much importance to peer review though.</p>
<p>Some studies use a “Randomo” language which randomizes design choices. It would be useful to implement syntax randomization so choices could be compared and tested. Basically we store code as base64 or a Lisp-like AST dump, and then the formatter produces/consumes this like any other code style. Then people get an initial randomized style, but can customize it to their liking, and once we reach 100 users we have a syntax battle.</p>
<p>Some languages offer a “simple” syntax. But simplicity is hard to define, and boils down to either a simple implementation (LR parser) or else just the syntax familiar to them from other languages (which implementation-wise is often quite complex). People seem to be afraid of new syntax so there is the tendency to make it explicit and loud while reserving the terse syntax for established features. But Stroscot’s goal is to unify all the features, so all of the notation is designed to be short, terse, flexible, and general.</p>
<p>Haskell/Idris syntax is mostly awesome, use it. (TODO: check this. The weird function call syntax may lose too many users) Almost everything is an expression. But there’s also block statements and layout.</p>
<p>Natural language like Inform 7, while interesting, is quite wordy. It’s also hard to scan through.</p>
<p>Fortress has “mathematical syntax”, with an ASCII form and typeset form. They used LaTeX but HTML / MathML output should be possible too. And juxtaposition was overloaded. Probably worth emulating.</p>
<p>A language encourages certain expressions of thought. If the syntax is awkward then the feature will be used less and a bias will be introduced. But the styles of programming people come up with after a language is released are often completely different to what was intended by the language (e.g. Java and its design patterns). It’s not clear that anything can be done about this, besides capturing as many existing patterns as cleanly as possible.</p>
</section>
</section>
<section id="text-based">
<h2>Text-based<a class="headerlink" href="#text-based" title="Permalink to this heading"></a></h2>
<p>There are some people who, when confronted with the complexity of syntax, think “It’s better to use a binary format and store everything in a database.” Now they have two problems. Math is textual, English is textual, the only programming stuff that isn’t textual are flowcharts and tables. Flowcharts might be OK (e.g. Labview) but graph layout is hard - graphviz barely works, and most graph layout algorithms such as IDA Pro’s are quite lacking. Labview struggleseven to layout wires (edges). Tables lead into spreadsheet programming which is generally not expressive as a language - and the formulas and cell values are textual. If you show me a way to write 123.6 that doesn’t involve text maybe visual programming is worth considering.</p>
<p>There’s also structural editing, <a class="reference external" href="http://www.lamdu.org/">lamdu</a> and so on, but they are designing an IDE alongside a programming language. I’m not too interested in IDEs and given that half the IDEs are for languages that also have a textual syntax, syntax doesn’t seem to be a big factor in writing such an IDE.</p>
<section id="legibility-readability">
<h3>Legibility/readability<a class="headerlink" href="#legibility-readability" title="Permalink to this heading"></a></h3>
<p>There have been many legibility/readability studies, but they have to be evaluated carefully. Some are out of date, some were poorly designed, and some are just not relevant to programming. So we have to describe our assumptions and working setup.</p>
<p>The first question is the medium. Most code will be read on a computer screen. Computer monitors have improved greatly over the years. Comparing the monochrome 1024x780 114ppi 11” $10k+ Tektronix 4010 in 1972 to the 24-bit color 1600x1024 110ppi 17.3” $2.5k SGI 1600SW in 1998 to the 3840x2160 140ppi 32” $850 Dell U3223QE recommended by <a class="reference external" href="https://www.rtings.com/monitor/reviews/best/by-usage/programming-and-coding">RTings</a> as of 2023, we see cost has significantly decreased and also there has been a significant amount of readability improvements in ppi, contrast, brightness, and persistence / refresh rate. Per <a class="reference external" href="https://en.wikipedia.org/wiki/Pixel_density#Printing_on_paper">WP</a>, PPI is about half DPI, so the 300 DPI “good quality typographic print” standard corresponds to 150ppi. With subpixel rendering enhancing horizontal resolution, the recent 140ppi monitors are finally starting to have decent text quality, and that ppi is probably becoming standard for professionals. But there are even higher PPI displays, e.g. a 23.8” 185ppi LG 24UD58 or Macbook “retina” laptop display, and there are reports that these high ppi have perceivably better text quality.</p>
<p>But let’s go through the findings.</p>
<ul class="simple">
<li><p>Many sources mention in passing that consistency improves readability. In particular, reading is disrupted when unconventional layouts, colors, or fonts are used, or when different values of such attributes are mixed in unconventional ways. <span id="id6">[]</span> This seems generally applicable. The IDE dictates fonts / spacing / coloring so we should ensure good IDEs are used for Stroscot.</p></li>
<li><p>The general rule for spacing is that it should be significantly larger than its next-smallest spacing unit to clearly identify the boundary it marks.</p>
<ul>
<li><p>Intra-letter spacing should be significantly smaller than inter-word spacing to allow identifying words.</p></li>
<li><p>The inconsistent inter-word spacing of justified text is harder to read than ragged-right. With good line breaking this is not as much of an issue but the effect is still there.</p></li>
<li><p>For sentences, there should be a little extra space after the period to emphasize the sentence boundary. Just a little, not a double space, because period-normal space is almost visually distinctive enough by itself and people have gotten used to that spacing.</p></li>
<li><p>The default inter-line spacing (line height, leading) in browsers is fine for most people. Some people with disabilities need more line height. Wider columns require a bit more line height.</p></li>
<li><p>To identify paragraphs, inter-paragraph spacing should be visibly larger than inter-line spacing, or paragraph indentation should be used.</p></li>
</ul>
</li>
<li><p>For English, and presumably other LTR languages, left-aligned text is easier to read than centered or right-aligned text because the reader knows where to look to find the next line.</p></li>
<li><p>According to an old study: “Longer lines will be read faster, due to less time scrolling. Though print studies find faster reading at medium line lengths, reading text on a computer screen is really exhausting, and slower than print, so there is no benefit to short lines except at large font sizes. Reading from a computer screen is different from printed media.” But there are newer monitors, so this has to be tested again. There are also physical constraints. Diff programs seem like a limiting case - on my monitor I can fit 2 108-character texts at the default font size side-by-side along with a space in the middle and the taskbar. Rounding this down to 100 leaves room for line numbers and similar decorations. Plus, most diffs these days are unified, and line-wrapping is always an option for smaller screens. OTOH it’s a tiny font, 18-26pt is the most readable for websites so maybe that size is needed for programming. At 18pt / 24px I can fit 97 characters, while a little less (17.25pt / 23px) fits 102 characters. The standard is 80 characters but monitors are wider now than they were in teletype days, so again 100 seems plausible.</p></li>
<li><p>Line-breaking (Knuth-Plass, hanging indents on soft linebreaks, etc.): This can really only be tested by finding long lines of code and asking what line-breaking placement is most readable;</p></li>
<li><p>A widow is when a paragraph line-breaks and leaves a word on its own line at the end. An orphan is when a paragraph line-breaks across a page and leave less than a full line on the next page. Widow and orphan lines are commonly cited as decreasing legibility, but I didn’t find any formal studies. I think people get used to bad line breaking. Also most code is viewed on a computer rather than printed out. So what should really be considered is code that doesn’t fit on one screen.</p></li>
</ul>
<p>Reading code top-to-bottom, left-to-right makes sense. So definitions should be on the left, blocks indented in, and lines themselves should read left to right. So Ruby’s statement modifiers <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">if</span> <span class="pre">Y</span></code> are a bad idea because the <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">Y</span></code> is easy to miss when scanning control flow.  But operators like <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">xor</span> <span class="pre">c</span></code> are fine because the assignment <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span></code> is clear and if the value of the expression matters you’re reading the whole line anyway and can parse it in your head.</p>
<p>Unicode can improve legibility when the character is standard (e.g. θ for angles), but generally long names like <code class="docutils literal notranslate"><span class="pre">Optimiser(learning_rate=...)</span></code> are more readable than <code class="docutils literal notranslate"><span class="pre">Optimiser(η=...)</span></code>. Programmers have neither the time nor the inclination to learn a new character set and accompanying set of conventions.</p>
<p>When the convention is established, short names are clearer than long names. Writing <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">{</span> <span class="pre">augend</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">addend</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">}</span></code> is less clear than the simple <code class="docutils literal notranslate"><span class="pre">1+2</span></code> - the long names are not commonly used. But it is arguably still useful to include the long names, e.g. for currying.</p>
<p>A study <span id="id7">[<a class="reference internal" href="../zzreferences.html#id45" title="Rodrigo Magalhães dos Santos and Marco Aurélio Gerosa. Impacts of coding practices on readability. In Proceedings of the 26th Conference on Program Comprehension, 277–285. Gothenburg Sweden, May 2018. ACM. URL: https://dl.acm.org/doi/10.1145/3196321.3196342 (visited on 2022-05-18), doi:10.1145/3196321.3196342.">dosSantosG18</a>]</span> found the following conventions were helpful for Java code readability:</p>
<ul class="simple">
<li><p>Putting opening braces in a line of their own (C# convention), as opposed to the same line of the statement, improved readability. The extra white space and matching vertical alignment of related curly braces makes blocks clearer. Closing curly braces terminating code blocks should be on their own line, except for secondary paths of execution, e.g.: closing brace of if statements followed by an else; closing braces of try statements followed by a catch.</p></li>
<li><p>80 character line lengths were helpful, although they did not test other lengths such as 100 or 120</p></li>
<li><p>Each statement should be in a line of its own; do not separate multiple statements by a ‘‘;’’ in a single line.</p></li>
<li><p>Use import clauses instead of qualified names to reference names in code.</p></li>
<li><p>Frequent calls to sub-properties of class member properties should be made by storing a reference to that sub-property, avoiding multiple statements containing long chains of objects and sub-properties;</p></li>
<li><p>Identifier names should use dictionary words.</p></li>
</ul>
<p>These conventions were inconclusive:</p>
<ul class="simple">
<li><p>Grouping instructions using blank lines was 50/50. Some thought the blanks broke the flow, others liked it.</p></li>
<li><p>On indenting 2 spaces vs 4 spaces, 58% preferred the 2 spaces.</p></li>
<li><p>Nesting conditionals more than three levels deep was considered by some to be easy to read and clearer than using a complex condition. But the majority preferred refactoring to an <code class="docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span></code> chain.</p></li>
<li><p>Using variables to store intermediate parts of long logical expressions was vetoed by 61%. It is only useful if that intermedate expression has a meaningful name and purpose or the expression is repeated. Otherwise it adds clutter, and you are better off just writing the complex expression.</p></li>
</ul>
<p><span id="id8">[<a class="reference internal" href="../zzreferences.html#id15" title="Jennifer Bauer, Janet Siegmund, Norman Peitek, Johannes C. Hofmeister, and Sven Apel. Indentation: Simply a Matter of Style or Support for Program Comprehension? In 2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC), 154–164. Montreal, QC, Canada, May 2019. IEEE. URL: https://ieeexplore.ieee.org/document/8813302/ (visited on 2022-05-19), doi:10.1109/ICPC.2019.00033.">BSP+19</a>]</span> studied indentation with eye tracking and found no statistically significant difference between 0,2,4,8 spaces. Looking at their graphs 4 spaces does seem to be a sweet spot though.</p>
<p>Another study <span id="id9">[<a class="reference internal" href="../zzreferences.html#id24" title="Raymond P.L. Buse and Westley R. Weimer. A metric for software readability. In Proceedings of the 2008 International Symposium on Software Testing and Analysis - ISSTA '08, 121. Seattle, WA, USA, 2008. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1390630.1390647 (visited on 2022-05-19), doi:10.1145/1390630.1390647.">BW08</a>]</span> identified factors for readability, in decreasing order of significance:</p>
<ul class="simple">
<li><p>fewer identifiers per line</p></li>
<li><p>shorter lines (characters)</p></li>
<li><p>fewer ‘(’ ‘{’ ‘.’ ‘,’</p></li>
<li><p>less indentation (preceding whitespace)</p></li>
<li><p>fewer keywords</p></li>
<li><p>more blank lines</p></li>
<li><p>lower maximum occurrences of any single identifier</p></li>
<li><p>shorter maximum length of identifier</p></li>
<li><p>lower maximum occurrences of any single character</p></li>
<li><p>more comments</p></li>
<li><p>fewer ‘=’  numbers spaces ‘==’ ‘&lt;’ ‘&gt;’ ‘if’ ‘for’ ‘while’</p></li>
<li><p>higher number of ‘+’ ‘*’ ‘%’ ‘/’ ‘-’</p></li>
</ul>
<p>They constructed several models using these factors, mainly a Bayesian classifier, all of which predicted average readability scores better than the original human raters. But the model is not public.</p>
</section>
<section id="proportional-fonts">
<h3>Proportional fonts<a class="headerlink" href="#proportional-fonts" title="Permalink to this heading"></a></h3>
<p>For prose, a proportional fonts is more readable than monospace because it is denser and hence less eye movement is needed for reading. Spaces between words are easier to see. <span id="id10">[<a class="reference internal" href="../zzreferences.html#id11" title="Aries Arditi, Kenneth Knoblauch, and Ilana Grunwald. Reading with fixed and variable character pitch. Journal of the Optical Society of America A, 7(10):2011, October 1990. URL: https://opg.optica.org/abstract.cfm?URI=josaa-7-10-2011 (visited on 2022-05-25), doi:10.1364/JOSAA.7.002011.">AKG90</a>]</span> But proportional fonts have not caught on in programming. The main complaint is that identifiers do not line up nicely the way they do with a monospace font.</p>
<p>After reading about elastic tabstops I’ve come up with my own solution, “tablike spaces”. The idea here is to use a proportional font for rendering, but to make the spaces jump to the pixel column they would use if the font was monospaced. So rendering “a bit of text” would render “a” at 0, “bit” at 2 ems, “of” at 6 ems, and “text” at 9 ems, where an em is the width of the widest character in the font.</p>
<p>A more complex algorithm treats the text as a giant table, so “a bit of text” gets split up into 4 cells “a “, “bit “, “of “, “text” which span 2,4,3,4 columns respectively. Then the column widths are calculated using the <a class="reference external" href="https://www.w3.org/TR/CSS2/tables.html#auto-table-layout">auto table layout algorithm</a> (simplified):</p>
<ul class="simple">
<li><p>Set the width of each column to 0.</p></li>
<li><p>For each cell, calculate the width as rendered by the font, and increase the widths of the columns it spans so that together, they are at least as wide as the cell. Widen all spanned columns to be approximately the same.</p></li>
</ul>
<p>Yet more complex is to treat it as a constraint problem. The constraints consist of minimum width constraints from the width of the tokens and order constraints that specify which chunks of text are before/after/line up with other chunks. The goal is to minimize the width of the table (sum of column widths), and as a secondary objective make the widths as uniform as possible (lowest standard deviation or absolute deviation). The Cassowary algorithm might work.</p>
<p>The constraint algorithm allows aligning the ends of text by justifying, so e.g. <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">=</span></code> and <code class="docutils literal notranslate"><span class="pre">bar</span> <span class="pre">=</span></code> have the identifiers stretched to the same width. But generally it is only the start of the text that needs to be aligned.</p>
<p>TODO: test it out by modifying <a class="reference external" href="https://github.com/isral/elastic_tabstops_mono.vsce">https://github.com/isral/elastic_tabstops_mono.vsce</a></p>
<p>The advantage of tablike spaces over elastic tabstops is that the underlying text file looks fine when viewed in a monospaced font. So it’s only the visual presentation that changes, hence it can be used on a team.</p>
</section>
<section id="dsls">
<h3>DSLs<a class="headerlink" href="#dsls" title="Permalink to this heading"></a></h3>
<p>Stroscot aims to be a “pluggable” language, where you can write syntax, type checking, etc. for a DSL and have it embed seamlessly into the main language. This may be possible due to the fexpr semantics, which allows pattern-matching the AST of any expression, like <code class="docutils literal notranslate"><span class="pre">javascript</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">&quot;abc&quot;</span> <span class="pre">{</span> <span class="pre">234</span> <span class="pre">})</span></code>, or may need more work to also do character-level embedding or seamless integration of parsers / escape sequences.</p>
<p>Example DSLs:</p>
<ul class="simple">
<li><p>SQL</p></li>
</ul>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">run_sql_statement</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">SELECT</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Assembly and C++.</p></li>
</ul>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">result</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">asm</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sumsq</span><span class="w"> </span><span class="p">(</span><span class="n">toregister</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">toregister</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="nf">my_func</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">load</span><span class="p">(</span><span class="s">&quot;foo.cpp&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;my_func&quot;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>TeX / mathematical expressions:</p></li>
</ul>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tex</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ax</span><span class="o">^</span><span class="mi">4</span><span class="o">+</span><span class="n">cx</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="p">}</span>
<span class="nf">math</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">beta</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">phi</span><span class="w"> </span><span class="n">lambda</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>It is not just fancy syntax. DSLs that use vanilla syntax are useful for staging computations, like passes that fuse multiple operations such as expmod and accuracy optimizers that figure out the best way to stage a computation.</p>
</section>
</section>
<section id="learning">
<h2>Learning<a class="headerlink" href="#learning" title="Permalink to this heading"></a></h2>
<p>Learning a language takes time and effort. Self-taught novices might want to start with a book. How long should it be? A <a class="reference external" href="https://www.amazon.com/Python-Programming-Beginners-Comprehensive-Hands/dp/B0BFV21L24/">121 page Python book (60 pages double spaced)</a> is derided as terse and useless, requiring to google every new keyword. <a class="reference external" href="https://www.amazon.com/C-Programming-Language-2nd-Edition/dp/0131103628/">K&amp;R C</a> has 272 pages, but is “not beginner friendly”. The <a class="reference external" href="http://www.csharpcourse.com/">C# Programming Yellow Book</a>  is 217 8.5x11 pages or about 322 of the standard 7x9 pages. <a class="reference external" href="https://www.amazon.com/Python-Kids-Playful-Introduction-Programming/dp/1593274076/">Python for Kids</a> clocks in at 344 pages but is still missing critical functions such as the input command. On the other hand some chapters such as turtle graphics, tkinter, and classes/objects can be skipped (74 pages). My first programming book <a class="reference external" href="https://www.amazon.com/Beginning-Programming-Java-Dummies-Computers/dp/0764526464/">Beginning Programming with Java For Dummies</a> had 408 pages. The <a class="reference external" href="https://www.amazon.com/Beginning-Programming-Java-Dummies-Computer/dp/1119235537/">5th edition</a> is the most popular and has 560 pages. But it still only covers the basics. <a class="reference external" href="https://www.amazon.com/Head-First-Java-2nd-Edition/dp/0596009208/">Head First Java</a> is recommended by the r/learnprogramming subreddit and has 688 pages.</p>
<p>Others recommend skipping the “dead tree” format altogether and watching videos on YouTube or doing educational courses on edX, Udacity, and Coursera. On YouTube <cite>MIT
6.0001 &lt;https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/video_galleries/lecture-videos/&gt;</cite> is around 12x45=540 minutes. <a class="reference external" href="https://www.youtube.com/playlist?list=PLhQjrBD2T3817j24-GogXmWqO5Q5vYy0V">CS50P</a> is 14x1.2=1005 minutes. The amateur <cite>CS Dojo &lt;https://www.youtube.com/playlist?list=PLBZBJbE_rGRWeh5mIBhD-hhDwSEDxogDg&gt;</cite> is 16x~13=217 minutes. <a class="reference external" href="https://www.youtube.com/playlist?list=PL0845FEB57E5894C2">Digilent Inc.’s course</a> is 87x6.5=561 minutes. Coursera’s <a class="reference external" href="https://www.coursera.org/learn/learn-to-program">Learn to program</a> course is 291 minutes or less than 5 hours of video content but there are 43 readings and Coursera says it will take 25 hours to complete.</p>
<p>Learning a new language can be faster if you already know a language, but you can also bring over preconceptions. For example in <span id="id11">[]</span>, imperative gotchas became misconceptions in functional programming: variables can be defined after they are used, operators like <code class="docutils literal notranslate"><span class="pre">tail</span></code>, <code class="docutils literal notranslate"><span class="pre">take</span></code>, <code class="docutils literal notranslate"><span class="pre">drop</span></code>, <code class="docutils literal notranslate"><span class="pre">remove</span></code>, <code class="docutils literal notranslate"><span class="pre">filter</span></code> do not mutate their arguments, and there is no need to clone results to prevent them from being mutated and corrupted. It’s not clear what can be done - people hate UI changes, and will complain when their cherished workarounds no longer work, even if they are now unnecessary. <a class="reference external" href="https://www.cs.utexas.edu/users/EWD/ewd04xx/EWD498.PDF">Dijkstra</a> similarly stated that COBOL “cripples the mind” and BASIC “mentally mutilates programmers beyond hope of regeneration”, presumably because they give the programmer the wrong impression of what programming is. Still though, Dijkstra is too pessimistic - a simple “Stroscot for Y programmers” guide series should be sufficient to retrain programmers away from their bad habits.</p>
<p>Immersion is by far the best way to learn anything. And as research shows, it turns out that humans retain:</p>
<blockquote>
<div><p>5% of what they learn when they’ve learned from a lecture.
10% of what they learn when they’ve learned from reading.
20% of what they learn from audio-visual.
30% of what they learn when they see a demonstration
50% of what they learn when engaged in a group discussion.
75% of what they learn when they practice what they learned.
90% of what they learn when they use it immediately.</p>
</div></blockquote>
<p>Think back to how you learned to play basketball, ride a bicycle, or swim. Instead of watching tutorial videos or reading a textbook on how to do something, the way to learn faster is to get into the trenches and gain experience through making mistakes.</p>
<p>Even if the learning material is there, what will convince people to invest the time to give it a try?</p>
<blockquote>
<div><p>Language designers should give careful thought to how strange their langauge is, and choose the right amount to accomplish what they’re trying to accomplish.</p>
</div></blockquote>
<p>Therefore, it’s best to treat familiarity as a tie-breaker: to be used sparingly, only when the pros and cons of different design options have been fully explored, and it has been determined that no design has an edge above the other.</p>
<p>But if one design has arguments for it, and another design has only familiarity on its side, language designers of the future are implored to pick the former to stop propagating the same language design mistakes further and further into the future.6</p>
<blockquote>
<div><p>the benefits of familiarity are fleeting, because once your language becomes standard people will be familiar with it anyway. This conflicts with the <a class="reference external" href="https://steveklabnik.com/writing/the-language-strangeness-budget">notion</a> of Rust’s “strangeness budget”, where a language can only be so weird before it gets discarded from consideration and can never become standard.</p>
</div></blockquote>
<p>As Randomo shows, the choice of characters for operators is arbitrary. Using familiar syntax at least benefits existing programmers, while new programmers will be confused regardless.</p>
<p>But cases where newbies can benefit, such as single = for assignment and comparison, do seem worth discarding familiarity for.</p>
</section>
<section id="filenames">
<h2>Filenames<a class="headerlink" href="#filenames" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p>On Linux, the kernel defines filenames as arbitrary byte sequences that do not contain ASCII / or null, compared by byte equality. Most applications expect filenames in UTF-8, and produce NFC UTF-8, but this is not enforced.</p></li>
<li><p>On Windows, NTFS defines filenames as sequences of 16 bit characters excluding 0x0000, compared case insensitively using an uppercase mapping table. The Windows APIs will error on filenames containing on the UTF-16 characters <code class="docutils literal notranslate"><span class="pre">&lt;&gt;:&quot;/\|?*</span></code>, and the UTF-16 filenames CON, PRN, AUX, CLOCK$, NUL, COM[0-9], LPT[0-9], $Mft, $MftMirr, $LogFile, $Volume, $AttrDef, $Bitmap, $Boot, $BadClus, $Secure, $Upcase, $Extend, $Quota, $ObjId and $Reparse are reserved by the system for internal use, including with file extensions such as aux.c or NUL.txt. Proper UTF-16 encoding is not enforced but most applications including the shell use NFC normalized UTF-16. The Windows shell does not support a filename ending with a UTF-16 space or a period, or displaying decomposed Hangul.</p></li>
<li><p>On macOS, filenames are UTF-8, normalized via Unicode 3.2 NFD (HFS+) or not (APFS). Case is preserved but filename comparison is case insensitive and normalized via Unicode 3.2 NFD (NFS+) or modern NFD (APFS).</p></li>
</ul>
<p>Taking union, we have that a filename is always a byte sequence. Taking intersection, we have that a NFC-normalized sequence of Unicode codepoints excluding <code class="docutils literal notranslate"><span class="pre">&lt;&gt;:&quot;/\|?*</span></code> and the Windows reserved names is always transformable to a filename.</p>
</section>
<section id="unicode">
<h2>Unicode<a class="headerlink" href="#unicode" title="Permalink to this heading"></a></h2>
<p>Per Rust, non-English beginner tutorials are more friendly if they can use localized variable names for familiarity. Identifiers seem to be the limit though. Per <a class="reference external" href="https://ystudios.com/insights-passion/codelanguage">quotes from Y studios</a>,  localized keywords are very tricky to implement, and often don’t work well with the rest of the syntax. Localized grammars and word order are even more tricky and also really confusing if you don’t know they’re in use. But there are experiments like ChinesePython that have seen limited interest. It is a lot of work to fully localize a language:</p>
<ul class="simple">
<li><p>parser - keywords/reserved words, grammar, word order</p></li>
<li><p>error messages, warnings, diagnostics</p></li>
<li><p>standard library method names and strings</p></li>
<li><p>documentation</p></li>
</ul>
<p>For Stroscot, at a minimum, comments in localized scripts should be supported. But <a class="reference external" href="https://rosettacode.org/wiki/Unicode_variable_names">lots of languages</a> support Unicode variable names too, so also seems good. Anything past that will be DSL territory and not part of the language proper.</p>
<p>TODO: see if there are any more Unicode guidelines relevant to writing a programming language parser</p>
<section id="usability">
<h3>Usability<a class="headerlink" href="#usability" title="Permalink to this heading"></a></h3>
<p>Unicode character input still has no standard solution. Copy-pasting from websites or a small cheat file is simple but it is too tedious to use frequently. Other methods include a language-specific keyboard, OS input methods like Character Map, or editor input methods like <code class="docutils literal notranslate"><span class="pre">\name&lt;tab&gt;</span></code> in Jupyter, <a class="reference external" href="https://marketplace.visualstudio.com/items?itemName=brunnerh.insert-unicode">extensions</a> for VSCode, or <code class="docutils literal notranslate"><span class="pre">Ctrl+x</span> <span class="pre">8</span> <span class="pre">Enter</span></code> in Emacs. Generally it seems there is no shortage of solutions and people will put in the effort to find a good IME as required. It is really an editor problem, not a PL problem.</p>
<p>Unicode itself is quite complex and people can get confused by invisible characters, different width spaces, bidirectional text, and lookalike characters. Compiler warnings can reduce the chance of confusion.</p>
</section>
<section id="language-fragmentation">
<h3>Language fragmentation<a class="headerlink" href="#language-fragmentation" title="Permalink to this heading"></a></h3>
<p>People aren’t omniglots, so using multiple languages will cause library fragmentation. Past introductory tutorials that write throwaway code it makes sense to use a common language. Which one though?</p>
<p>Per <a class="reference external" href="https://en.wikipedia.org/wiki/List_of_languages_by_total_number_of_speakers">Wikipedia</a> English has 1.452 billion total speakers and Standard Chinese 1.118 billion, with Hindi and others less than half English. Even if we count “second language” liberally, English is as high as 2 billion while Standard Chinese is only 1.5 billion, so the gap increases slightly. And calculating growth rates from <a class="reference external" href="https://en.wikipedia.org/w/index.php?title=List_of_languages_by_total_number_of_speakers&amp;direction=prev&amp;oldid=1073408213">2021</a> and earlier, English increased by 7.7%-9.8%/year while Chinese has remained mostly steady at -0.1% to 3.3%/year. Per <a class="reference external" href="https://en.wikipedia.org/wiki/Languages_used_on_the_Internet">this WP page</a> English websites are 61.1% English, 1.7% Chinese, while internet users are 25.9% English, 19.4% Chinese. The number of Chinese websites is probably skewed low because most Chinese content is on social sites rather than independent sites, and the firewall makes it hard to index. Still though, across all of these statistics, there is a clear pattern of English being first.</p>
<p>Choosing Standard Chinese also has political problems since the speakers are mainly native speakers in China that have been artificially created via the CCP systematically targeting ethnic minorities and forcing them to learn Standard Chinese in place of their original dialect. In contrast English is mainly a second language and its speakers are spread across many countries.</p>
<p>Also Chinese is <a class="reference external" href="http://pinyin.info/readings/texts/moser.html">just plain hard</a> to learn and remember. Per that article it takes 7-8 years to learn 3000 Chinese characters but half that time to learn a comparable number of French or Spanish words. Then there is the <a class="reference external" href="https://en.wikipedia.org/wiki/Character_amnesia">character amnesia</a> problem where people can read the character just fine but forget how to write it by hand, only remembering the pinyin Latin-based transcription.</p>
<p>So English it is.</p>
</section>
<section id="unicode-overuse">
<h3>Unicode overuse<a class="headerlink" href="#unicode-overuse" title="Permalink to this heading"></a></h3>
<p>Stroscot’s user-defined syntax is flexible enough to create APL-style operators if desired. But just compare this example of computing the prime numbers less than <code class="docutils literal notranslate"><span class="pre">R</span></code> in APL vs. a Haskell style:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>T←1↓⍳R
(~T∊T∘.×T)/T
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">T</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">drop</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="kt">R</span><span class="p">)</span>
<span class="nf">scan</span><span class="w"> </span><span class="p">(</span><span class="n">not</span><span class="w"> </span><span class="p">(</span><span class="n">isElementOf</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="p">(</span><span class="n">tie</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="kt">T</span><span class="w"> </span><span class="kt">T</span><span class="p">)))</span><span class="w"> </span><span class="kt">T</span>
</pre></div>
</div>
<p>IMO the letter-based prefix operators are easier to read - particularly, the word choices give clues as to what is happening. Although the number of APL hieroglyphs is not comparable to Chinese’s thousands of ideograms, it seems likely that APL suffers from learnability issues similar to Chinese and is harder to learn than letter-based identifiers because it does not have a phonetic basis.</p>
<p>Similarly Agda uses mathematical Unicode symbols extensively for both identifiers and syntax. This kind of mathematical jargon seems fine so long as there’s clear documentation or it’s limited to .</p>
</section>
<section id="encoding">
<h3>Encoding<a class="headerlink" href="#encoding" title="Permalink to this heading"></a></h3>
<p>There are various encodings of Unicode, like UTF-8, UTF-16, and GBK/GB 18030. But UTF-8 has 97.8% market share, and general-purpose compression algorithms provide better compression than specialized encodings. So for now it’s not worth supporting anything besides UTF-8. If it becomes necessary to support another encoding then it can be cheaply written as a prepass that run ICU and transforms the encoding to UTF-8. Maybe as an alternative it is possible to use an encoding abstraction that supports many encodings and doesn’t assume UTF-8 properties like stream synchronization; it depends on if there is a performance hit for such an abstraction.</p>
</section>
<section id="nfc">
<h3>NFC<a class="headerlink" href="#nfc" title="Permalink to this heading"></a></h3>
<p>NFC solves the issue of having the same font grapheme but different codepoint encoding, like A + combining acute accent vs the precomposed character “latin capital letter a with acute”. NFC is used by 98% of the web and a fair amount of software automatically normalizes input to NFC (e.g. web browsers). Also per <a class="reference external" href="http://www.unicode.org/faq/normalization.html">Unicode Normalization FAQ</a> “NFC is the best form for general text.” It also seems that the unstated opinion of the Unicode Consortium is that text that cannot be NFC’d does not count as “Unicode”. When there was an issue with NFC breaking <a class="reference external" href="https://www.unicode.org/mail-arch/unicode-ml/y2003-m06/0423.html">Biblical Hebrew</a> the solution was to change the input (inserting joiners) rather than modifying NFC.</p>
<p>So it seems correct to soft-require input to be NFC normalized. This might annoy someone somewhere, but they can work around it by putting in joiners, like Biblical Hebrew had to do. We cannot hard-require because <a class="reference external" href="https://github.com/rust-lang/rfcs/pull/2457#issuecomment-395488644">per someone</a> there exist some Vietnamese keyboards that produce combining characters not in NFC.</p>
<p>NFC also means that unnormalized strings or raw binary data can’t be included in files directly. But keeping those in separate files or encoding the bad bytes as hexadecimal seems fine.</p>
</section>
<section id="nfkc">
<h3>NFKC<a class="headerlink" href="#nfkc" title="Permalink to this heading"></a></h3>
<p>NFKC is often brought up as an alternative/extension of NFC. For example <a class="reference external" href="https://peps.python.org/pep-3131/">Python</a> uses NKFC for identifiers, and Go similarly has a <a class="reference external" href="https://github.com/golang/go/issues/27896">proposal</a> to use NFKC.</p>
<p>There are two choices for using NFKC, requiring input to be NFKC or applying NFKC to the input. Python only applies NFKC, so <a class="reference external" href="https://groups.google.com/g/dev-python/c/LkCtik9LyyE/m/QcRz1gdfAQAJ">the following</a> is a valid Python program:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>def 𝚑𝓮𝖑𝒍𝑜():
  try:
    𝔥e𝗅𝕝𝚘︴ = &quot;Hello&quot;
    𝕨𝔬r𝓵ᵈ﹎ = &quot;World&quot;
    ᵖ𝖗𝐢𝘯𝓽(f&quot;{𝗵ｅ𝓵𝔩º_}, {𝖜ₒ𝒓lⅆ︴}!&quot;)
  except 𝓣𝕪ᵖｅ𝖤𝗿ᵣ𝖔𝚛 as ⅇ𝗑c:
    𝒑rℹₙₜ(&quot;failed: {}&quot;.𝕗𝗼ʳᵐªｔ(ᵉ𝐱𝓬))


# snippet from unittest/util.py
_𝓟Ⅼ𝖠𝙲𝗘ℋ𝒪Lᴰ𝑬𝕽﹏𝕷𝔼𝗡 = 12
def _𝔰ʰ𝓸ʳ𝕥𝙚𝑛(𝔰, p𝑟𝔢ﬁ𝖝𝕝𝚎𝑛, ｓᵤ𝑓𝗳𝗂𝑥𝗹ₑ𝚗):
  ˢ𝗸ｉ𝗽 = 𝐥ｅ𝘯(𝖘) - ｐr𝚎𝖋𝐢x𝗅ᵉ𝓷 - 𝒔𝙪ﬀｉ𝘅𝗹𝙚ₙ
  if sｋi𝘱 &gt; _𝐏𝗟𝖠𝘊𝙴H𝕺Ｌ𝕯𝙀𝘙﹏L𝔈𝒩:
    𝘴 = &#39;%s[%d chars]%s&#39; % (𝙨[:𝘱𝐫𝕖𝑓𝕚ｘℓ𝒆𝕟], ₛ𝚔𝒊p, 𝓼[𝓁𝒆𝖓(𝚜) - 𝙨𝚞𝒇ﬁx𝙡ᵉ𝘯:])
  return ₛ

if _︴ⁿ𝓪𝑚𝕖__ == &quot;__main__&quot;:
  𝒉eℓˡ𝗈()
</pre></div>
</div>
<p>If we required the input to be in NFKC it would have to look like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">def</span><span class="w"> </span><span class="n">hello</span><span class="nb">()</span><span class="kt">:</span>
<span class="w"> </span><span class="n">try</span><span class="kt">:</span>
<span class="w">   </span><span class="n">hello_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span>
<span class="w">   </span><span class="n">world_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;World&quot;</span>
<span class="w">   </span><span class="n">print</span><span class="p">(</span><span class="n">f</span><span class="s">&quot;{hello_}, {world_}!&quot;</span><span class="p">)</span>
<span class="w"> </span><span class="n">except</span><span class="w"> </span><span class="kt">TypeError</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">exc</span><span class="kt">:</span>
<span class="w">   </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;failed: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

<span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">snippet</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">unittest</span><span class="o">/</span><span class="n">util</span><span class="o">.</span><span class="n">py</span>
<span class="w"> </span><span class="n">_PLACEHOLDER_LEN</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">12</span>
<span class="w"> </span><span class="n">def</span><span class="w"> </span><span class="n">_shorten</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">prefixlen</span><span class="p">,</span><span class="w"> </span><span class="n">suffixlen</span><span class="p">)</span><span class="kt">:</span>
<span class="w">   </span><span class="n">skip</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">prefixlen</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">suffixlen</span>
<span class="w">   </span><span class="kr">if</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">_PLACEHOLDER_LEN</span><span class="kt">:</span>
<span class="w">     </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">&#39;%</span><span class="n">s</span><span class="p">[</span><span class="o">%</span><span class="n">d</span><span class="w"> </span><span class="n">chars</span><span class="p">]</span><span class="o">%</span><span class="n">s&#39;</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="kt">:</span><span class="n">prefixlen</span><span class="p">],</span><span class="w"> </span><span class="n">skip</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">[</span><span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">suffixlen</span><span class="kt">:</span><span class="p">])</span>
<span class="w">   </span><span class="n">return</span><span class="w"> </span><span class="n">s</span>

<span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">__name__</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;__main__&quot;</span><span class="kt">:</span>
<span class="w">   </span><span class="n">hello</span><span class="nb">()</span>
</pre></div>
</div>
<p>Meanwhile with NFC the variable names would have to be consistent and built-in names could not be transformed, so a program could look like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>def 𝚑𝓮𝖑𝒍𝑜():
    try:
        𝔥e𝗅𝕝𝚘︴ = &quot;Hello&quot;
        𝕨𝔬r𝓵ᵈ﹎ = &quot;World&quot;
        print(f&quot;{𝔥e𝗅𝕝𝚘︴}, {𝕨𝔬r𝓵ᵈ﹎}!&quot;)
    except TypeError as ⅇ𝗑c:
        print(&quot;failed: {}&quot;.format(ⅇ𝗑c))

# snippet from unittest/util.py
_𝐏𝗟𝖠𝘊𝙴H𝕺Ｌ𝕯𝙀𝘙﹏L𝔈𝒩 = 12
def _𝔰ʰ𝓸ʳ𝕥𝙚𝑛(𝘴, p𝑟𝔢ﬁ𝖝𝕝𝚎𝑛, ｓᵤ𝑓𝗳𝗂𝑥𝗹ₑ𝚗):
    sｋi𝘱 = 𝐥ｅ𝘯(𝘴) - p𝑟𝔢ﬁ𝖝𝕝𝚎𝑛 - ｓᵤ𝑓𝗳𝗂𝑥𝗹ₑ𝚗
    if sｋi𝘱 &gt; _𝐏𝗟𝖠𝘊𝙴H𝕺Ｌ𝕯𝙀𝘙﹏L𝔈𝒩:
        𝘴 = &#39;%s[%d chars]%s&#39; % (𝘴[:p𝑟𝔢ﬁ𝖝𝕝𝚎𝑛], ₛ𝚔𝒊p, 𝘴[len(𝘴) - ｓᵤ𝑓𝗳𝗂𝑥𝗹ₑ𝚗:])
    return 𝘴

if __name__ == &quot;__main__&quot;:
    𝚑𝓮𝖑𝒍𝑜()
</pre></div>
</div>
<p>Python’s version where the variables do not have to be visually identical is really confusing. The NFKC input is too restrictive. IMO the NFC wins on both readability and flexibility.</p>
<p>In the Unicode TRs NFKC usually is used in conjunction with case folding. In particular Unicode 3.13 R5 defines the mapping toNFKC_Casefold which case folds, normalizes, and removes default ignorable code points, and this operation is recommended for matching identifiers case-insensitively. Similarly <a class="reference external" href="https://www.unicode.org/reports/tr36/#Recommendations_General">TR36</a> recommends processing identifiers by applying NFKC_Casefold. So NFKC doesn’t make a lot of sense since Stroscot is case-sensitive. Many have <a class="reference external" href="https://groups.google.com/g/dev-python/c/LkCtik9LyyE/m/ki8XN66iAQAJhttps://groups.google.com/g/dev-python/c/LkCtik9LyyE/m/ki8XN66iAQAJ">suggested</a> that Python made the wrong choice when it picked NFKC because Python is case-sensitive.</p>
<p>Let’s look at what NFKC actually does. Compared to NFC, it applies transformations with non-empty <a class="reference external" href="https://www.unicode.org/reports/tr44/#Character_Decomposition_Mappings">Decomposition_type</a>, which are as follows:</p>
<ul class="simple">
<li><p>font: 𝐀 (bold mathematical A) to A, ℍ to H</p></li>
<li><p>super/sub: ² to 2, ᵢ to i</p></li>
<li><p>circle: ① to 1</p></li>
<li><p>fraction: ¼ to 1/4</p></li>
<li><p>square: ㍌ to メカ◌゙トン</p></li>
<li><p>small: ﹛ to {</p></li>
<li><p>initial, isolated, medial, final (Arabic): ﯕ to ڭ</p></li>
<li><p>wide: Ｂ to B</p></li>
<li><p>narrow: ﾁ to チ</p></li>
<li><p>vertical: ︘ to the LTR variants like 〗</p></li>
<li><p>noBreak: ‑ (non-breaking hyphen) to ‐ (hyphen)</p></li>
<li><p>compat: a grab-bag that does many things:</p>
<ul>
<li><p>decompose ligatures and compound characters like æ to ae, ﬁ to fi, ℃ to °C, and ⑿ to (12)</p></li>
<li><p>changes µ MICRO SIGN to μ GREEK SMALL LETTER MU and similarly various other compatibility symbols to alphabetical letters</p></li>
<li><p>changes kanxi to unified CJK (but not CJK compatibility ideographs)</p></li>
<li><p>changes en/em spaces to normal spaces</p></li>
</ul>
</li>
</ul>
<p>TR31 specifically recommends excluding font transformations (1194 characters, 32% of NFKC) to allow mathematical notation. The superscript/subscript transforms also <a class="reference external" href="https://stackoverflow.com/questions/48404881/unicode-subscripts-and-superscripts-in-identifiers-why-does-python-consider-xu">confuse people</a> and seem to be unwanted. For Go, bcmills says superscripts and subscripts are ‘cutesy’ which seems to be an acknowledgement of the fact that they should not be erased. Similarly circle, fraction, square, and small look so different that they will confuse people as to why they are considered equivalent.</p>
<p>The symbol and ligature transformations in compat do seem useful. Python <a class="reference external" href="https://mail.python.org/pipermail/python-3000/2007-May/007995.html">apparently</a> went with NFKC because they were worried about confusing ligatures, specifically ﬁnd vs find (the first using the U+FB01 LATIN SMALL LIGATURE FI character). In VSCode the fi ligature shows up compressed into one fixed-width space so is visibly different from the non-ligature version, but in proportional fonts this is indeed a problem. The Go issue mentions micro and mu, which per Wikipedia look identical in most fonts, although some fonts do distinguish them. noBreak is also useful. wide/narrow/vertical/Arabic do look clearly different in my fonts, but the characters are intended only to support legacy character encodings so transforming them away is probably best. (<a class="reference external" href="https://www.w3.org/TR/charmod-norm/#canonical_compatibility">CHARMOD</a>)</p>
<p>Overall, only 20% of the transformations NFKC does are clearly useful (compat), the standard recommends excluding 32% of transformations (fonts), and a further 12% (circle, fraction, square, small) also are clearly unwanted. It’s clear that the stock NKFC transform isn’t appropriate. Even if we used the reasonable subset of NFKC transforms, we’re barely using half, so at best we could say we are using “NFC with most decompositions from NFKC”. The base is still NFC and it’s just monkeying up the encoding.</p>
</section>
<section id="tr31">
<h3>TR31<a class="headerlink" href="#tr31" title="Permalink to this heading"></a></h3>
<p>“UAX #31 Unicode Identifier and Pattern Syntax” is often brought up. I looked at <a class="reference external" href="https://www.unicode.org/reports/tr31/tr31-37.html">revision 37</a>, Unicode 15. There is a lot of background material and examples but only 7 actual “requirements”, a misleading name because some of them are mutually exclusive. In particular the normalization requirements (Section 5, R4-R7) are a mess. They are worded to allow NFKC or NFD in R4, but per the first paragraph “Generally if the programming language has case-sensitive identifiers, then NFC is appropriate; whereas, if the programming language has case-insensitive identifiers, then NFKC is more appropriate”. Furthermore NFKC is generally applied in combination with casefolding with the transformation toNFKC_Casefold. So there are really only two normalization algorithms, NFC and toNFKC_Casefold. Also they put the definition of XID_Start/XID_Continue in R5/R7, even though the use of Start/Continue is defined in R1. So I have modified the text of the requirements here accordingly.</p>
<ul>
<li><p>R1-2. Default Identifiers: Declare a precise specification of identifiers. Advised is R1-1, which is to use the rule <code class="docutils literal notranslate"><span class="pre">&lt;Identifier&gt;</span> <span class="pre">:=</span> <span class="pre">&lt;Start&gt;</span> <span class="pre">&lt;Continue&gt;*</span> <span class="pre">(&lt;Medial&gt;</span> <span class="pre">&lt;Continue&gt;+)*</span></code> for identifier syntax where Start/Continue are defined by XID_Start/XID_Continue and Medial is empty.</p></li>
<li><p>R1a. Restricted Format Characters: Restrict the use of ZERO WIDTH JOINER and ZERO WIDTH NON-JOINER characters to the following contexts:</p>
<ul class="simple">
<li><p>A1. /$LJ $T* ZWNJ $T* $RJ/</p></li>
<li><p>A2. /$L $M* $V $M₁* ZWNJ $M₁* $L/</p></li>
<li><ol class="upperalpha simple" start="2">
<li><p>/$L $M* $V $M₁* ZWJ (?!$D)/</p></li>
</ol>
</li>
<li><ol class="upperalpha simple" start="5">
<li><p>emoji sequences defined in ED-17 in <a class="reference external" href="https://unicode.org/reports/tr51/#Emoji_Sequences">UTS51</a></p></li>
</ol>
</li>
</ul>
<p>where these classes are defined as follows</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>$T = \p{Joining_Type=Transparent}
$RJ = [\p{Joining_Type=Dual_Joining}\p{Joining_Type=Right_Joining}]
$LJ = [\p{Joining_Type=Dual_Joining}\p{Joining_Type=Left_Joining}]
$L = \p{General_Category=Letter}
$V = \p{Canonical_Combining_Class=Virama}
$M = \p{General_Category=Mn}
$M₁ = [\p{General_Category=Mn}&amp;\p{CCC≠0}]
$D = \p{Indic_Syllabic_Category=Vowel_Dependent}
</pre></div>
</div>
</li>
<li><p>R1b / R2. Omitted, they’re just about forward/backward compatibility. Stroscot’s language versioning mechanism allows arbitrary changes in a robust manner.</p></li>
<li><p>R3-2. Pattern_White_Space and Pattern_Syntax Characters: Define the precise set of characters interpreted as lexical whitespace in parsing, and the precise set of syntactic characters, such as arithmetic operators, regular expression metacharacters, and <a class="reference external" href="https://docs.oracle.com/javase/8/docs/api/java/text/RuleBasedCollator.html">Java collation rule</a> syntax characters. All characters besides whitespace or syntactic characters must be available for use in identifiers or literals. Again there is an advisory requirement R3-1 which specifies to use the Pattern_White_Space and Pattern_Syntax properties for whitespace and syntactic characters respectively.</p></li>
<li><p>R4. Equivalent Normalized Identifiers: Specify NFC and characters excluded from normalization, if any. Except for identifiers containing excluded characters, any two identifiers that have the same Normalization Form shall be treated as equivalent by the implementation.</p></li>
<li><p>R5. Equivalent Case-Insensitive Identifiers: Specify that identifiers are transformed by toNFKC_Casefold before processing. Any two identifiers that have the same case-folded form shall be treated as equivalent by the implementation.</p></li>
<li><p>R6. Filtered Normalized Identifiers: Specify NFC and characters excluded from normalization, if any. Except for identifiers containing excluded characters, allowed identifiers must be in the specified Normalization Form.</p></li>
<li><p>R7. Filtered Case-Insensitive Identifiers: Specify that identifiers must be invariant under toNFKC_Casefold. Except for identifiers containing excluded characters, allowed identifiers must be in the specified case folded form. Note: filtering involves disallowing any characters in the set p{NFKC_QuickCheck=No}, or equivalently, P{isNFKC}, as well as any characters in the set p{Changes_When_Casefolded}.</p></li>
</ul>
</section>
<section id="case-restrictions">
<h3>Case restrictions<a class="headerlink" href="#case-restrictions" title="Permalink to this heading"></a></h3>
<p>Go’s rule is that identifier characters must be letters or digits as defined by Unicode, and exported identifiers must start with an upper-case letter, excluding combining characters and Devanagari. Haskell has a similar type/value distinction. But these sorts of restrictions mean 日本語 cannot be exported, and instead X日本語 must be used.</p>
<p>Generally it seeems that case distinctions only work for English, and are somewhat hard to get right. So we don’t put it in the syntax and leave case as a style guideline.</p>
</section>
<section id="confusables">
<h3>Confusables<a class="headerlink" href="#confusables" title="Permalink to this heading"></a></h3>
<p>So requiring NFKC is not a good idea - do we have to roll our own transform? Fortunately, the answer is not really - there is an alternative to NFKC, namely the TR39 <a class="reference external" href="https://www.unicode.org/reports/tr39/#Confusable_Detection">confusable detection</a> transformation. <a class="reference external" href="https://github.com/rust-lang/rfcs/blob/master/text/2457-non-ascii-idents.md">Rust</a> uses this. The dataset <a class="reference external" href="https://www.unicode.org/Public/security/latest/confusables.txt">contains</a> conversions of:</p>
<ul class="simple">
<li><p>micro to mu, and other standardization of symbols (including kanxi and CJK compatibility ideographs to unified CJK)</p></li>
<li><p>1 to l (one to ell), 0 to O (zero to oh), and other similar looking characters</p></li>
<li><p>ligatures like ffi to their expansion</p></li>
<li><p>parenthesized expressions like ⑵ to (2)</p></li>
<li><p>ℍ to H and other standardization of font styles</p></li>
<li><p>noBreak to normal, various spaces to normal</p></li>
<li><p>fullwidth to normal, vertical to similar characters like ︵ to ⏜</p></li>
<li><p>some amount of initial, isolated, medial, and final Arabic NFKC normalizations</p></li>
<li><p>no narrow, square, superscript, subscript, circle, or fraction NFKC mappings</p></li>
</ul>
<p>Due to the standardization of similar looking characters the confusable transform is actually larger than NFKC, 6311 vs 3675. But the transform makes a lot more sense for detecting similar-looking identifiers. The only unwanted transformations are the font styles which can be excluded from confusable detection just like they can be excluded from NKFC.</p>
<p>Also per <a class="reference external" href="https://github.com/rust-lang/rfcs/pull/2457#discussion_r192605996">dscorbett</a> the confusable transform should also be extended to remove <a class="reference external" href="https://unicode.org/reports/tr44/#Default_Ignorable_Code_Point">default ignorable code points</a> (<a class="reference external" href="https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt">consisting</a> of combining grapheme joiner, zero width space, hangul filler, and 146 other invisible characters, plus 256 variation selectors and 3769 reserved). Per the <a class="reference external" href="http://unicode.org/faq/vs.html">Variation Sequence FAQ</a> variation sequences are morally equivalent to code points, in that they distinguish different glyphs, but they were unable to be assigned a new codepoint because an existing codepoint was considered to be “clearly the same character”. This includes visually distinctive alterations such as rotating Egyptian Hieroglyphs 90 degrees or black-and-white vs color emoji, as well as less noticeable ones like adding serifs. From testing with my fonts (𓂑 vs 𓂑︀, ⊓ vs ⊓︀, 齋 vs 齋󠄁, ≩ vs ≩︀, ⛺︎ vs ⛺️) and various <a class="reference external" href="https://github.com/w3c/csswg-drafts/issues/1710">open</a> <a class="reference external" href="https://gitlab.gnome.org/GNOME/pango/-/issues/206">bugs</a> it seems variations besides emoji are not supported well and mostly fall back to the base character, so removing the selectors is appropriate for confusable detection. This could be revisited if more fonts start including variations or the <a class="reference external" href="https://drafts.csswg.org/css-fonts-3/#cluster-matching">CSS font substitution logic</a> that attempts to preserve variations is implemented. <a class="reference external" href="https://github.com/harfbuzz/harfbuzz/issues/515#issuecomment-317932409">As of 2017</a> font substitution for variations doesn’t work on Chrome, Firefox, or Word.</p>
<p>So overall the approach is “confusable detection with font variants distinguished and default ignorable code points ignored”. Since the focus for developing the confusable database was on covering characters with Identifier_Status=Allowed for standard OS fonts, it may be incomplete. But it’s the best production-quality database available, and Unicode claims to accept updates, and if not it’s not too hard to fork.</p>
<p>There are also research projects. <a class="reference external" href="https://arxiv.org/pdf/1909.07539.pdf">ShamFinder</a> provides a database SimChar similar to the confusables database. Its generation is based solely on Unifont so it misses many homoglyphs from other fonts. The pixel metric adds extra pairs such as accents, e vs é, which IMO are not going to confuse anyone. The database is publicly available at <a class="reference external" href="https://github.com/FlowCrypt/idn-homographs-database">GitHub</a>, but not the code used to generate it. <a class="reference external" href="https://arxiv.org/abs/2006.13742">PhishGAN</a> generates vectors from images and finds likely homoglyph identifiers, but was trained on a small identifier list, is Arial and Times only, trains over the whole identifier, and is not publicly available. But an ML approach which breaks up identifiers into fixations and compares these using a human visual perceptual model could theoretically be more accurate than a confusables database; getting it performant enough would require some specially crafted perceptual hash functions. This approach catches multicharacter homoglyphs like “vv” vs “w” (of course in a monospace font these are clearly distinguished by width). But, overall, neither of these approaches is ready for prime time with further work.</p>
<p>The transform generates a “skeleton” that can be compared with other skeletons to see if two identifiers are confusable. Per Rust the implementation should use the NFC form for compilation but hash the skeleton and generate an optional warning if the usage of an identifier is confusable with another identifier in scope. We could add an additional step that compares the actual identifiers and computes a confusion probability, but the skeleton alone is generally good enough. The warning can be turned off on a per-file or per-project basis if the user doesn’t care or on a per-grapheme basis if the user is using a font that clearly distinguishes the confused characters. But most users will appreciate the warning and fix their code to use clearer identifier names.</p>
<p>Also for unresolvable identifiers we should compute an edit distance score between skeletons to find likely typos.</p>
<p>Confusable detection generally prevents homoglyph attacks using identifiers, although homoglyph attacks are difficult to exploit to begin with as the duplicate definitions are visible. It is still possible to use zero-width characters or homoglyphs in strings or comments. Comments have no effect. With strings a comparison can fail, but the weird characters may be desired. One possibility is a warning with recommendation to replace with an escape sequence.</p>
</section>
<section id="script-restrictions">
<h3>Script restrictions<a class="headerlink" href="#script-restrictions" title="Permalink to this heading"></a></h3>
<p><a class="reference external" href="http://www.unicode.org/reports/tr31/#Table_Candidate_Characters_for_Exclusion_from_Identifiers">TR31</a> proposes lists of allowed and disallowed scripts, and recommends defaulting to allowing new characters in identifiers. IMO this sort of script restriction is not desired by default, e.g. I would want to be able to use the character 𓂸 (Egyptian Hieroglyphs script, on TR31 excluded list) without being forced to specify a flag.</p>
<p>TR39 defines a mixed script restriction, which prohibits text such as Ωmega, Teχ, HλLF-LIFE, and Toys-Я-Us. This could be used to enforce some uniformity on identifier parts, but again seems too restrictive to enable by default. It does prevent some homoglyph attacks, but the confusable detection approach is much more robust.</p>
</section>
<section id="bidi-attack">
<h3>Bidi attack<a class="headerlink" href="#bidi-attack" title="Permalink to this heading"></a></h3>
<p><span id="id12">[]</span> proposes a “Trojan Source” bidi attack based on Unicode. The idea is someone copy-pastes from StackOverflow, submits a malicious PR, or just publishes a new project, and the source code looks safe but isn’t. In particular the attack is based on bidi overrides, the LRE, RLE, LRO, RLO, LRI, RLI, FSI, PDF, and PDI invisible characters. For example RLI a b c PDI will display as cba, and RLI LRI a b c PDI LRI d e f PDI PDI will display as d e f a b c. This enables near-arbitrary reordering of strings, and even hiding parts of strings by overwriting characters.</p>
<p>Language syntax does not generally allow bidi overrides, but they can show up in comments and strings, and the bidi overrides can obsfuscate which part is the comment or string. For example <code class="docutils literal notranslate"><span class="pre">&quot;x&quot;;</span> <span class="pre">return</span></code> could look like <code class="docutils literal notranslate"><span class="pre">&quot;return</span> <span class="pre">x;&quot;</span></code> (early return), <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">if</span> <span class="pre">{</span> <span class="pre">*/</span></code> could look like <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span> <span class="pre">if</span> <span class="pre">{</span></code> (commenting out), and <code class="docutils literal notranslate"><span class="pre">&quot;user</span> <span class="pre">//</span> <span class="pre">check&quot;</span></code> could look like <code class="docutils literal notranslate"><span class="pre">&quot;user&quot;</span> <span class="pre">//</span> <span class="pre">check</span></code> (stretched string). The overrides are visible in most syntax highlighting and when selecting/navigating through the text, but these cues are easy to miss.</p>
<p>The solution presented in the paper is to ban unterminated bidi override characters within string literals and comments. This prevents reordering across string and comment boundaries.</p>
</section>
</section>
<section id="parsing">
<h2>Parsing<a class="headerlink" href="#parsing" title="Permalink to this heading"></a></h2>
<p>I’ve got a basic Earley algorithm working in JS, but it’s not used anywhere. But eventually I could extend it with BSRs and layout and other fun things. There’s also <a class="reference external" href="https://github.com/attresearch/yakker">Yakker</a>, which is the most developed parser I’ve seen feature-wise. It’s only missing incremental parsing.</p>
<blockquote>
<div><p>A new parsing engine, Yakker, capable of handling the requirements of modern applications including full scannerless context-free grammars with regular expressions as right-hand sides for defining nonterminals. Yakker also includes facilities for binding variables to intermediate parse results and using such bindings within arbitrary constraints to control parsing. Yakker supports both semantic actions and speculative parsing techniques such as backtracking and context-free lookahead and several parsing back ends (including Earley, GLR and backtracking).  In addition, nonterminals may be parameterized by arbitrary values, which gives the system good modularity and abstraction properties in the presence of data-dependent parsing. Finally, legacy parsing libraries, such as sophisticated libraries for dates and times, may be directly incorporated into parser specifications.</p>
</div></blockquote>
<p>I’ve looked at various algorithms but I think the only way to handle it completely correctly and generically is to have a disambiguating pass on the set of parse tree generated by a nondeterministic automaton. The alternatives involve restricting parsers to be deterministic, for example PEGs. But PEGs have big issues with error detection and reporting, not to mention correct parsing. There’s just no information on what possible parses are available or what token is expected. Whereas with Earley you can do “Ruby slippers”: scan the sets for what they want next, output “warning: expected ‘;’ at end of statement”, and then add that to the parse forest and continue parsing with almost no overhead.</p>
<p>Treesitter implements incremental LR parsing with error recovery, but since it doesn’t support ambiguity I don’t think it’s sufficient for a compiler.</p>
<p>Revisiting this, the goal is to use partial evaluation to generate the parser, by speeding up a naive brute-force algorithm applied to the grammar. There is already a paper on LR parsing by partial evaluation <span id="id13">[<a class="reference internal" href="../zzreferences.html#id148" title="Michael Sperber and Peter Thiemann. Generation of LR parsers by partial evaluation. ACM Transactions on Programming Languages and Systems (TOPLAS), 22(2):224–264, March 2000. URL: http://dl.acm.org/doi/10.1145/349214.349219 (visited on 2020-06-15), doi:10.1145/349214.349219.">ST00</a>]</span> and also on specializing Earley, so with sufficiently powerful compiler optimization handling general grammars should be possible.</p>
<p>In particular the parser should be written as a nondeterministic finite state transducer that builds up trees (outputs a list in the style of start-children-end or S-expressions or something).</p>
<p>Formally:</p>
<ul class="simple">
<li><p>Q is a finite set, the set of states;</p></li>
<li><p>I is a subset of Q, the set of initial states;</p></li>
<li><p>F is a subset of Q, the set of final states; and</p></li>
<li><p>Σ is a finite set, called the input alphabet;</p></li>
<li><p>Γ is a finite set, called the output alphabet;</p></li>
<li><p>The transition function is of type <span class="math notranslate nohighlight">\(Q \times (\Sigma \cup \{\epsilon \})\to P(Q \times (\Gamma \cup \{\epsilon \}))\)</span>, where ε is the empty string and P(Q) denotes the power set of Q.</p></li>
</ul>
<p>TODO: match this up with Parsec, attoparsec, trifecta, etc. the syntax should be similar except with nondeterministic choice <code class="docutils literal notranslate"><span class="pre">|</span></code>.</p>
</section>
<section id="blocks">
<h2>Blocks<a class="headerlink" href="#blocks" title="Permalink to this heading"></a></h2>
<p>Blocks are inspired by Haskell’s do notation. For an example of how natural this is you can look at <a class="reference internal" href="State.html#tasks"><span class="std std-ref">how I/O works</span></a>. Since codensity/continuations are the mother of all monads, we don’t lose anything by fixing the monadic operations in the do-notation to be the continuation monad operations.</p>
<p>There is also “not returning anything” versus returning a value <code class="docutils literal notranslate"><span class="pre">()</span></code>. In Haskell these are generally consdiered the same. But using the continuation monad allows us to separate commands (not returning a value) and operations (returning a value). Haskell has the translation <code class="docutils literal notranslate"><span class="pre">{e;stmts}</span> <span class="pre">=</span> <span class="pre">e</span> <span class="pre">&gt;&gt;</span> <span class="pre">stmts</span> <span class="pre">=</span> <span class="pre">\c</span> <span class="pre">-&gt;</span> <span class="pre">e</span> <span class="pre">(\_</span> <span class="pre">-&gt;</span> <span class="pre">{stmts}</span> <span class="pre">c)</span></code>. But usually <code class="docutils literal notranslate"><span class="pre">e</span></code> returns <code class="docutils literal notranslate"><span class="pre">()</span></code>, so <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> is applied at the type <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span></code> and that <code class="docutils literal notranslate"><span class="pre">\_</span></code> is a <code class="docutils literal notranslate"><span class="pre">\()</span></code>. With our translation, commands (which don’t return a value) are functions <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>. Haskell’s translation would require them to be <code class="docutils literal notranslate"><span class="pre">Cont</span> <span class="pre">r</span> <span class="pre">()</span> <span class="pre">=</span> <span class="pre">(()</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>, which is equivalent but has an extra <code class="docutils literal notranslate"><span class="pre">()</span></code> floating around. But in both translations operations (whose value is used) are of type <code class="docutils literal notranslate"><span class="pre">Cont</span> <span class="pre">r</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>. The non-uniform type for actions might make copying code from Haskell a little harder, but on the other hand we get function composition as a built-in syntax. That’s right, the most basic operation in category theory is available as syntactic sugar in Stroscot. Take that, Haskell. And also we can easily use indexed monads, just change <code class="docutils literal notranslate"><span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code> to <code class="docutils literal notranslate"><span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">s</span></code>.</p>
<p>The return keyword should be invalid in short-form (pure) method definitions, like <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span></code>, but should be required for blocks, i.e. <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">return</span> <span class="pre">x</span> <span class="pre">}</span></code>. There is some question over whether to allow calling a function without return, i.e. <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">return</span> <span class="pre">(g</span> <span class="pre">x)</span> <span class="pre">}</span></code> versus <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">g</span> <span class="pre">x</span> <span class="pre">}</span></code> where <code class="docutils literal notranslate"><span class="pre">g</span></code> is itself a block.</p>
<section id="applicativedo">
<h3>ApplicativeDo<a class="headerlink" href="#applicativedo" title="Permalink to this heading"></a></h3>
<p>ApplicativeDo <span id="id14">[<a class="reference internal" href="../zzreferences.html#id104" title="Simon Marlow, Simon Peyton Jones, Edward Kmett, and Andrey Mokhov. Desugaring Haskell's do-notation into applicative operations. In Proceedings of the 9th International Symposium on Haskell, Haskell 2016, 92–104. New York, NY, USA, September 2016. Association for Computing Machinery. URL: https://doi.org/10.1145/2976002.2976007 (visited on 2021-07-16), doi:10.1145/2976002.2976007.">MPJKM16</a>]</span> has two functions. The first is to make some do-notation sequences be Applicative rather than Monad. In fact though these are exactly the sequences handled by idiom brackets, of the form <code class="docutils literal notranslate"><span class="pre">{a</span> <span class="pre">&lt;-</span> <span class="pre">ax;</span> <span class="pre">b</span> <span class="pre">&lt;-</span> <span class="pre">bx;</span> <span class="pre">return</span> <span class="pre">(f</span> <span class="pre">a</span> <span class="pre">b)}</span> <span class="pre">=</span> <span class="pre">return</span> <span class="pre">(f</span> <span class="pre">!a</span> <span class="pre">!b)</span></code>. Idiom brackets are shorter, so the value this provides is minimal.</p>
<p>The second function is to use applicative operations instead of monadic operations because in “some” monads the applicative operation is more efficient. Their example is the Haxl DSL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">numCommonFriends</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Id</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Id</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Haxl</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">numCommonFriends</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="n">fx</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">friendsOf</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="n">fy</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">friendsOf</span><span class="w"> </span><span class="n">y</span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="p">(</span><span class="n">intersect</span><span class="w"> </span><span class="n">fx</span><span class="w"> </span><span class="n">fy</span><span class="p">))</span>
</pre></div>
</div>
<p>Well, if you’re writing a DSL then writing it as a macro is much more powerful than trying to shoehorn it into an applicative/monadic framework. They discuss in the paper that the translation to use applicative operations is ambiguous and the best one depends on details of the computation that are not accessible, because functions are opaque. It’s exactly these kinds of details that <em>are</em> accessible in a DSL - you just write a pass that walks over the expression tree and estimates the costs. Similarly the <a class="reference external" href="https://en.wikipedia.org/wiki/Use-define_chain">use/def analysis</a> that they use for the rewriting is a standard compiler pass. The commutativity mentioned in the paper is another property one could know from the DSL and that changes the output significantly.</p>
<p>For regular do notation with continuations, the applicative notation translates to exactly the same functions as the monadic notation.</p>
<p>Verdict: DSL in disguise. Just write a DSL. Stroscot does not benefit at all by adding ApplicativeDo.</p>
</section>
<section id="recursivedo">
<h3>RecursiveDo<a class="headerlink" href="#recursivedo" title="Permalink to this heading"></a></h3>
<p>RecursiveDo <span id="id15">[<a class="reference internal" href="../zzreferences.html#id57" title="Levent Erkok. Value Recursion in Monadic Computations. PhD thesis, Oregon Health and Science University, October 2002. URL: http://leventerkok.github.io/papers/erkok-thesis.pdf.">Erk02</a>]</span> is an older extension to do notation. The motivating example is a circuit DSL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">toggle</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Signal</span><span class="w"> </span><span class="kt">Bool</span>
<span class="nf">toggle</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">out</span>
<span class="w">   </span><span class="kr">where</span>
<span class="w">      </span><span class="n">inp</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">inv</span><span class="w"> </span><span class="n">out</span>
<span class="w">      </span><span class="n">out</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">delay</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="n">inp</span>

<span class="nf">counter</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Signal</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Signal</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">counter</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">out</span>
<span class="w">   </span><span class="kr">where</span>
<span class="w">      </span><span class="n">next</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">delay</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">inc</span>
<span class="w">      </span><span class="n">inc</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">      </span><span class="n">out</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mux</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="n">next</span>
<span class="w">      </span><span class="n">zero</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span>
</pre></div>
</div>
<p>But wait, where’s the do notation? In fact, this is really just a DSL. There are no monads and no sequencing to be found. All of these operations happen in parallel. The uses for these circuit descriptions all depend on the circuits being specified using a small set of operations specified in a typeclass.</p>
<p>Investigating Hackage, mdo is uncommon. “Many Haskell programmers will never use it in their careers.” (<a class="reference external" href="https://ro-che.info/articles/2015-09-02-monadfix">1</a>) Uses fall into categories:
* DSLs, where variable assignments are interpreted as data
* Gratuitous (no/one binding, or bindings do not refer to bindings from later)
* Examples where it would be clearer to use mfix or the do-rec notation that is just <code class="docutils literal notranslate"><span class="pre">(a,b,c)</span> <span class="pre">&lt;-</span> <span class="pre">mfix</span> <span class="pre">(\(a,b,c)</span> <span class="pre">-&gt;</span> <span class="pre">(_,_,_))</span></code>
* I/O monad, mfix is used to write the code in a recursive style instead of modifying a variable, e.g. forking two threads that kill each other:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mdo</span>
<span class="w">   </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">killThread</span><span class="w"> </span><span class="n">b</span>
<span class="w">   </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">killThread</span><span class="w"> </span><span class="n">a</span>

<span class="c1">-- vs</span>
<span class="nf">bId</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">newEmptyMVar</span>
<span class="nf">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">readMVar</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">killThread</span>
<span class="nf">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">killThread</span><span class="w"> </span><span class="n">a</span>
<span class="nf">writeMVar</span><span class="w"> </span><span class="n">bId</span><span class="w"> </span><span class="n">b</span>
</pre></div>
</div>
<p>The code for IO’s mfix uses unsafeDupableInterleaveIO. This has been the subject of at least one <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/issues/5421">bug</a> (<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/issues/15349">two</a> counting fixST), and is why there is both fixIO and <a class="reference external" href="https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO-Unsafe.html#v:unsafeFixIO">unsafeFixIO</a>. Reasoning about fixIO seems to <a class="reference external" href="https://wiki.haskell.org/Evaluation_order_and_state_tokens">require</a> laziness semantics and maybe also an understanding of Haskell’s State-based I/O model.</p>
<p>Also, most monads fail to satisfy monadic right shrinking, which IMO makes the notation completely unintuitive:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mdo</span>
<span class="w">   </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">z</span>
<span class="w">   </span><span class="n">w</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">z</span>
<span class="w">   </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>

<span class="c1">-- is NOT equivalent to</span>

<span class="nf">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mdo</span>
<span class="w">         </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">z</span>
<span class="w">         </span><span class="n">return</span><span class="w"> </span><span class="n">z</span>
<span class="nf">w</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">z</span>
<span class="nf">return</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p>The only price to pay for leaving mdo out is that value-recursive monadic computations have to be written with <code class="docutils literal notranslate"><span class="pre">mfix</span></code> or its tuple-heavy cousin <code class="docutils literal notranslate"><span class="pre">rec{}</span></code>. We can still implement <code class="docutils literal notranslate"><span class="pre">mfix</span></code> for the monads that matter, like <code class="docutils literal notranslate"><span class="pre">State</span></code>. According to all available knowledge, <code class="docutils literal notranslate"><span class="pre">mfix</span></code> can’t be implemented for continuations, so nothing is lost from regular programs.</p>
<p>Verdict: Not only a DSL in disguise, but also a footgun. mfix and the rec{} notation are better for those who care.</p>
</section>
<section id="arrows">
<h3>Arrows<a class="headerlink" href="#arrows" title="Permalink to this heading"></a></h3>
<p>You might be getting the pattern here. Arrows were inspired by a parsing DSL. Any arrow which supports the ArrowApply class is a monad. Arrows not supporting ArrowApply must write operations for every language element supported (variable, function, conditional, grammar production choice, and so on). Continuations require ArrowApply to even implement the basic arrow interface. Verdict: trash, a leaky “abstraction” that just wastes everyone’s time.</p>
</section>
<section id="idiom-brackets">
<h3>Idiom brackets<a class="headerlink" href="#idiom-brackets" title="Permalink to this heading"></a></h3>
<p>While do notation is defined for monads, idiom brackets are defined for applicative functors, <code class="docutils literal notranslate"><span class="pre">[[</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">]]</span> <span class="pre">=</span> <span class="pre">pure</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">a</span> <span class="pre">&lt;*&gt;</span> <span class="pre">b</span></code>. But DSL notation works too: <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">{</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">}</span></code>.</p>
<p>The issue with translating to <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> is that it assumes left-to-right evaluation. You can see this in the <a class="reference external" href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Applicative.html#t:Applicative">translation</a> for Monads: <code class="docutils literal notranslate"><span class="pre">m1</span> <span class="pre">&lt;*&gt;</span> <span class="pre">m2</span></code> binds <code class="docutils literal notranslate"><span class="pre">m1</span></code> before <code class="docutils literal notranslate"><span class="pre">m2</span></code>. In Stroscot the program is required to be equivalent under all evaluation orders. So to enforce this we need a function <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">:</span> <span class="pre">[m</span> <span class="pre">a]</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">[a]</span></code> that checks there is no issue with evaluating in parallel. Then using parallel the translation of <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">{</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">x</span> <span class="pre">}</span></code> looks like <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">(av,bv,cv)</span> <span class="pre">=</span> <span class="pre">parallel</span> <span class="pre">(a,b,c);</span> <span class="pre">return</span> <span class="pre">(f</span> <span class="pre">av</span> <span class="pre">bv</span> <span class="pre">cv)</span> <span class="pre">}</span></code></p>
<p>Idris defines <a class="reference external" href="http://docs.idris-lang.org/en/latest/tutorial/interfaces.html#notation">!-notation</a>, “implicitly bound application”. The scoping is <a class="reference external" href="https://github.com/idris-lang/Idris-dev/issues/4395">unintuitive</a>, but the notation itself is powerful. Binding it to a syntactic block seems reasonable. And it can easily express idiom brackets, <code class="docutils literal notranslate"><span class="pre">[[</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">]]</span></code> becomes <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">f</span> <span class="pre">!a</span> <span class="pre">!b</span> <span class="pre">}</span></code>. Idiom brackets save characters with more arguments, but bang notation looks natural if there are multiple bindings in the block.</p>
</section>
<section id="c-like-reference-access">
<h3>C-like reference access<a class="headerlink" href="#c-like-reference-access" title="Permalink to this heading"></a></h3>
<p>For example we want to do:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="nf">a</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">c</span>
</pre></div>
</div>
<p>Translated this looks like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ref</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="nf">\</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="nf">ref</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="nf">\</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="nf">parallel</span><span class="w"> </span><span class="p">(</span><span class="n">read</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="nf">\</span><span class="p">(</span><span class="n">av</span><span class="p">,</span><span class="n">bv</span><span class="p">)</span><span class="w">  </span><span class="ow">-&gt;</span>
<span class="kr">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">av</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bv</span><span class="w"> </span><span class="kr">in</span>
<span class="nf">writeRef</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span>
</pre></div>
</div>
<p>I think the solution is another DSL. Inserting <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">a</span></code> is not too complicated, just follow the C/C++ rules about converting lvalues to rvalues.</p>
</section>
</section>
<section id="assignment">
<h2>Assignment<a class="headerlink" href="#assignment" title="Permalink to this heading"></a></h2>
<p>As a syntax ambiguity, there are two different interpretations of assignment, pattern binding and clause definition. The difference:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pair</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="kt">B</span>

<span class="o">#</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="n">clauses</span>
<span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="nf">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">y</span>
<span class="o">--&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="o">#</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">clause</span><span class="w"> </span><span class="n">definition</span>
<span class="p">(,)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">pair</span>
<span class="o">--&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="n">reduces</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">reduces</span><span class="w"> </span><span class="n">cyclically</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">itself</span>
</pre></div>
</div>
<p>The pattern binding is more useful in this example than the clause definition. So we have a basic convention for assignments: if the head of the LHS is a constructor symbol then it’s a pattern binding. What is a constructor symbol? Well, it’s up to the code, defined by the predicate <code class="docutils literal notranslate"><span class="pre">isConstructor</span></code>. Most symbols are not constructors, so the ones that are constructors are declared with <code class="docutils literal notranslate"><span class="pre">isConstructor</span> <span class="pre">sym</span> <span class="pre">=</span> <span class="pre">true</span></code>  or the macro declaration <code class="docutils literal notranslate"><span class="pre">constructor</span> <span class="pre">sym</span></code>.</p>
<p>Assignment pattern bindings are irrefutable, meaning they never fail directly and instead define unevaluated variables that will raise pattern matching exceptions when evaluated. But there is an alternative syntax that allows failure as a control operation (from Idris / Inko):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pat</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;</span><span class="n">alternatives</span><span class="o">&gt;</span>
<span class="nf">p</span>
</pre></div>
</div>
<p>is desugared to</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="kr">of</span>
<span class="w">  </span><span class="n">pat</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">p</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">alternatives</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>If a clause does not match, the expression does not reduce - there is no error at all.</p>
<p>In the case of a simple variable <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">...</span></code> the definitions coincide - the end result is a clause definition.</p>
<p>Another way to resolve the ambiguity is to use separate syntaxes, e.g. to use <code class="docutils literal notranslate"><span class="pre">(x,y)</span> <span class="pre">&lt;-</span> <span class="pre">pair</span></code> for pattern bindings. But remembering to switch between pattern bindings and clause definitions is tedious.</p>
<p>The explicit syntax does allow defining new reduction rules for constructors. But if overriding basic syntax is desired, <code class="docutils literal notranslate"><span class="pre">isConstructor</span></code> can be locally overridden, e.g. if we want a sorted pair:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="n">isConstructor</span><span class="w"> </span><span class="p">(,)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">false</span>
</pre></div>
</div>
<p>Usually it’s more natural to use a new symbol, like <code class="docutils literal notranslate"><span class="pre">sortedPair</span> <span class="pre">(x,y)</span></code>, so that the global definition of pairs is not affected.</p>
<section id="constructor-discipline">
<h3>Constructor discipline<a class="headerlink" href="#constructor-discipline" title="Permalink to this heading"></a></h3>
<p>Haskell has a division between constructors and functions:
* identifiers starting with lowercase letters are functions, and can only be used with function bindings.
* identifiers starting with uppercase letters are constructors, and assignments of the form <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">...</span></code> are pattern bindings.</p>
<p>This rule reduces maintainability. If the representation is changed there is no way to replace the dumb constructor with a smart constructor. So instead libraries are littered with boilerplate pseudo-constructors like <code class="docutils literal notranslate"><span class="pre">mkThing</span> <span class="pre">=</span> <span class="pre">Thing</span></code> to get around this syntactic restriction. In fact in <span id="id16">[<a class="reference internal" href="../zzreferences.html#id87" title="Stefan Kahrs and Connor Smith. Non-Omega-Overlapping TRSs are UN. In Delia Kesner and Brigitte Pientka, editors, 1st International Conference on Formal Structures for Computation and Deduction (FSCD 2016), volume 52 of Leibniz International Proceedings in Informatics (LIPIcs), 22:1–22:17. Dagstuhl, Germany, 2016. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik. URL: http://drops.dagstuhl.de/opus/volltexte/2016/5996 (visited on 2021-09-11), doi:10.4230/LIPIcs.FSCD.2016.22.">KS16</a>]</span> there is a boilerplate trick to turn any TRS into a constructor TRS, by duplicating <code class="docutils literal notranslate"><span class="pre">foo</span></code> into a constructor <code class="docutils literal notranslate"><span class="pre">Foo</span></code> and a function <code class="docutils literal notranslate"><span class="pre">foo</span></code>, converting subterms of the original rules to match on constructors, and adding rules that turn stuck patterns into constructors. For example <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">x;</span> <span class="pre">s</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">(x</span> <span class="pre">z)</span> <span class="pre">(y</span> <span class="pre">z)</span></code> turns into:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">app</span><span class="w"> </span><span class="p">(</span><span class="kt">App</span><span class="w"> </span><span class="kt">K</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span>
<span class="nf">app</span><span class="w"> </span><span class="kt">K</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">App</span><span class="w"> </span><span class="kt">K</span><span class="w"> </span><span class="n">x</span>
<span class="nf">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">K</span>

<span class="nf">app</span><span class="w"> </span><span class="p">(</span><span class="kt">App</span><span class="w"> </span><span class="p">(</span><span class="kt">App</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">(</span><span class="n">app</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">app</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="nf">app</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">App</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">x</span>
<span class="nf">app</span><span class="w"> </span><span class="p">(</span><span class="kt">App</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">App</span><span class="w"> </span><span class="p">(</span><span class="kt">App</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">y</span>
<span class="nf">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">S</span>
</pre></div>
</div>
<p>This is pretty verbose but it’s curried so it isn’t as bad as it could be. For rules like associativity <code class="docutils literal notranslate"><span class="pre">x*(y*z)</span> <span class="pre">=</span> <span class="pre">(x*y)*z</span></code> and distributivity <code class="docutils literal notranslate"><span class="pre">x*(y+z)</span> <span class="pre">=</span> <span class="pre">x*y+x*z</span></code> handling all the stuck pattern rules for symbols <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">*</span></code> is a nightmare, and you also have to come up with alternative operator names for the constructors.</p>
<p>So Stroscot follows Pure in not having a constructor discipline. By appropriately setting <code class="docutils literal notranslate"><span class="pre">isConstructor</span> <span class="pre">=</span> <span class="pre">true</span></code> any symbol can be used as a constructor pattern on the left-hand side of an equation. Also any symbol may act as a constructor symbol in a value if it happens to occur in head position in a normal form term, regardless of <code class="docutils literal notranslate"><span class="pre">isConstructor</span></code>.</p>
<p>There is a general convention for the standard library to use lowercase for potentially reducible expressions or “smart” constructors and uppercase for dumb data constructors. This is to vaguely follow Haskell.</p>
</section>
<section id="recursive-definitions">
<h3>Recursive definitions<a class="headerlink" href="#recursive-definitions" title="Permalink to this heading"></a></h3>
<p>We want to support mutually recursive definitions, like so:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span>

<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">c</span>
<span class="nf">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">b</span>
</pre></div>
</div>
<p>And also sequential execution, like so:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">openFile</span><span class="w"> </span><span class="s">&quot;a.txt&quot;</span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">openFile</span><span class="w"> </span><span class="s">&quot;b.txt&quot;</span>
</pre></div>
</div>
<p>And also shadowing variables, like so:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="c1">-- interpreted as</span>
<span class="nf">a_new</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a_old</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
<p>In the recursive version <code class="docutils literal notranslate"><span class="pre">c</span></code> can be in scope in the body of <code class="docutils literal notranslate"><span class="pre">b</span></code> even though it is defined later. Presumably it isn’t in scope in the sequential version.</p>
<p>In the recursive version <code class="docutils literal notranslate"><span class="pre">a</span></code> is in scope in its own body. In the shadowing version <code class="docutils literal notranslate"><span class="pre">a</span></code> is not.</p>
<p>Resolving this probably means a special syntax for something. Choices:
* <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;-</span> <span class="pre">openFile</span> <span class="pre">&quot;a.txt&quot;</span></code> for sequenced actions
* <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;-</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">1</span></code> for shadowing
* <code class="docutils literal notranslate"><span class="pre">rec</span> <span class="pre">{</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">}</span></code> for recursive definitions</p>
<p>Generally sequential blocks do not use recursion. But recursion is used all the time at the module/function level.</p>
</section>
</section>
<section id="type-declarations">
<h2>Type declarations<a class="headerlink" href="#type-declarations" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">:</span> <span class="pre">s8</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">s8</span> <span class="pre">2</span></code> seem more logical compared to other choices such as <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">s8</span> <span class="pre">=</span> <span class="pre">2</span></code> (Swift,Jai - hard to find the = with long types) or <code class="docutils literal notranslate"><span class="pre">s8</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">2</span></code> (C,Rust - overlaps with function definition). The name is simply a syntactic handle to refer to the value; it doesn’t have an innate type. In contrast the representation of the value must be specified to compile the program. The second syntax <code class="docutils literal notranslate"><span class="pre">s8</span> <span class="pre">2</span></code> is similar to assembler syntax such as <code class="docutils literal notranslate"><span class="pre">dword</span> <span class="pre">0</span></code>.</p>
<p><a class="reference external" href="https://soc.me/languages/type-annotations">This</a> says name should be ahead of type annotation, which only <code class="docutils literal notranslate"><span class="pre">s8</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">2</span></code> breaks. The consistency stuff is not relevant.</p>
<p>In Go they introduced a special declare-and-initialize construct <code class="docutils literal notranslate"><span class="pre">myFoo</span> <span class="pre">:=</span> <span class="pre">new(foo.Foo)</span></code>, to replace the repetitive <code class="docutils literal notranslate"><span class="pre">foo.Foo*</span> <span class="pre">myFoo</span> <span class="pre">=</span> <span class="pre">new(foo.Foo)</span></code>. But it doesn’t need a special operator, <code class="docutils literal notranslate"><span class="pre">myFoo</span> <span class="pre">=</span> <span class="pre">new(foo.Foo)</span></code> works just as well.</p>
</section>
<section id="namespacing">
<h2>Namespacing<a class="headerlink" href="#namespacing" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">.</span></code> is preferred to <code class="docutils literal notranslate"><span class="pre">::</span></code> because it’s shorter and because modules are first-class. And as in Go, no <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>, always <code class="docutils literal notranslate"><span class="pre">.</span></code>.</p>
</section>
<section id="partial-loading">
<h2>Partial loading<a class="headerlink" href="#partial-loading" title="Permalink to this heading"></a></h2>
<p>The parser parses as much of the input as possible, but in general only a prefix of the input will be valid. Hence we can load a portion of the file by inserting junk / truncating the input buffer. The compiler will give a warning but the parser should handle it just fine.</p>
</section>
<section id="specificity">
<h2>Specificity<a class="headerlink" href="#specificity" title="Permalink to this heading"></a></h2>
<p>This might seem overly complicated, but it’s based on Zarf’s <a class="reference external" href="https://eblong.com/zarf/rule-language.html">rule-based programming</a>. When you’re defining lots of rules for a IF game then specifying priorities by hand is tedious.</p>
</section>
<section id="comments">
<h2>Comments<a class="headerlink" href="#comments" title="Permalink to this heading"></a></h2>
<p>Comments allow writing documentation inline with the code. This speeds up development by keeping all the information in one file and avoiding having to jump around. It also encourages a standardized documentation format.</p>
<p>Tool support can be incomplete because there is a lot of freedom in comments. People can put comments in random places and they can be attached to whatever and indented strangely. With such freedom the reformatter will likely mangle some comments, but probably people will just learn not to do that.</p>
<section id="shebangs">
<h3>Shebangs<a class="headerlink" href="#shebangs" title="Permalink to this heading"></a></h3>
<p>One “comment-like” thing is the shebang. The convention is that if a file starts with the characters “#!”, the remainder of the first line will be treated as the name of the interpreter to use (and possibly arguments to be passed to that interpreter). Per <a class="reference external" href="https://lwn.net/Articles/779997/">LWN</a> the kernel will truncate the line  to 128 bytes, so the interpreter should detect the shebang and reread the first line to get the proper argument list. See Perl for implementation details.</p>
<p>Usually the interpreter is <code class="docutils literal notranslate"><span class="pre">/usr/bin/env</span></code> rather than the actual program, because the interpeter’s full path must be specified and the user might have installed the program somewhere else. Even NixOS which has minimal files outside <code class="docutils literal notranslate"><span class="pre">/nix</span></code> has <code class="docutils literal notranslate"><span class="pre">/usr/bin/env</span></code> due to its ubiquity. The arguments are all combined into one string so a shebang like <code class="docutils literal notranslate"><span class="pre">#!/usr/bin/env</span> <span class="pre">perl</span> <span class="pre">-w</span> <span class="pre">-T</span></code> will gave an error that the program <code class="docutils literal notranslate"><span class="pre">perl</span> <span class="pre">-w</span> <span class="pre">-T</span></code> is not found, but <code class="docutils literal notranslate"><span class="pre">#!/usr/bin/env</span> <span class="pre">-S</span> <span class="pre">perl</span> <span class="pre">-w</span> <span class="pre">-T</span></code> will work as expected as will avoiding arguments like <code class="docutils literal notranslate"><span class="pre">#!/usr/bin/env</span> <span class="pre">perl</span></code>. Languages whose main commands default to compilation usually provide a specialized interpreter command like <code class="docutils literal notranslate"><span class="pre">language-run</span></code> for use with env.</p>
<p>The shebang, like the byte order mark, can be hardcoded into the file-level syntax and does not need to affect the comment syntax. On RosettaCode the frequency of <code class="docutils literal notranslate"><span class="pre">#</span></code> was less than <code class="docutils literal notranslate"><span class="pre">//</span></code> and several languages such as D and Gema hardcoded shebang support, so shebangs don’t seem to be a factor in deciding the syntax for normal comments.</p>
<p>Zig added and then removed shebang support. <a class="reference external" href="https://github.com/ziglang/zig/issues/2165#issuecomment-478813464">The justification for removal</a> is all over the place. What I get out of it is that he preferred a package compilation model and believed <code class="docutils literal notranslate"><span class="pre">zig</span> <span class="pre">run</span></code> sufficed for other cases. To make some counterpoints:</p>
<ul class="simple">
<li><p>There is significant demand for avoiding the overhead of a package build tool and edit-compile cycle and just working with the source.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zig</span> <span class="pre">run</span> <span class="pre">x</span></code> is more typing than <code class="docutils literal notranslate"><span class="pre">x</span></code>, although the shebang and <code class="docutils literal notranslate"><span class="pre">chmod</span> <span class="pre">+x</span></code> do add an upfront cost</p></li>
<li><p>If you have a significant command line then the shebang saves you from tediously typing it out every time or creating a separate shell script.</p></li>
</ul>
<p>He also talks about environments and versions; you can specify those in the path, in the shebang line, or in the file proper and they all work.</p>
</section>
<section id="types">
<h3>Types<a class="headerlink" href="#types" title="Permalink to this heading"></a></h3>
<p>Based loosely on <a class="reference external" href="https://www.gavilan.edu/csis/languages/comments.html">this</a>, syntactically there are 3 types of comments:</p>
<ul class="simple">
<li><p>A full-line comment begins with a start indicator at the beginning of the line, and finishes at the end of the line. Used in early fixed-column languages; no longer in common use.</p></li>
<li><p>An end-of-line comment begins with a start indicator anywhere in the line, and finishes at the end of the line.</p></li>
<li><p>A block comment has a start indicator and an end terminator and can continue for several lines, or be less than one line.</p></li>
</ul>
<p>Block comments can either nest, parsing <code class="docutils literal notranslate"><span class="pre">start</span> <span class="pre">start</span> <span class="pre">end</span> <span class="pre">end</span></code> as one comment, or not, parsing <code class="docutils literal notranslate"><span class="pre">start</span> <span class="pre">start</span> <span class="pre">end</span></code> as one comment and giving a syntax error on the nesting example.</p>
<p>Semantically there are 3 types:</p>
<ul class="simple">
<li><p>Implementation comments discuss the tricks used or maintainance advice, and have no effect on compilation.</p></li>
<li><p>Documentation comments are ignored like implementation comments during code generation, but are read by the documentation generator.</p></li>
<li><p>Code comments hide code that is not currently needed.  In this categorization code comments allow nesting other types of comments to allow commenting out huge chunks of code easily, while implementation and documentation comments do not.</p></li>
</ul>
<p>This gives 5 comment types: EOL impl, block impl, EOL doc, block doc, and block code. There is no point in an EOL code comment because an EOL implementation comment suffices.</p>
<p>Comments at the beginning of the file are a little special and can be forbidden or restricted to specific types such as documentation comments or shebangs.</p>
</section>
<section id="id17">
<h3>Parsing<a class="headerlink" href="#id17" title="Permalink to this heading"></a></h3>
<p>Generally EOL comments hide the start or end of a block comment. This is useful in some hacks like embedding Javascript in HTML or doing <code class="docutils literal notranslate"><span class="pre">//*</span> <span class="pre">\n</span> <span class="pre">/*/</span> <span class="pre">\n</span> <span class="pre">//</span> <span class="pre">*/</span></code> vs <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">\n</span> <span class="pre">/*/</span> <span class="pre">\n</span> <span class="pre">//</span> <span class="pre">*/</span></code> to switch between two blocks of code. But the parser could pick out the block start/end and not ignore it. There is a different code block trick <code class="docutils literal notranslate"><span class="pre">/*/</span> <span class="pre">\n</span> <span class="pre">/*/</span> <span class="pre">\n</span> <span class="pre">/**/</span></code> vs <code class="docutils literal notranslate"><span class="pre">/**/</span> <span class="pre">\n</span> <span class="pre">/*/</span> <span class="pre">\n</span> <span class="pre">/**/</span></code> which doesn’t depend on this behavior.</p>
<p>Using two characters to start a comment helps prevent the accidental starting of a comment and allows more freedom in avoiding syntax conflicts in the language. The double slash // does pretty well in this context, but the /* does not do quite as well. For example in C <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=1/*ptr;</span></code> starts a comment instead of doing a division. There is the opposite issue that an extra space between the two comment characters, like <code class="docutils literal notranslate"><span class="pre">/</span> <span class="pre">/</span> <span class="pre">comment</span></code>, will cause the comment to be missed, but usually the contents of the comment will cause a compilation error.</p>
<p>Multiline block comments have the issue of forgetting the end terminator and matching some other end terminator. Some languages only have EOL comments, presumably to avoid this problem. Nesting solves this because there will be an unterminated comment. Similarly forbidding block start indicators from appearing in a block comment will work. The compiler can also check each line and see if it looks like code, although this prevents commenting out code.</p>
</section>
</section>
<section id="whitespace">
<h2>Whitespace<a class="headerlink" href="#whitespace" title="Permalink to this heading"></a></h2>
<p>Whitespace in identifiers… this doesn’t work well with Haskell syntax. With whitespace <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">something</span> <span class="pre">=</span> <span class="pre">...`</span></code> would define the identifier <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">something</span></code>, but in Haskell it’s a clause <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">_</span></code> that binds <code class="docutils literal notranslate"><span class="pre">something</span></code>.</p>
<p>OTOH using a string works fine: <code class="docutils literal notranslate"><span class="pre">&quot;do</span> <span class="pre">something&quot;</span> <span class="pre">=</span> <span class="pre">...</span></code></p>
<p>You could also make something an atom, then you can write <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">something</span></code> in code but the clause definition is <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">^something</span> <span class="pre">=</span> <span class="pre">...</span></code>. The semantics are similar to a single identifier but different enough that I don’t think it counts.</p>
</section>
<section id="indentation-sensitivity">
<h2>Indentation sensitivity<a class="headerlink" href="#indentation-sensitivity" title="Permalink to this heading"></a></h2>
<p>Indentation-sensitivity (IS) like Python and Haskell seems great.</p>
<ul class="simple">
<li><p>IS requires less typing. All modern languages are presented with indentation, so IS is just omitting the curly braces or begin-end markers.</p></li>
<li><p>IS avoids the issue of braces mismatching indentation.</p></li>
<li><p>IS avoids confusion or arguments about where to put the braces - <a class="reference external" href="https://en.wikipedia.org/wiki/Indentation_style">WP</a> lists 8 different styles.</p></li>
<li><p>IS is fewer lines of vertical space, because there are no braces on their own lines. This makes it cheaper to print code listings out on paper.</p></li>
<li><p>IS improves code legibility. There haven’t been any formal studies that I can find, but Python syntax is often said to be “clean”.</p></li>
<li><p>When copy-pasting code, you only have to fix up the indentation by moving the block left/right (supported by all modern code editors), instead of messing with braces.</p></li>
</ul>
<p>More discussion: <a class="reference external" href="https://www.reddit.com/r/ProgrammingLanguages/comments/uo0nq7/end_keywords_vs_pythonstyle_blocks_for_beginners/">https://www.reddit.com/r/ProgrammingLanguages/comments/uo0nq7/end_keywords_vs_pythonstyle_blocks_for_beginners/</a>
<a class="reference external" href="https://unspecified.wordpress.com/2011/10/18/why-pythons-whitespace-rule-is-right/">https://unspecified.wordpress.com/2011/10/18/why-pythons-whitespace-rule-is-right/</a>
<a class="reference external" href="https://wiki.python.org/moin/Why%20separate%20sections%20by%20indentation%20instead%20of%20by%20brackets%20or%20%27end%27">https://wiki.python.org/moin/Why%20separate%20sections%20by%20indentation%20instead%20of%20by%20brackets%20or%20%27end%27</a></p>
<p>Mixing tabs and spaces can lead to errors, but erroring on this is fine.</p>
<p>Haskell’s layout rules seem overly restrictive, for example this is not allowed:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">bang_upper</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bang</span><span class="w"> </span><span class="p">(</span><span class="kt">Rule</span>
<span class="w">  </span><span class="p">(</span><span class="kt">Sequent</span><span class="w"> </span><span class="n">newcut_bseq</span><span class="w"> </span><span class="p">(</span><span class="n">bl_tlnotn</span><span class="o">++</span><span class="n">brl_bl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">bl_tmain</span><span class="p">,</span><span class="w"> </span><span class="n">bl_tr</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">brl_br</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="kt">Sequent</span><span class="w"> </span><span class="n">bl_bseq</span><span class="w"> </span><span class="p">(</span><span class="n">bl_blnotn</span><span class="o">++</span><span class="n">br_bl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">bl_bmain</span><span class="p">,</span><span class="w"> </span><span class="n">bl_br</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">br_br</span><span class="p">))))</span>
</pre></div>
</div>
<p>Although the parentheses make this unambiguous, Haskell requires indenting a lot more, past the <code class="docutils literal notranslate"><span class="pre">=</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">bang_upper</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bang</span><span class="w"> </span><span class="p">(</span><span class="kt">Rule</span>
<span class="w">                  </span><span class="p">(</span><span class="kt">Sequent</span><span class="w"> </span><span class="p">(</span><span class="n">fst</span><span class="w"> </span><span class="n">bl_tseq</span><span class="p">,</span><span class="w"> </span><span class="n">newcut_bseq</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">bl_tlnotn</span><span class="o">++</span><span class="n">brl_bl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">bl_tmain</span><span class="p">,</span><span class="w"> </span><span class="n">bl_tr</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">brl_br</span><span class="p">))</span>
<span class="w">                  </span><span class="p">(</span><span class="kt">Sequent</span><span class="w"> </span><span class="n">bl_bseq</span><span class="w"> </span><span class="p">(</span><span class="n">bl_blnotn</span><span class="o">++</span><span class="n">br_bl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">bl_bmain</span><span class="p">,</span><span class="w"> </span><span class="n">bl_br</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">br_br</span><span class="p">)))</span>
</pre></div>
</div>
<p>Per <a class="reference external" href="https://stackoverflow.com/a/2149878">anecdote of Kmett</a> this requirement makes Haskell’s layout rules too complex for blind people because it requires lining up columns.</p>
<p>Similarly <a class="reference external" href="https://www.youtube.com/watch?v=SUIUZ09mnwM">https://www.youtube.com/watch?v=SUIUZ09mnwM</a> says to avoid a layout like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">unstable</span><span class="w"> </span><span class="n">someExpresssion</span>
<span class="w">         </span><span class="n">anotherExpression</span>
</pre></div>
</div>
<p>because renaming <code class="docutils literal notranslate"><span class="pre">unstable</span></code> will require reindenting the rest of the expression. Prefer:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">stable</span>
<span class="w">  </span><span class="n">someExpresssion</span>
<span class="w">  </span><span class="n">anotherExpression</span>

<span class="o">//</span><span class="w"> </span><span class="n">or</span>

<span class="nf">stable</span><span class="w"> </span><span class="n">someExpresssion</span>
<span class="w">  </span><span class="n">anotherExpression</span>
</pre></div>
</div>
<p>Rob Pike says indentation sensitivity “is nice for small programs” but causes issues with embedding. For example, “a Python snippet embedded in another language, for instance through a SWIG invocation, is subtly and invisibly broken by a change in the indentation of the surrounding code.” This seems like an issue caused by the embedding style - if the snippet was in a separate file then the tools might deal with it better. Haskell defines a translation from indentation style to brace syntax, and just requiring brace syntax in these embeddings might be sufficient.</p>
<section id="blind-community">
<h3>Blind community<a class="headerlink" href="#blind-community" title="Permalink to this heading"></a></h3>
<p>Blind programmers have diverse opinions. I don’t know a significant number of them so this is all anecdotes. Per <a class="reference external" href="https://news.ycombinator.com/item?id=11419478">this HN comment</a> the majority seem to use screen readers and “almost all” screen readers have a setting to report the indentation of the current line, and this is relatively easy to use. For example per <a class="reference external" href="https://www.youtube.com/watch?v=qvg-uo_I7JM">this video</a> NVDA can be set up to automatically switch between different profiles for different tasks based on the focused window / process, and can announce indentation level using both beep tones and a TTS description of the number of spaces or tabs when navigating. Per <a class="reference external" href="https://github.com/microsoft/vscode/issues/147386">this</a> JAWS provides similar functionality. Roughly the experiences can be compared like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- original (sighted)</span>

<span class="kr">if</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="kr">then</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="s">&quot;hello&quot;</span>
<span class="kr">else</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="s">&quot;bye&quot;</span>

<span class="c1">-- screen reader with indentation on</span>

<span class="kr">if</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">less</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="kr">then</span>
<span class="nf">indent</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">quote</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="n">quote</span>
<span class="nf">dedent</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="kr">else</span>
<span class="nf">indent</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">quote</span><span class="w"> </span><span class="n">bye</span><span class="w"> </span><span class="n">quote</span>

<span class="c1">-- braces</span>

<span class="kr">if</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">less</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">open</span><span class="w"> </span><span class="n">brace</span>
<span class="nf">print</span><span class="w"> </span><span class="n">quote</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="n">quote</span>
<span class="nf">close</span><span class="w"> </span><span class="n">brace</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">open</span><span class="w"> </span><span class="n">brace</span>
<span class="nf">print</span><span class="w"> </span><span class="n">quote</span><span class="w"> </span><span class="n">bye</span><span class="w"> </span><span class="n">quote</span>
<span class="nf">close</span><span class="w"> </span><span class="n">brace</span>

<span class="c1">-- braces with indentation on</span>

<span class="kr">if</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">less</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">open</span><span class="w"> </span><span class="n">brace</span>
<span class="nf">indent</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">quote</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="n">quote</span>
<span class="nf">dedent</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">close</span><span class="w"> </span><span class="n">brace</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">open</span><span class="w"> </span><span class="n">brace</span>
<span class="nf">indent</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">quote</span><span class="w"> </span><span class="n">bye</span><span class="w"> </span><span class="n">quote</span>
<span class="nf">dedent</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">close</span><span class="w"> </span><span class="n">brace</span>
</pre></div>
</div>
<p>Some people turn on indentation even for brace languages, because knowing the indentation level can be helpful in navigating code. However, <a class="reference external" href="https://github.com/google/rune/blob/main/doc/rune4python.md">Rune</a> and <a class="reference external" href="https://www.youtube.com/watch?v=94swlF55tVc">several</a> <a class="reference external" href="https://stackoverflow.com/a/453758">others</a> say that brace languages like C# are usable without indentation on, and then they don’t have to set up profiles. IMO the indentation version seems a little easier to navigate, and this is backed up by Python still being a popular coding language for blind people (e.g. NVDA is written in Python). But obviously everyone has their preference and supporting several options can improve accessibility. There is a pindent script in the Python distribution that adds/removes block open/close markers, so you can run it as a git smudge/clean filter. It seems Stroscot similarly should provide an explicit but optional brace syntax and a smudge/clean filter to convert to/from this syntax.</p>
<p>Another option for blind people is the Braille display, but it is expensive and only shows at most 80 characters. Per <a class="reference external" href="https://stackoverflow.com/a/148880">this user</a> it can help with both indentation and complex punctuation, particularly lines with many nested parentheses. But the screen reader is usually faster. Comparing wpm, Braille is around 150 wpm starting out going up to 250 wpm, a physical limit of how fast fingers can run over the dots. 150 wpm is also about what TTS does by default but TTS can be sped up to around 500 wpm as the user becomes more accustomed to the synthesizer, <span id="id18">[<a class="reference internal" href="../zzreferences.html#id150" title="Amanda Stent, Ann Syrdal, and Taniya Mishra. On the intelligibility of fast synthesized speech for individuals with early-onset blindness. In The Proceedings of the 13th International ACM SIGACCESS Conference on Computers and Accessibility - ASSETS '11, 211. Dundee, Scotland, UK, 2011. ACM Press. URL: http://dl.acm.org/citation.cfm?doid=2049536.2049574 (visited on 2022-11-30), doi:10.1145/2049536.2049574.">SSM11</a>]</span> and even at 900 wpm experienced users can still transcribe gibberish text with 50% accuracy. So TTS has markedly more bandwidth.</p>
<p><a class="reference external" href="http://tvraman.github.io/emacspeak/manual/emacspeak_002dpython.html">emacspeak</a> has speech-enabled python-mode and <a class="reference external" href="https://groups.google.com/g/comp.lang.python/c/Dm-qTzO8Db8?hl=en#3216b7a02047873a">per ML thread</a> reads things like “closes block &lt;block’s opening line&gt;” on dedent. But it seems like it is hard to install and not really that popular.</p>
</section>
</section>
<section id="braces-and-brackets">
<h2>Braces and brackets<a class="headerlink" href="#braces-and-brackets" title="Permalink to this heading"></a></h2>
<p>Haskell uses parentheses for most grouping, <code class="docutils literal notranslate"><span class="pre">{}</span></code> for replacing whitespace with explicit syntax, <code class="docutils literal notranslate"><span class="pre">[]</span></code> for lists, and has no special meaning for angle brackets.</p>
<p><a class="reference external" href="https://soc.me/languages/stop-using-angle-brackets-for-generics">Simon</a> says to use square brackets <code class="docutils literal notranslate"><span class="pre">[]</span></code> instead of angle brackets <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code> for generics. With Haskell syntax this is moot because parentheses suffices. But he argues collection literals and array lookup should use standard parentheses <code class="docutils literal notranslate"><span class="pre">()</span></code> instead of special syntax, because it will become dead weight once the standard library develops better data structures.</p>
<p>Seems a bit weird, he cites Python as an example but Python still uses list literals: the syntax for a NumPy array is <code class="docutils literal notranslate"><span class="pre">np.array([1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5])</span></code>. The only thing overloaded is access <code class="docutils literal notranslate"><span class="pre">arr[i]</span> <span class="pre">=</span> <span class="pre">x</span></code>.</p>
<p>Julia doesn’t require parens around conditions in <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span></code>, <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code> instead of <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(a</span> <span class="pre">==</span> <span class="pre">b)</span></code>.</p>
</section>
<section id="function-syntax">
<h2>Function syntax<a class="headerlink" href="#function-syntax" title="Permalink to this heading"></a></h2>
<p>Stroscot has first-class functions with lexically scoped name binding.</p>
<p>Lambdas are defined using whatever syntax. The <code class="docutils literal notranslate"><span class="pre">\x.y</span></code> style is closest to the mathematical notation (barring Unicode), Haskell uses <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">y</span></code>, Cliff likes <code class="docutils literal notranslate"><span class="pre">{x</span> <span class="pre">=&gt;</span> <span class="pre">y}</span></code>.</p>
<p>Conceptually, higher-order term rewriting is the underlying model of computation. So definitions are not equivalent to lambdas, although in many cases they produce equivalent results.</p>
<section id="arguments">
<h3>Arguments<a class="headerlink" href="#arguments" title="Permalink to this heading"></a></h3>
<p>Stroscot supports many types of arguments. Functions are extremely common, so the more styles supported,
the shorter the code will be.</p>
<p>Equations are tried in the order in which they are written; as soon as the left-hand side of an equation matches (and the condition part of the equation, if any, is satisfied), it can be applied to reduce the target term to the corresponding right-hand side. The term is rewritten until no more equations are applicable.</p>
</section>
<section id="call-syntax">
<h3>Call syntax<a class="headerlink" href="#call-syntax" title="Permalink to this heading"></a></h3>
<p>There are various ways to write function calls:</p>
<ul class="simple">
<li><p>Haskell style: <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(g</span> <span class="pre">a</span> <span class="pre">1)</span> <span class="pre">(h</span> <span class="pre">b</span> <span class="pre">2)</span></code>.</p></li>
<li><p>Lisp style: <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">(g</span> <span class="pre">a</span> <span class="pre">1)</span> <span class="pre">(h</span> <span class="pre">b</span> <span class="pre">2))</span></code> (Haskell with extra parentheses)</p></li>
<li><p>Coffeescript: <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(g</span> <span class="pre">a</span> <span class="pre">1),</span> <span class="pre">(h</span> <span class="pre">b</span> <span class="pre">2)</span></code> (Haskell with extra commas)</p></li>
<li><p>Explicit call, Haskell: <code class="docutils literal notranslate"><span class="pre">call</span> <span class="pre">f</span> <span class="pre">(call</span> <span class="pre">g</span> <span class="pre">a</span> <span class="pre">1)</span> <span class="pre">(call</span> <span class="pre">h</span> <span class="pre">b</span> <span class="pre">2)</span></code> (Haskell with call inserted before functions)</p></li>
<li><p>C style: <code class="docutils literal notranslate"><span class="pre">f(g(a,1),h(b,2))</span></code></p></li>
<li><p>C with spaces style: <code class="docutils literal notranslate"><span class="pre">f(g(a</span> <span class="pre">1)</span> <span class="pre">h(b</span> <span class="pre">2))</span></code></p></li>
<li><p>Explicit call, C: <code class="docutils literal notranslate"><span class="pre">call(f,call(g,a,1),call(h,b,2))</span></code> (Haskell style with call inserted before parentheses and commas instead of spaces)</p></li>
<li><p>Postfix: <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">b</span> <span class="pre">h</span> <span class="pre">1</span> <span class="pre">a</span> <span class="pre">g</span> <span class="pre">f</span></code></p></li>
<li><p>Postfix with argument counts: <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">b</span> <span class="pre">2</span> <span class="pre">h</span> <span class="pre">1</span> <span class="pre">a</span> <span class="pre">2</span> <span class="pre">g</span> <span class="pre">2</span> <span class="pre">f</span></code></p></li>
</ul>
<p>Comparing character counts for this example, postfix is 13, C is 16, and Haskell is 17. Lisp, Coffeescript, and the explicit calls are all similar to Haskell style, and are longer, so can be ignored. For a simple function application <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code> Haskell is shorter by one character than C (more if you add a space after the comma like <code class="docutils literal notranslate"><span class="pre">f(a,</span> <span class="pre">b)</span></code>, as is common) and the spaces are easier to type than the commas. Haskell loses in character count only if you have a pattern like <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(a)</span> <span class="pre">(b)</span> <span class="pre">(c)</span></code> where all the expressions need parentheses.</p>
<p>Postfix is pretty much unreadable so I’m ignoring it. So the two main contenders are Haskell and C. The C style is incredibly common, whereas Haskell is only used by functional languages like Haskell and OCaml. But I’m still going with Haskell for now, because: (<a class="reference external" href="https://www.reddit.com/r/ProgrammingLanguages/comments/jde9xp/advantages_of_currying_in_a_programming_language/">Reddit thread</a>)</p>
<ul class="simple">
<li><p>Haskell is more readable - the spaces and parentheses have more vertical variation compared to commas</p></li>
<li><p>Haskell is pretty simple, only a bit more complex than S-expressions</p></li>
<li><p>Haskell is good for writing curried functions. In contrast the C style makes it inconvenient to use curried functions, you have to write lots of parentheses <code class="docutils literal notranslate"><span class="pre">f(1)(2)(3)</span></code>. Also comparing <code class="docutils literal notranslate"><span class="pre">any</span> <span class="pre">(==</span> <span class="pre">x)</span> <span class="pre">l</span></code> and <code class="docutils literal notranslate"><span class="pre">any(\y</span> <span class="pre">-&gt;</span> <span class="pre">y</span> <span class="pre">==</span> <span class="pre">x,l)</span></code>, in the C style the comma is almost unnoticeable and the syntax is ambiguous as it could be grouped <code class="docutils literal notranslate"><span class="pre">(x,l)</span></code></p></li>
<li><p>Haskell style still allows passing a tuple and matching the C syntax, <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(1,2)</span></code>, or no arguments <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">()</span></code>. It also allows a record like <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">{a=1}</span></code> which C would require separate support for. In contrast the C style forces a tuple object even if the combination of arguments doesn’t represent a meaningful idea.</p></li>
</ul>
<p>For beginners the main question is which style makes it easier to match parentheses - mismatching is a common novice programming error. <span id="id19">[<a class="reference internal" href="../zzreferences.html#id145" title="Jeremy Singer and Blair Archibald. Functional Baby Talk: Analysis of Code Fragments from Novice Haskell Programmers. Electronic Proceedings in Theoretical Computer Science, 270:37–51, May 2018. URL: http://arxiv.org/abs/1805.05126v1 (visited on 2022-05-23), doi:10.4204/EPTCS.270.3.">SA18</a>]</span> Also error messages for accidental partial application are important. TODO: test or survey some novice programmers later on. Provisionally I expect Haskell to do better because it has fewer parentheses in the common case.</p>
</section>
<section id="implicit-arguments">
<h3>Implicit arguments<a class="headerlink" href="#implicit-arguments" title="Permalink to this heading"></a></h3>
<p>Claim: Explicit argument passing cannot replace implicit arguments</p>
<p>See example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- standard library</span>
<span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="n">priority</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">loglevel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">logPrint</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">}</span>

<span class="c1">-- components of an application</span>
<span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">priority</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">DEBUG</span><span class="w"> </span><span class="p">}</span>
<span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="s">&quot;bar&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">priority</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">WARNING</span><span class="w"> </span><span class="p">}</span>
<span class="w"> </span><span class="n">baz</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">foo</span>
<span class="w">  </span><span class="n">bar</span>

<span class="c1">-- main file</span>
<span class="w"> </span><span class="n">logPrint</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">writeFile</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="n">x</span>
<span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;a&quot;</span>
<span class="w"> </span><span class="n">loglevel</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">WARNING</span>

<span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="ow">=</span>
<span class="w">   </span><span class="n">baz</span>
<span class="w">   </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span><span class="n">loglevel</span><span class="ow">=</span><span class="kt">DEBUG</span><span class="p">}</span>
<span class="w">   </span><span class="n">bar</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">loglevel</span></code> is defined at the top level, but each use site is scattered in the code. The implicit argument replaces the global variable that is often used. Similarly <code class="docutils literal notranslate"><span class="pre">logPrint</span></code> is passed implicitly instead of being a member of a global Logger instance. The <code class="docutils literal notranslate"><span class="pre">file</span></code> variable does not exist in the standard library; it is part of the user’s code.</p>
<p>To use explicit argument passing, we’d have to add explicit <code class="docutils literal notranslate"><span class="pre">loglevel</span></code> and <code class="docutils literal notranslate"><span class="pre">logPrint</span></code> arguments to <code class="docutils literal notranslate"><span class="pre">log</span></code> and all its callers. To minimize callers we could partially apply it in <code class="docutils literal notranslate"><span class="pre">main</span></code> and pass around just the <code class="docutils literal notranslate"><span class="pre">log</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">Cmd</span></code> function. But still, we have to modify every caller of <code class="docutils literal notranslate"><span class="pre">log</span></code> and its callers and so on to pass around the <code class="docutils literal notranslate"><span class="pre">log</span></code> function.</p>
</section>
</section>
<section id="n-k-patterns">
<h2>n+k patterns<a class="headerlink" href="#n-k-patterns" title="Permalink to this heading"></a></h2>
<p>This is a feature removed from Haskell that simplifies writing recursive integer functions, like factorial. Basically <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">v</span> <span class="pre">of</span> <span class="pre">{</span> <span class="pre">x+k</span> <span class="pre">-&gt;</span> <span class="pre">e;</span> <span class="pre">_</span> <span class="pre">-&gt;</span> <span class="pre">e'</span> <span class="pre">}</span></code> translates to <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">v</span> <span class="pre">&gt;=</span> <span class="pre">k</span> <span class="pre">then</span> <span class="pre">(\x</span> <span class="pre">-&gt;</span> <span class="pre">e)</span> <span class="pre">(v-k)</span> <span class="pre">else</span> <span class="pre">e'</span></code>, where <code class="docutils literal notranslate"><span class="pre">k</span></code> is a literal.</p>
<p>Arguments:
* concise special notation, like for tuples and lists
* unfamiliar: the symbol + is being abused
* unnatural: not clear that residue must always be <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code>, i.e. pattern matches a natural number
* easy to change to a guard clause <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">v</span> <span class="pre">of</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">|</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">v-k</span> <span class="pre">in</span> <span class="pre">e;</span> <span class="pre">_</span> <span class="pre">-&gt;</span> <span class="pre">e'</span> <span class="pre">}</span></code> or a view pattern <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">v</span> <span class="pre">of</span> <span class="pre">{</span> <span class="pre">(dec</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">Just</span> <span class="pre">x)</span> <span class="pre">-&gt;</span> <span class="pre">e;</span> <span class="pre">_</span> <span class="pre">-&gt;</span> <span class="pre">e'</span> <span class="pre">}</span> <span class="pre">where</span> <span class="pre">dec</span> <span class="pre">k</span> <span class="pre">v</span> <span class="pre">=</span> <span class="pre">if</span> <span class="pre">v</span> <span class="pre">&gt;=</span> <span class="pre">k</span> <span class="pre">then</span> <span class="pre">Just</span> <span class="pre">(v-k)</span> <span class="pre">else</span> <span class="pre">Nothing</span></code></p>
<p>GHC-specific:
* Pattern still applies even if <code class="docutils literal notranslate"><span class="pre">(+)</span></code> is rebound away from <code class="docutils literal notranslate"><span class="pre">(Prelude.+)</span></code>.
* only works for <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>, as writing <code class="docutils literal notranslate"><span class="pre">n+(-1)</span></code> is forbidden.</p>
<p>Pattern synonyms should allow defining this like a view pattern, but without the ugly <code class="docutils literal notranslate"><span class="pre">Just</span></code>. Then the pattern like <code class="docutils literal notranslate"><span class="pre">x&#64;(dec</span> <span class="pre">k)</span> <span class="pre">-&gt;</span> <span class="pre">e</span></code> solves the main issues: dec is its own symbol, and the user has imported it so knows its semantics. And <code class="docutils literal notranslate"><span class="pre">k</span></code> should be evaluated so can be a negative number or constant expression.</p>
</section>
<section id="pattern-matching-conditionals">
<h2>Pattern matching / conditionals<a class="headerlink" href="#pattern-matching-conditionals" title="Permalink to this heading"></a></h2>
<p><a class="reference external" href="https://soc.me/languages/unified-condition-expressions">This</a> has a good overview of potential syntax patterns. The keyword can be if, match, when, switch, case, etc. Here we use <code class="docutils literal notranslate"><span class="pre">:</span></code> for if, <code class="docutils literal notranslate"><span class="pre">~</span></code> for then, <code class="docutils literal notranslate"><span class="pre">,</span></code> for else, <code class="docutils literal notranslate"><span class="pre">=</span></code> for is (Pattern matching), <code class="docutils literal notranslate"><span class="pre">\</span></code> for <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code> for <code class="docutils literal notranslate"><span class="pre">===</span></code>, modeled on Randomo in <span id="id20">[<a class="reference internal" href="../zzreferences.html#id149" title="Andreas Stefik, Susanna Siebert, Melissa Stefik, and Kim Slattery. An empirical comparison of the accuracy rates of novices using the quorum, perl, and randomo programming languages. In Proceedings of the 3rd ACM SIGPLAN Workshop on Evaluation and Usability of Programming Languages and Tools - PLATEAU '11, 3. Portland, Oregon, USA, 2011. ACM Press. URL: http://dl.acm.org/citation.cfm?doid=2089155.2089159 (visited on 2022-06-18), doi:10.1145/2089155.2089159.">SSSS11</a>]</span>. Figure out actual keywords based on novice surveys and what developers are familiar with.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="w"> </span><span class="n">simple</span><span class="w"> </span><span class="kr">if</span>
<span class="kt">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;z&quot;</span>

<span class="o">//</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="n">matching</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="s">&quot;if-let&quot;</span>

<span class="kt">:</span><span class="w"> </span><span class="n">person</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Person</span><span class="w"> </span><span class="s">&quot;Alice&quot;</span><span class="w"> </span><span class="n">age</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;${age}&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;o&quot;</span>

<span class="o">//</span><span class="w"> </span><span class="n">comparison</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">multiple</span><span class="w"> </span><span class="n">values</span>
<span class="kt">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nf">\</span>
<span class="w">  </span><span class="mf">1.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;a&quot;</span>
<span class="w">  </span><span class="mf">2.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;b&quot;</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;z&quot;</span>

<span class="kt">:</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="nf">\</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;a&quot;</span>
<span class="w">  </span><span class="nf">\</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;b&quot;</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;z&quot;</span>

<span class="kt">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;a&quot;</span>
<span class="p">,</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;b&quot;</span>
<span class="p">,</span><span class="w"> </span><span class="s">&quot;z&quot;</span>

<span class="o">//</span><span class="w"> </span><span class="n">multi</span><span class="o">-</span><span class="n">way</span><span class="w"> </span><span class="kr">if</span>
<span class="kt">:</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;a&quot;</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;b&quot;</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;z&quot;</span>

<span class="o">//</span><span class="w"> </span><span class="n">different</span><span class="w"> </span><span class="n">comparison</span><span class="w"> </span><span class="n">operators</span><span class="w"> </span><span class="p">(</span><span class="n">predicates</span><span class="p">)</span>
<span class="kt">:</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="nf">\</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;a&quot;</span>
<span class="w">    </span><span class="o">^</span><span class="w"> </span><span class="kt">NaN</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;n&quot;</span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;z&quot;</span>

<span class="kt">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;a&quot;</span>
<span class="p">,</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="kt">NaN</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;n&quot;</span>
<span class="p">,</span><span class="w"> </span><span class="s">&quot;z&quot;</span>

<span class="o">//</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">predicates</span>

<span class="kt">:</span><span class="w"> </span><span class="n">xs</span>
<span class="w">  </span><span class="n">isEmpty</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;e&quot;</span>
<span class="w">  </span><span class="n">contains</span><span class="w"> </span><span class="p">{</span><span class="n">element</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">}</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;n&quot;</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;z&quot;</span>

<span class="kt">:</span><span class="w"> </span><span class="n">isEmpty</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;e&quot;</span>
<span class="p">,</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">contains</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;n&quot;</span>
<span class="p">,</span><span class="w"> </span><span class="s">&quot;z&quot;</span>

<span class="o">//</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="n">matching</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">bindings</span>

<span class="kt">:</span><span class="w"> </span><span class="n">alice</span>
<span class="w">  </span><span class="n">age</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;18&quot;</span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">person</span><span class="o">@</span><span class="p">(</span><span class="kt">Person</span><span class="w"> </span><span class="s">&quot;Alice&quot;</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;${age person}&quot;</span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Person</span><span class="w"> </span><span class="s">&quot;Bob&quot;</span><span class="w"> </span><span class="n">age</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;${age}&quot;</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;0&quot;</span>

<span class="o">//</span><span class="w"> </span><span class="n">wildcards</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="n">guards</span><span class="ow">::</span>

<span class="kt">:</span><span class="w"> </span><span class="n">person</span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Person</span><span class="w"> </span><span class="s">&quot;Alice&quot;</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;alice&quot;</span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Person</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">age</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;adult&quot;</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;minor&quot;</span>

<span class="kt">:</span><span class="w"> </span><span class="n">person</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="p">(</span><span class="kt">Person</span><span class="w"> </span><span class="s">&quot;Alice&quot;</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;alice&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="kt">Person</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">age</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;adult&quot;</span>
<span class="w">                 </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;minor&quot;</span>
</pre></div>
</div>
<p>The condition can be split between a common discriminator and individual cases. This requires doing away with mandatory parentheses around the conditions. This strongly suggests using a keyword (then) to introduce branches, instead of using curly braces, based on readability considerations.</p>
</section>
<section id="id21">
<h2>Assignment<a class="headerlink" href="#id21" title="Permalink to this heading"></a></h2>
<p><a class="reference external" href="https://craftofcoding.wordpress.com/2021/02/19/evolution-of-the-assignment-operator/">Discussion</a>. Stroscot’s assignment syntax is complicated because I want separate initialization (declarative assignment) and reassignment (mutating assignment).</p>
<table class="docutils align-default" id="id37">
<caption><span class="caption-text">Comparison</span><a class="headerlink" href="#id37" title="Permalink to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Language</p></th>
<th class="head"><p>Initialization</p></th>
<th class="head"><p>Reassignment</p></th>
<th class="head"><p>Equality</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Mathematics</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">⟹</span></code> or <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Algol</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">:=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">:=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Fortran</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.EQ.</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>PL/I</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
</tr>
<tr class="row-even"><td><p>BCPL</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">:=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>B</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">:=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
</tr>
<tr class="row-even"><td><p>C</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>APL</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">←</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">←</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
</tr>
<tr class="row-even"><td><p>R</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;-</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;-</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>J</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=:</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=:</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
</tr>
</tbody>
</table>
<p>Looking at precedents, the only languages with distinct initialization and reassignment are B and BCPL, so reassignment should definitely be <code class="docutils literal notranslate"><span class="pre">:=</span></code>. Then we can either follow mathematical convention and PL/I in making initialization and comparison use the same symbol, or simplify parsing by making equality <code class="docutils literal notranslate"><span class="pre">==</span></code>. Quorum uses the same symbol and apparently this is what novices expect. <span id="id22">[]</span></p>
<section id="chained-assignment">
<h3>Chained assignment<a class="headerlink" href="#chained-assignment" title="Permalink to this heading"></a></h3>
<p>Chained assignment is an expression like <code class="docutils literal notranslate"><span class="pre">w</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">z</span></code>. The value of <code class="docutils literal notranslate"><span class="pre">z</span></code> is assigned to multiple variables <code class="docutils literal notranslate"><span class="pre">w</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, and <code class="docutils literal notranslate"><span class="pre">y</span></code>. The <a class="reference external" href="http://www.cse.iitm.ac.in/~amannoug/imop/tr-3.pdf">literature</a> classifies this as “syntactic sugar”, so handling it in the parser like Python seems the reasonable solution - C’s “the assignment returns the lvalue” semantics seems contrived.</p>
<p>The evaluation strategy differs between languages. For simple chained assignments, like initializing multiple variables, the evaluation strategy does not matter, but if the targets (l-values) in the assignment are connected in some way, the evaluation strategy affects the result. Here C’s RTL semantics makes more sense and seems more useful than <cite>Python’s LTR &lt;https://docs.python.org/3/reference/simple_stmts.html#assignment-statements&gt;</cite> semantics. So a chain <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:=</span> <span class="pre">b</span> <span class="pre">:=</span> <span class="pre">2</span></code> should expand to <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">:=</span> <span class="pre">2;</span> <span class="pre">a</span> <span class="pre">:=</span> <span class="pre">b</span></code> rather than <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">2;</span> <span class="pre">a</span> <span class="pre">:=</span> <span class="pre">t;</span> <span class="pre">b</span> <span class="pre">:=</span> <span class="pre">t</span></code> .</p>
<p>Chained update with <code class="docutils literal notranslate"><span class="pre">:=</span></code>, like <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:=</span> <span class="pre">b</span> <span class="pre">:=</span> <span class="pre">2</span></code>, seems the most useful to shorten some assignments. Chained <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">2</span></code> with value semantics doesn’t really seem that useful when you could just replace <code class="docutils literal notranslate"><span class="pre">a</span></code> with <code class="docutils literal notranslate"><span class="pre">b</span></code> in the rest of the expression and save yourself an identifier. Also it conflicts with using <code class="docutils literal notranslate"><span class="pre">=</span></code> for comparison, because it can be interpreted as <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">(b</span> <span class="pre">==</span> <span class="pre">2)</span></code>.</p>
<p>There is an issue with running I/O multiple times. For example if you need multiple variables with the same value then you would write <code class="docutils literal notranslate"><span class="pre">[a,b,c]</span> <span class="pre">=</span> <span class="pre">replicateM</span> <span class="pre">3</span> <span class="pre">(ref</span> <span class="pre">0)</span></code> rather than using a chain, because a chain would alias to the same variable. Python already has this problem with aliasing for <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">[]</span></code>, because <code class="docutils literal notranslate"><span class="pre">[]</span></code> is mutable, but in Stroscot <code class="docutils literal notranslate"><span class="pre">[]</span></code> is pure so this is fine.</p>
</section>
<section id="embedded-assignment">
<h3>Embedded assignment<a class="headerlink" href="#embedded-assignment" title="Permalink to this heading"></a></h3>
<p>This embeds assignments in expressions, like</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Clearly it conflicts with <code class="docutils literal notranslate"><span class="pre">=</span></code> as comparison.</p>
<p>But for chained update it is unambiguous and returning the value would be possible:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>But then statements like</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">b</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
<p>would have an unused return value. Maybe this value could be marked as optional somehow.</p>
</section>
</section>
<section id="conditionals">
<h2>Conditionals<a class="headerlink" href="#conditionals" title="Permalink to this heading"></a></h2>
<p>There is a “unified” syntax by <a class="reference external" href="https://github.com/soc/soc.me/tree/main/_languages">Simon</a>, also a very similar paper on the “ultimate” syntax <span id="id23">[]</span>. Interesting idea, but still has to be tested real-world somehow.</p>
<p>Per the internet, Ruby’s <code class="docutils literal notranslate"><span class="pre">unless-else</span></code> is unintuitive. Only support <code class="docutils literal notranslate"><span class="pre">if-else</span></code> and <code class="docutils literal notranslate"><span class="pre">unless</span></code> without the else. Also <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">not</span></code> is a possible replacement for <code class="docutils literal notranslate"><span class="pre">unless</span></code>.</p>
</section>
<section id="integers">
<h2>Integers<a class="headerlink" href="#integers" title="Permalink to this heading"></a></h2>
<p>Flix says binary and octal literals are rarely used in practice, and uses this as a reason to drop support for them. Despite this most languages include support. Clearly there is a conflict here, so let’s dive deeper.</p>
<p>Per <a class="reference external" href="https://en.wikipedia.org/wiki/Octal">Wikipedia</a>, octal is indeed rare these days because bytes do not divide evenly into octets whereas they do divide into 2 hex digits. But it can still be useful in certain cases like the ModRM byte which is divided into 2/3/3 just like how a byte divides unevenly into octets, or chmod’s Unix file permission specifications which use 3-bit modes. Of course such usages are more likely to confuse than elucidate and using symbolic notation like <code class="docutils literal notranslate"><span class="pre">modrm</span> <span class="pre">direct</span> <span class="pre">eax</span></code> or <code class="docutils literal notranslate"><span class="pre">u=rwx,g=rw,o=r</span></code> is clearer. Nonetheless octal still crops up in legacy code as an omnipresent C feature, so should be included for compatibility. The main thing to avoid is the prefix 0 for octal, as leading zeros are useful for other purposes as well. <code class="docutils literal notranslate"><span class="pre">0o</span></code> has been introduced and widely adopted, with no obvious complaints.</p>
<p>For binary literals, Java 7 added binary literals in 2011, C++ in 2014, and C# 7 in 2017, suggesting significant demand. The <a class="reference external" href="https://mail.openjdk.org/pipermail/coin-dev/2009-March/000929.html">Java proposal</a> lists bitmasks, bit arrays, and matching protocol specifications as killer usages. Hexadecimal is just artifical for these usages and obscures the intent of the code. Key to the usage of binary literals is a digit separator, so you can break up a long sequence like <code class="docutils literal notranslate"><span class="pre">0b1010_1011_1100_1101_1110_1111</span></code>. In theory <code class="docutils literal notranslate"><span class="pre">0b1</span></code> could be confused with <code class="docutils literal notranslate"><span class="pre">0xB1</span></code>, but teaching programmers about the standardized <code class="docutils literal notranslate"><span class="pre">0-letter</span></code> pattern should mostly solve this.</p>
<p>The alternative to not including literal support is to use a function parsing a string, so one would write for example <code class="docutils literal notranslate"><span class="pre">binary</span> <span class="pre">&quot;001100&quot;</span></code>. Since Stroscot does compile-time evaluation this would work with no runtime overhead and give compile-time exceptions. But it is a little more verbose than the <code class="docutils literal notranslate"><span class="pre">0-letter</span></code> literals. It is true that humans have 10 fingers but this isn’t much reason to restrict literals to decimal, and once you have hex, binary and octal are just more cases to add.</p>
</section>
<section id="tuples-and-records">
<h2>Tuples and records<a class="headerlink" href="#tuples-and-records" title="Permalink to this heading"></a></h2>
<p>In <a class="reference external" href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/MaybeNot.md">Maybe Not</a> Rich Hickey  says records/fields, and product types are “place oriented programming”, hence bad. Well, in <a class="reference external" href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/ValueOfValuesLong.md">The Value of Values</a> he says place-oriented programming is when you use in-place update. But maps (his proposed alternative) also support in-place update and are place-oriented. The only difference between maps and records seems to be that records have ordered fields.</p>
<p>So he seems have a different definition in mind, in particular that place-oriented means accessors are not first class - even when the fields are named, you cannot say <code class="docutils literal notranslate"><span class="pre">object[&quot;name&quot;]</span></code> for an arbitrary object or an arbitrary name. But this is easily solved by adding such functionality. It also doesn’t get into the mutable/immutable distinction that the values talk made.</p>
<p>His second point is that product types “complects” the meaning of things with their position in a list. “Complect” is from <a class="reference external" href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/SimpleMadeEasy-mostly-text.md">Simple Made Easy</a> and is a pejorative version of “braid together”.
Essentially he’s saying that if you have <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">String)</span></code> there is no way to know how the second string is different from the first string. Well, for commutative operations like addition the order literally doesn’t matter. Adding any sort of information to <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">:</span> <span class="pre">(Int,</span> <span class="pre">Int)</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code> is complicating the picture. Similarly for Strings <a class="reference external" href="https://gemma.msl.ubc.ca/resources/baseCode/apidocs/ubic/basecode/util/StringUtil.html#append-java.lang.String-java.lang.String-java.lang.String-">coming up</a> with names “appendee” and “appendant” for an  append operation is almost as bad as digging up “complect”. Using numerical names <code class="docutils literal notranslate"><span class="pre">s1</span></code> and <code class="docutils literal notranslate"><span class="pre">s2</span></code> makes more sense. It still gives a record with named fields, but it makes sense to use positional arguments.</p>
<p>And if the types are different there’s no ambiguity: <code class="docutils literal notranslate"><span class="pre">(FirstName,</span> <span class="pre">LastName</span></code>, <code class="docutils literal notranslate"><span class="pre">(Int,Bool)</span></code>, etc.</p>
</section>
<section id="precedence">
<h2>Precedence<a class="headerlink" href="#precedence" title="Permalink to this heading"></a></h2>
<p>Julia has juxtaposed multiplication. <a class="reference external" href="https://jump.dev/JuMP.jl/dev/developers/style/#Juxtaposed-multiplication">Jump</a> recommends limiting to cases where RHS is a symbol, like <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">pi</span></code>.</p>
<p><a class="reference external" href="https://ericlippert.com/2020/02/27/hundred-year-mistakes/">This post</a> describes a mistake in C-style precedence: it should be <code class="docutils literal notranslate"><span class="pre">&amp;&amp;,</span> <span class="pre">==,</span> <span class="pre">&amp;</span></code> but is instead <code class="docutils literal notranslate"><span class="pre">&amp;&amp;,</span> <span class="pre">&amp;</span> <span class="pre">==</span></code>, causing a footgun. “Swift, Go, Ruby and Python get it right.”</p>
<section id="cycle">
<h3>Cycle<a class="headerlink" href="#cycle" title="Permalink to this heading"></a></h3>
<p>Can we have a precedence cycle, like associating <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">(b</span> <span class="pre">*</span> <span class="pre">c)</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">(b</span> <span class="pre">^</span> <span class="pre">c)</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">^</span> <span class="pre">(b</span> <span class="pre">+</span> <span class="pre">c)</span></code>?</p>
<p>Well what about this expression:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">d</span><span class="p">))</span>
<span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">))</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">d</span>
</pre></div>
</div>
<p>These are both consistent with the cyclic precedence so we would need more rules to decide between them.</p>
</section>
</section>
<section id="logic-programming">
<h2>Logic programming<a class="headerlink" href="#logic-programming" title="Permalink to this heading"></a></h2>
<p>Prolog uses Horn clauses of the form <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">:-</span> <span class="pre">A1,</span> <span class="pre">A2,</span> <span class="pre">A3</span></code>. This is read “The clause head <code class="docutils literal notranslate"><span class="pre">H</span></code> is implied by the body’s goals <code class="docutils literal notranslate"><span class="pre">A1</span></code>, <code class="docutils literal notranslate"><span class="pre">A2</span></code> and <code class="docutils literal notranslate"><span class="pre">A3</span></code>.” A fact is a clause with no goals, <code class="docutils literal notranslate"><span class="pre">F.</span></code> or <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">:-</span> <span class="pre">``,</span> <span class="pre">equivalent</span> <span class="pre">to</span> <span class="pre">``F</span> <span class="pre">:-</span> <span class="pre">true</span></code> (since <code class="docutils literal notranslate"><span class="pre">true</span> <span class="pre">&amp;&amp;</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span></code>). The head and goals are predicates of various syntax. There are various goals; they can be predicate terms with variables and list patterns (Herbrand domain, original Prolog), linear logic formulas (<a class="reference external" href="https://www.youtube.com/watch?v=rICThUCtJ0k">linear logic programming</a>), or constraints (constraint logic programming).</p>
<p>For example, reversing a list:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nrev</span><span class="p">(</span><span class="kt">[]</span><span class="p">,</span><span class="kt">[]</span><span class="p">)</span><span class="o">.</span>
<span class="nf">nrev</span><span class="p">([</span><span class="kt">H</span><span class="o">|</span><span class="kt">T</span><span class="p">],</span><span class="kt">L2</span><span class="p">)</span><span class="w"> </span><span class="kt">:-</span><span class="w"> </span><span class="n">nrev</span><span class="p">(</span><span class="kt">T</span><span class="p">,</span><span class="kt">R</span><span class="p">),</span><span class="w"> </span><span class="n">append</span><span class="p">(</span><span class="kt">R</span><span class="p">,[</span><span class="kt">H</span><span class="p">],</span><span class="kt">L2</span><span class="p">)</span><span class="o">.</span>

<span class="kt">:-</span><span class="w"> </span><span class="n">nrev</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="kt">X</span><span class="p">),</span><span class="w"> </span><span class="n">write</span><span class="p">(</span><span class="kt">X</span><span class="p">),</span><span class="w"> </span><span class="n">nl</span>
<span class="o">%</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>In practice Prolog syntax is pretty bad; programs are heavy on meaningless intermediate variables such as <code class="docutils literal notranslate"><span class="pre">R</span></code> in the above.</p>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h3>
<p>There is a <a class="reference external" href="https://www.swi-prolog.org/pack/list?p=func">func</a> package that allows writing <code class="docutils literal notranslate"><span class="pre">nrev</span> <span class="pre">$</span> <span class="pre">T</span></code> in an expression instead of <code class="docutils literal notranslate"><span class="pre">nrev(T,R)</span></code> and then using <code class="docutils literal notranslate"><span class="pre">R</span></code> in the expression. A “function” is defined as follows:</p>
<ul class="simple">
<li><p>Any predicate <code class="docutils literal notranslate"><span class="pre">p(...in,</span> <span class="pre">out)</span></code> is a function from <code class="docutils literal notranslate"><span class="pre">in</span></code> to <code class="docutils literal notranslate"><span class="pre">out</span></code></p></li>
<li><p>A dictionary is a function from keys to values</p></li>
<li><p>An arithmetic expression <code class="docutils literal notranslate"><span class="pre">2*_+3</span></code> is a function on numbers</p></li>
<li><p>A format string is a function from argument list to interpolated output</p></li>
<li><p>A term with a <code class="docutils literal notranslate"><span class="pre">~</span></code> is a function which takes no input values and produces an output at the ~ position. For example</p></li>
</ul>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">atom</span><span class="p">(</span><span class="n">atom_string</span><span class="p">(</span><span class="o">~</span><span class="p">,</span><span class="s">&quot;hello world&quot;</span><span class="p">))</span><span class="o">.</span>

<span class="o">%</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">equivalent</span><span class="w"> </span><span class="n">to</span>

<span class="nf">atom_string</span><span class="p">(</span><span class="kt">X</span><span class="p">,</span><span class="s">&quot;hello world&quot;</span><span class="p">),</span><span class="n">atom</span><span class="p">(</span><span class="kt">X</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>More generally we should be able to build compound expressions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">z</span> <span class="pre">=</span> <span class="pre">append</span> <span class="pre">a</span> <span class="pre">(append</span> <span class="pre">b</span> <span class="pre">c)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">append(a,b,temp),append(temp,c,z)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">g</span> <span class="pre">x</span></code> instead of <code class="docutils literal notranslate"><span class="pre">f(x,y),</span> <span class="pre">g(x,z),</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">z</span></code></p></li>
<li><p>in general, <code class="docutils literal notranslate"><span class="pre">pred</span> <span class="pre">(f</span> <span class="pre">x)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">y,</span> <span class="pre">pred(y)</span></code></p></li>
</ul>
<p>There is no issue with devising a consistent use of output variables for an expression syntax; Oz does this. In practice the “boring” deterministic code will take up 66%-95% of the program so special-casing familiar function syntax is important. Horn clauses are less readable than compound expressions, and programmers have gotten used to skimming over assignment clauses and parsing parentheses and infix expressions.</p>
</section>
<section id="relations">
<h3>Relations<a class="headerlink" href="#relations" title="Permalink to this heading"></a></h3>
<p>For relations like <code class="docutils literal notranslate"><span class="pre">precedes(x,y)</span></code>, Horn clauses are not necessarily the optimal syntax. We could say it is a nondeterministic function <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">precedes(x)</span></code>. But the predicate syntax is traditional for boolean formulas in logic and unlike functions there is not a well-developed alternative syntax to use for formulas. Powerful high-level logic syntax is still an unexplored area.</p>
<p>miniKanren <span id="id24">[<a class="reference internal" href="../zzreferences.html#id25" title="William E. Byrd. Relational Programming in Minikanren: Techniques, Applications, and Implementations. PhD thesis, Indiana University, August 2009. URL: https://scholarworks.iu.edu/dspace/handle/2022/8777 (visited on 2022-07-14).">Byr09</a>]</span> doesn’t have a global clause database so clauses of the same predicate must be grouped, this gives a local “match” syntax for relations:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nrev</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="n">l2</span><span class="w"> </span><span class="kt">:-</span>
<span class="w">  </span><span class="n">matche</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="n">l2</span>
<span class="w">    </span><span class="kt">[]</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">true</span>
<span class="w">    </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="n">l2</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">fresh</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">r</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">conj</span>
<span class="w">      </span><span class="p">[</span><span class="w"> </span><span class="n">nrev</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">r</span>
<span class="w">      </span><span class="p">,</span><span class="w"> </span><span class="n">append</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="w"> </span><span class="n">l2</span>
<span class="w">      </span><span class="p">])</span>

<span class="nf">print</span><span class="w"> </span><span class="p">(</span><span class="n">run</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">nrev</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="c1">-- [[2,1]]</span>
</pre></div>
</div>
<p>This seems helpful syntax-wise, but MiniKanren and Clojure core.logic are also quite tedious to use in practice.</p>
</section>
<section id="primitives">
<h3>Primitives<a class="headerlink" href="#primitives" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">matche</span></code> and other syntax desugars into a small set of primitives: <span id="id25">[<a class="reference internal" href="../zzreferences.html#id70" title="Jason Hemann and Daniel P. . Friedman. microKanren: A Minimal Functional Core for Relational Programming. In Proceedings of the 2013 Workshop on Scheme and Functional Programming. 2013. URL: http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf (visited on 2022-07-14).">HF13</a>]</span></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fresh</span></code> or <code class="docutils literal notranslate"><span class="pre">exists</span> <span class="pre">(\x.&lt;body&gt;)</span></code>: true if <code class="docutils literal notranslate"><span class="pre">body</span></code> is true for some value of <code class="docutils literal notranslate"><span class="pre">x</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unify</span> <span class="pre">x</span> <span class="pre">y</span></code> / <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>: true if <code class="docutils literal notranslate"><span class="pre">x</span></code> unifies with <code class="docutils literal notranslate"><span class="pre">y</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">disj</span> <span class="pre">[x,y,z]</span></code> / <code class="docutils literal notranslate"><span class="pre">conde</span> <span class="pre">[x,y,z]</span></code>: true if any of <code class="docutils literal notranslate"><span class="pre">x,y,z</span></code> are true (logical or / disjunction)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conj</span> <span class="pre">[x,y,z]</span></code>: true if all of <code class="docutils literal notranslate"><span class="pre">x,y,z</span></code> are true (logical and / conjunction)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">(\x</span> <span class="pre">y.</span> <span class="pre">&lt;body&gt;)</span></code> delimits the boundary of the logic program. It returns the stream of substitutions of the given variables for which the body is true. Optionally the maximum length of the stream may be specified.</p></li>
</ul>
<p>The expansion of <code class="docutils literal notranslate"><span class="pre">nrev</span></code> is given in <span id="id26">[<a class="reference internal" href="../zzreferences.html#id69" title="Jason Hemann and Daniel P. Friedman. A framework for extending microkanren with constraints. Electronic Proceedings in Theoretical Computer Science, 234:135–149, January 2017. Comment: In Proceedings WLP'15/'16/WFLP'16, arXiv:1701.00148. URL: http://arxiv.org/abs/1701.00633 (visited on 2022-07-15), arXiv:1701.00633, doi:10.4204/EPTCS.234.10.">HF17</a>]</span> page 137 (<code class="docutils literal notranslate"><span class="pre">define-relation</span></code> is just DSL fluff around <code class="docutils literal notranslate"><span class="pre">define</span></code> per the appendix):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nrev</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="n">l2</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">disj</span>
<span class="w">    </span><span class="p">[</span><span class="w"> </span><span class="n">conj</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="n">l2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="p">]</span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">fresh</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">h</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">fresh</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">t</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">        </span><span class="n">conj</span>
<span class="w">          </span><span class="p">[</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">l1</span>
<span class="w">          </span><span class="p">,</span><span class="n">fresh</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">r</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">conj</span><span class="w"> </span><span class="p">[</span><span class="n">nrev</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">append</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="w"> </span><span class="n">l2</span><span class="p">])]</span>
<span class="w">          </span><span class="p">]</span>
<span class="w">    </span><span class="p">))]</span>

<span class="nf">print</span><span class="w"> </span><span class="p">(</span><span class="n">run</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">nrev</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="c1">-- [[2,1]]</span>
</pre></div>
</div>
</section>
</section>
<section id="functional-programming">
<h2>Functional programming<a class="headerlink" href="#functional-programming" title="Permalink to this heading"></a></h2>
<p>In a true empirical comparison study <span id="id27">[<a class="reference internal" href="../zzreferences.html#id120" title="Victor Pankratius, Felix Schmidt, and Gilda Garreton. Combining functional and imperative programming for multicore software: An empirical study evaluating Scala and Java. In 2012 34th International Conference on Software Engineering (ICSE), 123–133. Zurich, June 2012. IEEE. URL: https://web.archive.org/web/20120704064618id_/http://www.rz.uni-karlsruhe.de/~kb95/papers/pankratius-Scala-ICSE12-preprint.pdf (visited on 2022-11-10), doi:10.1109/ICSE.2012.6227200.">PSG12</a>]</span>, Scala programs ended up taking a lot longer to write than Java - 72 hours vs 43 hours, with no working Scala programs submitted until the third week, versus a working Java program submitted the first week. The reasons given in the paper were Scala’s complex type system, poor documentation, poor IDE/debugging support, complex memory model, and complex parallel programming abstractions. That gives an idea of what the important factors are in cycle time: making programming language features more intuitive so that they can be used correctly with little study, and implementing “creature comforts” to help to write and test code. For example, according to ChatGPT, Scala’s FP features are complex and make programs less readable to newcomers, but once you have learned Scala’s FP syntax and nomenclature, the FP style makes programs more readable because they are more concise. This suggests that redesigning the FP paradigm to use intuitive naming and syntax will improve readability. But it may be that no concise and understandable FP design exists and there will always be a learning curve for FP features.</p>
</section>
<section id="go-syntax-notes">
<h2>Go syntax notes<a class="headerlink" href="#go-syntax-notes" title="Permalink to this heading"></a></h2>
<p>small set of keywords, without filler keywords (such as ‘of’, ‘to’, etc.) or other gratuitous syntax
prefer keywords (e.g.  ‘function’) over operators or blocks
variables, simple control flow are expressed using a light-weight notation (short keywords, little syntax)</p>
</section>
<section id="id28">
<h2>DSLs<a class="headerlink" href="#id28" title="Permalink to this heading"></a></h2>
<p>Scala and JS have support for native XML literals. Scala had one syntax in 2 and a new syntax in 3. Similarly JS had E4X, but client-side E4X is dead today, replaced by server-side React JSX which is honestly pretty similar. More recently XML has been perceived as verbose and JSON has become popular. JSON is native to Javascript hence literals/interpolation are aleady supported, and then browsers added parsers/pretty printers. The lesson is not (like Flix says) that no support should be present - rather it is that the design should be flexible and allow easily adding markup syntaxes.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="kt">Scala</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="kt">XML</span><span class="w"> </span><span class="n">literals</span><span class="w"> </span><span class="p">(</span><span class="n">dropped</span><span class="p">)</span>
<span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="n">mails1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">heading</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">todoList</span><span class="w"> </span><span class="n">yield</span>
<span class="w">   </span><span class="o">&lt;</span><span class="n">message</span><span class="o">&gt;</span>
<span class="w">     </span><span class="o">&lt;</span><span class="n">from</span><span class="o">&gt;</span><span class="p">{</span><span class="n">from</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">from</span><span class="o">&gt;&lt;</span><span class="n">to</span><span class="o">&gt;</span><span class="p">{</span><span class="n">to</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">to</span><span class="o">&gt;</span>
<span class="w">     </span><span class="o">&lt;</span><span class="n">heading</span><span class="o">&gt;</span><span class="p">{</span><span class="n">heading</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">heading</span><span class="o">&gt;&lt;</span><span class="n">body</span><span class="o">&gt;</span><span class="p">{</span><span class="n">body</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">body</span><span class="o">&gt;</span>
<span class="w">   </span><span class="o">&lt;/</span><span class="n">message</span><span class="o">&gt;</span>

<span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="kt">Scala</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="kt">XML</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">interpolation</span>
<span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="n">mails2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">heading</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">todoList</span><span class="w"> </span><span class="n">yield</span><span class="w"> </span><span class="n">xml</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">   &lt;message&gt;</span>
<span class="s">     &lt;from&gt;${from}&lt;/from&gt;&lt;to&gt;${to}&lt;/to&gt;</span>
<span class="s">     &lt;heading&gt;${heading}&lt;/heading&gt;&lt;body&gt;${body}&lt;/body&gt;</span>
<span class="s">   &lt;/message&gt;&quot;&quot;&quot;</span>
<span class="w"> </span><span class="n">println</span><span class="p">(</span><span class="n">mails2</span><span class="p">)</span>

<span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="kt">E4X</span>
<span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="n">sales</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sales</span><span class="w"> </span><span class="n">vendor</span><span class="ow">=</span><span class="s">&quot;John&quot;</span><span class="o">&gt;</span>
<span class="w">   </span><span class="o">&lt;</span><span class="n">item</span><span class="w"> </span><span class="kr">type</span><span class="ow">=</span><span class="s">&quot;peas&quot;</span><span class="w"> </span><span class="n">price</span><span class="ow">=</span><span class="s">&quot;4&quot;</span><span class="w"> </span><span class="n">quantity</span><span class="ow">=</span><span class="s">&quot;6&quot;</span><span class="o">/&gt;</span>
<span class="w">   </span><span class="o">&lt;</span><span class="n">item</span><span class="w"> </span><span class="kr">type</span><span class="ow">=</span><span class="s">&quot;carrot&quot;</span><span class="w"> </span><span class="n">price</span><span class="ow">=</span><span class="s">&quot;3&quot;</span><span class="w"> </span><span class="n">quantity</span><span class="ow">=</span><span class="s">&quot;10&quot;</span><span class="o">/&gt;</span>
<span class="w">   </span><span class="o">&lt;</span><span class="n">item</span><span class="w"> </span><span class="kr">type</span><span class="ow">=</span><span class="s">&quot;chips&quot;</span><span class="w"> </span><span class="n">price</span><span class="ow">=</span><span class="s">&quot;5&quot;</span><span class="w"> </span><span class="n">quantity</span><span class="ow">=</span><span class="s">&quot;3&quot;</span><span class="o">/&gt;</span>
<span class="w"> </span><span class="o">&lt;/</span><span class="n">sales</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w"> </span><span class="n">sales</span><span class="o">.</span><span class="n">item</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">item</span><span class="w"> </span><span class="kr">type</span><span class="ow">=</span><span class="s">&quot;oranges&quot;</span><span class="w"> </span><span class="n">price</span><span class="ow">=</span><span class="s">&quot;4&quot;</span><span class="o">/&gt;</span><span class="p">;</span>

<span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;bar&quot;</span><span class="p">;</span>
<span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="kr">data</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">foo</span><span class="w"> </span><span class="n">id</span><span class="ow">=</span><span class="p">{</span><span class="n">a</span><span class="o">+</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="p">)}</span><span class="o">&gt;</span><span class="p">{</span><span class="n">a</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="s">&quot;bat&quot;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="kr">data</span><span class="p">);</span>
<span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">foo</span><span class="w"> </span><span class="n">id</span><span class="ow">=</span><span class="s">&quot;bar7&quot;</span><span class="o">&gt;</span><span class="n">bar</span><span class="w"> </span><span class="n">bat</span><span class="o">&lt;/</span><span class="n">foo</span><span class="o">&gt;</span>

<span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="kt">JSX</span>
<span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">div</span><span class="o">&gt;</span>
<span class="w">      </span><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="p">{</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">&#39;true&#39;</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">&#39;false&#39;</span><span class="w"> </span><span class="p">}</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">&lt;/</span><span class="n">div</span><span class="o">&gt;</span>
<span class="w"> </span><span class="p">);</span>

<span class="kt">All</span><span class="w"> </span><span class="n">these</span><span class="w"> </span><span class="n">support</span><span class="w"> </span><span class="n">interpolation</span><span class="p">,</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">that&#39;s</span><span class="w"> </span><span class="n">clearly</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">necessary</span><span class="w"> </span><span class="n">feature</span><span class="o">.</span>
</pre></div>
</div>
</section>
<section id="identifier-conventions">
<h2>Identifier conventions<a class="headerlink" href="#identifier-conventions" title="Permalink to this heading"></a></h2>
<p>Per Binkley, a study of real-world code found identifiers were 43.8% 1 part, 29.5% 2 parts, 16.4% 3 parts, 6.2% 4 parts, and then we can calculate that 5+ parts were 4.1%. Longer identifiers require more time to read, due to requiring more fixations - Binkley found that going from 2 to 3 identifier parts increased the cloud word recognition task time by 0.981 seconds. For identifiers of one part there is only uppercase vs lowercase (ignoring stUDly CaPs), but for more parts we can choose how to join them: snake case (underscore style), camel case, kebab case (hyphen style), or Unicode characters like a shaded box ░ or half box ▆.</p>
<ul class="simple">
<li><p>The shaded box performed well in Epelboim’s study, being only 4% harder to read than normal text in conditions such as “░this░ ░is░” and “░░an░░example░░”. Unfortunately the pattern of interest “some░filler” was untested, but just reading it with my eyes it doesn’t seem too hard to read. Visually, a shaded box should allow easily distinguishing the extent of an identifier. Of course typing the shaded box character is somewhat difficult as it’s not on standard keyboards.</p></li>
<li><p>The underscore style provides clear separation between parts when looking at the top, but may require a little work to see the underscore and identify the extent of an identifier. Sharif’s figure 4 of underscore fixations suggests that underscore-trained programmers do not need any extra fixations to see the underscores, but that the last identifier part may have a longer fixation. There is also a “bumpy case” variation that uses double underscores, I don’t think this improves readability.</p></li>
<li><p>Kebab case moves the line upwards, closer to the centers of the fixations, and may thus make it easier to determine identifier extents. The half box could provide a similar benefit. Searching Google Scholar for kebab case produced no academic studies on readability.</p></li>
<li><p>Camel case requires identifying parts by letter height variation, which is visually difficult and requires longer or multiple fixations. Camel case does however provide good extent identification. In long lines of identifiers it is probably as bad as text with no spaces, which takes 44% mean percent longer to read. Binkley and Sharif found 13.5% and 20% longer times with camel case over underscores for the cloud task. 2-part identifiers take approximately the same time as underscores - it is 3-part identifiers that lose big.</p></li>
<li><p>Whitespace - there are ways to allow true multi-word identifiers using the space character, but these suffer greatly from extent identification because there is visual indication at all.</p></li>
</ul>
<p>When reading there is an accuracy vs speed tradeoff. If something is really easy to read, one tends to just skim it and gloss over small mispellings. Because camel case is harder to read, in Binkley’s studies the participants took longer to answer the questions and had slightly improved accuracy overall compared to snake case. There was however one contrary question: <code class="docutils literal notranslate"><span class="pre">attackerHealth/attackedHealth</span></code> was easily confused in camel case but in snake case <code class="docutils literal notranslate"><span class="pre">attacker_health/attacked_health</span></code> it was more distinguishable due to the stem of the d.</p>
<blockquote>
<div><p>so far have not had enough statistical power to state any effects. Binkley found, if there are effects, in his studies they were most likely that training on an identifier style increased the speed of reading that style but made it harder to read other styles. Training on a style may also make it harder to read normal prose that had been randomly chunked into identifiers of that style.</p>
</div></blockquote>
<p><span id="id29">[]</span> found it is 2% faster (15ms) to read a word if the preceding word is in the same font. <span id="id30">[]</span> found that this “font tuning” adaptation increases, so that reading the same font for 20 minutes improves the speed of reading paragraphs by 6.3% (0.43 paragraphs or 11wpm). Even after significant font exposure there is also a “familiarity” effect where common fonts such as Times and Helvetica do 9.4% better (0.64 paragraphs or 16wpm) than novel fonts.</p>
<p>There may also be an effect on longer timescales, where exposure to a font increases reading speed in that font weeks or years later, but the 20-minute exposure effect was only</p>
<blockquote>
<div><p>There is probably a similar effect for 20-minute exposure to a given identifier convention (TODO: conifrm with formal study). Since long-term memory is anything longer than 30 seconds and observers can fairly accurately pick out a photo exposed for 3 seconds, even hours or days later, any training effect can probably be entirely explained as a function of the exposure to the visual patterns of letters.</p>
</div></blockquote>
<p>There is also a short-term memory “font tuning” effect where one adapts to the glyphs of a specific font and slows down if a glyph from a random readable font is inserted, but this mainly means to avoid a mixture of identifier styles. It’s worth checking if there is a tuning effect only for mixing identifiers of the same syntactic category or if having module names in camel case is slower if variables are in snake case vs camel case.</p>
<p>The actual names also affect readability. Binkley found that the phrases likely to be found in programs were answered incorrectly more often than prose phrases. This is likely due to the phrases being less memorable, e.g. it seems like it would be easier to confuse “full pathname” with “full pathnum” than “river bank” with “river tank” (unfortunately the most common distractor is not reported).</p>
<p>Theoretically, the best identifier style could vary by individual and depend on external factors such as font or eye correction. It’s unlikely, because the eye-tracking data says that camel case needs more eye fixations, and that’s a physical constraint of the human visual system that probably doesn’t change by individual. But, automatically translating between different identifier styles is possible, so identifier style could be yet another option in the code formatter, along with a compile option to translate the style of libraries.</p>
<p>Even so, just letting people pick a style would not work. Wallace found that people’s preferred font (as found by asking “which font is this paragraph more readable in?”) has no correlation with their fastest font among 5 fonts, and that the best font among 16 tested varied randomly per individual. So an actual timed test is really the only option to obtain optimal performance. Wallace found a 14% improvement in WPM reading speed over the subjectively preferred font and 35% over the worst font. Unfortunately Wallace’s study did not control for exposure so they may just be measuring noise. Exposure accounted for 30ish wpm in Beier’s study and in Wallace’s study the difference between fastest and preferred was 39wpm.</p>
<p>This doesn’t solve the issue of picking a default style for the standard library though. Non-programmers prefer the underscore style, and it’s more readable, so that’s probably what common variables should use. Since that puts us in the Python camp and Python is the most popular language we should probably just follow Python’s identifier conventions uniformly.</p>
</section>
<section id="layout">
<h2>Layout<a class="headerlink" href="#layout" title="Permalink to this heading"></a></h2>
<p>The most obvious instance of layout is the module declaration list, but other constructs introduce clauses as well. For readability, clauses may span multiple lines, so some way of distingishing the start / end of clauses must be defined. This amounts to adding braces and semicolons so as to make it layout-insensitive. The braces are virtual braces; they don’t syntactically match with explicit braces, but are semantically identical.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">assertEqual</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">a</span>
<span class="w">      </span><span class="n">b</span>
<span class="w">      </span><span class="n">c</span>
<span class="w">    </span><span class="n">d</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">{</span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="p">};</span><span class="w"> </span><span class="n">d</span><span class="p">}</span>
</pre></div>
</div>
<p>Behavior of a new line depends on its indentation level, relative to the indentation of the previous line. Indentation level is taken to be the sequence of whitespace characters related by “is prefix of”, so “space, tab, space” is different from (incomparable to) “tab, space, space” but is less than “space, tab, space, em space” and more than “space, tab”.</p>
<ul class="simple">
<li><p>If it is indented more, it’s a sequence given as an argument to the previous line, so a virtual open brace is inserted</p></li>
<li><p>If it is at the same level, another item in the sequence, so a (virtual) semicolon is inserted</p></li>
<li><p>If there is a line at lower indentation (or EOF), the sequence is ended as it’s a new declaration (<a class="reference external" href="https://en.wikipedia.org/wiki/Off-side_rule">off-side rule</a>). A virtual close brace is inserted at the start of the line.</p></li>
<li><p>Incomparable levels are an error.</p></li>
</ul>
<p>Layout handling is complicated by the presence of grammar rules without layout that allow free choice of indentation, e.g.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">assertEqual</span>
<span class="w">  </span><span class="n">a</span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="n">c</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="p">{</span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">}</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>It should be possible to handle these with a fixup phase.</p>
<p>Also, closed operators (e.g. parentheses) inhibit layout; this amounts to skipping whitespace layout when inside an explicit delimiter pair. But of course constructs inside the delimiter pair can start another layout. Finally for constructs that usually use layout we still want to parse 1-line things without braces:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">assertEqual</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">c</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">c</span>
</pre></div>
</div>
<section id="operators">
<h3>Operators<a class="headerlink" href="#operators" title="Permalink to this heading"></a></h3>
<p>New operators can be declared with <a class="reference external" href="http://www.cse.chalmers.se/~nad/publications/danielsson-norell-mixfix.pdf">mix</a> <a class="reference external" href="http://www.bramvandersanden.com/publication/pdf/sanden2014thesis.pdf">fix</a> semantics, e.g.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">syntax</span><span class="w"> </span><span class="kr">_</span><span class="o">&amp;&amp;</span><span class="kr">_</span><span class="w"> </span><span class="n">associate</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">_and_</span><span class="w"> </span><span class="n">_or_</span><span class="w"> </span><span class="n">_not_</span><span class="w"> </span><span class="n">below</span><span class="w"> </span><span class="kr">_</span><span class="o">||</span><span class="kr">_</span><span class="w"> </span><span class="n">equals</span><span class="w"> </span><span class="kr">_</span><span class="o">&amp;</span><span class="kr">_</span>
<span class="nf">syntax</span><span class="w"> </span><span class="p">[[</span><span class="kr">_</span><span class="p">]]</span>
<span class="nf">syntax</span><span class="w"> </span><span class="n">if_then_else_</span>
<span class="nf">syntax</span><span class="w"> </span><span class="n">_postfix</span>
<span class="nf">syntax</span><span class="w"> </span><span class="n">prefix_</span>
</pre></div>
</div>
<p>Operator precedence will be a poset, rather than levels. Infix symbols can be left or right associative.</p>
<p>Stroscot supports your typical PEMDAS:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">assertEqual</span>
<span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="o">^</span><span class="mi">2</span>
<span class="w">  </span><span class="mi">19</span>
<span class="nf">assertEqual</span>
<span class="w">  </span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">7</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">15</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="p">))</span>
<span class="w">  </span><span class="mi">355</span><span class="o">/</span><span class="mi">113</span>
<span class="w">  </span><span class="mf">3.14159292035</span><span class="o">...</span>
</pre></div>
</div>
<p>Most operators are textual:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">assert</span>
<span class="w">  </span><span class="n">true</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">false</span>
<span class="w">  </span><span class="n">true</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">true</span>
<span class="w">  </span><span class="n">true</span><span class="w"> </span><span class="n">xor</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">false</span>
<span class="w">  </span><span class="mi">5</span><span class="w"> </span><span class="n">div</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span>
<span class="w">  </span><span class="mi">5</span><span class="w"> </span><span class="n">mod</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
<p>Minus is both a unary prefix operator and a binary infix operator with special support to disambiguate the two. <code class="docutils literal notranslate"><span class="pre">(-)</span></code> denotes the binary minus operator and <code class="docutils literal notranslate"><span class="pre">neg</span></code> the unary minus operation.</p>
</section>
<section id="parentheses">
<h3>Parentheses<a class="headerlink" href="#parentheses" title="Permalink to this heading"></a></h3>
<p>Parentheses can be used to group expressions and override parsing as usual.</p>
<p>For brevity, trailing parentheses can be omitted:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">assertEqual</span>
<span class="w">  </span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">7</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">15</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="mi">1</span>
<span class="w">  </span><span class="mi">355</span><span class="o">/</span><span class="mi">113</span>
</pre></div>
</div>
<p>Although it parses, you can set Stroscot to warn or error on unmatched parentheses, or run the code formatter which will add them.</p>
</section>
<section id="chained-comparison">
<h3>Chained Comparison<a class="headerlink" href="#chained-comparison" title="Permalink to this heading"></a></h3>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">assert</span>
<span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span>
<span class="w">  </span><span class="mi">9</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span>
</pre></div>
</div>
</section>
</section>
<section id="variables">
<h2>Variables<a class="headerlink" href="#variables" title="Permalink to this heading"></a></h2>
<p>Identifiers cannot be directly reassigned; you can shadow, which generates a warning, but once an identifier is declared in a scope, that’s what that identifier refers to for the duration of the scope. OTOH references behave like mutable variables.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mut</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">a</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">raise</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
<p>Mutable assignment (<code class="docutils literal notranslate"><span class="pre">:=</span></code>) is completely distinct from name binding (<code class="docutils literal notranslate"><span class="pre">=</span></code>). They have distinct notation and mutable assignment cannot create new bindings.</p>
</section>
<section id="id31">
<h2>Functions<a class="headerlink" href="#id31" title="Permalink to this heading"></a></h2>
<p>Sequential matching:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">3</span>
</pre></div>
</div>
<p>Parallel matching:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="p">;</span>
<span class="nf">f</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
<span class="p">;</span>
<span class="nf">f</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">3</span>
</pre></div>
</div>
<p>The extra <code class="docutils literal notranslate"><span class="pre">;</span></code> is an escape to avoid sequential matching of a sequence; if you alternate clauses of different functions or define clauses in different files they will also be combined with parallel matching.</p>
<p>Function application (juxtaposition) binds stronger than all operators and associates to the left, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">--&gt;</span> <span class="pre">(x</span> <span class="pre">y)</span> <span class="pre">z</span></code>.</p>
<section id="patterns">
<h3>Patterns<a class="headerlink" href="#patterns" title="Permalink to this heading"></a></h3>
<p>Patterns all compile to guard conditions on <code class="docutils literal notranslate"><span class="pre">$args</span></code>. They also check that the arity of <code class="docutils literal notranslate"><span class="pre">$args</span></code> is the number of patterns.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="c1">-- wildcard</span>
<span class="o">^</span><span class="n">a</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="c1">-- matches the atom a</span>
<span class="o">^</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">matches</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">atom</span><span class="w"> </span><span class="n">f</span>
<span class="p">(</span><span class="n">f</span><span class="o">@</span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">matches</span><span class="w"> </span><span class="n">any</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="n">besides</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">single</span><span class="w"> </span><span class="n">atom</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">),</span><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="kt">:</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">}]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">),</span><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="kt">:</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">}]</span><span class="w"> </span><span class="c1">-- literal match</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- matches any list starting with 1 and ending with 2</span>
<span class="p">{</span><span class="n">a</span><span class="kt">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">}</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">matches</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">rest</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">record</span>
<span class="w"> </span><span class="n">pat1</span><span class="w"> </span><span class="kt">AND</span><span class="w"> </span><span class="n">pat2</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="w"> </span><span class="n">pat1</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="w"> </span><span class="n">pat2</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">matches</span><span class="w"> </span><span class="n">both</span><span class="w"> </span><span class="n">patterns</span><span class="w"> </span><span class="n">simultaneously</span>
<span class="w"> </span><span class="n">pat1</span><span class="w"> </span><span class="kt">OR</span><span class="w"> </span><span class="n">pat2</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="w"> </span><span class="n">pat1</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="w"> </span><span class="n">pat2</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">matches</span><span class="w"> </span><span class="n">either</span><span class="w"> </span><span class="n">pattern</span>
<span class="o">~</span><span class="n">pat</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">desugars</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">u_</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">pat</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">u_</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="o">...</span><span class="p">,</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="n">u_</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">unique</span><span class="w"> </span><span class="n">name</span>
<span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">elemOf</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="n">tag</span>
<span class="nf">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">guard</span><span class="p">,</span><span class="w"> </span><span class="n">arbitrary</span><span class="w"> </span><span class="n">function</span>
<span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">$</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="n">pattern</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">_</span></code> occuring by itself denotes an anonymous variable which matches any value without actually binding a name.</p>
</section>
<section id="destructuring-and-function-bindings">
<h3>Destructuring and function bindings<a class="headerlink" href="#destructuring-and-function-bindings" title="Permalink to this heading"></a></h3>
<p>Generally identifiers <code class="docutils literal notranslate"><span class="pre">f</span></code> in head positions of a LHS <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code> are taken as literal function symbols. Identifiers in head position in a sub-term are taken to be constructors, and destructure the function argument. Identifiers in non-head positions are taken to be variables. This is Pure’s “head = function rule”.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">arguments</span>
<span class="nf">x</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">argument</span><span class="p">,</span><span class="w"> </span><span class="n">binds</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="s">&quot;a&quot;</span>
<span class="nf">x</span><span class="w"> </span><span class="p">(</span><span class="n">foo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">argument</span><span class="p">,</span><span class="w"> </span><span class="n">destructures</span><span class="w"> </span><span class="n">term</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">binds</span><span class="w"> </span><span class="n">a</span><span class="o">/</span><span class="n">b</span>
</pre></div>
</div>
<p>Certain symbols such as tuple heads as head of the LHS are assumed not to be function definitions. Instead matching on them destructures the right hand side. For example you can define functions using destructuring:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">s&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">digitsToBits</span><span class="w"> </span><span class="n">digits</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="kt">CR</span><span class="w"> </span><span class="n">s&#39;</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="o">-</span><span class="n">y</span>
</pre></div>
</div>
<p>This translates to:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="c1">-- equivalent to</span>
<span class="nf">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">}</span>

<span class="nf">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>

<span class="nf">z</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">s&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">digitsToBits</span><span class="w"> </span><span class="n">digits</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="kt">CR</span><span class="w"> </span><span class="n">s&#39;</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="o">-</span><span class="n">y</span>
<span class="c1">-- z a fresh symbol</span>
</pre></div>
</div>
<p>To force a function definition you can use an as pattern, <code class="docutils literal notranslate"><span class="pre">_&#64;(,)</span></code></p>
<p>To force interpretation as a variable you can use an anonymous as pattern, <code class="docutils literal notranslate"><span class="pre">(f&#64;_)</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code>. Then <code class="docutils literal notranslate"><span class="pre">f</span></code> is a variable and will match any symbol, rather just <code class="docutils literal notranslate"><span class="pre">f</span></code>. Example converting a function application to a list:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="p">((</span><span class="n">x</span><span class="o">@</span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">foo</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
<span class="nf">foo</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">]</span>
</pre></div>
</div>
<p>To force interpretation as a literal you can use <code class="docutils literal notranslate"><span class="pre">^</span></code>. The symbol will be interpreted as a literal even in variable position:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="o">^</span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;self-application&quot;</span>

<span class="nf">foo</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">reduce</span>
</pre></div>
</div>
<p>You can also declare <code class="docutils literal notranslate"><span class="pre">foo</span></code> to be a symbol:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">symbol</span><span class="w"> </span><span class="n">foo</span>
</pre></div>
</div>
<p>However this is a module definition and means the symbol cannot be used as a variable in the module anymore.</p>
</section>
<section id="symbols">
<h3>Symbols<a class="headerlink" href="#symbols" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>To say that it is actually a symbol a special keyword <code class="docutils literal notranslate"><span class="pre">symbol</span></code> is used:</p>
</div></blockquote>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">symbol</span><span class="w"> </span><span class="n">foo</span>

<span class="nf">foo</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>

<span class="nf">bar</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
<span class="o">#</span><span class="w"> </span><span class="n">equivalent</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">interpreted</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">variable</span>
</pre></div>
</div>
<p>Furthermore you can define a function symbol with an arity. This resolves applying the function symbol to arguments for which no clauses are defined to the exception <code class="docutils literal notranslate"><span class="pre">undefined</span></code>, which often has better semantics than an unevaluated normal form.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">function</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="n">arity</span><span class="w"> </span><span class="mi">2</span>

<span class="nf">foo</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;fine&quot;</span>

<span class="nf">foo</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="s">&quot;fine&quot;</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">undefined</span>
<span class="nf">foo</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">affected</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">normal</span><span class="w"> </span><span class="n">form</span>
</pre></div>
</div>
<p>This just creates a low priority definition <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">_</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">undefined</span></code>.</p>
</section>
<section id="non-linear-patterns">
<h3>Non-linear patterns<a class="headerlink" href="#non-linear-patterns" title="Permalink to this heading"></a></h3>
<p>Non-left-linear patterns such as <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">a</span> <span class="pre">a</span></code> are allowed, this is interpreted as <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">|</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code> - rename variables and check for equality using <code class="docutils literal notranslate"><span class="pre">==</span></code>. See <a class="reference internal" href="TermRewriting.html#trs-equality-linearity"><span class="std std-ref">Left-nonlinearity</span></a> for a discussion.</p>
</section>
<section id="pattern-synonyms">
<h3>Pattern synonyms<a class="headerlink" href="#pattern-synonyms" title="Permalink to this heading"></a></h3>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">toPolar</span><span class="w"> </span><span class="p">(</span><span class="kt">Point</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">sqrt</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">atan2</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="nf">pattern</span><span class="w"> </span><span class="kt">Polar</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">toPolar</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<p>Pattern definitions are unidirectional in that they define matchers for syntax used only in patterns, not in expressions. To make a bidirectional pattern simply define the builder:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Polar</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cos</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sin</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="variable-bindings">
<h3>Variable bindings<a class="headerlink" href="#variable-bindings" title="Permalink to this heading"></a></h3>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="o">$</span><span class="n">arga</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="c1">-- binds a if a is not defined as a symbol</span>
<span class="nf">_a</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="c1">-- hole, binds a even if a is an existing symbol</span>
</pre></div>
</div>
<p>This defines the variables as a zero-arity function symbol. So for example you can write</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
<p>which means the same thing as</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">True</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
<p>i.e. <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</section>
<section id="inline-definitions">
<h3>Inline definitions<a class="headerlink" href="#inline-definitions" title="Permalink to this heading"></a></h3>
<p>Definitions can be made inline; they are lifted to the closest scope that allows definitions.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="n">range</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">((</span><span class="n">dx</span><span class="ow">=</span><span class="n">x1</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">dy</span><span class="ow">=</span><span class="n">y1</span><span class="o">-</span><span class="n">y0</span><span class="p">)</span><span class="o">*</span><span class="n">dy</span><span class="p">)</span>

<span class="c1">-- translates to</span>
<span class="w"> </span><span class="n">dx</span><span class="ow">=</span><span class="n">x1</span><span class="o">-</span><span class="n">x0</span>
<span class="w"> </span><span class="n">dy</span><span class="ow">=</span><span class="n">y1</span><span class="o">-</span><span class="n">y0</span>
<span class="w"> </span><span class="n">range</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dy</span><span class="o">*</span><span class="n">dy</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="keyword-arguments">
<h3>Keyword arguments<a class="headerlink" href="#keyword-arguments" title="Permalink to this heading"></a></h3>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">w</span>

<span class="nf">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="kt">:</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="kt">:</span><span class="mi">0</span><span class="p">)</span>
<span class="o">#</span><span class="w"> </span><span class="mi">0</span><span class="o">-</span><span class="mi">4</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="mi">1</span>
<span class="nf">v</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="kt">:</span><span class="mi">4</span><span class="p">,</span><span class="n">y</span><span class="kt">:</span><span class="mi">2</span><span class="p">,</span><span class="n">w</span><span class="kt">:</span><span class="mi">1</span><span class="p">,</span><span class="n">z</span><span class="kt">:</span><span class="mi">0</span><span class="p">}</span>
<span class="o">#</span><span class="w"> </span><span class="n">true</span>
</pre></div>
</div>
<p>You can specify a subset of the arguments to generate a partially applied function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="kt">:</span><span class="mi">1</span><span class="p">)</span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="kt">:</span><span class="mi">0</span><span class="p">)</span>
<span class="nf">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">v</span>
<span class="o">#</span><span class="w"> </span><span class="n">true</span>
</pre></div>
</div>
<p>Using the variable name in braces by itself uses the value of that variable in scope:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">4</span>
<span class="nf">w</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span>
<span class="nf">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span><span class="n">w</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="positional-arguments">
<h3>Positional arguments<a class="headerlink" href="#positional-arguments" title="Permalink to this heading"></a></h3>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">v</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">0</span>
<span class="o">#</span><span class="w"> </span><span class="n">true</span>
</pre></div>
</div>
<p>You can mix positional and keyword arguments freely; positions are
assigned to whatever is not a keyword argument.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">v</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span><span class="n">z</span><span class="kt">:</span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="n">w</span><span class="kt">:</span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">2</span>
<span class="o">#</span><span class="w"> </span><span class="n">true</span>
</pre></div>
</div>
<p>Positional arguments support currying, for example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">c</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="o">-</span><span class="n">y</span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="mi">3</span>

<span class="nf">b</span><span class="w"> </span><span class="mi">4</span>
<span class="o">#</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
<p>Positional arguments may be filled by the special syntax <code class="docutils literal notranslate"><span class="pre">_</span></code> to write a partial application:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sub</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span>
<span class="nf">sub1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">sub</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="mi">1</span>

<span class="o">#</span><span class="w"> </span><span class="n">equivalent</span><span class="w"> </span><span class="n">definition</span>
<span class="nf">sub1</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">sub</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span>

<span class="nf">sub1</span><span class="w"> </span><span class="mi">3</span>
<span class="o">#</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
<p>All the underscores of a call are regrouped to form the parameters of a unique function in the same order as the corresponding underscores.</p>
</section>
<section id="id32">
<h3>Implicit arguments<a class="headerlink" href="#id32" title="Permalink to this heading"></a></h3>
<p>These behave similarly to arguments in languages with dynamical scoping. Positional arguments can be passed implicitly, but only if the function is used without applying any positional arguments. If the LHS contains positional arguments only that number of positional arguments are consumed and they are not passed implicitly.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">w</span>
<span class="nf">bar</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">baz</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="kt">:</span><span class="mi">4</span><span class="p">,</span><span class="n">y</span><span class="kt">:</span><span class="mi">2</span><span class="p">}</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span>

<span class="nf">bar</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span>
<span class="o">#</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="o">/</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span>

<span class="p">((</span><span class="mi">0</span><span class="o">-</span><span class="mi">4</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">baz</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">{</span><span class="n">z</span><span class="kt">:</span><span class="mi">0</span><span class="p">,</span><span class="n">w</span><span class="kt">:</span><span class="mi">1</span><span class="p">}</span>
<span class="o">#</span><span class="w"> </span><span class="n">true</span>
<span class="w"> </span><span class="n">baz</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span>
<span class="o">#</span><span class="w"> </span><span class="kt">Error:</span><span class="w"> </span><span class="n">too</span><span class="w"> </span><span class="n">many</span><span class="w"> </span><span class="n">arguments</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">baz</span><span class="p">,</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>Similarly keyword arguments inhibit passing down that keyword
implicitly:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">b</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span>

<span class="nf">b</span><span class="w"> </span><span class="p">{</span><span class="n">k</span><span class="kt">:</span><span class="mi">2</span><span class="p">}</span>
<span class="o">#</span><span class="w"> </span><span class="kt">Error:</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">definition</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">given</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
<p>A proper definition for b would either omit k or pass it explicitly to a:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span>
<span class="nf">b&#39;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">k</span>

<span class="nf">b</span><span class="w"> </span><span class="p">{</span><span class="n">k</span><span class="kt">:</span><span class="mi">2</span><span class="p">}</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b&#39;</span><span class="w"> </span><span class="p">{</span><span class="n">k</span><span class="kt">:</span><span class="mi">2</span><span class="p">}</span>
<span class="o">#</span><span class="w"> </span><span class="n">true</span>
</pre></div>
</div>
<p>For functions with no positional arguments, positions are assigned
implicitly left-to-right:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="nf">a</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">1</span>
<span class="o">#</span><span class="w"> </span><span class="mi">5</span>
</pre></div>
</div>
<p>Atoms that are in lexical scope are not assigned positions, hence (/)
and (+) are not implicit positional arguments for a in the example
above. But they are implicit keyword arguments:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="nf">assert</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="p">{(</span><span class="o">+</span><span class="p">)</span><span class="kt">:</span><span class="p">(</span><span class="o">-</span><span class="p">)}</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="o">/</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span>
<span class="w">  </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span>
</pre></div>
</div>
<p>The namespace scoping mechanism protects against accidental use in large
projects.</p>
<p>Infix operators can accept implicit arguments just like prefix functions:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">infix</span><span class="w"> </span><span class="p">(</span><span class="o">**</span><span class="p">)</span>
<span class="nf">x</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">{</span><span class="n">z</span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">/</span><span class="n">z</span>
</pre></div>
</div>
</section>
<section id="default-arguments">
<h3>Default arguments<a class="headerlink" href="#default-arguments" title="Permalink to this heading"></a></h3>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="p">{</span><span class="n">k</span><span class="kt">:</span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">a</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
<p>Modula-3 added keyword arguments and default arguments to Modula-2. But I think they also added a misfeature: positional arguments with default values. In particular this interacts very poorly with currying. If <code class="docutils literal notranslate"><span class="pre">foo</span></code> is a function with two positional arguments, the second of them having a default value, then <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">a</span> <span class="pre">b</span></code> is ambiguous as to whether the second argument is overriden.</p>
<p>We can resolve this by requiring parentheses: <code class="docutils literal notranslate"><span class="pre">(foo</span> <span class="pre">a)</span> <span class="pre">b</span></code> passes <code class="docutils literal notranslate"><span class="pre">b</span></code> to the result of <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">{_2=default}</span></code>, while <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">a</span> <span class="pre">b</span></code> is overriding the second argument. But it’s somewhat fragile, a more robust method is to require specifying/overriding default arguments to use keyword syntax.</p>
<p>Implicit arguments use keyword syntax as well, so they override default arguments:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="p">{</span><span class="n">k</span><span class="kt">:</span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">k</span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span>
<span class="nf">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">{</span><span class="n">k</span><span class="kt">:</span><span class="mi">2</span><span class="p">}</span>
<span class="nf">c</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
</section>
<section id="output-arguments">
<h3>Output arguments<a class="headerlink" href="#output-arguments" title="Permalink to this heading"></a></h3>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="kt">:</span><span class="mi">3</span><span class="p">};</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span>
<span class="o">#</span><span class="w"> </span><span class="mi">5</span>
</pre></div>
</div>
<p>Output arguments can chain into implicit arguments, so you get something like the state monad:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">inc</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="kt">:</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span>

<span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">inc</span>
<span class="nf">x</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
<p>It might be worth having a special keyword <code class="docutils literal notranslate"><span class="pre">inout</span></code> for this.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">inc</span><span class="w"> </span><span class="p">{</span><span class="n">inout</span><span class="w"> </span><span class="n">x</span><span class="p">}</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
</section>
<section id="variadic-arguments">
<h3>Variadic arguments<a class="headerlink" href="#variadic-arguments" title="Permalink to this heading"></a></h3>
<p>Positional variadic arguments:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">$</span><span class="n">arguments</span>
<span class="nf">c</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span>
<span class="o">#</span><span class="w"> </span><span class="mi">6</span>
<span class="nf">c</span><span class="w"> </span><span class="p">{</span><span class="o">$</span><span class="n">arguments</span><span class="ow">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]}</span>
<span class="o">#</span><span class="w"> </span><span class="mi">3</span>
</pre></div>
</div>
<p>Only syntactically adjacent arguments are passed, e.g.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span>
<span class="o">#</span><span class="w"> </span><span class="ne">error</span><span class="kt">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">reducible</span>

<span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">2</span>
<span class="o">#</span><span class="w"> </span><span class="ne">error</span><span class="kt">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">reducible</span>
</pre></div>
</div>
<p>There are also variadic keyword arguments:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="o">$</span><span class="n">kwargs</span>
<span class="nf">s</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="kt">:</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="kt">:</span><span class="mi">2</span><span class="p">}</span>
<span class="o">#</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="kt">:</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="kt">:</span><span class="mi">2</span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="concatenative-arguments">
<h3>Concatenative arguments<a class="headerlink" href="#concatenative-arguments" title="Permalink to this heading"></a></h3>
<p>Results not assigned to a variable are pushed to a stack:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>

<span class="o">%</span><span class="n">stack</span>
<span class="o">#</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">%</span></code> is the most recent result, with <code class="docutils literal notranslate"><span class="pre">%2</span></code> <code class="docutils literal notranslate"><span class="pre">%3</span></code> etc. referring to
less recent results. These stack arguments are used for positional arguments when not
supplied.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="p">}</span>
<span class="nf">extend</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">{</span><span class="n">b</span><span class="ow">=</span><span class="mi">2</span><span class="p">}</span>
<span class="nf">extend</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="ow">=</span><span class="mi">3</span><span class="p">}</span>
<span class="nf">shuffle</span>
<span class="o">#</span><span class="w"> </span><span class="p">{</span><span class="n">b</span><span class="ow">=</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="ow">=</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="ow">=</span><span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="inheritance">
<h3>Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this heading"></a></h3>
<p>The general idea of inheritance is, for <code class="docutils literal notranslate"><span class="pre">Foo</span></code> a child of <code class="docutils literal notranslate"><span class="pre">Bar</span></code> to rewrite calls <code class="docutils literal notranslate"><span class="pre">exec</span> <span class="pre">(Foo</span> <span class="pre">...)</span> <span class="pre">a</span> <span class="pre">b</span></code> to calls <code class="docutils literal notranslate"><span class="pre">exec</span> <span class="pre">(Bar</span> <span class="pre">...)</span> <span class="pre">a</span> <span class="pre">b</span></code>, and this can be automated with a macro:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">inherit</span><span class="w"> </span><span class="n">foopat</span><span class="w"> </span><span class="n">barpat</span><span class="w"> </span><span class="n">barmethodlist</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">for</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">barmethodlist</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">m</span><span class="w"> </span><span class="n">foopat</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">barpat</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id33">
<h3>Operators<a class="headerlink" href="#id33" title="Permalink to this heading"></a></h3>
<p>Operators are syntactic sugar for functions. Enclosing an operator
in parentheses turns it into an ordinary function symbol, thus <code class="docutils literal notranslate"><span class="pre">x+y</span></code> is
exactly the same as <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">x</span> <span class="pre">y</span></code>.</p>
</section>
</section>
<section id="lambdas">
<h2>Lambdas<a class="headerlink" href="#lambdas" title="Permalink to this heading"></a></h2>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">\</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">stuff</span>
<span class="nf">\</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="n">stuff</span>
<span class="nf">lambda</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">stuff</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">other</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A lambda raises an exception if no pattern matches (defined function), but otherwise is
a nameless local function. With the <code class="docutils literal notranslate"><span class="pre">lambda{}</span></code> syntax multiple clauses can be defined - they are matched sequentially. Multiple-argument lambdas are curried.</p>
<p>Because they’re nameless lambdas aren’t sufficient to define recursive function - use (named) local functions, or the function <code class="docutils literal notranslate"><span class="pre">fix</span> <span class="pre">:</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>.</p>
<p>Destructuring works in the arguments of lambdas as with named functions.</p>
<section id="matching">
<h3>Matching<a class="headerlink" href="#matching" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">match</span></code> is an expression:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">                      </span><span class="o">|</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
<p>It desugars to a lambda applied to the arguments.</p>
<p><code class="docutils literal notranslate"><span class="pre">impossible</span></code> is a special RHS used to help the verification analysis:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">impossible</span>
</pre></div>
</div>
<p>Reduce similarly reduces an expression to normal form using some rules:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">reduce</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">y</span>
<span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">z</span>
<span class="o">#</span><span class="w"> </span><span class="n">z</span>
</pre></div>
</div>
</section>
<section id="operator-sections">
<h3>Operator sections<a class="headerlink" href="#operator-sections" title="Permalink to this heading"></a></h3>
<p>Operator sections allow writing partial applications of infix operators.
A left section <code class="docutils literal notranslate"><span class="pre">(x+)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">x</span></code>. A right section <code class="docutils literal notranslate"><span class="pre">(+y)</span></code> is
equivalent to <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>.</p>
<p>In contrast, <code class="docutils literal notranslate"><span class="pre">(-x)</span></code> denotes an application of unary minus; the
section <code class="docutils literal notranslate"><span class="pre">(+-x)</span></code> can be used to indicate a function which subtracts <code class="docutils literal notranslate"><span class="pre">x</span></code>
from its argument.</p>
</section>
</section>
<section id="id34">
<h2>Blocks<a class="headerlink" href="#id34" title="Permalink to this heading"></a></h2>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="n">number</span>
<span class="w"> </span><span class="n">display</span><span class="w"> </span><span class="n">x</span>

<span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span>
<span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">   </span><span class="n">provide</span><span class="w"> </span><span class="n">x</span>

<span class="w"> </span><span class="n">obtain</span><span class="w"> </span><span class="n">http_server</span>
<span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="ow">=</span>
<span class="w">   </span><span class="n">parse_args</span>
<span class="w">   </span><span class="n">build_folder</span>
<span class="w">   </span><span class="n">http_server</span><span class="o">.</span><span class="n">serve</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>
</pre></div>
</div>
<p>The translation rules are based on the continuation monad:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">e</span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span>
<span class="p">{</span><span class="n">e</span><span class="p">;</span><span class="n">stmts</span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">({</span><span class="n">stmts</span><span class="p">}</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="p">{</span><span class="n">stmts</span><span class="p">}</span>
<span class="p">{</span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="n">stmts</span><span class="p">}</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">c</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">p</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">stmts</span><span class="p">})</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="p">{</span><span class="n">stmts</span><span class="p">}</span>
</pre></div>
</div>
<section id="bang-notation">
<h3>Bang notation<a class="headerlink" href="#bang-notation" title="Permalink to this heading"></a></h3>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">print</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">!</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>

<span class="o">//</span><span class="w"> </span><span class="n">desugars</span><span class="w"> </span><span class="n">to</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">t1</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">y</span>
<span class="w">  </span><span class="n">t2</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="n">t3</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">t2</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="n">t3</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The notation <code class="docutils literal notranslate"><span class="pre">!expr</span></code> within a block means that the expression <code class="docutils literal notranslate"><span class="pre">expr</span></code> should be bound in the block to a temporary before computing the surrounding expression. The expression is bound in the nearest enclosing block.
Expressions are lifted leftmost innermost.</p>
</section>
<section id="local-definitions">
<h3>Local definitions<a class="headerlink" href="#local-definitions" title="Permalink to this heading"></a></h3>
<p>You can define variables and function locally to a block, clause, or clause group with let and where. These are in a new scope and only apply to the block where they are defined. This avoids cluttering up the program. All local definitions are substituted away before the block is evaluated in the ambient context.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="c1">-- block definition</span>
<span class="p">}</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="n">g</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="c1">-- clause definition</span>
<span class="nf">foo</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">impossible</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="n">h</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- last clause, hence a clause group definition, but uses &quot;a&quot; which is only defined for first clause</span>
</pre></div>
</div>
<p>A local definition shadows an ambient one, so for example you can write:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">4</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(x-1)</span></code> both refer to the local definition. But you will get a shadowing warning as it is bad style.</p>
<p><code class="docutils literal notranslate"><span class="pre">let</span></code> allows recursive definitions, bare definitions are not recursive:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">shadowing</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="n">x</span>
<span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">fixed</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">unique</span><span class="w"> </span><span class="n">solution</span><span class="w"> </span><span class="n">x</span><span class="ow">=</span><span class="mi">0</span>

<span class="nf">fact</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">fails</span><span class="w"> </span><span class="n">due</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="n">being</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">unbound</span><span class="w"> </span><span class="n">symbol</span>
<span class="kr">let</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">proper</span><span class="w"> </span><span class="n">definition</span>
</pre></div>
</div>
</section>
<section id="monad-comprehensions">
<h3>Monad comprehensions<a class="headerlink" href="#monad-comprehensions" title="Permalink to this heading"></a></h3>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="ow">=</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="ow">=</span><span class="mi">1</span><span class="o">..</span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="p">]</span>
</pre></div>
</div>
<p>A convenient means to construct lists and to write blocks compactly. There is a template expression, generator clauses which bind the result of continuation to a pattern, and filter clauses which allow skipping results.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Expressions:</span><span class="w"> </span><span class="n">e</span>
<span class="kt">Declarations:</span><span class="w"> </span><span class="n">d</span>
<span class="kt">Lists</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">qualifiers</span><span class="kt">:</span><span class="w"> </span><span class="kt">Q</span><span class="p">,</span><span class="kt">R</span><span class="p">,</span><span class="kt">S</span>
<span class="kt">Qv</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">variables</span><span class="w"> </span><span class="n">bound</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">(</span><span class="n">and</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">subsequently</span><span class="p">)</span>
<span class="nf">selQvi</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">selector</span><span class="w"> </span><span class="n">mapping</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">ith</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="kt">Qv</span>

<span class="c1">-- Basic forms</span>
<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">e</span>
<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">,</span><span class="n">e3</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">[</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">,</span><span class="n">e3</span><span class="p">]</span>
<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span><span class="w">  </span><span class="ow">=</span>
<span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">e</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span>
<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">guard</span><span class="w"> </span><span class="n">e</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span>
<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">d</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span>

<span class="c1">-- Parallel comprehensions (iterate for multiple parallel branches)</span>
<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="kt">Q</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">R</span><span class="p">),</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="p">(</span><span class="kt">Qv</span><span class="p">,</span><span class="kt">Rv</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mzip</span><span class="w"> </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="kt">Rv</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="p">]</span>

<span class="c1">-- Transform comprehensions</span>
<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="kt">Qv</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span>

<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="kt">Qv</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="kt">Qv</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span>

<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=\</span>
<span class="w">  </span><span class="n">ys</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">fmap</span><span class="w"> </span><span class="n">selQv1</span><span class="w"> </span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">,</span><span class="w"> </span><span class="n">fmap</span><span class="w"> </span><span class="n">selQvn</span><span class="w"> </span><span class="n">ys</span><span class="p">)</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span>

<span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">ys</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="kt">Qv</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Q</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="kt">Qv</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">fmap</span><span class="w"> </span><span class="n">selQv1</span><span class="w"> </span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">,</span><span class="w"> </span><span class="n">fmap</span><span class="w"> </span><span class="n">selQvn</span><span class="w"> </span><span class="n">ys</span><span class="p">)</span>
<span class="w">  </span><span class="kt">D</span><span class="p">[</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">R</span><span class="w"> </span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="control-structures">
<h2>Control structures<a class="headerlink" href="#control-structures" title="Permalink to this heading"></a></h2>
<p>These are things that can show up in blocks and have blocks as arguments.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">-- just a function if_then_else_ : Bool -&gt; a -&gt; a -&gt; a</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mut</span><span class="w"> </span><span class="n">undefined</span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">-- if on blocks</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="n">x</span>
<span class="p">}</span>
<span class="nf">repeat</span><span class="w"> </span><span class="n">while</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span>
<span class="nf">repeat</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span>
<span class="nf">repeat</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">times</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span>
<span class="nf">repeat</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">while</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="nf">repeat</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">break</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">check</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">risky_procedure</span>
<span class="p">}</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">fix</span><span class="p">(</span><span class="ne">error</span><span class="p">)</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="ne">error</span><span class="p">(</span><span class="s">&quot;wtf&quot;</span><span class="p">)</span>
<span class="p">}</span><span class="w"> </span><span class="n">regardless</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">save_logs</span>
<span class="p">}</span>
</pre></div>
</div>
<p>More here: <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions">https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions</a></p>
<p>Also the do-while block from <a class="reference external" href="https://github.com/google/rune/blob/main/doc/rune4python.md#looping">Rune</a>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>do
  c = getNextChar()
while c != ‘\0’
  processChar(c)
</pre></div>
</div>
<p>The do-block always executes, and the while-block only executes if the condition is true, after which we jump to the start of the do-block. If the condition is false, the loop terminates. This avoids the common C/C++ assignment-in-condition hack:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>int c;
while ((c = getNextChar()) != &#39;\0&#39;) {
  processChar(c);
}
</pre></div>
</div>
</section>
<section id="programs">
<h2>Programs<a class="headerlink" href="#programs" title="Permalink to this heading"></a></h2>
<p>A program is a block, and every declaration is a macro or control structure.</p>
<p>So top-level statements and function calls are allowed. For example you can implement a conditional definition:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span><span class="w"> </span><span class="n">condition</span>
<span class="w">   </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="kr">else</span>
<span class="w">   </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
</section>
<section id="id35">
<h2>Comments<a class="headerlink" href="#id35" title="Permalink to this heading"></a></h2>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="w"> </span><span class="n">comment</span>
<span class="o">/*</span><span class="w"> </span><span class="n">multiline</span>
<span class="w">    </span><span class="n">comment</span><span class="w"> </span><span class="o">*/</span>
<span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="n">nesting</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="n">comment</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="p">)</span>
<span class="w"> </span><span class="kr">if</span><span class="p">(</span><span class="n">false</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">code_comment</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">lexed</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">parsed</span><span class="w"> </span><span class="n">except</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="n">start</span><span class="o">/</span><span class="n">end</span><span class="w"> </span><span class="p">}</span>
<span class="o">#!</span><span class="w"> </span><span class="n">shebang</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">beginning</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="n">file</span>
</pre></div>
</div>
</section>
<section id="id36">
<h2>Type declarations<a class="headerlink" href="#id36" title="Permalink to this heading"></a></h2>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">s8</span>
<span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s8</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="State.html" class="btn btn-neutral float-left" title="Stateful programming" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="TermRewriting.html" class="btn btn-neutral float-right" title="Term rewriting" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>