<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Syntax &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Term rewriting" href="TermRewriting.html" />
    <link rel="prev" title="Stateful programming" href="State.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Paradigms.html">Comparison</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Syntax</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#design">Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#textual">Textual</a></li>
<li class="toctree-l4"><a class="reference internal" href="#legibility-research">Legibility research</a></li>
<li class="toctree-l4"><a class="reference internal" href="#code-legibility">Code legibility</a></li>
<li class="toctree-l4"><a class="reference internal" href="#proportional-fonts">Proportional fonts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#familiarity">Familiarity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parsing">Parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#blocks">Blocks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#applicativedo">ApplicativeDo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recursivedo">RecursiveDo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arrows">Arrows</a></li>
<li class="toctree-l4"><a class="reference internal" href="#idiom-brackets">Idiom brackets</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-like-reference-access">C-like reference access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#assignment">Assignment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#constructor-discipline">Constructor discipline</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recursive-definitions">Recursive definitions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#type-declarations">Type declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#namespacing">Namespacing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#partial-loading">Partial loading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#specificity">Specificity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#comments">Comments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#whitespace">Whitespace</a></li>
<li class="toctree-l3"><a class="reference internal" href="#braces-and-brackets">Braces and brackets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-syntax">Function syntax</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#arguments">Arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#currying">Currying</a></li>
<li class="toctree-l4"><a class="reference internal" href="#call-syntax">Call syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicit-arguments">Implicit arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#n-k-patterns">n+k patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pattern-matching-conditionals">Pattern matching / conditionals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#chained-assignment">Chained assignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#embedded-assignment">Embedded assignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unless">Unless</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tuples-and-records">Tuples and records</a></li>
<li class="toctree-l3"><a class="reference internal" href="#precedence">Precedence</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cycle">Cycle</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Commentary</a> &raquo;</li>
      <li>Syntax</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Syntax.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="syntax">
<h1>Syntax<a class="headerlink" href="#syntax" title="Permalink to this heading"></a></h1>
<section id="design">
<h2>Design<a class="headerlink" href="#design" title="Permalink to this heading"></a></h2>
<p>The stuff here is mostly a dumping ground of ideas while the rest of the language is designed. The actual syntax will be designed by going through the syntax of other languages (primarily the ones listed in the influences section, but also all the ones listed on RosettaCode and <a class="reference external" href="http://rigaux.org/language-study/syntax-across-languages/">Rigaux’s list of syntax across languages</a>) and picking out the nicest examples. But in the end, syntax is decided by usage, so a lot of the syntax here will probably become final.</p>
<p>Quorum and its associated set of syntax studies provide useful datapoints on keywords and constructs. But Stroscot has a unique design so we can’t use a lot of the research, and the research is limited to begin with.</p>
<p>Some studies use a “Randomo” language which randomizes design choices. It would be useful to implement this so choices could be A/B tested.</p>
<p>Some languages offer a “simple” syntax. But simplicity is hard to define, and boils down to either a simple implementation (LR) or else just the syntax familiar to them from other languages (which implementation-wise is often quite complex). People seem to be afraid of new syntax so there is the tendency to make it explicit and loud while reserving the terse syntax for established features. But Stroscot’s goal is to unify all the features, so all of the notation is designed to be short, terse, flexible, and general.</p>
<p>Haskell/Idris syntax is mostly awesome, use it. (TODO: check this. The weird parentheses style may lose too many users)</p>
<p>TODO: see if there are any more Unicode guidelines relevant to writing a programming language parser</p>
<p>Natural language like Inform 7, while interesting, is quite wordy. It’s also hard to scan through.</p>
<p>Fortress has “mathematical syntax”, with an ASCII form and typeset form. They used LaTeX but HTML / MathML output should be possible too. And juxtaposition was overloaded. Probably worth emulating.</p>
<p>A language encourages certain expressions of thought. If the syntax is awkward then the feature will be used less and a bias will be introduced. But the styles of programming people come up with after a language is released are often completely different to what was intended by the language (e.g. Java and its design patterns). It’s not clear that anything can be done about this, besides capturing as many existing patterns as cleanly as possible.</p>
<section id="textual">
<h3>Textual<a class="headerlink" href="#textual" title="Permalink to this heading"></a></h3>
<p>There are some people who, when confronted with the complexity of syntax, think “It’s better to use a binary format and store everything in a database.” Now they have two problems. Math is textual, English is textual, the only stuff that isn’t textual are flowcharts and tables. Flowcharts might be OK but graph layout is hard - graphviz barely works, and IDA Pro’s graph layout when it decompiles stuff is quite lacking. Tables lead into spreadsheet programming which is generally not expressive as a language - and the formulas and cell values are textual. If you show me a way to write 123.6 that doesn’t involve text maybe I’ll think about this more.</p>
<p>There’s also structural editing, <a class="reference external" href="http://www.lamdu.org/">lamdu</a> and so on, but they are designing an IDE alongside a programming language. I’m not too interested in IDEs and given that half the IDEs are for languages that also have a textual syntax, syntax doesn’t seem to be a big factor in writing such an IDE.</p>
</section>
<section id="legibility-research">
<h3>Legibility research<a class="headerlink" href="#legibility-research" title="Permalink to this heading"></a></h3>
<p>The main factor improving readability is consistency; reading is disrupted when unconventional layouts are used.</p>
<p>Spacing helps identify boundaries:
* For words, intra-letter spacing should be significantly smaller than inter-word spacing.
* For sentences, there should be extra space after the period, although the period’s whitespace itself is distinctive.
* Justified text is harder to read than ragged-right due to the inconsistent spacing arising from bad line-breaking.
* The default inter-line spacing (line height, leading) is fine for most people. Some people with disabilities need more. Longer lines can use a little bit more line height.
* To identify paragraphs, inter-paragraph spacing should be visibly larger than inter-line spacing, or paragraph indentation should be used.</p>
<p>Left-aligned text is easier to read than centered or right-aligned text because the reader knows where to look to find the next line.</p>
<p>Maximum line length is an open question. Diff programs seem like the limiting factor, but on my monitor I can fit 2 108-character texts at the default font size side-by-side along with a space in the middle and the taskbar. Rounding this down to 100 leaves room for line numbers and similar decorations. Plus, most diffs these days are unified, and line-wrapping is always an option for smaller screens. OTOH it’s a tiny font, 18-26pt is the most readable for websites so maybe that size is needed for programming. At 18pt / 24px I can fit 97 characters, while a little less (17.25pt / 23px) fits 102 characters. The standard is 80 characters but monitors are wider now, so again 100 seems plausible. This can really only be tested by finding long lines of code and asking what line-breaking placement is most readable.</p>
</section>
<section id="code-legibility">
<h3>Code legibility<a class="headerlink" href="#code-legibility" title="Permalink to this heading"></a></h3>
<p>IMO layout improves code legibility. There haven’t been any formal studies that I can find, but Python syntax is often said to be “clean”. Also layout makes arguments over where to put braces moot. Hence Stroscot has layout.</p>
<p>Reading code top-to-bottom, left-to-right makes sense. So definitions should be on the left, blocks indented in, and lines themselves should read left to right. So Ruby’s statement modifiers <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">if</span> <span class="pre">Y</span></code> are a bad idea because the <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">Y</span></code> is easy to miss when scanning control flow.  But operators like <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">xor</span> <span class="pre">c</span></code> are fine because the assignment <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span></code> is clear and if the value of the expression matters you’re reading the whole line anyway and can parse it in your head.</p>
<p>Unicode can improve legibility when the syntax is standard (e.g. θ for angles), but generally long names like <code class="docutils literal notranslate"><span class="pre">Optimiser(learning_rate=...)</span></code> are more readable than <code class="docutils literal notranslate"><span class="pre">Optimiser(η=...)</span></code>. Programmers have neither the time nor the inclination to learn a new character set and accompanying set of conventions.</p>
<p>When the convention is established, short names are clearer than long names. Writing <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">{</span> <span class="pre">augend</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">addend</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">}</span></code> is less clear than the simple <code class="docutils literal notranslate"><span class="pre">1+2</span></code> - the long names are not commonly used. But it is arguably still useful to include the long names, e.g. for currying.</p>
<p>A study <span id="id1">[<a class="reference internal" href="../zzreferences.html#id39" title="Rodrigo Magalhães dos Santos and Marco Aurélio Gerosa. Impacts of coding practices on readability. In Proceedings of the 26th Conference on Program Comprehension, 277–285. Gothenburg Sweden, May 2018. ACM. URL: https://dl.acm.org/doi/10.1145/3196321.3196342 (visited on 2022-05-18), doi:10.1145/3196321.3196342.">dosSantosG18</a>]</span> found the following:</p>
<p>Putting opening braces in a line of their own (C# convention), as opposed to the same line of the statement, improved readability. The extra white space and matching vertical alignment of related curly braces makes blocks clearer. Closing curly braces terminating code blocks should be on their own line, except for secondary paths of execution, e.g.: closing brace of if statements followed by an else; closing braces of try statements followed by a catch.
Line lengths must be kept within the limit of 80 characters;
Each statement should be in a line of its own; do not separate multiple statements by a ‘‘;’’ in a single line.
Use import clauses instead of qualified names to reference names in code.
Frequent calls to sub-properties of class member properties should be made storing a reference to that sub-property, avoiding multiple statements containing long chains of objects and sub-properties;
Identifier names should use dictionary words for readability.
Grouping instructions using blank lines was inconclusive. Some thought the blanks broke the flow, others liked it.
On indenting 2 spaces vs 4 spaces, there was no consensus.
Nesting conditionals more than three levels deep was considered by some to be easy to read and clearer than using a complex condition. But the majority preferred refactoring to an <code class="docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span></code> chain.
Using variables to store intermediate parts of long logical expressions is only useful if that intermedate expression has a meaningful name and purpose or the expression is repeated. Otherwise it adds clutter, and you are better off just writing the complex expression.</p>
<p><span id="id2">[<a class="reference internal" href="../zzreferences.html#id13" title="Jennifer Bauer, Janet Siegmund, Norman Peitek, Johannes C. Hofmeister, and Sven Apel. Indentation: Simply a Matter of Style or Support for Program Comprehension? In 2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC), 154–164. Montreal, QC, Canada, May 2019. IEEE. URL: https://ieeexplore.ieee.org/document/8813302/ (visited on 2022-05-19), doi:10.1109/ICPC.2019.00033.">BSP+19</a>]</span> studied indentation with eye tracking and found no statistically significant difference between 0,2,4,8 spaces. Looking at their graphs 4 spaces does seem to be a sweet spot though.</p>
<p>Another study <span id="id3">[<a class="reference internal" href="../zzreferences.html#id21" title="Raymond P.L. Buse and Westley R. Weimer. A metric for software readability. In Proceedings of the 2008 International Symposium on Software Testing and Analysis - ISSTA '08, 121. Seattle, WA, USA, 2008. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1390630.1390647 (visited on 2022-05-19), doi:10.1145/1390630.1390647.">BW08</a>]</span> identified factors for readability, in decreasing order of significance:</p>
<ul class="simple">
<li><p>fewer identifiers per line</p></li>
<li><p>shorter lines (characters)</p></li>
<li><p>fewer ‘(’ ‘{’ ‘.’ ‘,’</p></li>
<li><p>less indentation (preceding whitespace)</p></li>
<li><p>fewer keywords</p></li>
<li><p>more blank lines</p></li>
<li><p>lower maximum occurrences of any single identifier</p></li>
<li><p>shorter maximum length of identifier</p></li>
<li><p>lower maximum occurrences of any single character</p></li>
<li><p>more comments</p></li>
<li><p>fewer ‘=’  numbers spaces ‘==’ ‘&lt;’ ‘&gt;’ ‘if’ ‘for’ ‘while’</p></li>
<li><p>higher number of ‘+’ ‘*’ ‘%’ ‘/’ ‘-’</p></li>
</ul>
<p>They constructed several models using these factors, mainly a Bayesian classifier, all of which predicted average readability scores better than the human raters. But the model is not public.</p>
</section>
<section id="proportional-fonts">
<h3>Proportional fonts<a class="headerlink" href="#proportional-fonts" title="Permalink to this heading"></a></h3>
<p>For prose, a proportional fonts is more readable than monospace because it is denser and hence less eye movement is needed for reading. Spaces between words are easier to see. <span id="id4">[<a class="reference internal" href="../zzreferences.html#id10" title="Aries Arditi, Kenneth Knoblauch, and Ilana Grunwald. Reading with fixed and variable character pitch. Journal of the Optical Society of America A, 7(10):2011, October 1990. URL: https://opg.optica.org/abstract.cfm?URI=josaa-7-10-2011 (visited on 2022-05-25), doi:10.1364/JOSAA.7.002011.">AKG90</a>]</span> But proportional fonts have not caught on in programming. The main complaint is that identifiers do not line up nicely the way they do with a monospace font.</p>
<p>After reading about elastic tabstops I’ve come up with my own solution, “tablike spaces”. The idea here is to use a proportional font for rendering, but to make the spaces jump to the pixel column they would use if the font was monospaced. So rendering “a bit of text” would render “a” at 0, “bit” at 2 ems, “of” at 6 ems, and “text” at 9 ems, where an em is the width of the widest character in the font.</p>
<p>A more complex algorithm treats the text as a giant table, so “a bit of text” gets split up into 4 cells “a “, “bit “, “of “, “text” which span 2,4,3,4 columns respectively. Then the column widths are calculated using the <a class="reference external" href="https://www.w3.org/TR/CSS2/tables.html#auto-table-layout">auto table layout algorithm</a> (simplified):</p>
<ul class="simple">
<li><p>Set the width of each column to 0.</p></li>
<li><p>For each cell, calculate the width as rendered by the font, and increase the widths of the columns it spans so that together, they are at least as wide as the cell. Widen all spanned columns to be approximately the same.</p></li>
</ul>
<p>Yet more complex is to treat it as a constraint problem. The constraints consist of minimum width constraints from the width of the tokens and order constraints that specify which chunks of text are before/after/line up with other chunks. The goal is to minimize the width of the table (sum of column widths), and as a secondary objective make the widths as uniform as possible (lowest standard deviation or absolute deviation). The Cassowary algorithm might work.</p>
<p>The constraint algorithm allows aligning the ends of text by justifying, so e.g. <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">=</span></code> and <code class="docutils literal notranslate"><span class="pre">bar</span> <span class="pre">=</span></code> have the identifiers stretched to the same width. But generally it is only the start of the text that needs to be aligned.</p>
<p>TODO: test it out by modifying <a class="reference external" href="https://github.com/isral/elastic_tabstops_mono.vsce">https://github.com/isral/elastic_tabstops_mono.vsce</a></p>
<p>The advantage of tablike spaces over elastic tabstops is that the underlying text file is just indenting with spaces in a monospaced font. So it’s only the visual presentation that changes, hence it can be used on a team.</p>
</section>
</section>
<section id="familiarity">
<h2>Familiarity<a class="headerlink" href="#familiarity" title="Permalink to this heading"></a></h2>
<p>According to <a class="reference external" href="https://soc.me/languages/familiarity">this</a> the benefits of familiarity are fleeting, because once your language becomes standard people will be familiar with it anyway. This conflicts with the <a class="reference external" href="https://steveklabnik.com/writing/the-language-strangeness-budget">notion</a> of Rust’s “strangeness budget”, where a language can only be so weird before it gets discarded from consideration and can never become standard.</p>
<p>As Randomo shows, the choice of characters for operators is arbitrary. Using familiar syntax at least benefits existing programmers, while new programmers will be confused regardless.</p>
<p>But cases where newbies can benefit, such as single = for assignment and comparison, do seem worth discarding familiarity for.</p>
</section>
<section id="parsing">
<h2>Parsing<a class="headerlink" href="#parsing" title="Permalink to this heading"></a></h2>
<p>I’ve got a basic Earley algorithm working for now. But eventually I’m extending it with BSRs and layout and other fun things. There’s also <a class="reference external" href="https://github.com/attresearch/yakker">Yakker</a>, which is the most developed parser I’ve seen feature-wise. It’s only missing incremental parsing.</p>
<blockquote>
<div><p>A new parsing engine, Yakker, capable of handling the requirements of modern applications including full scannerless context-free grammars with regular expressions as right-hand sides for defining nonterminals. Yakker also includes facilities for binding variables to intermediate parse results and using such bindings within arbitrary constraints to control parsing. Yakker supports both semantic actions and speculative parsing techniques such as backtracking and context-free lookahead and several parsing back ends (including Earley, GLR and backtracking).  In addition, nonterminals may be parameterized by arbitrary values, which gives the system good modularity and abstraction properties in the presence of data-dependent parsing. Finally, legacy parsing libraries, such as sophisticated libraries for dates and times, may be directly incorporated into parser specifications.</p>
</div></blockquote>
<p>I’ve looked at various algorithms but I think the only way to handle it completely correctly and generically is to have a disambiguating pass on the set of parse tree generated by a nondeterministic automaton. The alternatives involve restricting parsers to be deterministic, for example PEGs. But PEGs have big issues with error detection and reporting, not to mention correct parsing. There’s just no information on what possible parses are available or what token is expected. Whereas with Earley you can do “Ruby slippers”: scan the sets for what they want next, output “warning: expected ‘;’ at end of statement”, and then add that to the parse forest and continue parsing with almost no overhead.</p>
<p>Treesitter implements incremental LR parsing with error recovery, but since it doesn’t support ambiguity I don’t think it’s sufficient for a compiler.</p>
<p>Revisiting this, the goal is to use partial evaluation to generate the parser, by speeding up a naive brute-force algorithm applied to the grammar. There is already a paper on LR parsing by partial evaluation <span id="id5">[<a class="reference internal" href="../zzreferences.html#id130" title="Michael Sperber and Peter Thiemann. Generation of LR parsers by partial evaluation. ACM Transactions on Programming Languages and Systems (TOPLAS), 22(2):224–264, March 2000. URL: http://dl.acm.org/doi/10.1145/349214.349219 (visited on 2020-06-15), doi:10.1145/349214.349219.">ST00</a>]</span> and also on specializing Earley, so with sufficiently powerful compiler optimization handling general grammars should be possible.</p>
<p>In particular the parser should be written as a nondeterministic finite state transducer that builds up trees (outputs a list in the style of start-children-end or S-expressions or something).</p>
<p>Formally:</p>
<ul class="simple">
<li><p>Q is a finite set, the set of states;</p></li>
<li><p>I is a subset of Q, the set of initial states;</p></li>
<li><p>F is a subset of Q, the set of final states; and</p></li>
<li><p>Σ is a finite set, called the input alphabet;</p></li>
<li><p>Γ is a finite set, called the output alphabet;</p></li>
<li><p>The transition function is of type <span class="math notranslate nohighlight">\(Q \times (\Sigma \cup \{\epsilon \})\to P(Q \times (\Gamma \cup \{\epsilon \}))\)</span>, where ε is the empty string and P(Q) denotes the power set of Q.</p></li>
</ul>
<p>TODO: match this up with Parsec, attoparsec, trifecta, etc. the syntax should be similar except with nondeterministic choice <code class="docutils literal notranslate"><span class="pre">|</span></code>.</p>
</section>
<section id="blocks">
<h2>Blocks<a class="headerlink" href="#blocks" title="Permalink to this heading"></a></h2>
<p>Blocks are inspired by Haskell’s do notation. For an example of how natural this is you can look at <a class="reference internal" href="State.html#tasks"><span class="std std-ref">how I/O works</span></a>. Since codensity/continuations are the mother of all monads, we don’t lose anything by fixing the monadic operations in the do-notation to be the continuation monad operations.</p>
<p>Using the continuation monad allows us to separate commands (not returning a value) and operations (returning a value). Haskell has the translation <code class="docutils literal notranslate"><span class="pre">{e;stmts}</span> <span class="pre">=</span> <span class="pre">e</span> <span class="pre">&gt;&gt;</span> <span class="pre">stmts</span> <span class="pre">=</span> <span class="pre">\c</span> <span class="pre">-&gt;</span> <span class="pre">e</span> <span class="pre">(\_</span> <span class="pre">-&gt;</span> <span class="pre">{stmts}</span> <span class="pre">c)</span></code>. But usually <code class="docutils literal notranslate"><span class="pre">e</span></code> returns <code class="docutils literal notranslate"><span class="pre">()</span></code>, so <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> is applied at the type <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span></code> and that <code class="docutils literal notranslate"><span class="pre">\_</span></code> is a <code class="docutils literal notranslate"><span class="pre">\()</span></code>. With our translation, commands (which don’t return a value) are functions <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>. Haskell’s translation would require them to be <code class="docutils literal notranslate"><span class="pre">Cont</span> <span class="pre">r</span> <span class="pre">()</span> <span class="pre">=</span> <span class="pre">(()</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>, which is equivalent but has an extra <code class="docutils literal notranslate"><span class="pre">()</span></code> floating around. But in both translations operations (whose value is used) are of type <code class="docutils literal notranslate"><span class="pre">Cont</span> <span class="pre">r</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>. The non-uniform type for actions might make copying code from Haskell a little harder, but on the other hand we get function composition as a built-in syntax. That’s right, the most basic operation in category theory is available as syntactic sugar in Stroscot. Take that, Haskell. And also we can easily use indexed monads, just change <code class="docutils literal notranslate"><span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code> to <code class="docutils literal notranslate"><span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">s</span></code>.</p>
<section id="applicativedo">
<h3>ApplicativeDo<a class="headerlink" href="#applicativedo" title="Permalink to this heading"></a></h3>
<p>ApplicativeDo <span id="id6">[<a class="reference internal" href="../zzreferences.html#id91" title="Simon Marlow, Simon Peyton Jones, Edward Kmett, and Andrey Mokhov. Desugaring Haskell's do-notation into applicative operations. In Proceedings of the 9th International Symposium on Haskell, Haskell 2016, 92–104. New York, NY, USA, September 2016. Association for Computing Machinery. URL: https://doi.org/10.1145/2976002.2976007 (visited on 2021-07-16), doi:10.1145/2976002.2976007.">MPJKM16</a>]</span> has two functions. The first is to make some do-notation sequences be Applicative rather than Monad. In fact though these are exactly the sequences handled by idiom brackets, of the form <code class="docutils literal notranslate"><span class="pre">{a</span> <span class="pre">&lt;-</span> <span class="pre">ax;</span> <span class="pre">b</span> <span class="pre">&lt;-</span> <span class="pre">bx;</span> <span class="pre">return</span> <span class="pre">(f</span> <span class="pre">a</span> <span class="pre">b)}</span> <span class="pre">=</span> <span class="pre">return</span> <span class="pre">(f</span> <span class="pre">!a</span> <span class="pre">!b)</span></code>. Idiom brackets are shorter, so the value this provides is minimal.</p>
<p>The second function is to use applicative operations instead of monadic operations because in “some” monads the applicative operation is more efficient. Their example is the Haxl DSL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">numCommonFriends</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Id</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Id</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Haxl</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">numCommonFriends</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">fx</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">friendsOf</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">  </span><span class="n">fy</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">friendsOf</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="p">(</span><span class="n">intersect</span><span class="w"> </span><span class="n">fx</span><span class="w"> </span><span class="n">fy</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>Well, if you’re writing a DSL then writing it as a macro is much more powerful than trying to shoehorn it into an applicative/monadic framework. They discuss in the paper that the translation to use applicative operations is ambiguous and the best one depends on details of the computation that are not accessible, because functions are opaque. It’s exactly these kinds of details that <em>are</em> accessible in a DSL - you just write a pass that walks over the expression tree and estimates the costs. Similarly the <a class="reference external" href="https://en.wikipedia.org/wiki/Use-define_chain">use/def analysis</a> that they use for the rewriting is a standard compiler pass. The commutativity mentioned in the paper is another property one could know from the DSL and that changes the output significantly.</p>
<p>For regular do notation with continuations, the applicative notation translates to exactly the same functions as the monadic notation.</p>
<p>Verdict: DSL in disguise. Just write a DSL. Stroscot does not benefit at all by adding ApplicativeDo.</p>
</section>
<section id="recursivedo">
<h3>RecursiveDo<a class="headerlink" href="#recursivedo" title="Permalink to this heading"></a></h3>
<p>RecursiveDo <span id="id7">[<a class="reference internal" href="../zzreferences.html#id49" title="Levent Erkok. Value Recursion in Monadic Computations. PhD thesis, Oregon Health and Science University, October 2002. URL: http://leventerkok.github.io/papers/erkok-thesis.pdf.">Erk02</a>]</span> is an older extension to do notation. The motivating example is a circuit DSL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">toggle</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Signal</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">toggle</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">out</span><span class="w"></span>
<span class="w">   </span><span class="kr">where</span><span class="w"></span>
<span class="w">      </span><span class="n">inp</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">inv</span><span class="w"> </span><span class="n">out</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">delay</span><span class="w"> </span><span class="kt">False</span><span class="w"> </span><span class="n">inp</span><span class="w"></span>

<span class="nf">counter</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">Signal</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Signal</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">counter</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">out</span><span class="w"></span>
<span class="w">   </span><span class="kr">where</span><span class="w"></span>
<span class="w">      </span><span class="n">next</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">delay</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">inc</span><span class="w"></span>
<span class="w">      </span><span class="n">inc</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mux</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="n">next</span><span class="w"></span>
<span class="w">      </span><span class="n">zero</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
</div>
<p>But wait, where’s the do notation? In fact, this is really just a DSL. There are no monads and no sequencing to be found. All of these operations happen in parallel. The uses for these circuit descriptions all depend on the circuits being specified using a small set of operations specified in a typeclass.</p>
<p>Investigating Hackage, mdo is uncommon. “Many Haskell programmers will never use it in their careers.” (<a class="reference external" href="https://ro-che.info/articles/2015-09-02-monadfix">1</a>) Uses fall into categories:
* DSLs, where variable assignments are interpreted as data
* Gratuitous (no/one binding, or bindings do not refer to bindings from later)
* Examples where it would be clearer to use mfix or the do-rec notation that is just <code class="docutils literal notranslate"><span class="pre">(a,b,c)</span> <span class="pre">&lt;-</span> <span class="pre">mfix</span> <span class="pre">(\(a,b,c)</span> <span class="pre">-&gt;</span> <span class="pre">(_,_,_))</span></code>
* I/O monad, mfix is used to write the code in a recursive style instead of modifying a variable, e.g. forking two threads that kill each other:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mdo</span><span class="w"></span>
<span class="w">   </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">killThread</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">   </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">killThread</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="c1">-- vs</span><span class="w"></span>
<span class="nf">bId</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">newEmptyMVar</span><span class="w"></span>
<span class="nf">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">readMVar</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">killThread</span><span class="w"></span>
<span class="nf">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">killThread</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">writeMVar</span><span class="w"> </span><span class="n">bId</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>The code for IO’s mfix uses unsafeDupableInterleaveIO. This has been the subject of at least one <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/issues/5421">bug</a> (<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/issues/15349">two</a> counting fixST), and is why there is both fixIO and <a class="reference external" href="https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO-Unsafe.html#v:unsafeFixIO">unsafeFixIO</a>. Reasoning about fixIO seems to <a class="reference external" href="https://wiki.haskell.org/Evaluation_order_and_state_tokens">require</a> laziness semantics and maybe also an understanding of Haskell’s State-based I/O model.</p>
<p>Also, most monads fail to satisfy monadic right shrinking, which IMO makes the notation completely unintuitive:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mdo</span><span class="w"></span>
<span class="w">   </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">z</span><span class="w"></span>
<span class="w">   </span><span class="n">w</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">z</span><span class="w"></span>
<span class="w">   </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="w"></span>

<span class="c1">-- is NOT equivalent to</span><span class="w"></span>

<span class="nf">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mdo</span><span class="w"></span>
<span class="w">         </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">z</span><span class="w"></span>
<span class="w">         </span><span class="n">return</span><span class="w"> </span><span class="n">z</span><span class="w"></span>
<span class="nf">w</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">z</span><span class="w"></span>
<span class="nf">return</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The only price to pay for leaving mdo out is that value-recursive monadic computations have to be written with <code class="docutils literal notranslate"><span class="pre">mfix</span></code> or its tuple-heavy cousin <code class="docutils literal notranslate"><span class="pre">rec{}</span></code>. We can still implement <code class="docutils literal notranslate"><span class="pre">mfix</span></code> for the monads that matter, like <code class="docutils literal notranslate"><span class="pre">State</span></code>. According to all available knowledge, <code class="docutils literal notranslate"><span class="pre">mfix</span></code> can’t be implemented for continuations, so nothing is lost from regular programs.</p>
<p>Verdict: Not only a DSL in disguise, but also a footgun. mfix and the rec{} notation are better for those who care.</p>
</section>
<section id="arrows">
<h3>Arrows<a class="headerlink" href="#arrows" title="Permalink to this heading"></a></h3>
<p>You might be getting the pattern here. Arrows were inspired by a parsing DSL. Any arrow which supports the ArrowApply class is a monad. Arrows not supporting ArrowApply must write operations for every language element supported (variable, function, conditional, grammar production choice, and so on). Continuations require ArrowApply to even implement the basic arrow interface. Verdict: trash, a leaky “abstraction” that just wastes everyone’s time.</p>
</section>
<section id="idiom-brackets">
<h3>Idiom brackets<a class="headerlink" href="#idiom-brackets" title="Permalink to this heading"></a></h3>
<p>While do notation is defined for monads, idiom brackets are defined for applicative functors, <code class="docutils literal notranslate"><span class="pre">[[</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">]]</span> <span class="pre">=</span> <span class="pre">pure</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">a</span> <span class="pre">&lt;*&gt;</span> <span class="pre">b</span></code>. But DSL notation works too: <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">{</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">}</span></code>.</p>
<p>The issue with translating to <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> is that it assumes left-to-right evaluation. You can see this in the <a class="reference external" href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Applicative.html#t:Applicative">translation</a> for Monads: <code class="docutils literal notranslate"><span class="pre">m1</span> <span class="pre">&lt;*&gt;</span> <span class="pre">m2</span></code> binds <code class="docutils literal notranslate"><span class="pre">m1</span></code> before <code class="docutils literal notranslate"><span class="pre">m2</span></code>. In Stroscot the program is required to be equivalent under all evaluation orders. So to enforce this we need a function <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">:</span> <span class="pre">[m</span> <span class="pre">a]</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">[a]</span></code> that checks there is no issue with evaluating in parallel. Then using parallel the translation of <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">{</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">x</span> <span class="pre">}</span></code> looks like <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">(av,bv,cv)</span> <span class="pre">=</span> <span class="pre">parallel</span> <span class="pre">(a,b,c);</span> <span class="pre">return</span> <span class="pre">(f</span> <span class="pre">av</span> <span class="pre">bv</span> <span class="pre">cv)</span> <span class="pre">}</span></code></p>
<p>Idris defines <a class="reference external" href="http://docs.idris-lang.org/en/latest/tutorial/interfaces.html#notation">!-notation</a>, “implicitly bound application”. The scoping is <a class="reference external" href="https://github.com/idris-lang/Idris-dev/issues/4395">unintuitive</a>, but the notation itself is powerful. Binding it to a syntactic block seems reasonable. And it can easily express idiom brackets, <code class="docutils literal notranslate"><span class="pre">[[</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">]]</span></code> becomes <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">f</span> <span class="pre">!a</span> <span class="pre">!b</span> <span class="pre">}</span></code>. Idiom brackets save characters with more arguments, but bang notation looks natural if there are multiple bindings in the block.</p>
</section>
<section id="c-like-reference-access">
<h3>C-like reference access<a class="headerlink" href="#c-like-reference-access" title="Permalink to this heading"></a></h3>
<p>For example we want to do:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="nf">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">a</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
</pre></div>
</div>
<p>Translated this looks like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ref</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="nf">\</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="nf">ref</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="nf">\</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="nf">parallel</span><span class="w"> </span><span class="p">(</span><span class="n">read</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="nf">\</span><span class="p">(</span><span class="n">av</span><span class="p">,</span><span class="n">bv</span><span class="p">)</span><span class="w">  </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="kr">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">av</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bv</span><span class="w"> </span><span class="kr">in</span><span class="w"></span>
<span class="nf">writeRef</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
</pre></div>
</div>
<p>I think the solution is another DSL. Inserting <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">a</span></code> is not too complicated, just follow the C/C++ rules about converting lvalues to rvalues.</p>
</section>
</section>
<section id="assignment">
<h2>Assignment<a class="headerlink" href="#assignment" title="Permalink to this heading"></a></h2>
<p>As a syntax ambiguity, there are two different interpretations of assignment, pattern binding and clause definition. The difference:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pair</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="kt">B</span><span class="w"></span>

<span class="o">#</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="n">clauses</span><span class="w"></span>
<span class="nf">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="nf">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="o">--&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="o">#</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">clause</span><span class="w"> </span><span class="n">definition</span><span class="w"></span>
<span class="p">(,)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">pair</span><span class="w"></span>
<span class="o">--&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="n">reduces</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">reduces</span><span class="w"> </span><span class="n">cyclically</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">itself</span><span class="w"></span>
</pre></div>
</div>
<p>Clearly the pattern binding is more useful here. So we have a basic convention for assignments: if the head of the LHS is a constructor symbol then it’s a pattern binding. What is a constructor symbol? Well, it’s up to the code, defined by the predicate <code class="docutils literal notranslate"><span class="pre">isConstructor</span></code>. Most symbols are not constructors, so the ones that are constructors are declared with <code class="docutils literal notranslate"><span class="pre">isConstructor</span> <span class="pre">sym</span> <span class="pre">=</span> <span class="pre">true</span></code>  or the macro declaration <code class="docutils literal notranslate"><span class="pre">constructor</span> <span class="pre">sym</span></code>.</p>
<p>Assignment pattern bindings are irrefutable, meaning they never fail directly and instead define unevaluated variables that will raise pattern matching exceptions when evaluated. But there is an alternative syntax that allows failure as a control operation (from Idris / Inko):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pat</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">&lt;</span><span class="n">alternatives</span><span class="o">&gt;</span><span class="w"></span>
<span class="nf">p</span><span class="w"></span>
</pre></div>
</div>
<p>is desugared to</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">  </span><span class="n">pat</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">p</span><span class="w"></span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">alternatives</span><span class="o">&gt;</span><span class="w"></span>
</pre></div>
</div>
<p>If a clause does not match, the expression does not reduce - there is no error at all.</p>
<p>In the case of a simple variable <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">...</span></code> the definitions coincide - the end result is a clause definition.</p>
<p>Another way to resolve the ambiguity is to use separate syntaxes, e.g. to use <code class="docutils literal notranslate"><span class="pre">(x,y)</span> <span class="pre">&lt;-</span> <span class="pre">pair</span></code> for pattern bindings. But remembering to switch between pattern bindings and clause definitions is tedious.</p>
<p>The explicit syntax does allow defining new reduction rules for constructors. But if overriding basic syntax is desired, <code class="docutils literal notranslate"><span class="pre">isConstructor</span></code> can be locally overridden, e.g. if we want a sorted pair:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">isConstructor</span><span class="w"> </span><span class="p">(,)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">false</span><span class="w"></span>
</pre></div>
</div>
<p>Usually it’s more natural to use a new symbol, like <code class="docutils literal notranslate"><span class="pre">sortedPair</span> <span class="pre">(x,y)</span></code>, so that the global definition of pairs is not affected.</p>
<section id="constructor-discipline">
<h3>Constructor discipline<a class="headerlink" href="#constructor-discipline" title="Permalink to this heading"></a></h3>
<p>Haskell has a division between constructors and functions:
* identifiers starting with lowercase letters are functions, and can only be used with function bindings.
* identifiers starting with uppercase letters are constructors, and assignments of the form <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">...</span></code> are pattern bindings.</p>
<p>This rule reduces maintainability. If the representation is changed there is no way to replace the dumb constructor with a smart constructor. So instead libraries are littered with boilerplate pseudo-constructors like <code class="docutils literal notranslate"><span class="pre">mkThing</span> <span class="pre">=</span> <span class="pre">Thing</span></code> to get around this syntactic restriction. In fact in <span id="id8">[<a class="reference internal" href="../zzreferences.html#id75" title="Stefan Kahrs and Connor Smith. Non-Omega-Overlapping TRSs are UN. In Delia Kesner and Brigitte Pientka, editors, 1st International Conference on Formal Structures for Computation and Deduction (FSCD 2016), volume 52 of Leibniz International Proceedings in Informatics (LIPIcs), 22:1–22:17. Dagstuhl, Germany, 2016. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik. URL: http://drops.dagstuhl.de/opus/volltexte/2016/5996 (visited on 2021-09-11), doi:10.4230/LIPIcs.FSCD.2016.22.">KS16</a>]</span> there is a boilerplate trick to turn any TRS into a constructor TRS, by duplicating <code class="docutils literal notranslate"><span class="pre">foo</span></code> into a constructor <code class="docutils literal notranslate"><span class="pre">Foo</span></code> and a function <code class="docutils literal notranslate"><span class="pre">foo</span></code>, converting subterms of the original rules to match on constructors, and adding rules that turn stuck patterns into constructors. For example <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">x;</span> <span class="pre">s</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">(x</span> <span class="pre">z)</span> <span class="pre">(y</span> <span class="pre">z)</span></code> turns into:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">app</span><span class="w"> </span><span class="p">(</span><span class="kt">App</span><span class="w"> </span><span class="kt">K</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="nf">app</span><span class="w"> </span><span class="kt">K</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">App</span><span class="w"> </span><span class="kt">K</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="nf">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">K</span><span class="w"></span>

<span class="nf">app</span><span class="w"> </span><span class="p">(</span><span class="kt">App</span><span class="w"> </span><span class="p">(</span><span class="kt">App</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">(</span><span class="n">app</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">app</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"></span>
<span class="nf">app</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">App</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="nf">app</span><span class="w"> </span><span class="p">(</span><span class="kt">App</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">App</span><span class="w"> </span><span class="p">(</span><span class="kt">App</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="nf">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">S</span><span class="w"></span>
</pre></div>
</div>
<p>This is pretty verbose but it’s curried so it isn’t as bad as it could be. For rules like associativity <code class="docutils literal notranslate"><span class="pre">x*(y*z)</span> <span class="pre">=</span> <span class="pre">(x*y)*z</span></code> and distributivity <code class="docutils literal notranslate"><span class="pre">x*(y+z)</span> <span class="pre">=</span> <span class="pre">x*y+x*z</span></code> handling all the stuck pattern rules for symbols <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">*</span></code> is a nightmare, and you also have to come up with alternative operator names for the constructors.</p>
<p>So Stroscot follows Pure in not having a constructor discipline. By appropriately setting <code class="docutils literal notranslate"><span class="pre">isConstructor</span> <span class="pre">=</span> <span class="pre">true</span></code> any symbol can be used as a constructor pattern on the left-hand side of an equation. Also any symbol may act as a constructor symbol in a value if it happens to occur in head position in a normal form term, regardless of <code class="docutils literal notranslate"><span class="pre">isConstructor</span></code>.</p>
<p>There is a general convention for the standard library to use lowercase for potentially reducible expressions or “smart” constructors and uppercase for dumb data constructors. This is to vaguely follow Haskell.</p>
</section>
<section id="recursive-definitions">
<h3>Recursive definitions<a class="headerlink" href="#recursive-definitions" title="Permalink to this heading"></a></h3>
<p>We want to support mutually recursive definitions, like so:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="nf">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>And also sequential execution, like so:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">openFile</span><span class="w"> </span><span class="s">&quot;a.txt&quot;</span><span class="w"></span>
<span class="nf">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">openFile</span><span class="w"> </span><span class="s">&quot;b.txt&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>And also shadowing variables, like so:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="c1">-- interpreted as</span><span class="w"></span>
<span class="nf">a_new</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">a_old</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>In the recursive version <code class="docutils literal notranslate"><span class="pre">c</span></code> can be in scope in the body of <code class="docutils literal notranslate"><span class="pre">b</span></code> even though it is defined later. Presumably it isn’t in scope in the sequential version.</p>
<p>In the recursive version <code class="docutils literal notranslate"><span class="pre">a</span></code> is in scope in its own body. In the shadowing version <code class="docutils literal notranslate"><span class="pre">a</span></code> is not.</p>
<p>Resolving this probably means a special syntax for something. Choices:
* <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;-</span> <span class="pre">openFile</span> <span class="pre">&quot;a.txt&quot;</span></code> for sequenced actions
* <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;-</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">1</span></code> for shadowing
* <code class="docutils literal notranslate"><span class="pre">rec</span> <span class="pre">{</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">}</span></code> for recursive definitions</p>
<p>Generally sequential blocks do not use recursion. But recursion is used all the time at the module/function level.</p>
</section>
</section>
<section id="type-declarations">
<h2>Type declarations<a class="headerlink" href="#type-declarations" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">:</span> <span class="pre">s8</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">s8</span> <span class="pre">2</span></code> seem more logical compared to other choices such as <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">s8</span> <span class="pre">=</span> <span class="pre">2</span></code> (Swift,Jai - hard to find the = with long types) or <code class="docutils literal notranslate"><span class="pre">s8</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">2</span></code> (C,Rust - overlaps with function definition). The name is simply a syntactic handle to refer to the value; it doesn’t have an innate type. In contrast the representation of the value must be specified to compile the program. The second syntax <code class="docutils literal notranslate"><span class="pre">s8</span> <span class="pre">2</span></code> is similar to assembler syntax such as <code class="docutils literal notranslate"><span class="pre">dword</span> <span class="pre">0</span></code>.</p>
<p><a class="reference external" href="https://soc.me/languages/type-annotations">This</a> says name should be ahead of type annotation, which only <code class="docutils literal notranslate"><span class="pre">s8</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">2</span></code> breaks. The consistency stuff is not relevant.</p>
</section>
<section id="namespacing">
<h2>Namespacing<a class="headerlink" href="#namespacing" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">.</span></code> is preferred to <code class="docutils literal notranslate"><span class="pre">::</span></code> because it’s shorter and because modules are first-class. And as in Go, no <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>, always <code class="docutils literal notranslate"><span class="pre">.</span></code>.</p>
</section>
<section id="partial-loading">
<h2>Partial loading<a class="headerlink" href="#partial-loading" title="Permalink to this heading"></a></h2>
<p>The parser parses as much of the input as possible, but in general only a prefix of the input will be valid. Hence we can load a portion of the file by inserting junk / truncating the input buffer. The compiler will give a warning but the parser should handle it just fine.</p>
</section>
<section id="specificity">
<h2>Specificity<a class="headerlink" href="#specificity" title="Permalink to this heading"></a></h2>
<p>This might seem overly complicated, but it’s based on Zarf’s <a class="reference external" href="https://eblong.com/zarf/rule-language.html">rule-based programming</a>. When you’re defining lots of rules for a IF game then specifying priorities by hand is tedious.</p>
</section>
<section id="comments">
<h2>Comments<a class="headerlink" href="#comments" title="Permalink to this heading"></a></h2>
<p>Analysis of languages showed C-style comments <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span></code> and C++ style comments <code class="docutils literal notranslate"><span class="pre">//</span></code> are very common. In addition Pascal-style nesting multiline comments <code class="docutils literal notranslate"><span class="pre">(*</span> <span class="pre">*)</span></code> seem useful. Supporting shebang comments at the beginning of a file complicates the syntax a bit but makes the language easier to use for scripting. But the frequency of <code class="docutils literal notranslate"><span class="pre">#</span></code> is still less than <code class="docutils literal notranslate"><span class="pre">//</span></code> so it’s not usable for normal comments.</p>
<p>Javadoc-style comments <code class="docutils literal notranslate"><span class="pre">/**</span> <span class="pre">*/</span></code> are used in very clear stylized ways, so there seems to be no reason to forbid them.</p>
<p>People put comments in random places and they can be attached to whatever and indented strangely. The reformatter will mangle them, but hopefully this will become accepted behavior.</p>
</section>
<section id="whitespace">
<h2>Whitespace<a class="headerlink" href="#whitespace" title="Permalink to this heading"></a></h2>
<p>Whitespace in identifiers… this doesn’t work well with Haskell syntax. With whitespace <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">something</span> <span class="pre">=</span> <span class="pre">...`</span></code> would define the identifier <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">something</span></code>, but in Haskell it’s a clause <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">_</span></code> that binds <code class="docutils literal notranslate"><span class="pre">something</span></code>.</p>
<p>OTOH using a string works fine: <code class="docutils literal notranslate"><span class="pre">&quot;do</span> <span class="pre">something&quot;</span> <span class="pre">=</span> <span class="pre">...</span></code></p>
<p>You could also make something an atom, then you can write <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">something</span></code> in code but the clause definition is <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">^something</span> <span class="pre">=</span> <span class="pre">...</span></code>. The semantics are similar to a single identifier but different enough that I don’t think it counts.</p>
<p>Indentation-sensitivty like Python seems great. It is readable and when copy-pasting code you only have to fix up the indentation by moving the block left/right (supported by all modern code editors) instead of messing with braces.</p>
<p>Haskell’s layout rules seem overly restrictive, for example this is not allowed:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">bang_upper</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bang</span><span class="w"> </span><span class="p">(</span><span class="kt">Rule</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="kt">Sequent</span><span class="w"> </span><span class="n">newcut_bseq</span><span class="w"> </span><span class="p">(</span><span class="n">bl_tlnotn</span><span class="o">++</span><span class="n">brl_bl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">bl_tmain</span><span class="p">,</span><span class="w"> </span><span class="n">bl_tr</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">brl_br</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="kt">Sequent</span><span class="w"> </span><span class="n">bl_bseq</span><span class="w"> </span><span class="p">(</span><span class="n">bl_blnotn</span><span class="o">++</span><span class="n">br_bl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">bl_bmain</span><span class="p">,</span><span class="w"> </span><span class="n">bl_br</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">br_br</span><span class="p">))))</span><span class="w"></span>
</pre></div>
</div>
<p>Although the parentheses make this unambiguous, Haskell requires indenting a lot more, past the <code class="docutils literal notranslate"><span class="pre">=</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">bang_upper</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Bang</span><span class="w"> </span><span class="p">(</span><span class="kt">Rule</span><span class="w"></span>
<span class="w">                  </span><span class="p">(</span><span class="kt">Sequent</span><span class="w"> </span><span class="p">(</span><span class="n">fst</span><span class="w"> </span><span class="n">bl_tseq</span><span class="p">,</span><span class="w"> </span><span class="n">newcut_bseq</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">bl_tlnotn</span><span class="o">++</span><span class="n">brl_bl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">bl_tmain</span><span class="p">,</span><span class="w"> </span><span class="n">bl_tr</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">brl_br</span><span class="p">))</span><span class="w"></span>
<span class="w">                  </span><span class="p">(</span><span class="kt">Sequent</span><span class="w"> </span><span class="n">bl_bseq</span><span class="w"> </span><span class="p">(</span><span class="n">bl_blnotn</span><span class="o">++</span><span class="n">br_bl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">bl_bmain</span><span class="p">,</span><span class="w"> </span><span class="n">bl_br</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">br_br</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="braces-and-brackets">
<h2>Braces and brackets<a class="headerlink" href="#braces-and-brackets" title="Permalink to this heading"></a></h2>
<p>Haskell uses parentheses for most grouping, <code class="docutils literal notranslate"><span class="pre">{}</span></code> for replacing whitespace with explicit syntax, <code class="docutils literal notranslate"><span class="pre">[]</span></code> for lists, and has no special meaning for angle brackets.</p>
<p><a class="reference external" href="https://soc.me/languages/stop-using-angle-brackets-for-generics">This</a> argues for square brackets <code class="docutils literal notranslate"><span class="pre">[]</span></code> over angle brackets <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code> for generics. With Haskell syntax this is moot because parentheses suffices. But he argues collection literals and array lookup should use standard parentheses <code class="docutils literal notranslate"><span class="pre">()</span></code> instead of special syntax, because it will become dead weight once the standard library develops better data structures.</p>
<p>Seems a bit weird, he cites Python as an example but Python still uses list literals: the syntax for a NumPy array is <code class="docutils literal notranslate"><span class="pre">np.array([1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5])</span></code>. The only thing overloaded is access <code class="docutils literal notranslate"><span class="pre">arr[i]</span> <span class="pre">=</span> <span class="pre">x</span></code>.</p>
</section>
<section id="function-syntax">
<h2>Function syntax<a class="headerlink" href="#function-syntax" title="Permalink to this heading"></a></h2>
<p>Stroscot has first-class functions with lexically scoped name binding.</p>
<p>Lambdas are defined using whatever syntax. The <code class="docutils literal notranslate"><span class="pre">\x.y</span></code> style is closest to the mathematical notation (barring Unicode), Haskell uses <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">y</span></code>, Cliff likes <code class="docutils literal notranslate"><span class="pre">{x</span> <span class="pre">=&gt;</span> <span class="pre">y}</span></code>.</p>
<p>APL-style functions/operators <code class="docutils literal notranslate"><span class="pre">(~R∊R∘.×R)/R←1↓⍳R</span></code> are not preferred due to Unicode overuse, preferring operators written with words instead, but one could create them if desired.</p>
<p>Conceptually, term rewriting is the underlying model of computation.</p>
<section id="arguments">
<h3>Arguments<a class="headerlink" href="#arguments" title="Permalink to this heading"></a></h3>
<p>Stroscot supports many types of arguments. Functions are extremely common, so the more styles supported,
the shorter the code will be.</p>
<p>Equations are tried in the order in which they are written; as soon as the left-hand side of an equation matches (and the condition part of the equation, if any, is satisfied), it can be applied to reduce the target term to the corresponding right-hand side. The term is rewritten until no more equations are applicable.</p>
</section>
<section id="currying">
<h3>Currying<a class="headerlink" href="#currying" title="Permalink to this heading"></a></h3>
<p>Currying makes all functions symbols of order 0 and allows easy partial function application.
Partial function application allows reusing functions more easily, e.g. as the argument to map.
Function symbols also become first-class, because they can be passed around without being applied, <code class="docutils literal notranslate"><span class="pre">f</span></code> vs <code class="docutils literal notranslate"><span class="pre">\x.</span> <span class="pre">f</span> <span class="pre">x</span></code></p>
</section>
<section id="call-syntax">
<h3>Call syntax<a class="headerlink" href="#call-syntax" title="Permalink to this heading"></a></h3>
<p>There are a few ways to write function calls:
* Curried style: <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(g</span> <span class="pre">a</span> <span class="pre">1)</span> <span class="pre">(h</span> <span class="pre">b</span> <span class="pre">2)</span></code>
* Lisp style: <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">(g</span> <span class="pre">a</span> <span class="pre">1)</span> <span class="pre">(h</span> <span class="pre">b</span> <span class="pre">2))</span></code>
* C style: <code class="docutils literal notranslate"><span class="pre">f(g(a,1),h(b,2))</span></code>
* C with spaces style: <code class="docutils literal notranslate"><span class="pre">f(g(a</span> <span class="pre">1)</span> <span class="pre">h(b</span> <span class="pre">2))</span></code>
* Coffeescript: <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(g</span> <span class="pre">a</span> <span class="pre">1),</span> <span class="pre">(h</span> <span class="pre">b</span> <span class="pre">2)</span></code>
* Postfix: <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">b</span> <span class="pre">h</span> <span class="pre">1</span> <span class="pre">a</span> <span class="pre">g</span> <span class="pre">f</span></code>
* Postfix with argument counts: <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">b</span> <span class="pre">2</span> <span class="pre">h</span> <span class="pre">1</span> <span class="pre">a</span> <span class="pre">2</span> <span class="pre">g</span> <span class="pre">2</span> <span class="pre">f</span></code>
* Explicit call, C: <code class="docutils literal notranslate"><span class="pre">call(f,call(g,a,1),call(h,b,2))</span></code>
* Explicit call, curried: <code class="docutils literal notranslate"><span class="pre">call</span> <span class="pre">f</span> <span class="pre">(call</span> <span class="pre">g</span> <span class="pre">a</span> <span class="pre">1)</span> <span class="pre">(call</span> <span class="pre">h</span> <span class="pre">b</span> <span class="pre">2)</span></code></p>
<p>Comparing character counts, postfix is 13, C is 16, and curried is 17. For a simple function application <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code> curried is shorter by one character than C (more if you add a space after the comma like <code class="docutils literal notranslate"><span class="pre">f(a,</span> <span class="pre">b)</span></code>, as is common) and the spaces are easier to type. Curried loses in character count only if you have a pattern like <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(a)</span> <span class="pre">(b)</span> <span class="pre">(c)</span></code> where all the expressions need parentheses. The curried style still allows passing a tuple and matching the C syntax.</p>
<p>Lisp is curried with extra parentheses. Coffeescript is curried with extra commas. Explicit call C is curried style with call inserted before parentheses and commas instead of spaces. Explicit call curried is curried with call inserted before functions. Postfix is pretty much unreadable so I’m ignoring it. So the two main contenders are curried and C.</p>
<p>The C style is incredibly common, whereas curried is only used by functional languages like Haskell and OCaml. But I’m still going with curried for now, because:</p>
<p>Arguments: (<a class="reference external" href="https://www.reddit.com/r/ProgrammingLanguages/comments/jde9xp/advantages_of_currying_in_a_programming_language/">Reddit thread</a>)
* Curried is more readable - the spaces and parentheses have more vertical variation compared to commas
* Curried is pretty simple, only a bit more complex than S-expressions
* Curried is good for writing curried functions. In contrast the C style makes it inconvenient to use curried functions, you have to write lots of parentheses <code class="docutils literal notranslate"><span class="pre">f(1)(2)(3)</span></code>. Also comparing <code class="docutils literal notranslate"><span class="pre">any</span> <span class="pre">(==</span> <span class="pre">x)</span> <span class="pre">l</span></code> and <code class="docutils literal notranslate"><span class="pre">any(\y</span> <span class="pre">-&gt;</span> <span class="pre">y</span> <span class="pre">==</span> <span class="pre">x,l)</span></code>, in the C style the comma is almost unnoticeable and the syntax is ambiguous as it could be grouped <code class="docutils literal notranslate"><span class="pre">(x,l)</span></code>
* Curried style still allows tuples as arguments, pretty much matching the C style. In contrast the C style forces a tuple even if the combination of arguments doesn’t represent a meaningful idea.</p>
<p>The main question is which style makes it easier to match parentheses - mismatching is a common novice programming error. <span id="id9">[<a class="reference internal" href="../zzreferences.html#id128" title="Jeremy Singer and Blair Archibald. Functional Baby Talk: Analysis of Code Fragments from Novice Haskell Programmers. Electronic Proceedings in Theoretical Computer Science, 270:37–51, May 2018. URL: http://arxiv.org/abs/1805.05126v1 (visited on 2022-05-23), doi:10.4204/EPTCS.270.3.">SA18</a>]</span> Also error messages for accidental partial application are important. TODO: test or survey some novice programmers later on</p>
</section>
<section id="implicit-arguments">
<h3>Implicit arguments<a class="headerlink" href="#implicit-arguments" title="Permalink to this heading"></a></h3>
<p>Claim: Explicit argument passing cannot replace implicit arguments</p>
<p>See example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- standard library</span><span class="w"></span>
<span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="n">priority</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">loglevel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">logPrint</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="c1">-- components of an application</span><span class="w"></span>
<span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">priority</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">DEBUG</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="s">&quot;bar&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">priority</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">WARNING</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="n">baz</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="w"></span>
<span class="w">  </span><span class="n">bar</span><span class="w"></span>

<span class="c1">-- main file</span><span class="w"></span>
<span class="w"> </span><span class="n">logPrint</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">writeFile</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"></span>
<span class="w"> </span><span class="n">loglevel</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">WARNING</span><span class="w"></span>

<span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">   </span><span class="n">baz</span><span class="w"></span>
<span class="w">   </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span><span class="n">loglevel</span><span class="ow">=</span><span class="kt">DEBUG</span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="n">bar</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">loglevel</span></code> is defined at the top level, but each use site is scattered in the code. The implicit argument replaces the global variable that is often used. Similarly <code class="docutils literal notranslate"><span class="pre">logPrint</span></code> is passed implicitly instead of being a member of a global Logger instance. The <code class="docutils literal notranslate"><span class="pre">file</span></code> variable does not exist in the standard library; it is part of the user’s code.</p>
<p>To use explicit argument passing, we’d have to add explicit <code class="docutils literal notranslate"><span class="pre">loglevel</span></code> and <code class="docutils literal notranslate"><span class="pre">logPrint</span></code> arguments to <code class="docutils literal notranslate"><span class="pre">log</span></code> and all its callers. To minimize callers we could partially apply it in <code class="docutils literal notranslate"><span class="pre">main</span></code> and pass around just the <code class="docutils literal notranslate"><span class="pre">log</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">Cmd</span></code> function. But still, we have to modify every caller of <code class="docutils literal notranslate"><span class="pre">log</span></code> and its callers and so on to pass around the <code class="docutils literal notranslate"><span class="pre">log</span></code> function.</p>
</section>
</section>
<section id="n-k-patterns">
<h2>n+k patterns<a class="headerlink" href="#n-k-patterns" title="Permalink to this heading"></a></h2>
<p>This is a feature removed from Haskell that simplifies writing recursive integer functions, like factorial. Basically <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">v</span> <span class="pre">of</span> <span class="pre">{</span> <span class="pre">x+k</span> <span class="pre">-&gt;</span> <span class="pre">e;</span> <span class="pre">_</span> <span class="pre">-&gt;</span> <span class="pre">e'</span> <span class="pre">}</span></code> translates to <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">v</span> <span class="pre">&gt;=</span> <span class="pre">k</span> <span class="pre">then</span> <span class="pre">(\x</span> <span class="pre">-&gt;</span> <span class="pre">e)</span> <span class="pre">(v-k)</span> <span class="pre">else</span> <span class="pre">e'</span></code>, where <code class="docutils literal notranslate"><span class="pre">k</span></code> is a literal.</p>
<p>Arguments:
* concise special notation, like for tuples and lists
* unfamiliar: the symbol + is being abused
* unnatural: not clear that residue must always be <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code>, i.e. pattern matches a natural number
* easy to change to a guard clause <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">v</span> <span class="pre">of</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">|</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">v-k</span> <span class="pre">in</span> <span class="pre">e;</span> <span class="pre">_</span> <span class="pre">-&gt;</span> <span class="pre">e'</span> <span class="pre">}</span></code> or a view pattern <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">v</span> <span class="pre">of</span> <span class="pre">{</span> <span class="pre">(dec</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">Just</span> <span class="pre">x)</span> <span class="pre">-&gt;</span> <span class="pre">e;</span> <span class="pre">_</span> <span class="pre">-&gt;</span> <span class="pre">e'</span> <span class="pre">}</span> <span class="pre">where</span> <span class="pre">dec</span> <span class="pre">k</span> <span class="pre">v</span> <span class="pre">=</span> <span class="pre">if</span> <span class="pre">v</span> <span class="pre">&gt;=</span> <span class="pre">k</span> <span class="pre">then</span> <span class="pre">Just</span> <span class="pre">(v-k)</span> <span class="pre">else</span> <span class="pre">Nothing</span></code></p>
<p>GHC-specific:
* Pattern still applies even if <code class="docutils literal notranslate"><span class="pre">(+)</span></code> is rebound away from <code class="docutils literal notranslate"><span class="pre">(Prelude.+)</span></code>.
* only works for <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>, as writing <code class="docutils literal notranslate"><span class="pre">n+(-1)</span></code> is forbidden.</p>
<p>Pattern synonyms should allow defining this like a view pattern, but without the ugly <code class="docutils literal notranslate"><span class="pre">Just</span></code>. Then the pattern like <code class="docutils literal notranslate"><span class="pre">x&#64;(dec</span> <span class="pre">k)</span> <span class="pre">-&gt;</span> <span class="pre">e</span></code> solves the main issues: dec is its own symbol, and the user has imported it so knows its semantics. And <code class="docutils literal notranslate"><span class="pre">k</span></code> should be evaluated so can be a negative number or constant expression.</p>
</section>
<section id="pattern-matching-conditionals">
<h2>Pattern matching / conditionals<a class="headerlink" href="#pattern-matching-conditionals" title="Permalink to this heading"></a></h2>
<p><a class="reference external" href="https://soc.me/languages/unified-condition-expressions">This</a> has some syntax.</p>
<p>The keyword can be if, match, when, switch, case. Here we use <code class="docutils literal notranslate"><span class="pre">:~,\</span></code> modeled on Randomo in <span id="id10">[<a class="reference internal" href="../zzreferences.html#id131" title="Andreas Stefik, Susanna Siebert, Melissa Stefik, and Kim Slattery. An empirical comparison of the accuracy rates of novices using the quorum, perl, and randomo programming languages. In Proceedings of the 3rd ACM SIGPLAN Workshop on Evaluation and Usability of Programming Languages and Tools - PLATEAU '11, 3. Portland, Oregon, USA, 2011. ACM Press. URL: http://dl.acm.org/citation.cfm?doid=2089155.2089159 (visited on 2022-06-18), doi:10.1145/2089155.2089159.">SSSS11</a>]</span></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;z&quot;</span><span class="w"></span>

<span class="kt">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"></span>
<span class="w">  </span><span class="mf">2.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;z&quot;</span><span class="w"></span>

<span class="kt">:</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">    </span><span class="nf">\</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="w"></span>
<span class="w">    </span><span class="o">^</span><span class="w"> </span><span class="kt">NaN</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;n&quot;</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;z&quot;</span><span class="w"></span>

<span class="kt">:</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
<span class="w">  </span><span class="o">.</span><span class="n">isEmpty</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;e&quot;</span><span class="w"></span>
<span class="w">  </span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;n&quot;</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;z&quot;</span><span class="w"></span>

<span class="kt">:</span><span class="w"> </span><span class="n">alice</span><span class="w"></span>
<span class="w">  </span><span class="o">.</span><span class="n">age</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;18&quot;</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Person</span><span class="p">(</span><span class="s">&quot;Alice&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">$</span><span class="n">age</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;$age&quot;</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Person</span><span class="p">(</span><span class="s">&quot;Bob&quot;</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="o">$</span><span class="n">person</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="s">&quot;{$person.age}&quot;</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;0&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>pattern matching using “if-let”12</p>
<p>if person is Person(“Alice”, $age) then “$age” else “o”</p>
<p>wildcards (_) and pattern guards</p>
<dl>
<dt>if person                         /* same as <a href="#id11"><span class="problematic" id="id12">*</span></a>/      if person is</dt><dd><p>is Person(“Alice”, _)           then “alice”         Person(“Alice”, _)           then “alice”
is Person(_, $age) &amp;&amp; age &gt;= 18 then “adult”         Person(_, $age) &amp;&amp; age &gt;= 18 then “adult”</p>
<blockquote>
<div><blockquote>
<div><p>else “minor”                                      else “minor”</p>
</div></blockquote>
<dl class="simple">
<dt>The condition can be split between a common discriminator and individual cases.</dt><dd><p>This requires doing away with mandatory parentheses around the conditions.
This strongly suggests using a keyword (then) to introduce branches, instead of using curly braces, based on readability considerations.</p>
</dd>
</dl>
<p>The   because it is keyword the largest number of developers are familiar with.</p>
</div></blockquote>
</dd>
</dl>
</section>
<section id="chained-assignment">
<h2>Chained assignment<a class="headerlink" href="#chained-assignment" title="Permalink to this heading"></a></h2>
<p>w = x = y = z
the value of z is assigned to multiple variables w, x, and y</p>
<p>the evaluation strategy differs between languages. For simple chained assignments, like initializing multiple variables, the evaluation strategy does not matter, but if the targets (l-values) in the assignment are connected in some way, the evaluation strategy affects the result.</p>
<p>In Python, assignment statements are not expressions and thus do not have a value. Instead, chained assignments are a series of statements with multiple targets for a single expression. The assignments are executed left-to-right so that i = arr[i] = f() evaluates the expression f(), then assigns the result to the leftmost target, i, and then assigns the same result to the next target, arr[i], using the new value of i.[9] This is essentially equivalent to tmp = f(); i = tmp; arr[i] = tmp though no actual variable is produced for the temporary value.</p>
<p>The <a class="reference external" href="http://www.cse.iitm.ac.in/~amannoug/imop/tr-3.pdf">literature</a> classifies this as “syntactic sugar”, so handling it in the parser like Python seems the reasonable solution. C’s “the assignment returns the lvalue” semantics is possible too but seems contrived. C’s RTL semantics is probably better than <cite>Python’s LTR &lt;https://docs.python.org/3/reference/simple_stmts.html#assignment-statements&gt;</cite>.  So a chain <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">2</span></code> expands to <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">2;</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code>.</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">=</span></code> for comparison conflicts with chaining <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">2</span></code>, because it can be interpreted as <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">(b</span> <span class="pre">==</span> <span class="pre">2)</span></code>. Really <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">2</span></code> doesn’t really seem that useful when you can just replace <code class="docutils literal notranslate"><span class="pre">a</span></code> with <code class="docutils literal notranslate"><span class="pre">b</span></code> in the rest of the expression. If you need multiple variables with the same value then you would write <code class="docutils literal notranslate"><span class="pre">[a,b,c]</span> <span class="pre">=</span> <span class="pre">replicateM</span> <span class="pre">3</span> <span class="pre">(ref</span> <span class="pre">0)</span></code> rather than using a chain, because a chain would alias to the same variable. Python already has this problem with aliasing for <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">[]</span></code>, because <code class="docutils literal notranslate"><span class="pre">[]</span></code> is mutable.</p>
<p>Chained update with <code class="docutils literal notranslate"><span class="pre">:=</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:=</span> <span class="pre">b</span> <span class="pre">:=</span> <span class="pre">2</span></code>, seems implementable. It doesn’t conflict with equality and shortens some assignments.</p>
</section>
<section id="embedded-assignment">
<h2>Embedded assignment<a class="headerlink" href="#embedded-assignment" title="Permalink to this heading"></a></h2>
<p>This embeds assignments in expressions, like</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Clearly it conflicts with <code class="docutils literal notranslate"><span class="pre">=</span></code> as comparison.</p>
<p>But for chained update it is unambiguous and returning the value would be possible:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>But then statements like</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">b</span><span class="w"> </span><span class="kt">:=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>would have an unused return value. Maybe this value could be marked as optional somehow.</p>
</section>
<section id="unless">
<h2>Unless<a class="headerlink" href="#unless" title="Permalink to this heading"></a></h2>
<p>Ruby’s <code class="docutils literal notranslate"><span class="pre">unless-else</span></code> is unintuitive. Only support <code class="docutils literal notranslate"><span class="pre">if-else</span></code> and <code class="docutils literal notranslate"><span class="pre">unless</span></code> without the else. Also <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">not</span></code> is a possible replacement for <code class="docutils literal notranslate"><span class="pre">unless</span></code>.</p>
</section>
<section id="tuples-and-records">
<h2>Tuples and records<a class="headerlink" href="#tuples-and-records" title="Permalink to this heading"></a></h2>
<p>In <a class="reference external" href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/MaybeNot.md">Maybe Not</a> Rich Hickey  says records/fields, and product types are “place oriented programming”, hence bad. Well, in <a class="reference external" href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/ValueOfValuesLong.md">The Value of Values</a> he says place-oriented programming is when you use in-place update. But maps (his proposed alternative) also support in-place update and are place-oriented. The only difference between maps and records seems to be that records have ordered fields.</p>
<p>So he seems have a different definition in mind, in particular that place-oriented means accessors are not first class - even when the fields are named, you cannot say <code class="docutils literal notranslate"><span class="pre">object[&quot;name&quot;]</span></code> for an arbitrary object or an arbitrary name. But this is easily solved by adding such functionality. It also doesn’t get into the mutable/immutable distinction that the values talk made.</p>
<p>His second point is that product types “complects” the meaning of things with their position in a list. “Complect” is from <a class="reference external" href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/SimpleMadeEasy-mostly-text.md">Simple Made Easy</a> and is a pejorative version of “braid together”.
Essentially he’s saying that if you have <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">String)</span></code> there is no way to know how the second string is different from the first string. Well, for commutative operations like addition the order literally doesn’t matter. Adding any sort of information to <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">:</span> <span class="pre">(Int,</span> <span class="pre">Int)</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code> is complicating the picture. Similarly for Strings <a class="reference external" href="https://gemma.msl.ubc.ca/resources/baseCode/apidocs/ubic/basecode/util/StringUtil.html#append-java.lang.String-java.lang.String-java.lang.String-">coming up</a> with names “appendee” and “appendant” for an  append operation is almost as bad as digging up “complect”. Using numerical names <code class="docutils literal notranslate"><span class="pre">s1</span></code> and <code class="docutils literal notranslate"><span class="pre">s2</span></code> makes more sense. It still gives a record with named fields, but it makes sense to use positional arguments.</p>
<p>And if the types are different there’s no ambiguity: <code class="docutils literal notranslate"><span class="pre">(FirstName,</span> <span class="pre">LastName</span></code>, <code class="docutils literal notranslate"><span class="pre">(Int,Bool)</span></code>, etc.</p>
</section>
<section id="precedence">
<h2>Precedence<a class="headerlink" href="#precedence" title="Permalink to this heading"></a></h2>
<p><a class="reference external" href="https://ericlippert.com/2020/02/27/hundred-year-mistakes/">This post</a> describes a mistake in C-style precedence: it should be <code class="docutils literal notranslate"><span class="pre">&amp;&amp;,</span> <span class="pre">==,</span> <span class="pre">&amp;</span></code> but is instead <code class="docutils literal notranslate"><span class="pre">&amp;&amp;,</span> <span class="pre">&amp;</span> <span class="pre">==</span></code>, causing a footgun. “Swift, Go, Ruby and Python get it right.”</p>
<section id="cycle">
<h3>Cycle<a class="headerlink" href="#cycle" title="Permalink to this heading"></a></h3>
<p>Can we have a precedence cycle, like <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">(b</span> <span class="pre">*</span> <span class="pre">c)</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">(b</span> <span class="pre">^</span> <span class="pre">c)</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">^</span> <span class="pre">(b</span> <span class="pre">+</span> <span class="pre">c)</span></code>?</p>
<p>Well what about a large expression:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">d</span><span class="p">))</span><span class="w"></span>
<span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">))</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
</pre></div>
</div>
<p>These are both consistent with precedence so we would need another rules to decide between them.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="State.html" class="btn btn-neutral float-left" title="Stateful programming" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="TermRewriting.html" class="btn btn-neutral float-right" title="Term rewriting" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>