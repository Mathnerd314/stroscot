<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Syntax &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Term rewriting" href="TermRewriting.html" />
    <link rel="prev" title="Imperative programming" href="State.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fexprs.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">About</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html#random-old-junk">Random old junk</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Imperative programming</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Syntax</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#design">Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#legibility">Legibility</a></li>
<li class="toctree-l4"><a class="reference internal" href="#blocks">Blocks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#applicativedo">ApplicativeDo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recursivedo">RecursiveDo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arrows">Arrows</a></li>
<li class="toctree-l4"><a class="reference internal" href="#idiom-brackets">Idiom brackets</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-like-reference-access">C-like reference access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#type-declarations">Type declarations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#namespacing">Namespacing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#partial-loading">Partial loading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#specificity">Specificity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#whitespace">Whitespace</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-syntax">Function syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arguments">Arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implicit-arguments">Implicit arguments</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Commentary</a> &raquo;</li>
      <li>Syntax</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Syntax.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="syntax">
<h1>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline"></a></h1>
<section id="design">
<h2>Design<a class="headerlink" href="#design" title="Permalink to this headline"></a></h2>
<p>The stuff here is mostly a dumping ground of ideas while the rest of the language is designed. The actual syntax will be designed by going through the syntax of other languages (primarily the ones listed in the influences section, but also all the ones listed on RosettaCode and <a class="reference external" href="http://rigaux.org/language-study/syntax-across-languages/">Rigaux’s list of syntax across languages</a>) and picking out the nicest examples. But in the end, syntax is decided by usage, so a lot of the syntax here will probably become final.</p>
<p>Quorum and its associated set of syntax studies provide useful datapoints on keywords and constructs. But Stroscot has a unique design so we can’t use a lot of the research, and the research is limited to begin with.</p>
<p>Some languages offer a “simple” syntax. But simplicity is hard to define, and boils down to either a simple implementation (LR) or else just the syntax familiar to them from other languages (which implementation-wise is often quite complex). People seem to be afraid of new syntax so there is the tendency to make it explicit and loud while reserving the terse syntax for established features. But Stroscot’s goal is to unify all the features, so all of the notation is designed to be short, terse, flexible, and general.</p>
<p>Haskell/Idris syntax is mostly awesome, use it.</p>
<p>TODO: see if there are any more Unicode guidelines relevant to writing a programming language parser</p>
<p>Natural language like Inform 7, while interesting, is quite wordy. It’s also hard to scan through.</p>
<section id="legibility">
<h3>Legibility<a class="headerlink" href="#legibility" title="Permalink to this headline"></a></h3>
<p>The main factor improving readability is consistency; reading is disrupted when unconventional layouts are used.</p>
<p>Spacing is important to identify word boundaries (intra-letter spacing significantly smaller than inter-word spacing) and sentence boundaries (two spaces after the period, although the period’s whitespace itself is distinctive). Justified text is harder to read than ragged-right due to the inconsistent spacing arising from bad line-breaking. Left-aligned text is easier to read than centered or right-aligned text because the reader knows where to look to find the next line. The default line spacing seems fine.</p>
<p>Line length is a good question. Programming uses fixed-width characters so it’s measured in characters. 80 characters is standard, but monitors are wider now, so 100 is plausible. Diff programs are often the limiting factor, but on my monitor I can fit 2 108-character texts side-by-side along with a space in the middle and the taskbar. 100 leaves room for line numbers and similar decorations. Plus, most diffs these days are unified, and line-wrapping is always an option for smaller screens. OTOH it’s a tiny font, 18-26pt is the most readable for websites so maybe that size is needed for programming. At 18pt (24px) I can fit 97 characters, while 23px fits 102 characters.</p>
<p>Layout improves legibility, Python syntax is often said to be “clean”, hence why Stroscot has layout</p>
</section>
<section id="blocks">
<h3>Blocks<a class="headerlink" href="#blocks" title="Permalink to this headline"></a></h3>
<p>Blocks are inspired by Haskell’s do notation, but have a twist, based on the observation that the continuation monad is <a class="reference external" href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads">the mother of all monads</a>. Since it’s the mother, we don’t lose anything by fixing the monadic operations in the do-notation to be the continuation monad operations. That link gives a generic way to implement monads via the continuation monad, but the direct implementation is pretty clean. For example the <a class="reference external" href="https://github.com/Mathnerd314/stroscot/blob/master/tests/Continuations-State.hs">StateT monad</a>.</p>
<p>It’s worth noting that even though monads can be implemented easily, monads are overrated to begin with:</p>
<ul class="simple">
<li><p>ReaderT is handled by implicit parameters</p></li>
<li><p>StateT is a mutable reference</p></li>
<li><p>WriterT is a StateT that’s not read</p></li>
<li><p>Error/Except are handled by poison values</p></li>
</ul>
<p>Using the continuation monad allows us to separate commands (not returning a value) and operations (returning a value). Haskell has the translation <code class="docutils literal notranslate"><span class="pre">{e;stmts}</span> <span class="pre">=</span> <span class="pre">e</span> <span class="pre">&gt;&gt;</span> <span class="pre">stmts</span> <span class="pre">=</span> <span class="pre">\c</span> <span class="pre">-&gt;</span> <span class="pre">e</span> <span class="pre">(\_</span> <span class="pre">-&gt;</span> <span class="pre">{stmts}</span> <span class="pre">c)</span></code>. But usually <code class="docutils literal notranslate"><span class="pre">e</span></code> returns <code class="docutils literal notranslate"><span class="pre">()</span></code>, so <code class="docutils literal notranslate"><span class="pre">(&gt;&gt;)</span></code> is applied at the type <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span></code> and that <code class="docutils literal notranslate"><span class="pre">\_</span></code> is a <code class="docutils literal notranslate"><span class="pre">\()</span></code>. With our translation, commands (which don’t return a value) are functions <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>. Haskell’s translation would require them to be <code class="docutils literal notranslate"><span class="pre">Cont</span> <span class="pre">r</span> <span class="pre">()</span> <span class="pre">=</span> <span class="pre">(()</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>, which is equivalent but has an extra <code class="docutils literal notranslate"><span class="pre">()</span></code> floating around. But in both translations operations (whose value is used) are of type <code class="docutils literal notranslate"><span class="pre">Cont</span> <span class="pre">r</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code>. The non-uniform type for actions might make copying code from Haskell a little harder, but on the other hand we get function composition as a built-in syntax. That’s right, the most basic operation in category theory is available as syntactic sugar in Stroscot. Take that, Haskell. And also we can easily use indexed monads, just change <code class="docutils literal notranslate"><span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code> to <code class="docutils literal notranslate"><span class="pre">r)</span> <span class="pre">-&gt;</span> <span class="pre">s</span></code>.</p>
<p>For an example of how natural this is you can look at <a class="reference internal" href="State.html#tasks"><span class="std std-ref">how I/O works</span></a>.</p>
</section>
<section id="applicativedo">
<h3>ApplicativeDo<a class="headerlink" href="#applicativedo" title="Permalink to this headline"></a></h3>
<p>ApplicativeDo <span id="id1">[]</span> has two functions. The first is to make some do-notation sequences be Applicative rather than Monad. In fact though these are exactly the sequences handled by idiom brackets, of the form <code class="docutils literal notranslate"><span class="pre">{a</span> <span class="pre">&lt;-</span> <span class="pre">ax;</span> <span class="pre">b</span> <span class="pre">&lt;-</span> <span class="pre">bx;</span> <span class="pre">return</span> <span class="pre">(f</span> <span class="pre">a</span> <span class="pre">b)}</span> <span class="pre">=</span> <span class="pre">return</span> <span class="pre">(f</span> <span class="pre">!a</span> <span class="pre">!b)</span></code>. Idiom brackets are shorter, so the value this provides is minimal.</p>
<p>The second function is to use applicative operations instead of monadic operations because in “some” monads the applicative operation is more efficient. Their example is the Haxl DSL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>numCommonFriends :: Id → Id → Haxl Int
numCommonFriends x y = do
   fx ← friendsOf x
   fy ← friendsOf y
   return (length (intersect fx fy))
</pre></div>
</div>
<p>Well, sorry to burst the bubble, but if you’re writing a DSL then writing it as a macro is much more powerful than trying to shoehorn it into an applicative/monadic framework. They discuss in the paper that the translation to use applicative operations is ambiguous and the best one depends on details of the computation that are not accessible, because functions are opaque. It’s exactly these kinds of details that <em>are</em> accessible in a DSL - you just write a pass that walks over the expression tree and estimates the costs. Similarly the <a class="reference external" href="https://en.wikipedia.org/wiki/Use-define_chain">use/def analysis</a> that they use for the rewriting is a standard compiler pass. The commutativity mentioned in the paper is another property one could know from the DSL and that changes the output significantly.</p>
<p>For regular do notation, the applicative notation translates to exactly the same continuation as the monadic notation.</p>
<p>Verdict: DSL in disguise. Just write a DSL. Stroscot does not benefit at all by adding ApplicativeDo.</p>
</section>
<section id="recursivedo">
<h3>RecursiveDo<a class="headerlink" href="#recursivedo" title="Permalink to this headline"></a></h3>
<p>RecursiveDo <span id="id2">[<a class="reference internal" href="../zzreferences.html#id31" title="Levent Erkok. Value Recursion in Monadic Computations. PhD thesis, Oregon Health and Science University, October 2002. URL: http://leventerkok.github.io/papers/erkok-thesis.pdf.">Erk02</a>]</span> is an older extension to do notation. The motivating example is a circuit DSL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">toggle</span> <span class="kt">:</span> <span class="kt">Signal</span> <span class="kt">Bool</span>
<span class="nf">toggle</span> <span class="ow">=</span> <span class="n">out</span>
   <span class="kr">where</span>
      <span class="n">inp</span> <span class="ow">=</span> <span class="n">inv</span> <span class="n">out</span>
      <span class="n">out</span> <span class="ow">=</span> <span class="n">delay</span> <span class="kt">False</span> <span class="n">inp</span>

<span class="nf">counter</span> <span class="kt">:</span> <span class="kt">Signal</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Signal</span> <span class="kt">Int</span>
<span class="nf">counter</span> <span class="n">reset</span> <span class="ow">=</span> <span class="n">out</span>
   <span class="kr">where</span>
      <span class="n">next</span> <span class="ow">=</span> <span class="n">delay</span> <span class="mi">0</span> <span class="n">inc</span>
      <span class="n">inc</span> <span class="ow">=</span> <span class="n">out</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">out</span> <span class="ow">=</span> <span class="n">mux</span> <span class="n">reset</span> <span class="n">zero</span> <span class="n">next</span>
      <span class="n">zero</span> <span class="ow">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>But wait, where’s the do notation? In fact, this is really just a DSL. There are no monads and no sequencing to be found. All of these operations happen in parallel. The uses for these circuit descriptions all depend on the circuits being specified using a small set of operations specified in a typeclass.</p>
<p>Investigating Hackage, mdo is uncommon. “Many Haskell programmers will never use it in their careers.” (<a class="reference external" href="https://ro-che.info/articles/2015-09-02-monadfix">1</a>) Uses fall into categories:
* DSLs, where variable assignments are interpreted as data
* Gratuitous (no/one binding, or bindings do not refer to bindings from later)
* Examples where it would be clearer to use mfix or the do-rec notation that is just <code class="docutils literal notranslate"><span class="pre">(a,b,c)</span> <span class="pre">&lt;-</span> <span class="pre">mfix</span> <span class="pre">(\(a,b,c)</span> <span class="pre">-&gt;</span> <span class="pre">(_,_,_))</span></code>
* I/O monad, mfix is used to write the code in a recursive style instead of modifying a variable, e.g. forking two threads that kill each other:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mdo</span>
   <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">fork</span> <span class="o">$</span> <span class="n">killThread</span> <span class="n">b</span>
   <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">fork</span> <span class="o">$</span> <span class="n">killThread</span> <span class="n">a</span>

<span class="c1">-- vs</span>
<span class="nf">bId</span> <span class="ow">&lt;-</span> <span class="n">newEmptyMVar</span>
<span class="nf">a</span> <span class="ow">&lt;-</span> <span class="n">fork</span> <span class="o">$</span> <span class="n">readMVar</span> <span class="n">b</span> <span class="o">&gt;&gt;=</span> <span class="n">killThread</span>
<span class="nf">b</span> <span class="ow">&lt;-</span> <span class="n">fork</span> <span class="o">$</span> <span class="n">killThread</span> <span class="n">a</span>
<span class="nf">writeMVar</span> <span class="n">bId</span> <span class="n">b</span>
</pre></div>
</div>
<p>The code for IO’s mfix uses unsafeDupableInterleaveIO. This has been the subject of at least one <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/issues/5421">bug</a> (<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/issues/15349">two</a> counting fixST), and is why there is both fixIO and <a class="reference external" href="https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO-Unsafe.html#v:unsafeFixIO">unsafeFixIO</a>. Reasoning about fixIO seems to <a class="reference external" href="https://wiki.haskell.org/Evaluation_order_and_state_tokens">require</a> laziness semantics and maybe also an understanding of Haskell’s State-based I/O model.</p>
<p>Also, most monads fail to satisfy monadic right shrinking, which IMO makes the notation completely unintuitive:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mdo</span>
   <span class="n">z</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">z</span>
   <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">g</span> <span class="n">z</span>
   <span class="n">return</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>

<span class="c1">-- is NOT equivalent to</span>

<span class="nf">z</span> <span class="ow">&lt;-</span> <span class="n">mdo</span>
         <span class="n">z</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">z</span>
         <span class="n">return</span> <span class="n">z</span>
<span class="nf">w</span> <span class="ow">&lt;-</span> <span class="n">g</span> <span class="n">z</span>
<span class="nf">return</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p>The only price to pay for leaving mdo out is that value-recursive monadic computations have to be written with <code class="docutils literal notranslate"><span class="pre">mfix</span></code>. We can still implement <code class="docutils literal notranslate"><span class="pre">mfix</span></code> for the monads that matter, like <code class="docutils literal notranslate"><span class="pre">State</span></code>. According to all available knowledge, <code class="docutils literal notranslate"><span class="pre">mfix</span></code> can’t be implemented for continuations, so nothing is lost from regular programs.</p>
<p>Verdict: Not only a DSL in disguise, but also a footgun. Provide mfix and the rec{} notation in an obscure library for those who care.</p>
</section>
<section id="arrows">
<h3>Arrows<a class="headerlink" href="#arrows" title="Permalink to this headline"></a></h3>
<p>You might be getting the pattern here. Arrows were inspired by a parsing DSL. Any arrow which supports the ArrowApply class is a monad. Arrows not supporting ArrowApply must write operations for every language element supported (variable, function, conditional, grammar production choice, and so on). Continuations require ArrowApply to even implement the basic arrow interface. Verdict: trash, a leaky “abstraction” that just wastes everyone’s time.</p>
</section>
<section id="idiom-brackets">
<h3>Idiom brackets<a class="headerlink" href="#idiom-brackets" title="Permalink to this headline"></a></h3>
<p>While do notation is defined for monads, idiom brackets are defined for applicative functors, <code class="docutils literal notranslate"><span class="pre">[[</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">]]</span> <span class="pre">=</span> <span class="pre">pure</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">a</span> <span class="pre">&lt;*&gt;</span> <span class="pre">b</span></code>. But DSL notation works too: <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">{</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">}</span></code>.</p>
<p>The issue with translating to <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> is that it assumes left-to-right evaluation. You can see this in the <a class="reference external" href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Applicative.html#t:Applicative">translation</a> for Monads: <code class="docutils literal notranslate"><span class="pre">m1</span> <span class="pre">&lt;*&gt;</span> <span class="pre">m2</span></code> binds <code class="docutils literal notranslate"><span class="pre">m1</span></code> before <code class="docutils literal notranslate"><span class="pre">m2</span></code>. In Stroscot the program is required to be equivalent under all evaluation orders. So to enforce this we need a function <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">:</span> <span class="pre">[m</span> <span class="pre">a]</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">[a]</span></code> that checks there is no issue with evaluating in parallel. Then using parallel the translation of <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">{</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">x</span> <span class="pre">}</span></code> looks like <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">(av,bv,cv)</span> <span class="pre">=</span> <span class="pre">parallel</span> <span class="pre">(a,b,c);</span> <span class="pre">return</span> <span class="pre">(f</span> <span class="pre">av</span> <span class="pre">bv</span> <span class="pre">cv)</span> <span class="pre">}</span></code></p>
<p>Idris defines <a class="reference external" href="http://docs.idris-lang.org/en/latest/tutorial/interfaces.html#notation">!-notation</a>, “implicitly bound application”. The scoping is <a class="reference external" href="https://github.com/idris-lang/Idris-dev/issues/4395">unintuitive</a>, but the notation itself is powerful. Binding it to a syntactic block seems reasonable. And it can easily express idiom brackets, <code class="docutils literal notranslate"><span class="pre">[[</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">]]</span></code> becomes <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">f</span> <span class="pre">!a</span> <span class="pre">!b</span> <span class="pre">}</span></code>. Idiom brackets save characters with more arguments, but bang notation looks natural if there are multiple bindings in the block.</p>
</section>
<section id="c-like-reference-access">
<h3>C-like reference access<a class="headerlink" href="#c-like-reference-access" title="Permalink to this headline"></a></h3>
<p>For example we want to do:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span> <span class="ow">=</span> <span class="n">ref</span> <span class="mi">1</span>
<span class="nf">b</span> <span class="ow">=</span> <span class="n">ref</span> <span class="mi">2</span>
<span class="nf">c</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="nf">a</span> <span class="kt">:=</span> <span class="n">c</span>
</pre></div>
</div>
<p>Translated this looks like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ref</span> <span class="mi">1</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">a</span> <span class="ow">-&gt;</span>
<span class="nf">ref</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">b</span> <span class="ow">-&gt;</span>
<span class="nf">parallel</span> <span class="p">(</span><span class="n">read</span> <span class="n">a</span><span class="p">,</span> <span class="n">read</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="p">(</span><span class="n">av</span><span class="p">,</span><span class="n">bv</span><span class="p">)</span>  <span class="ow">-&gt;</span>
<span class="kr">let</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">av</span> <span class="o">+</span> <span class="n">bv</span> <span class="kr">in</span>
<span class="nf">writeRef</span> <span class="n">a</span> <span class="n">c</span>
</pre></div>
</div>
<p>I think the solution is another DSL. Inserting <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">a</span></code> is not too complicated, just follow the C/C++ rules about converting lvalues to rvalues.</p>
</section>
</section>
<section id="type-declarations">
<h2>Type declarations<a class="headerlink" href="#type-declarations" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">:</span> <span class="pre">s8</span></code> and <code class="docutils literal notranslate"><span class="pre">s8</span> <span class="pre">2</span></code> seem more logical compared to other choices such as <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">s8</span> <span class="pre">=</span> <span class="pre">2</span></code> (Swift,Jai - hard to find the = with long types) or <code class="docutils literal notranslate"><span class="pre">s8</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">2</span></code> (C,Rust - overlaps with function definition). The name is simply a syntactic handle to refer to the value; it doesn’t have an innate type. In contrast the representation of the value must be specified to compile the program. The second syntax is similar to assembler syntax such as <code class="docutils literal notranslate"><span class="pre">dword</span> <span class="pre">0</span></code>.</p>
</section>
<section id="namespacing">
<h2>Namespacing<a class="headerlink" href="#namespacing" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">.</span></code> is preferred to <code class="docutils literal notranslate"><span class="pre">::</span></code> because it’s shorter and because modules are first-class.</p>
</section>
<section id="partial-loading">
<h2>Partial loading<a class="headerlink" href="#partial-loading" title="Permalink to this headline"></a></h2>
<p>The parser parses as much of the input as possible, but in general only a prefix of the input will be valid. Hence we can load a portion of the file by inserting junk / truncating the input buffer. The compiler will give a warning but the parser should handle it just fine.</p>
</section>
<section id="specificity">
<h2>Specificity<a class="headerlink" href="#specificity" title="Permalink to this headline"></a></h2>
<p>This might seem overly complicated, but it’s based on Zarf’s <a class="reference external" href="https://eblong.com/zarf/rule-language.html">rule-based programming</a>. When you’re defining lots of rules for a IF game then specifying priorities by hand is tedious.</p>
</section>
<section id="whitespace">
<h2>Whitespace<a class="headerlink" href="#whitespace" title="Permalink to this headline"></a></h2>
<p>Whitespace in identifiers… this doesn’t work well with Haskell syntax. With whitespace <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">something</span> <span class="pre">=</span> <span class="pre">...`</span></code> would define the identifier <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">something</span></code>, but in Haskell it’s a clause <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">_</span></code> that binds <code class="docutils literal notranslate"><span class="pre">something</span></code>.</p>
<p>OTOH using a string works fine: <code class="docutils literal notranslate"><span class="pre">&quot;do</span> <span class="pre">something&quot;</span> <span class="pre">=</span> <span class="pre">...</span></code></p>
<p>You could also make something an atom, then you can write <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">something</span></code> in code but the clause definition is <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">^something</span> <span class="pre">=</span> <span class="pre">...</span></code>. The semantics are similar to a single identifier but different enough that I don’t think it counts.</p>
</section>
<section id="function-syntax">
<h2>Function syntax<a class="headerlink" href="#function-syntax" title="Permalink to this headline"></a></h2>
<p>Lambdas are defined using whatever syntax. The <code class="docutils literal notranslate"><span class="pre">\x.y</span></code> style is closest to the mathematical notation (barring Unicode), Haskell uses <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">y</span></code>, Cliff likes <code class="docutils literal notranslate"><span class="pre">{x</span> <span class="pre">=&gt;</span> <span class="pre">y}</span></code>.</p>
<p>Haskell style arguments <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code> are preferred over C style <code class="docutils literal notranslate"><span class="pre">f(a)</span></code> due to being shorter for arguments that are identifiers. The only place they lose in character count is complex arguments <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(a+1)</span> <span class="pre">(b+2)</span></code> vs <code class="docutils literal notranslate"><span class="pre">f(a+1,b+2)</span></code>, but there you can use a tuple to match the syntax or the record <code class="docutils literal notranslate"><span class="pre">f{x=a+1,y=b+2}</span></code> which will most likely be clearer.</p>
<p>APL-style functions/operators <code class="docutils literal notranslate"><span class="pre">(~R∊R∘.×R)/R←1↓⍳R</span></code> are not preferred due to Unicode overuse, preferring operators written with words instead, but one could create them if desired.</p>
</section>
<section id="arguments">
<h2>Arguments<a class="headerlink" href="#arguments" title="Permalink to this headline"></a></h2>
<p>Stroscot supports many types of arguments. Functions are extremely common, so the more styles supported,
the shorter the code will be.</p>
<p>Functions operate on values and produce the same outputs given the same inputs.</p>
<p>Conceptually, term rewriting is the underlying model of computation.</p>
<p>Clauses are applied as rewriting rules, reading them from left to right. A clause is applicable if its left-hand side matches the term to be evaluated, in which case we bind the variables in the left-hand side to the corresponding subterms in the target term.</p>
<p>Equations are tried in the order in which they are written; as soon as the left-hand side of an equation matches (and the condition part of the equation, if any, is satisfied), it can be applied to reduce the target term to the corresponding right-hand side. The term is rewritten until no more equations are applicable.</p>
<p>any function symbol or operator can be used anywhere on the left-hand side of an equation, and may act as a constructor symbol if it happens to occur in a normal form term. This enables you to work with algebraic rules like associativity and distributivity in a direct fashion:</p>
<p>&gt; (x+y)*z = x*z+y*z; x*(y+z) = x*y+x*z;
&gt; x*(y*z) = (x*y)*z; x+(y+z) = (x+y)+z;
&gt; square (a+b);
a*a+a*b+b*a+b*b</p>
<p>The above isn’t possible in languages like Haskell and ML which always enforce that only “pure” constructor symbols (without any defining equations) may occur as a subterm on the left-hand side of a definition</p>
<p>constructor discipline: Haskell has a rule that identifiers starting with uppercase letters are constructors and cannot be defined to be functions, but this rule reduces maintainability. If the representation is changed there is no way to replace the raw constructor with a smart constructor. So instead every library is forced to define functions like <code class="docutils literal notranslate"><span class="pre">mkThing</span> <span class="pre">=</span> <span class="pre">Thing</span></code> to get around this syntactic restriction.</p>
<p>The semantics of functions are defined by pattern-matching rules a la <a class="reference external" href="https://agraef.github.io/pure-docs/pure.html#definitions-and-expression-evaluation">Pure</a>.</p>
<section id="implicit-arguments">
<h3>Implicit arguments<a class="headerlink" href="#implicit-arguments" title="Permalink to this headline"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">loglevel</span></code> is defined close to the top level, but each use
site is scattered in the code. The implicit argument replaces
the global variable that is often used.
Similarly <code class="docutils literal notranslate"><span class="pre">logPrint</span></code> is passed implicitly instead of being a member of a global Logger instance.</p>
<p>Claim: Explicit argument passing cannot replace our implicit variable example</p>
<p>The file variable does not exist in the standard
library; it is part of the user’s code. To use explicit argument passing
would require adding new arguments to log, or modifying main to store print partially-applied, but this would break anyone
else using the library. Not to mention that just one intervening
function is rare and we’d probably need to modify 20 or 30 functions in
a bad case.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="State.html" class="btn btn-neutral float-left" title="Imperative programming" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="TermRewriting.html" class="btn btn-neutral float-right" title="Term rewriting" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2020 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>