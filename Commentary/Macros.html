<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Macros &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Memory management" href="Memory-Management.html" />
    <link rel="prev" title="Logic programming" href="LogicProgramming.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler-Library.html">Compiler library</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Intrinsics.html">Intrinsics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Macros</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#comparison">Comparison</a></li>
<li class="toctree-l3"><a class="reference internal" href="#terminology">Terminology</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hygiene">Hygiene</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parsing">Parsing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#resources">Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#metrics">Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#methods">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#action">Action</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard-Library.html">Standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Macros</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Macros.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="macros">
<h1>Macros<a class="headerlink" href="#macros" title="Permalink to this heading"></a></h1>
<p>Macros are a facility that allows defining syntactic extensions to a programming language. Macros implement the essence of Lisp: code can be used as data, and data can be used as code. Although in Lisp the transformation of code into data (specifically, an AST tree) is obvious as the S-expression syntax is just nested lists, in Stroscot we choose to have more complex syntax and accompanying mental overhead. It should be noted that even McCarthy the inventor of Lisp intended to use an M-expression (mathematical expression) syntax and S-expressions were only a matter of convenience.</p>
<section id="comparison">
<h2>Comparison<a class="headerlink" href="#comparison" title="Permalink to this heading"></a></h2>
<p>Macros, micros, and fexprs are all possibilities. Comparing them:</p>
<ol class="arabic simple" start="0">
<li><p>A (C) macro is a function translating text into text. Textual macros suffer from the scoping/name capture problem. Applying a macro <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">x=x+x</span></code> to a side-effectful expression like <code class="docutils literal notranslate"><span class="pre">double(i++)</span></code> executes the side effect twice. They allow unbalanced/incorrect expansions like <code class="docutils literal notranslate"><span class="pre">startLoop</span> <span class="pre">=</span> <span class="pre">while(true)</span> <span class="pre">{</span></code> and <code class="docutils literal notranslate"><span class="pre">double(+)</span> <span class="pre">=</span> <span class="pre">+++</span></code>. One often can’t easily determine the expanded expression due to multiple layers of macros. Furthermore looking for control flow paths is hard.</p></li>
<li><p>A (Scheme) macro is a function translating an AST node into an AST node. Macro substitution of an AST reduces away all macros and produces an AST. Scheme macros have a complex hygiene system to make naive macros handle scoping correctly and avoid name capture.</p></li>
<li><p>A micro <span id="id1">[<a class="reference internal" href="../zzreferences.html#id99" title="Shriram Krishnamurthi. Linguistic Reuse. PhD thesis, Rice University, 2001. URL: https://scholarship.rice.edu/handle/1911/17993 (visited on 2021-08-06).">Kri01</a>]</span> is a function translating from a source AST node and an environment to an expression in the intermediate language. Micro dispatch of an AST reduces away all micros and produces an intermediate representation.</p></li>
<li><p>An f-expression (fexpr) <span id="id2">[<a class="reference internal" href="../zzreferences.html#id144" title="John N Shutt. Fexprs as the Basis of Lisp Function Application or \$vau : The Ultimate Abstraction. PhD thesis, WORCESTER POLYTECHNIC INSTITUTE, August 2010. URL: https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/.">Shu10</a>]</span> is a function translating an AST node and an environment to a value. Fexpr evaluation of an AST reduces away all fexprs and produces a value.</p></li>
</ol>
<p>Fexprs are the most powerful: IR expressions and AST nodes are values, hence micros and macros can be implemented in terms of fexprs, but conversely fexprs can’t be emulated. E.g. we can implement Scheme macros as f-expressions by computing the AST and evaluating, <code class="docutils literal notranslate"><span class="pre">defmacro</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">\vau</span> <span class="pre">$args</span> <span class="pre">$env</span> <span class="pre">-&gt;</span> <span class="pre">eval</span> <span class="pre">$env</span> <span class="pre">(f</span> <span class="pre">$args)</span></code>, modulo some hygiene stuff. But there is no macro corresponding to an eval function <code class="docutils literal notranslate"><span class="pre">evalF</span> <span class="pre">=</span> <span class="pre">\vau</span> <span class="pre">$args</span> <span class="pre">env</span> <span class="pre">-&gt;</span> <span class="pre">\f</span> <span class="pre">-&gt;</span> <span class="pre">eval</span> <span class="pre">f</span> <span class="pre">$env</span></code> that evaluates a value in an environment at runtime.</p>
<p>Another advantage of fexprs is that there are no phases - the full language is always available and immediately executed. For example predicate dispatch of fexprs is possible - you just have to look up the argument values in the environment like with predicate dispatch on applicatives. In contrast macros can only overload on number of arguments because the precise values are not available in the preprocessing phase, and similarly micros have a linking phase for the IR. Hence implementing the compiler using the Futamura projection of specializing an interpreter to a program is only sensible for fexprs.</p>
</section>
<section id="terminology">
<h2>Terminology<a class="headerlink" href="#terminology" title="Permalink to this heading"></a></h2>
<p>Loosely adapting <span id="id3">[<a class="reference internal" href="../zzreferences.html#id144" title="John N Shutt. Fexprs as the Basis of Lisp Function Application or \$vau : The Ultimate Abstraction. PhD thesis, WORCESTER POLYTECHNIC INSTITUTE, August 2010. URL: https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/.">Shu10</a>]</span>’s terminology we get the following:</p>
<ul class="simple">
<li><p>Evaluation is a function from an AST node and a (lexical) environment to produce a value. Values are AST nodes that evaluate to themselves in every environment. A non-value AST node (reducible expression) is usually a variable <code class="docutils literal notranslate"><span class="pre">x</span></code> or an application <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code>, but since Stroscot is term-rewriting it can be anything.</p></li>
<li><p>A reduction rule maps particular AST nodes and environments to new AST nodes and environments. These AST nodes are of course reducible.</p></li>
<li><p>An applicative is a reduction rule that uses each pattern variable once by transforming it to an “argument” by evaluating it using the current environment.</p></li>
<li><p>An operative is a non-applicative reduction rule.</p></li>
<li><p>A (Scheme) macro is an operative that uses its operands to derive a syntax tree and then returns the result of evaluating the entire tree.</p></li>
<li><p>A (Scheme) special form is an operative built into the language, accessible by a reserved symbol.</p></li>
<li><p>A (Kernel) fexpr is a non-macro operative that is expressed as a <code class="docutils literal notranslate"><span class="pre">$vau</span></code> lambda taking unevaluated operands and the environment.</p></li>
</ul>
<p>Although it gives each concept its own name, “fexpr” is an unusual word with no prior referent except maybe the old Lisp I fexpr which didn’t take an environment hence couldn’t implement lexical scope. So Stroscot’s terminology follows <a class="reference external" href="http://www.newlisp.org/index.cgi?page=Differences_to_Other_LISPs">newLISP</a>  and calls fexprs “macros”:</p>
<ul class="simple">
<li><p>A Stroscot function is a Shutt applicative</p></li>
<li><p>A Stroscot macro is a Shutt operative</p></li>
</ul>
<p>Stroscot’s macros operate on ASTs like macros in other languages, so it’s clearer to the uninitiated to call them macros. But, they return a value instead of an AST, so they are more powerful than other languages’ macros.</p>
</section>
<section id="hygiene">
<h2>Hygiene<a class="headerlink" href="#hygiene" title="Permalink to this heading"></a></h2>
<p>Scheme macros are supposed to be “hygienic” in that they always evaluate expressions in the lexical environment of the macro’s definition site, as opposed to use site. But <span id="id4">[<a class="reference internal" href="../zzreferences.html#id95" title="Oleg Kiselyov. How to write seemingly unhygienic and referentially opaque macros with syntax-rules. In Third Workshop on Scheme and Functional Programming, 77. October 2002. URL: https://okmij.org/ftp/Scheme/Dirty-Macros.pdf.">Kis02</a>]</span> shows that in fact the environment of the use site is fully accessible through some tricks. The newer syntax-case allows explicit access through <code class="docutils literal notranslate"><span class="pre">datum-&gt;syntax</span></code>.</p>
<p>Fexprs in contrast get an explicit environment. They can do staged lookup, <code class="docutils literal notranslate"><span class="pre">eval</span> <span class="pre">$env</span> <span class="pre">(eval</span> <span class="pre">$env</span> <span class="pre">(f</span> <span class="pre">$args))</span></code>, where an expression evaluates to an AST symbol and the AST symbol is looked up, and other weird things. <span id="id5">[<a class="reference internal" href="../zzreferences.html#id144" title="John N Shutt. Fexprs as the Basis of Lisp Function Application or \$vau : The Ultimate Abstraction. PhD thesis, WORCESTER POLYTECHNIC INSTITUTE, August 2010. URL: https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/.">Shu10</a>]</span> chapter 5 discusses various hygiene-breaking problems and concludes they aren’t too worrisome.</p>
<p><code class="docutils literal notranslate"><span class="pre">eval</span></code> is hard to compile, because it makes the full power of an interpreter available. But we can often simplify <code class="docutils literal notranslate"><span class="pre">eval</span> <span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span></code> to <code class="docutils literal notranslate"><span class="pre">eval</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">eval</span> <span class="pre">b</span></code>, reducing the amount of code that is evaluated each loop. If all of the variable lookups are static, we can furthermore optimize the environment to remove all unneeded variables. Hence we can recover macro-level performance on macros. Dynamic lookups need the full environment unfortunately. But dynamic lookups are essentially a REPL or debugging tool, so does not need to be too efficient, and we can warn that they are not optimized.</p>
<p>Fexprs make the equational theory of ASTs trivial, (<span id="id6">[<a class="reference internal" href="../zzreferences.html#id144" title="John N Shutt. Fexprs as the Basis of Lisp Function Application or \$vau : The Ultimate Abstraction. PhD thesis, WORCESTER POLYTECHNIC INSTITUTE, August 2010. URL: https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/.">Shu10</a>]</span>, chapter 15) in that ASTs can be completely deconstructed, so no two ASTS are behaviorally equivalent. But this is good, because it means the programmer’s intent can be fully examined. If <code class="docutils literal notranslate"><span class="pre">(\x.</span> <span class="pre">x)</span> <span class="pre">y</span></code> was equivalent to <code class="docutils literal notranslate"><span class="pre">y</span></code> then many DSL’s would not be possible. The behavior of programs containing fexprs is decidedly nontrivial and quite varied.</p>
</section>
<section id="parsing">
<h2>Parsing<a class="headerlink" href="#parsing" title="Permalink to this heading"></a></h2>
<p>Macros consume the syntax tree, so</p>
<p>The general procedure is as follows:</p>
<blockquote>
<div><p>Lean parses a command, creating a Lean syntax tree which contains any unexpanded macros.</p>
<p>Lean repeats the cycle (elaboration ~&gt; (macro hygiene and expansion) ~&gt; elaboration…)</p>
</div></blockquote>
<p>The cycle in step 2 repeats until there are no more macros which need to be expanded, and elaboration can finish normally. This repetition is required since macros can expand to other macros, and may expand to code that needs information from the elaborator. As you can see, the process of macro parsing and expansion is interleaved with the parsing and elaboration of non-macro code.</p>
<p>By default, macros in Lean are hygienic, which means the system avoids accidental name capture when reusing the same name inside and outside the macro. Users may occasionally want to disable hygiene, which can be accomplished with the command set_option hygiene false. More in-depth information about hygiene and how it’s implemented in the official paper and supplement linked at the top of this guide.
Elements of “a” macro (important types)</p>
<p>In the big picture, a macro has two components that must be implemented by the user, parsers and syntax transformers, where the latter is a function that says what the input syntax should expand to. There is a third component, syntax categories, such as term, tactic, and command, but declaring a new syntax category is not always necessary. When we say “parser” in the context of a macro, we refer to the core type Lean.ParserDescr, which parses elements of type Lean.Syntax, where Lean.Syntax represents elements of a Lean syntax tree. Syntax transformers are functions of type Syntax -&gt; MacroM Syntax. Lean has a synonym for this type, which is simply Macro. MacroM is a monad that carries state needed for macro expansion to work nicely, including the info needed to implement hygiene.</p>
<p>As an example, we again refer to Mathlib’s set builder notation:</p>
<p>/- Declares a parser -/
syntax (priority := high) “{” term,+ “}” : term</p>
<p>/- Declares two expansions/syntax transformers -/
macro_rules</p>
<blockquote>
<div><div class="line-block">
<div class="line"><a href="#id7"><span class="problematic" id="id8">`</span></a>({$x}) =&gt; <a href="#id9"><span class="problematic" id="id10">`</span></a>(Set.singleton $x)</div>
<div class="line"><a href="#id11"><span class="problematic" id="id12">`</span></a>({$x, $xs:term,*}) =&gt; <a href="#id13"><span class="problematic" id="id14">`</span></a>(Set.insert $x {$xs,*})</div>
</div>
</div></blockquote>
<p>/- Provided <cite>Set</cite> has been imported (from Mathlib4), these are all we need for <cite>{1, 2, 3}</cite> to be valid notation to create a literal set -/</p>
<p>This example should also make clear the reason why macros (and pretty much all of Lean 4’s metaprogramming facilities) are functions that take an argument of type Syntax e.g. Syntax -&gt; MacroM Syntax; the leading syntax element is the thing that actually triggers the macro expansion by matching with the declared parser, and as a user, you will almost always be interested in inspecting and transforming that initial syntax element (though there are cases in which it can just be ignored, as in the parameter-less exfalso tactic).</p>
<p>Returning briefly to the API provided by Lean, Lean.Syntax, is pretty much what you would expect a basic syntax tree type to look like. Below is a slightly simplified representation which omits details in the atom and ident constructors; users can create atoms and idents which comport with this simplified representation using the mkAtom and mkIdent methods provided in the Lean namespace.</p>
<dl>
<dt>inductive Syntax where</dt><dd><div class="line-block">
<div class="line">missing : Syntax</div>
<div class="line">node (kind : SyntaxNodeKind) (args : Array Syntax) : Syntax</div>
<div class="line">atom : String -&gt; Syntax</div>
<div class="line">ident : Name -&gt; Syntax</div>
</div>
</dd>
</dl>
<p>For those interested, MacroM is a ReaderT:</p>
<p>abbrev MacroM := ReaderT Macro.Context (EStateM Macro.Exception Macro.State)</p>
<p>The other relevant components are defined as follows:</p>
<dl>
<dt>structure Context where</dt><dd><p>methods        : MethodsRef
mainModule     : Name
currMacroScope : MacroScope
currRecDepth   : Nat := 0
maxRecDepth    : Nat := defaultMaxRecDepth
ref            : Syntax</p>
</dd>
<dt>inductive Exception where</dt><dd><div class="line-block">
<div class="line">error             : Syntax → String → Exception</div>
<div class="line">unsupportedSyntax : Exception</div>
</div>
</dd>
<dt>structure State where</dt><dd><p>macroScope : MacroScope
traceMsgs  : List (Prod Name String) := List.nil
deriving Inhabited</p>
</dd>
</dl>
<p>As a review/checklist, the three (sometimes only two depending on whether you need a new syntax category) components users need to be concerned with are:</p>
<blockquote>
<div><p>You may or may not need to declare a new syntax category using declare_syntax_cat
Declare a parser with either syntax or macro
Declare an expansion/syntax transformer with either macro_rules or macro</p>
</div></blockquote>
<p>Parsers and syntax transformers can be declared manually, but use of the pattern language and syntax, macro_rules, and macro is recommended.
syntax categories with declare_syntax_cat</p>
<p>declare_syntax_cat declares a new syntax category, like command, tactic, or mathlib4’s binderterm. These are the different categories of things that can be referred to in a quote/antiquote. declare_syntax_cat results in a call to registerParserCategory and produces a new parser descriptor:</p>
<p>set_option trace.Elab.definition true in
declare_syntax_cat binderterm</p>
<p>/-
Output:</p>
<p>[Elab.definition.body] binderterm.quot : Lean.ParserDescr :=
Lean.ParserDescr.node <a href="#id15"><span class="problematic" id="id16">`</span></a>Lean.Parser.Term.quot 1024</p>
<blockquote>
<div><dl class="simple">
<dt>(Lean.ParserDescr.binary <a href="#id17"><span class="problematic" id="id18">`</span></a>andthen (Lean.ParserDescr.symbol “<a href="#id19"><span class="problematic" id="id20">`</span></a>(binderterm|”)</dt><dd><dl class="simple">
<dt>(Lean.ParserDescr.binary <a href="#id21"><span class="problematic" id="id22">`</span></a>andthen (Lean.ParserDescr.cat <a href="#id23"><span class="problematic" id="id24">`</span></a>binderterm 0)</dt><dd><p>(Lean.ParserDescr.symbol “)”)))</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>-/</p>
<p>Declaring a new syntax category like this one automatically declares a quotation operator <a href="#id25"><span class="problematic" id="id26">`</span></a>(binderterm| …). These pipe prefixes &lt;thing&gt;| are used in syntax quotations to say what category a given quotation is expected to be an element of. The pipe prefixes are not used for elements in the term and command categories (since they’re considered the default), but need to be used for everything else.
Parsers and the syntax keyword</p>
<p>Internally, elements of type Lean.ParserDescr are implemented as parser combinators. However, Lean offers the ability to write parsers using the macro/pattern language by way of the syntax keyword. This is the recommended means of writing parsers. As an example, the parser for the rwa (rewrite, then use assumption) tactic is:</p>
<p>set_option trace.Elab.definition true in
syntax “rwa ” rwRuleSeq (location)? : tactic</p>
<p>/-
which expands to:
[Elab.definition.body] <a href="#id73"><span class="problematic" id="id74">tacticRwa__</span></a> : Lean.ParserDescr :=
Lean.ParserDescr.node <a href="#id27"><span class="problematic" id="id28">`</span></a><a href="#id73"><span class="problematic" id="id75">tacticRwa__</span></a> 1022</p>
<blockquote>
<div><dl class="simple">
<dt>(Lean.ParserDescr.binary <a href="#id29"><span class="problematic" id="id30">`</span></a>andthen</dt><dd><p>(Lean.ParserDescr.binary <a href="#id31"><span class="problematic" id="id32">`</span></a>andthen (Lean.ParserDescr.nonReservedSymbol “rwa ” false) Lean.Parser.Tactic.rwRuleSeq)
(Lean.ParserDescr.unary <a href="#id33"><span class="problematic" id="id34">`</span></a>optional Lean.Parser.Tactic.location))</p>
</dd>
</dl>
</div></blockquote>
<p>-/</p>
<p>Literals are written as double-quoted strings (“rwa ” expects the literal sequence of characters rwa, while the trailing space provides a hint to the formatter that it should add a space after rwa when pretty printing this syntax); rwRuleSeq and location are themselves ParserDescrs, and we finish with : tactic specifying that the preceding parser is for an element in the tactic syntax category. The parentheses around (location)? are necessary (rather than location?) because Lean 4 allows question marks to be used in identifiers, so location? is one single identifier that ends with a question mark, which is not what we want.</p>
<p>The name <a href="#id73"><span class="problematic" id="id76">tacticRwa__</span></a> is automatically generated. You can name parser descriptors declared with the syntax keyword like so:</p>
<p>set_option trace.Elab.definition true in
syntax (name := introv) “introv ” (colGt ident)* : tactic</p>
<p>/-
[Elab.definition.body] introv : Lean.ParserDescr :=
Lean.ParserDescr.node <a href="#id35"><span class="problematic" id="id36">`</span></a>introv 1022</p>
<blockquote>
<div><dl class="simple">
<dt>(Lean.ParserDescr.binary <a href="#id37"><span class="problematic" id="id38">`</span></a>andthen (Lean.ParserDescr.nonReservedSymbol “introv ” false)</dt><dd><dl class="simple">
<dt>(Lean.ParserDescr.unary <a href="#id39"><span class="problematic" id="id40">`</span></a>many</dt><dd><p>(Lean.ParserDescr.binary <a href="#id41"><span class="problematic" id="id42">`</span></a>andthen (Lean.ParserDescr.const <a href="#id43"><span class="problematic" id="id44">`</span></a>colGt) (Lean.ParserDescr.const <a href="#id45"><span class="problematic" id="id46">`</span></a>ident))))</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>-/</p>
<p>The pattern language</p>
<p>Available quantifiers are ? (one or zero occurrences, see note below), * (zero or more occurrences), and + (one or more occurrences).</p>
<p>Keep in mind that Lean makes ? available for use in identifiers, so if we want a parser to look for an optional location, we would need to write (location)? with parenthesis acting as a separator, since location? would look for something under the identifier location? (where the ? is part of the identifier).</p>
<p>Parentheses can be used as delimiters.</p>
<p>Separated lists can be constructed like so: $ts,* for a comma separated list.</p>
<p>“extended splices” can be constructed as $[..]. See the official paper (p. 12) for more details.</p>
<p>Literals are written as double-quoted strings. A literal may use trailing whitespace (see e.g. the rwa or introv tactics) to tell the pretty-printer how it should be displayed, but such whitespace will not prevent a literal with no trailing whitespace from matching. The spaces are relevant, but not interpreted literally. When the ParserDescr is turned into a Parser, the actual token matcher uses the .trim of the provided string, but the generated formatter uses the spaces as specified, that is, turning the atom “rwa” in the syntax into the string rwa as part of the pretty printed output.
Syntax expansions with macro_rules, and how it desugars.</p>
<p>macro_rules lets you declare expansions for a given Syntax element using a syntax similar to a match statement. The left-hand side of a match arm is a quotation (with a leading &lt;cat&gt;| for categories other than term and command) in which users can specify the pattern they’d like to write an expansion for. The right-hand side returns a syntax quotation which is the output the user wants to expand to.</p>
<p>A feature of Lean’s macro system is that if there are multiple expansions for a particular match, Lean will try the most recently declared expansion first, and will retry with other matching expansions if the previous attempt failed. This is particularly useful for extending existing tactics.</p>
<p>The following example shows both the retry behavior, and the fact that macros declared using the shorthand macro syntax can still have additional expansions declared with macro_rules. This transitivity tactic is implemented such that it will work for either Nat.le or Nat.lt. The Nat.lt version was declared “most recently”, so it will be tried first, but if it fails (for example, if the actual term in question is Nat.le) the next potential expansion will be tried:</p>
<p>macro “transitivity” e:(colGt term) : tactic =&gt; <a href="#id47"><span class="problematic" id="id48">`</span></a>(tactic| apply Nat.le_trans (m := $e))
macro_rules</p>
<blockquote>
<div><div class="line-block">
<div class="line"><a href="#id49"><span class="problematic" id="id50">`</span></a>(tactic| transitivity $e) =&gt; <a href="#id51"><span class="problematic" id="id52">`</span></a>(tactic| apply Nat.lt_trans (m := $e))</div>
</div>
</div></blockquote>
<dl class="simple">
<dt>example (a b c<span class="classifier">Nat) (h0</span><span class="classifier">a &lt; b) (h1</span><span class="classifier">b &lt; c)</span><span class="classifier">a &lt; c := by</span></dt><dd><p>transitivity b &lt;;&gt;
assumption</p>
</dd>
<dt>example (a b c<span class="classifier">Nat) (h0</span><span class="classifier">a &lt;= b) (h1</span><span class="classifier">b &lt;= c)</span><span class="classifier">a &lt;= c := by</span></dt><dd><p>transitivity b &lt;;&gt;
assumption</p>
</dd>
<dt>/- This will fail, but is interesting in that it exposes the “most-recent first” behavior, since the</dt><dd><p>error message complains about being unable to unify mvar1 &lt;= mvar2, rather than mvar1 &lt; mvar2. -/</p>
</dd>
</dl>
<p>/-
example (a b c : Nat) (h0 : a &lt;= b) (h1 : b &lt;= c) : False := by</p>
<blockquote>
<div><p>transitivity b &lt;;&gt;
assumption</p>
</div></blockquote>
<p>-/</p>
<p>To see the desugared definition of the actual expansion, we can again use set_option trace.Elab.definition true in and observe the output of the humble exfalso tactic defined in Mathlib4:</p>
<p>set_option trace.Elab.definition true in
macro “exfalso” : tactic =&gt; <a href="#id53"><span class="problematic" id="id54">`</span></a>(tactic| apply False.elim)</p>
<p>/-
Results in the expansion:</p>
<p>[Elab.definition.body] _aux___macroRules_tacticExfalso_1 : Lean.Macro :=
fun x =&gt;</p>
<blockquote>
<div><p>let discr := x;
/- This is where Lean tries to actually identify that it’s an invocation of the exfalso tactic -/
if Lean.Syntax.isOfKind discr <a href="#id55"><span class="problematic" id="id56">`</span></a>tacticExfalso = true then</p>
<blockquote>
<div><p>let discr := Lean.Syntax.getArg discr 0;
let x := discr;
do</p>
<blockquote>
<div><p>/- Lean getting scope/meta info from the macro monad -/
let info ← Lean.MonadRef.mkInfoFromRefPos
let scp ← Lean.getCurrMacroScope
let mainModule ← Lean.getMainModule
pure</p>
<blockquote>
<div><dl class="simple">
<dt>(Lean.Syntax.node Lean.SourceInfo.none <a href="#id57"><span class="problematic" id="id58">`</span></a>Lean.Parser.Tactic.seq1</dt><dd><dl class="simple">
<dt>#[Lean.Syntax.node Lean.SourceInfo.none <a href="#id59"><span class="problematic" id="id60">`</span></a>null</dt><dd><dl class="simple">
<dt>#[Lean.Syntax.node Lean.SourceInfo.none <a href="#id61"><span class="problematic" id="id62">`</span></a>Lean.Parser.Tactic.apply</dt><dd><dl class="simple">
<dt>#[Lean.Syntax.atom info “apply”,</dt><dd><dl class="simple">
<dt>Lean.Syntax.ident info (String.toSubstring “False.elim”)</dt><dd><p>(Lean.addMacroScope mainModule <a href="#id63"><span class="problematic" id="id64">`</span></a>False.elim scp) [(<a href="#id65"><span class="problematic" id="id66">`</span></a>False.elim, [])]]]])</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>else</dt><dd><p>/- If this wasn’t actually an invocation of the exfalso tactic, throw the “unsupportedSyntax” error -/
let discr := x;
throw Lean.Macro.Exception.unsupportedSyntax</p>
</dd>
</dl>
</div></blockquote>
<p>-/</p>
<p>We can also create the syntax transformer declaration ourselves instead of using macro_rules. We’ll need to name our parser and use the attribute &#64;[macro myExFalsoParser] to associate our declaration with the parser:</p>
<p>syntax (name := myExfalsoParser) “myExfalso” : tactic</p>
<p>– remember that <cite>Macro</cite> is a synonym for <cite>Syntax -&gt; TacticM Unit</cite>
&#64;[macro myExfalsoParser] def implMyExfalso : Macro :=
fun stx =&gt; <a href="#id67"><span class="problematic" id="id68">`</span></a>(tactic| apply False.elim)</p>
<dl class="simple">
<dt>example (p<span class="classifier">Prop) (h</span><span class="classifier">p) (f</span><span class="classifier">p -&gt; False)</span><span class="classifier">3 = 2 := by</span></dt><dd><p>myExfalso
exact f h</p>
</dd>
</dl>
<p>In the above example, we’re still using the sugar Lean provides for creating quotations, as it feels more intuitive and saves us some work. It is possible to forego the sugar altogether:</p>
<p>syntax (name := myExfalsoParser) “myExfalso” : tactic</p>
<dl class="simple">
<dt>&#64;[macro myExfalsoParser] def implMyExfalso<span class="classifier">Lean.Macro :=</span></dt><dd><dl class="simple">
<dt>fun stx =&gt; pure (Lean.mkNode <a href="#id69"><span class="problematic" id="id70">`</span></a>Lean.Parser.Tactic.apply</dt><dd><p>#[Lean.mkAtomFrom stx “apply”, Lean.mkCIdentFrom stx <a href="#id71"><span class="problematic" id="id72">``</span></a>False.elim])</p>
</dd>
</dl>
</dd>
<dt>example (p<span class="classifier">Prop) (h</span><span class="classifier">p) (f</span><span class="classifier">p -&gt; False)</span><span class="classifier">3 = 2 := by</span></dt><dd><p>myExfalso
exact f h</p>
</dd>
</dl>
<p>The macro keyword</p>
<p>macro is a shortcut which allows users to declare both a parser and an expansion at the same time as a matter of convenience. Additional expansions for the parser generated by the macro invocation can be added with a separate macro_rules block (see the example in the macro_rules section).
Unexpanders</p>
<p>TODO; for now, see the unexpander in Mathlib.Set for an example.
More illustrative examples:</p>
<p>The Tactic.Basic file in Mathlib4 contains many good examples to learn from.
Practical tips:</p>
<p>You can observe the output of commands and functions that in some way use the macro system by setting this option to true : set_option trace.Elab.definition true</p>
<p>Lean also offers the option of limiting the region in which option is set with the syntax set_option … in):</p>
<p>Hygiene can be disabled with the command option set_option hygiene false</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="LogicProgramming.html" class="btn btn-neutral float-left" title="Logic programming" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Memory-Management.html" class="btn btn-neutral float-right" title="Memory management" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>