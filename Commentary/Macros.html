<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Macros &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Memory management" href="Memory-Management.html" />
    <link rel="prev" title="Logic programming" href="LogicProgramming.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler-Library.html">Compiler library</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Intrinsics.html">Intrinsics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicProgramming.html">Logic programming</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Macros</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#comparison">Comparison</a></li>
<li class="toctree-l3"><a class="reference internal" href="#terminology">Terminology</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hygiene">Hygiene</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parsing">Parsing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#resources">Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#metrics">Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#methods">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#action">Action</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard-Library.html">Standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Macros</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/Macros.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="macros">
<h1>Macros<a class="headerlink" href="#macros" title="Permalink to this heading"></a></h1>
<p>Macros are a facility that allows defining syntactic extensions to a programming language. Macros implement the essence of Lisp: code can be used as data, and data can be used as code. Although in Lisp the transformation of code into data (specifically, an AST tree) is obvious as the S-expression syntax is just nested lists, in Stroscot we choose to have more complex syntax and accompanying mental overhead. It should be noted that even McCarthy the inventor of Lisp intended to use an M-expression (mathematical expression) syntax and S-expressions were only a matter of convenience.</p>
<section id="comparison">
<h2>Comparison<a class="headerlink" href="#comparison" title="Permalink to this heading"></a></h2>
<p>Macros, micros, and fexprs are all possibilities. Comparing them:</p>
<ol class="arabic simple" start="0">
<li><p>A (C) macro is a function translating text into text. Textual macros suffer from the scoping/name capture problem. Applying a macro <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">x=x+x</span></code> to a side-effectful expression like <code class="docutils literal notranslate"><span class="pre">double(i++)</span></code> executes the side effect twice. They allow unbalanced/incorrect expansions like <code class="docutils literal notranslate"><span class="pre">startLoop</span> <span class="pre">=</span> <span class="pre">while(true)</span> <span class="pre">{</span></code> and <code class="docutils literal notranslate"><span class="pre">double(+)</span> <span class="pre">=</span> <span class="pre">+++</span></code>. One often can’t easily determine the expanded expression due to multiple layers of macros. Furthermore looking for control flow paths is hard.</p></li>
<li><p>A (Scheme) macro is a function translating an AST node into an AST node. Macro substitution of an AST reduces away all macros and produces an AST. Scheme macros have a complex hygiene system to make naive macros handle scoping correctly and avoid name capture.</p></li>
<li><p>A micro <span id="id1">[<a class="reference internal" href="../zzreferences.html#id99" title="Shriram Krishnamurthi. Linguistic Reuse. PhD thesis, Rice University, 2001. URL: https://scholarship.rice.edu/handle/1911/17993 (visited on 2021-08-06).">Kri01</a>]</span> is a function translating from a source AST node and an environment to an expression in the intermediate language. Micro dispatch of an AST reduces away all micros and produces an intermediate representation.</p></li>
<li><p>An f-expression (fexpr) <span id="id2">[<a class="reference internal" href="../zzreferences.html#id144" title="John N Shutt. Fexprs as the Basis of Lisp Function Application or \$vau : The Ultimate Abstraction. PhD thesis, WORCESTER POLYTECHNIC INSTITUTE, August 2010. URL: https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/.">Shu10</a>]</span> is a function translating an AST node and an environment to a value. Fexpr evaluation of an AST reduces away all fexprs and produces a value.</p></li>
</ol>
<p>Fexprs are the most powerful: IR expressions and AST nodes are values, hence micros and macros can be implemented in terms of fexprs, but conversely fexprs can’t be emulated. E.g. we can implement Scheme macros as f-expressions by computing the AST and evaluating, <code class="docutils literal notranslate"><span class="pre">defmacro</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">\vau</span> <span class="pre">$args</span> <span class="pre">$env</span> <span class="pre">-&gt;</span> <span class="pre">eval</span> <span class="pre">$env</span> <span class="pre">(f</span> <span class="pre">$args)</span></code>, modulo some hygiene stuff. But there is no macro corresponding to an eval function <code class="docutils literal notranslate"><span class="pre">evalF</span> <span class="pre">=</span> <span class="pre">\vau</span> <span class="pre">$args</span> <span class="pre">env</span> <span class="pre">-&gt;</span> <span class="pre">\f</span> <span class="pre">-&gt;</span> <span class="pre">eval</span> <span class="pre">f</span> <span class="pre">$env</span></code> that evaluates a value in an environment at runtime.</p>
<p>Another advantage of fexprs is that there are no phases - the full language is always available and immediately executed. For example predicate dispatch of fexprs is possible - you just have to look up the argument values in the environment like with predicate dispatch on applicatives. In contrast macros can only overload on number of arguments because the precise values are not available in the preprocessing phase, and similarly micros have a linking phase for the IR. Hence implementing the compiler using the Futamura projection of specializing an interpreter to a program is only sensible for fexprs.</p>
</section>
<section id="terminology">
<h2>Terminology<a class="headerlink" href="#terminology" title="Permalink to this heading"></a></h2>
<p>Loosely adapting <span id="id3">[<a class="reference internal" href="../zzreferences.html#id144" title="John N Shutt. Fexprs as the Basis of Lisp Function Application or \$vau : The Ultimate Abstraction. PhD thesis, WORCESTER POLYTECHNIC INSTITUTE, August 2010. URL: https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/.">Shu10</a>]</span>’s terminology we get the following:</p>
<ul class="simple">
<li><p>Evaluation is a function from an AST node and a (lexical) environment to produce a value. Values are AST nodes that evaluate to themselves in every environment. A non-value AST node (reducible expression) is usually a variable <code class="docutils literal notranslate"><span class="pre">x</span></code> or an application <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code>, but since Stroscot is term-rewriting it can be anything.</p></li>
<li><p>A reduction rule maps particular AST nodes and environments to new AST nodes and environments. These AST nodes are of course reducible.</p></li>
<li><p>An applicative is a reduction rule that uses each pattern variable once by transforming it to an “argument” by evaluating it using the current environment.</p></li>
<li><p>An operative is a non-applicative reduction rule.</p></li>
<li><p>A (Scheme) macro is an operative that uses its operands to derive a syntax tree and then returns the result of evaluating the entire tree.</p></li>
<li><p>A (Scheme) special form is an operative built into the language, accessible by a reserved symbol.</p></li>
<li><p>A (Kernel) fexpr is a non-macro operative that is expressed as a <code class="docutils literal notranslate"><span class="pre">$vau</span></code> lambda taking unevaluated operands and the environment.</p></li>
</ul>
<p>Although it gives each concept its own name, “fexpr” is an unusual word with no prior referent except maybe the old Lisp I fexpr which didn’t take an environment hence couldn’t implement lexical scope. So Stroscot’s terminology follows <a class="reference external" href="http://www.newlisp.org/index.cgi?page=Differences_to_Other_LISPs">newLISP</a>  and calls fexprs “macros”:</p>
<ul class="simple">
<li><p>A Stroscot function is a Shutt applicative</p></li>
<li><p>A Stroscot macro is a Shutt operative</p></li>
</ul>
<p>Stroscot’s macros operate on ASTs like macros in other languages, so it’s clearer to the uninitiated to call them macros. But, they return a value instead of an AST, so they are more powerful than other languages’ macros.</p>
</section>
<section id="hygiene">
<h2>Hygiene<a class="headerlink" href="#hygiene" title="Permalink to this heading"></a></h2>
<p>Scheme macros are supposed to be “hygienic” in that they always evaluate expressions in the lexical environment of the macro’s definition site, as opposed to use site. But <span id="id4">[<a class="reference internal" href="../zzreferences.html#id95" title="Oleg Kiselyov. How to write seemingly unhygienic and referentially opaque macros with syntax-rules. In Third Workshop on Scheme and Functional Programming, 77. October 2002. URL: https://okmij.org/ftp/Scheme/Dirty-Macros.pdf.">Kis02</a>]</span> shows that in fact the environment of the use site is fully accessible through some tricks. The newer syntax-case allows explicit access through <code class="docutils literal notranslate"><span class="pre">datum-&gt;syntax</span></code>.</p>
<p>Fexprs in contrast get an explicit environment. They can do staged lookup, <code class="docutils literal notranslate"><span class="pre">eval</span> <span class="pre">$env</span> <span class="pre">(eval</span> <span class="pre">$env</span> <span class="pre">(f</span> <span class="pre">$args))</span></code>, where an expression evaluates to an AST symbol and the AST symbol is looked up, and other weird things. <span id="id5">[<a class="reference internal" href="../zzreferences.html#id144" title="John N Shutt. Fexprs as the Basis of Lisp Function Application or \$vau : The Ultimate Abstraction. PhD thesis, WORCESTER POLYTECHNIC INSTITUTE, August 2010. URL: https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/.">Shu10</a>]</span> chapter 5 discusses various hygiene-breaking problems and concludes they aren’t too worrisome.</p>
<p><code class="docutils literal notranslate"><span class="pre">eval</span></code> is hard to compile, because it makes the full power of an interpreter available. But we can often simplify <code class="docutils literal notranslate"><span class="pre">eval</span> <span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span></code> to <code class="docutils literal notranslate"><span class="pre">eval</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">eval</span> <span class="pre">b</span></code>, reducing the amount of code that is evaluated each loop. If all of the variable lookups are static, we can furthermore optimize the environment to remove all unneeded variables. Hence we can recover macro-level performance on macros. Dynamic lookups need the full environment unfortunately. But dynamic lookups are essentially a REPL or debugging tool, so does not need to be too efficient, and we can warn that they are not optimized.</p>
<p>Fexprs make the equational theory of ASTs trivial, (<span id="id6">[<a class="reference internal" href="../zzreferences.html#id144" title="John N Shutt. Fexprs as the Basis of Lisp Function Application or \$vau : The Ultimate Abstraction. PhD thesis, WORCESTER POLYTECHNIC INSTITUTE, August 2010. URL: https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/.">Shu10</a>]</span>, chapter 15) in that ASTs can be completely deconstructed, so no two ASTS are behaviorally equivalent. But this is good, because it means the programmer’s intent can be fully examined. If <code class="docutils literal notranslate"><span class="pre">(\x.</span> <span class="pre">x)</span> <span class="pre">y</span></code> was equivalent to <code class="docutils literal notranslate"><span class="pre">y</span></code> then many DSL’s would not be possible. The behavior of programs containing fexprs is decidedly nontrivial and quite varied.</p>
</section>
<section id="parsing">
<h2>Parsing<a class="headerlink" href="#parsing" title="Permalink to this heading"></a></h2>
<p>Macros consume the syntax tree, so</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="LogicProgramming.html" class="btn btn-neutral float-left" title="Logic programming" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Memory-Management.html" class="btn btn-neutral float-right" title="Memory management" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>