<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Logic programming &mdash; Stroscot  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/hexagon_favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Macros" href="Macros.html" />
    <link rel="prev" title="Logic" href="Logic.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hexagon_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HowTo/index.html">How to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Reference/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Commentary</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="Checklist.html">Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="Code-Generation.html">Code generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compiler-Library.html">Compiler library</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerOutput.html">Compiler output</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html">Concurrency</a></li>
<li class="toctree-l2"><a class="reference internal" href="CoreSyntax.html">Core syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="Dispatch.html">Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="Errors.html">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Evaluation-Strategy.html">Evaluation strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fastest.html">As fast as C</a></li>
<li class="toctree-l2"><a class="reference internal" href="IR.html">Intermediate representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Intrinsics.html">Intrinsics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Learning.html">Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Logic programming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#motivation">Motivation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semantics">Semantics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#relational">Relational</a></li>
<li class="toctree-l4"><a class="reference internal" href="#imperative">Imperative</a></li>
<li class="toctree-l4"><a class="reference internal" href="#proof-search">Proof-search</a></li>
<li class="toctree-l4"><a class="reference internal" href="#answer-set">Answer set</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#modes">Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unification">Unification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sources">Sources</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="Memory-Management.html">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Meta.html">Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="Objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="Parsing.html">Parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="Posets.html">Posets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html">Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#resources">Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#metrics">Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#statistics">Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#methods">Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#action">Action</a></li>
<li class="toctree-l2"><a class="reference internal" href="Profiling.html#caches">Caches</a></li>
<li class="toctree-l2"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l2"><a class="reference internal" href="Resource-Management.html">Resource management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Sets.html">Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard-Library.html">Standard library</a></li>
<li class="toctree-l2"><a class="reference internal" href="State.html">Stateful programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="TermRewriting.html">Term rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="Time.html">Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="Units.html">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../zzreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Stroscot</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Commentary</a></li>
      <li class="breadcrumb-item active">Logic programming</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Commentary/LogicProgramming.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="logic-programming">
<h1>Logic programming<a class="headerlink" href="#logic-programming" title="Permalink to this heading"></a></h1>
<section id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Permalink to this heading"></a></h2>
<p>Misquoting <span id="id1">[<a class="reference internal" href="../zzreferences.html#id79" title="Kenneth E. Iverson. Notation as a tool of thought. Communications of the ACM, 23(8):444–465, August 1980. URL: https://doi.org/10.1145/358896.358899 (visited on 2022-07-18), doi:10.1145/358896.358899.">Ive80</a>]</span>:</p>
<blockquote>
<div><p>Users of computers and programming languages are often concerned primarily with the efficiency of execution of algorithms, and might, therefore, summarily dismiss [logic programming]. Such dismissal would be short-sighted since a clear statement […] can usually be used as a basis from which one may easily derive a more efficient algorithm.</p>
<p>[…]</p>
<p>The practice of first developing a clear and precise definition […] without regard to efficiency, and then using it as a guide and a test in exploring equivalent processes possessing other characteristics, such as greater efficiency, is very common in mathematics. It is a very fruitful practice which should not be blighted by premature emphasis on efficiency in computer execution.</p>
<p>[…]</p>
<p>Finally, overemphasis of efficiency leads to an unfortunate circularity in design: for reasons of efficiency early programming languages reflected the characteristics of the early computers, and each generation of computers reflects the needs of the programming languages of the preceding generation.</p>
</div></blockquote>
<p>Practically, logic programming is a great tool for naturally expressing computational tasks that use logical constraints. Large programs generally run into one or two of these tasks. Without logic programming these tasks must be solved in an ad-hoc and verbose way. Compare <a class="reference external" href="https://www.metalevel.at/sudoku/">Sudoku with Prolog</a> vs <a class="reference external" href="https://norvig.com/sudopy.shtml">Norvig’s Sudoku solution</a>. Other examples include parsers, typecheckers, and database queries. Specifically:</p>
<ul class="simple">
<li><p>Prolog’s Definite Clause Grammars, and library <a class="reference external" href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/pio.pl">pio</a>, are a great parsing DSL. Furthermore the relation <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">parses_to</span> <span class="pre">Y</span></code> can be flipped to get <code class="docutils literal notranslate"><span class="pre">Y</span> <span class="pre">prints_to</span> <span class="pre">X</span></code>, automatically generating serializers from deserializers.</p></li>
<li><p>With typecheckers you can just directly translate the rules to Horn clauses and it runs. Similarly language interpreters are a direct translation of their operational semantics.</p></li>
<li><p>Incomplete data structures are great. <code class="docutils literal notranslate"><span class="pre">date(2018,</span> <span class="pre">month,</span> <span class="pre">14)</span></code> describes every 14th day in this year, and the month can be constrained or the set of dates extracted. Furthermore with constraint logic programming sets of dates can be manipulated.</p></li>
<li><p>Database queries are naturally expressed as logical operations on relations. For example pyDatalog and SQL can be called relational languages.</p></li>
</ul>
</section>
<section id="semantics">
<h2>Semantics<a class="headerlink" href="#semantics" title="Permalink to this heading"></a></h2>
<section id="relational">
<h3>Relational<a class="headerlink" href="#relational" title="Permalink to this heading"></a></h3>
<p>Logic programs over classical true, false, not, ∧, ∨, ⊃, ∀, and ∃ have what <span id="id2">[<a class="reference internal" href="../zzreferences.html#id26" title="William E. Byrd. Relational Programming in Minikanren: Techniques, Applications, and Implementations. PhD thesis, Indiana University, August 2009. URL: https://scholarworks.iu.edu/dspace/handle/2022/8777 (visited on 2022-07-14).">Byr09</a>]</span> terms “relational” semantics (to be confused with relational databases). A state is a map from some set of nominal variables to their substitution, a set of ground terms. A goal is a logical predicate over some variables - applying it to a state that defines the relevant variables gives true or false. Running a program consists of computing the set of satisifable states, which may be empty or infinite.</p>
<p>Practically the execution engine does not return a set, but rather a finite or infinite stream of satisfying meta-states. Meta-states are states that include unbound variables representing any term, and (in constraint logic programming) constraints for these unbound variables. Ideally the stream would be a minimal completely-covering set of meta-states in some arbitrary order, but in practice implementations can return identical or overlapping results.</p>
<p>miniKanren uses an “interleaving” search from <span id="id3">[<a class="reference internal" href="../zzreferences.html#id94" title="Oleg Kiselyov, Chung-chieh Shan, Daniel P. Friedman, and Amr Sabry. Backtracking, interleaving, and terminating monad transformers: (functional pearl). In Proceedings of the Tenth ACM SIGPLAN International Conference on Functional Programming - ICFP '05, 192. Tallinn, Estonia, 2005. ACM Press. URL: http://portal.acm.org/citation.cfm?doid=1086365.1086390 (visited on 2022-07-15), doi:10.1145/1086365.1086390.">KSFS05</a>]</span>, which is “complete” in the sense that it explores all branches fairly and will find all answers eventually. Generally the search strategy is irrelevant so long as it is fair, so there are many other choices; we can optimize the search, or dump the problem into an SMT solver and use its search strategy. CDCL with optimizations should be the fastest.</p>
</section>
<section id="imperative">
<h3>Imperative<a class="headerlink" href="#imperative" title="Permalink to this heading"></a></h3>
<p>Prolog has extended the execution engine with predicates that expose details of the underlying implementation:</p>
<ul class="simple">
<li><p>Cut (!) which commits to choices made since the parent goal was unified with the left-hand side of the clause containing the cut. miniKanren similarly includes operators conda (soft-cut) and condu (committed choice). Concurrent logic programming also has committed choice which prunes off all other branches once it is known that a clause’s guard goals all succeed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">var/1</span></code> which checks if the variable is unbound</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">copy_term/2</span></code> which can duplicate unbound variables to fresh ones</p></li>
<li><p>Side-effectful operations which execute even if the operation fails</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is</span></code> which - as a side effect - computes an arithmetic expression and binds a variable</p></li>
<li><p>unfair search so that <code class="docutils literal notranslate"><span class="pre">ancestor_of(A,</span> <span class="pre">P)</span> <span class="pre">:-</span> <span class="pre">ancestor_of(A,</span> <span class="pre">Parent),</span> <span class="pre">parent_of(Parent,</span> <span class="pre">P).</span> <span class="pre">:-</span> <span class="pre">ancestor_of(x,y)</span></code> diverges e switching the order of the goals does not</p></li>
<li><p>Meta-programming which allows querying or modifying clauses at run time, such as nth_clause, assert, retract</p></li>
</ul>
<p>In particular these features expose Prolog’s search strategy. Prolog uses a simple depth-first search strategy, “SLD resolution”, to explore clauses. This means the denotational semantics of programs must include the search strategy’s implementation and any goal side effects. SLD resolution is inefficient and biased compared to more modern logic search strategies such as DPLL or CDCL. But SLD’s simplicity is the main reason imperative Prolog execution is comprehensible.</p>
<p>Programs that heavily use imperative features and SLD resolution are best understood using an imperative execution model with embedded backtracking commands that can re-execute side-effectful operations. The imperative “Byrd Box” execution model was first described in “Understanding the control flow of Prolog programs” by Lawrence Byrd. This paper is not available online but the idea is described in many other places, e.g. <a class="reference external" href="https://www.amzi.com/articles/prolog_under_the_hood.htm">Merritt</a>, and is visible in Prolog debuggers. It goes as follows. A goal is of type <code class="docutils literal notranslate"><span class="pre">Goal</span> <span class="pre">=</span> <span class="pre">{call</span> <span class="pre">:</span> <span class="pre">Entry,</span> <span class="pre">redo</span> <span class="pre">:</span> <span class="pre">Entry</span> <span class="pre">};</span> <span class="pre">Entry</span> <span class="pre">=</span> <span class="pre">{exit:</span> <span class="pre">Entry,</span> <span class="pre">fail</span> <span class="pre">:</span> <span class="pre">Entry}</span> <span class="pre">-&gt;</span> <span class="pre">Exit;</span> <span class="pre">Exit</span> <span class="pre">=</span> <span class="pre">IO</span> <span class="pre">()</span></code>. The composition <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">,</span> <span class="pre">B</span></code> of two goals is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">comp</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="kt">B</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Goal</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">exit</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">redo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">exit</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">where</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">A</span><span class="o">.</span><span class="n">call</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">f</span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">B</span><span class="o">.</span><span class="n">call</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">e</span>
<span class="w">  </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">exit</span>
<span class="w">  </span><span class="n">d</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">B</span><span class="o">.</span><span class="n">redo</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">e</span>
<span class="w">  </span><span class="n">e</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">A</span><span class="o">.</span><span class="n">redo</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">f</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fail</span>
</pre></div>
</div>
<p>Various examples of goals:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">write</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="n">print</span><span class="w"> </span><span class="kt">X</span><span class="p">;</span><span class="w"> </span><span class="n">exit</span><span class="p">}</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">redo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="p">}</span>
<span class="nf">fail</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">redo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="p">}</span>
<span class="nf">cut</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">exit</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">redo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">abort_goal</span><span class="w"> </span><span class="p">}</span>
<span class="nf">unify</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="kt">Y</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newGoalId</span><span class="p">;</span>
<span class="w">  </span><span class="n">tryNext</span><span class="w"> </span><span class="ow">=</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">pop</span><span class="w"> </span><span class="n">unifiers</span><span class="p">)</span>
<span class="w">      </span><span class="n">pushChoicePoint</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="n">unifiers</span><span class="p">)</span>
<span class="w">      </span><span class="n">unify</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="n">u</span>
<span class="w">      </span><span class="n">exit</span>
<span class="w">    </span><span class="kr">else</span>
<span class="w">      </span><span class="n">fail</span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="ow">=</span>
<span class="w">      </span><span class="p">(</span><span class="kt">X</span><span class="p">,</span><span class="w"> </span><span class="kt">Y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">lookupOrAllocVars</span><span class="w"> </span><span class="p">(</span><span class="kt">X</span><span class="p">,</span><span class="kt">Y</span><span class="p">)</span>
<span class="w">      </span><span class="n">unifiers</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">unificationAlgo</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="kt">Y</span>
<span class="w">      </span><span class="n">pushChoicePoint</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">unifiers</span>
<span class="w">      </span><span class="n">tryNext</span>
<span class="w">    </span><span class="n">redo</span><span class="w"> </span><span class="ow">=</span>
<span class="w">      </span><span class="n">unifiers</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">popChoicePoint</span><span class="w"> </span><span class="n">r</span>
<span class="w">      </span><span class="n">tryNext</span>
<span class="w">  </span><span class="p">}</span>

<span class="nf">predicate</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">newGoalId</span>
<span class="w">  </span><span class="n">tryNext</span><span class="w"> </span><span class="ow">=</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">pop</span><span class="w"> </span><span class="n">unifiers</span><span class="p">)</span>
<span class="w">      </span><span class="n">pushChoicePoint</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="n">unifiers</span><span class="p">)</span>
<span class="w">      </span><span class="n">unify</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="n">u</span>
<span class="w">      </span><span class="n">exit</span>
<span class="w">    </span><span class="kr">else</span>
<span class="w">      </span><span class="n">fail</span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">call</span><span class="w"> </span><span class="ow">=</span>
<span class="w">      </span><span class="n">unifiers</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">findClauses</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">findUnifiers</span>
<span class="w">      </span><span class="n">pushChoicePoint</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">unifiers</span>
<span class="w">      </span><span class="n">tryNext</span>
<span class="w">    </span><span class="n">redo</span><span class="w"> </span><span class="ow">=</span>
<span class="w">      </span><span class="n">unifiers</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">popChoicePoint</span><span class="w"> </span><span class="n">r</span>
<span class="w">      </span><span class="n">tryNext</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>The general advice is to use imperative features <a class="reference external" href="http://www.cse.unsw.edu.au/~billw/dictionaries/prolog/cut.html">sparingly</a> and only if you can justify the need based on performance. <span id="id4">[<a class="reference internal" href="../zzreferences.html#id26" title="William E. Byrd. Relational Programming in Minikanren: Techniques, Applications, and Implementations. PhD thesis, Indiana University, August 2009. URL: https://scholarworks.iu.edu/dspace/handle/2022/8777 (visited on 2022-07-14).">Byr09</a>]</span> shows that, for a sample program, these features can be completely avoided. Cut can almost always be replaced with a tagging scheme that makes the matching clause unambiguous, or more expressive constraints. Byrd says there is no complete method for avoiding copy-term, but in his example it can be replaced by using templates with unique names and substituting these with logic variables.</p>
<p>Overall it seems that imperative features are antipatterns: band-aid implementation hacks that can be avoided by making the compiler smarter or the constraint language more expressive. Mercury has eliminated these features in favor of a state-token I/O system. <span id="id5">[<a class="reference internal" href="../zzreferences.html#id72" title="Fergus Henderson, Zoltan Somogyi, and Thomas Conway. Determinism analysis in the Mercury compiler. In In Proceedings of the Australian Computer Science Conference, 337–346. 1996. URL: https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.17.3967&amp;rep=rep1&amp;type=pdf.">HSC96</a>]</span></p>
<ul class="simple">
<li><p>XSB: <a class="reference external" href="http://xsb.sourceforge.net/manual1/manual1.pdf">http://xsb.sourceforge.net/manual1/manual1.pdf</a></p></li>
</ul>
</section>
<section id="proof-search">
<h3>Proof-search<a class="headerlink" href="#proof-search" title="Permalink to this heading"></a></h3>
<p>A more general paradigm is sequent proof search, which allows all the connectives of linear logic and extensions such as infinite proof trees. A logic program consists of some list of program clauses (proof sequents) ∆ which can be seen as assumptions or axioms. There is then a goal sequent !∆, C −→ G representing a search state in which formulas ∆ are assumed, resources C are provided, and the goal is G. The logic engine then searches for proof trees which prove this sequent. Via the Curry-Howard correspondence, these proof trees correspond to programs of the type described by the sequent. As with relational programming a finite or infinite stream of satisfying programs is returned.</p>
<p>Since programs such as <code class="docutils literal notranslate"><span class="pre">undefined</span></code> trivially satisfy all goals, restrictions must be made to the space of proofs to obtain useful results. The standard restriction is to finite “cut free” proofs, which by the cut elimination theorem can prove all sequents with finite proofs. Uniform proofs are cut-free sequent proofs P such that every subproof of P is uniform and also for every non-atomic formula occurrence B in the right-hand side of the end-sequent of P, there is a proof P0 equal to P up to permutation of inference rules such that P0’s last inference rule is the right introduction rule for the top-level logical connective occurring in B. The existence of uniform proofs allow a goal-directed search which starts by logically decomposing goals. It is only when the goal formula is atomic that other proof methods are used (“backchaining”). An abstract logic programming language is a system of goals, formulas, and rules such that a sequent has a proof if and only if it has a uniform proof.</p>
<p>Uniformity seems mainly useful for classical logic. In linear logic the dynamics of cut-free proof search can be described via Andreoli’s focused proofs which alternate between “unfocused”/goal-reduction decomposition of all asynchronous formulas and “focused”/backchaining decomposition of some synchronous formula by using introduction rules for its top-level connective and all synchronous subformulas that might arise.</p>
</section>
<section id="answer-set">
<h3>Answer set<a class="headerlink" href="#answer-set" title="Permalink to this heading"></a></h3>
<p>Answer-set programming (ASP) rebases the solving process onto SMT/SAT-style propositional solvers. ASP is based on “stable-model semantics”, which competes with “program completion” and the “well-founded semantics” to define the meaning of negation. Program completion <span id="id6">[<a class="reference internal" href="../zzreferences.html#id30" title="Keith L. Clark. Negation as Failure. In Hervé Gallaire and Jack Minker, editors, Logic and Data Bases, pages 293–322. Springer US, Boston, MA, 1978. URL: http://www.doc.ic.ac.uk/~klc/NegAsFailure.pdf (visited on 2022-07-15), doi:10.1007/978-1-4684-3384-5_11.">Cla78</a>]</span> interprets as a clause <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">:-</span> <span class="pre">q,</span> <span class="pre">not</span> <span class="pre">r</span></code> as “p if and only if q and not r”. A stable model is a mapping <code class="docutils literal notranslate"><span class="pre">Prop</span> <span class="pre">-&gt;</span> <span class="pre">{T,F}</span></code> such that for each clause <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">:-</span> <span class="pre">B1,</span> <span class="pre">…,</span> <span class="pre">Bm</span> <span class="pre">,</span> <span class="pre">not</span> <span class="pre">C1,</span> <span class="pre">…,</span> <span class="pre">not</span> <span class="pre">Cn</span></code> either some proposition <code class="docutils literal notranslate"><span class="pre">Ci</span></code> is true or the negation-free sequent <code class="docutils literal notranslate"><span class="pre">B1,</span> <span class="pre">…,</span> <span class="pre">Bm</span> <span class="pre">|-</span> <span class="pre">A</span></code> holds.</p>
<p>Although the semantics of ASP is conventional first-order logic, existing practical tools for ASP only implement propositional solvers, not first-order logic - they work by first “grounding” the first-order formulae to a propositional representation, and then solving them. Compared to SLDNF this can cause blow-up or speed-up but under a finite domain assumption it gives the same results.</p>
</section>
</section>
<section id="modes">
<h2>Modes<a class="headerlink" href="#modes" title="Permalink to this heading"></a></h2>
<p>Mercury has <a class="reference external" href="https://www.mercurylang.org/information/doc-latest/mercury_ref/Modes.html#Modes">modes</a>. An instantiation state is either “free”, a unbound variable “distinct” in that it does not appear anywhere else, or “bound”, a mapping from possible function symbols to instantiation states of the symbols’ arguments. A mode is a mapping from initial instantiation states to final instantiation states, with the constraint that no node is transformed from bound to free. The two standard modes are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">==</span> <span class="pre">ground</span> <span class="pre">&gt;&gt;</span> <span class="pre">ground.</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">==</span> <span class="pre">free</span> <span class="pre">&gt;&gt;</span> <span class="pre">ground.</span></code></p></li>
</ul>
<p>There are other states, e.g. <code class="docutils literal notranslate"><span class="pre">X</span></code> in the term <code class="docutils literal notranslate"><span class="pre">[X,X]</span></code> is neither free nor bound, hence Mercury’s mode system is incomplete.  I think this deficiency can be fixed by allowing constrained modes, at the expense of making the definition of modes even more complicated.</p>
<p>Mercury also categorises each mode of a predicate according to how many times it can succeed:</p>
<ul class="simple">
<li><p>deterministic: exactly one solution</p></li>
<li><p>semideterministic: no solutions or one solution</p></li>
<li><p>multisolution: at least one solution</p></li>
<li><p>nondeterministic: zero, one, or more solutions</p></li>
<li><p>failure/erroneous: no solution, always fails/errors</p></li>
</ul>
<p>For example append can work in several modes:</p>
<ul class="simple">
<li><p>predicate (in, in, in), semideterministic: <code class="docutils literal notranslate"><span class="pre">append</span> <span class="pre">[a,b]</span> <span class="pre">[c]</span> <span class="pre">[a,b,c]</span> <span class="pre">--&gt;</span> <span class="pre">yes</span></code></p></li>
<li><p>function (in, in, out), deterministic: <code class="docutils literal notranslate"><span class="pre">append</span> <span class="pre">[a,b]</span> <span class="pre">[c]</span> <span class="pre">Z</span> <span class="pre">--&gt;</span> <span class="pre">Z</span> <span class="pre">=</span> <span class="pre">[a,b,c]</span></code></p></li>
<li><p>match left (out, in, in), semideterministic: <code class="docutils literal notranslate"><span class="pre">append</span> <span class="pre">X</span> <span class="pre">[c]</span> <span class="pre">[a,b,c]</span> <span class="pre">--&gt;</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">[a,b]</span></code></p></li>
<li><p>match both (out, out, in), nondeterministic: <code class="docutils literal notranslate"><span class="pre">append</span> <span class="pre">X</span> <span class="pre">Y</span> <span class="pre">[a,b,c]</span> <span class="pre">--&gt;</span> <span class="pre">X=[],Y=[a,b,c];X=[a],Y=[b,c];X=[a,b],Y=[c],X=[a,b,c],Y=[]</span></code></p></li>
<li><p>match all (out, out, out), nondeterministic: <code class="docutils literal notranslate"><span class="pre">append</span> <span class="pre">X</span> <span class="pre">Y</span> <span class="pre">Z</span> <span class="pre">--&gt;</span> <span class="pre">X=[],Y=[],Z=[];...</span></code></p></li>
</ul>
<p>Each mode is a function from inputs to a set of outputs (or output / Maybe, in the deterministic/semideterministic case). So, characterizing all uses of predicates with mode declarations, predicates can be thought of as a collection of ad-hoc overloaded functions. Except it’s not ad-hoc, because they all represent the same logical relation. Anyways, we can embed functional programming into logic programming, by a mode declaration <code class="docutils literal notranslate"><span class="pre">(in,</span> <span class="pre">out),</span> <span class="pre">deterministic</span></code> for each function. Similarly we can embed term rewriting, by a mode declaration <code class="docutils literal notranslate"><span class="pre">(in,</span> <span class="pre">out),</span> <span class="pre">nondeterministic</span></code> for the rewrite relation. The reverse is not possible - we cannot get from the behavior on a specific mode to the overall behavior of the predicate. To support logic programming in an integrated manner everything must be interpretable as a logic program.</p>
<p>Logic programming allows writing very concise code, although it can be unusably inefficient in some cases. For this, we can allow writing optimized imperative code, and asserting that this implements a specific mode of a predicate. Then the predicate becomes optimized. But with a smart compiler, the imperative code can be avoided most of the time, saving the need for duplication - just tune the hot cases. Similarly writing imperative code in the first place avoids the issue altogether, although it precludes most of the benefits of logic programming.</p>
</section>
<section id="unification">
<h2>Unification<a class="headerlink" href="#unification" title="Permalink to this heading"></a></h2>
<p>Unification is the problem of finding all solutions to a system of equations. First-order unification solves a set of equalities <code class="docutils literal notranslate"><span class="pre">a1=b1,</span> <span class="pre">a2=b2,</span> <span class="pre">...</span></code> over tree terms and variables. This can be extended to the “dual unification” problem that also includes disequations <code class="docutils literal notranslate"><span class="pre">c1</span> <span class="pre">!=</span> <span class="pre">d1</span></code> in the list that must not be satisfied. Constraint logic programming requires solving systems of equations over reals or other sets. The solution takes the form of a complete set of unifiers, where each unifier is a substitution that may have its free variables substituted to obtain a solution, together with constraints over those free variables. A substitution is a set of assignments from variables to expressions.</p>
<p>Unification isn’t really part of the semantics of logic programming, as the semantics is phrased in terms of satisfiability. But it is a standard technique used in implementing logic programming, and in practice the implementation defines the semantics. Prolog only implements first-order unification. Teyjus / λProlog limit to higher-order “pattern lambdas”. With ZipperPosition <span id="id7">[<a class="reference internal" href="../zzreferences.html#id164" title="Petar Vukmirović, Alexander Bentkamp, and Visa Nummelin. Efficient Full Higher-Order Unification. Logical Methods in Computer Science, December 2021. URL: https://lmcs.episciences.org/8837/pdf (visited on 2022-06-14), doi:10.46298/lmcs-17(4:18)2021.">VBN21</a>]</span> there is outlined a full higher-order unification algorithm extending Huet’s semi-algorithm - the need to support multiple unifiers for a complete set complicates things a bit.</p>
<p>The outline of every unification algorithm is that it randomly applies simplifying reduction operations to an equation until it results in a substitution, then applies the substitution to the remaining equations (dereferencing). Here we show <span id="id8">[<a class="reference internal" href="../zzreferences.html#id164" title="Petar Vukmirović, Alexander Bentkamp, and Visa Nummelin. Efficient Full Higher-Order Unification. Logical Methods in Computer Science, December 2021. URL: https://lmcs.episciences.org/8837/pdf (visited on 2022-06-14), doi:10.46298/lmcs-17(4:18)2021.">VBN21</a>]</span>’s, adapted to match the presentation on <a class="reference external" href="https://en.wikipedia.org/wiki/Unification_(computer_science)#A_unification_algorithm">Wikipedia</a>:</p>
<ul class="simple">
<li><p>delete: <code class="docutils literal notranslate"><span class="pre">s=s</span></code> is removed</p></li>
<li><p>decompose: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">s1</span> <span class="pre">...</span> <span class="pre">sm</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">t1</span> <span class="pre">...</span> <span class="pre">tm</span></code> to equations <code class="docutils literal notranslate"><span class="pre">{s1</span> <span class="pre">=</span> <span class="pre">t1,</span> <span class="pre">...,</span> <span class="pre">sm</span> <span class="pre">=</span> <span class="pre">tm</span> <span class="pre">}</span></code></p></li>
<li><p>rigid/rigid conflict: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">sm</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">tn</span></code> fails if a and b are different rigid heads</p></li>
<li><p>dereference: <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">s1</span> <span class="pre">...</span> <span class="pre">sn</span> <span class="pre">=</span> <span class="pre">t</span></code> to <code class="docutils literal notranslate"><span class="pre">(F</span> <span class="pre">/.</span> <span class="pre">σ)</span> <span class="pre">...</span> <span class="pre">=</span> <span class="pre">t</span></code>, if the substitution σ from another equation maps F</p></li>
<li><p>empty equation list: trivially soluble</p></li>
<li><p>alpha/eta normalization: <code class="docutils literal notranslate"><span class="pre">λxm.s</span> <span class="pre">=</span> <span class="pre">λyn.t</span></code> to <code class="docutils literal notranslate"><span class="pre">λxm.s</span> <span class="pre">=</span> <span class="pre">λxm.t'</span> <span class="pre">xn+1</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">xm</span></code>, where <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">≥</span> <span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">xi</span></code> disjoint from <code class="docutils literal notranslate"><span class="pre">yj</span></code>, and <code class="docutils literal notranslate"><span class="pre">t'</span> <span class="pre">=</span> <span class="pre">t</span> <span class="pre">/.</span> <span class="pre">{y1</span> <span class="pre">→</span> <span class="pre">x1</span> <span class="pre">,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">yn</span> <span class="pre">→</span> <span class="pre">xn</span> <span class="pre">}</span></code></p></li>
<li><p>beta normalization: reduce left/right to hnf</p></li>
<li><p>under lambda: apply rule for <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code> to <code class="docutils literal notranslate"><span class="pre">λx.</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">λx.</span> <span class="pre">b</span></code></p></li>
</ul>
<p>ZipperPosition has more complex reductions for hard cases:</p>
<ul class="simple">
<li><p>oracle fail: <code class="docutils literal notranslate"><span class="pre">s=t</span></code> fails if oracle determines to be insoluble</p></li>
<li><p>oracle success: <code class="docutils literal notranslate"><span class="pre">s=t</span></code> has finite CSU, branch to each solution σ_i</p></li>
<li><p>bind: try projections with the following binding substitutions:</p>
<ul>
<li><p>flex-rigid <code class="docutils literal notranslate"><span class="pre">P(λx.</span> <span class="pre">F</span> <span class="pre">s</span> <span class="pre">=</span> <span class="pre">λx.</span> <span class="pre">a</span> <span class="pre">t)</span></code>: try an imitation of a for F, if a is constant, and all Huet-style projections for F, if F is not an identification variable.</p></li>
<li><p>flex-flex with different heads <code class="docutils literal notranslate"><span class="pre">P(λx.</span> <span class="pre">F</span> <span class="pre">s</span> <span class="pre">=</span> <span class="pre">λx.</span> <span class="pre">G</span> <span class="pre">t)</span></code>: all identifications and iterations for both F and G, and all JP-style projections for non-identification variables among F and G.</p></li>
<li><p>flex-flex with identical heads and the head is an elimination variable, <code class="docutils literal notranslate"><span class="pre">P(λx.</span> <span class="pre">s</span> <span class="pre">=</span> <span class="pre">λx.</span> <span class="pre">t)</span></code>: no bindings.</p></li>
<li><p>flex-flex with identical heads, <code class="docutils literal notranslate"><span class="pre">P(λx.</span> <span class="pre">F</span> <span class="pre">s</span> <span class="pre">=</span> <span class="pre">λx.</span> <span class="pre">F</span> <span class="pre">t)</span></code>: all iterations for F at arguments of functional type and all eliminations for F.</p></li>
</ul>
</li>
</ul>
<p>The flex-binding step is slow, but a good set of oracles makes the algorithm efficient for most practical cases. Of course it would be better to find reduction rules that solve things generally rather than oracles which work on specific cases, but this is hard.</p>
<p>The unifier search can be integrated with the overall logical search for satisfiable formulas.</p>
<p>By default Prolog does not use the <a class="reference external" href="https://en.wikipedia.org/wiki/Occurs_check">occurs check</a> in unification. This means for <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">f</span> <span class="pre">x</span></code> the substitution <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">x</span></code> is obtained. Denotationally this can be accommodated by allowing states to contain infinite rational terms, <span id="id9">[<a class="reference internal" href="../zzreferences.html#id168" title="W.P. Weijland. Semantics for logic programs without occur check. Theoretical Computer Science, 71(1):155–174, March 1990. URL: https://linkinghub.elsevier.com/retrieve/pii/030439759090194M (visited on 2022-07-15), doi:10.1016/0304-3975(90)90194-M.">Wei90</a>]</span> <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">(f</span> <span class="pre">(f</span> <span class="pre">(...)))</span></code> in this case. In most Prolog programs the occurs check does not make a difference and simply slows down unification. <span id="id10">[<a class="reference internal" href="../zzreferences.html#id10" title="Krzysztof R. Apt and Alessandro Pellegrini. Why the occur-check is not a problem. In Maurice Bruynooghe and Martin Wirsing, editors, Programming Language Implementation and Logic Programming, volume 631, pages 69–86. Springer-Verlag, Berlin/Heidelberg, 1992. URL: http://link.springer.com/10.1007/3-540-55844-6_128 (visited on 2022-07-14), doi:10.1007/3-540-55844-6_128.">AP92</a>]</span> Prolog defines a <code class="docutils literal notranslate"><span class="pre">unify_with_occurs_check</span></code> predicate, and has an option for doing the occurs check in the implicit unification when dispatching predicates. Meanwhile miniKanren always uses the occurs check. The occurs check is needed in first order logic theorem-proving, where skolemization turns quantifiers into variables and is sound only if the occurs check is used.</p>
</section>
<section id="sources">
<h2>Sources<a class="headerlink" href="#sources" title="Permalink to this heading"></a></h2>
<p>Based on:
* <a class="reference external" href="https://stackoverflow.com/questions/28467011/what-are-the-main-technical-differences-between-prolog-and-minikanren-with-resp">Byrd</a>, author of miniKanren
* <a class="reference external" href="https://www.reddit.com/r/ProgrammingLanguages/comments/9kb9z5/logic_programming_languages/">Reddit thread</a>, particularly Paul Bone who did his PhD “Automatic Parallelism in Mercury”)
* <a class="reference external" href="https://news.ycombinator.com/item?id=14439137">HN thread</a></p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Logic.html" class="btn btn-neutral float-left" title="Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Macros.html" class="btn btn-neutral float-right" title="Macros" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022 Mathnerd314.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>