

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Memory management &mdash; Stroscot  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="_static/hexagon_favicon.png"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Assembly" href="Assembly.html" />
    <link rel="prev" title="Compiler design" href="Compiler.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html">
          

          
            
            <img src="_static/hexagon_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="About.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fexprs.html">Metaprogramming</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arguments.html">Argument passing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="Overloading.html">Overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="Delimited-Continuations.html">Delimited continuations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="Verification.html">Verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="Logic.html">Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reduction.html#random-old-junk">Random old junk</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l1"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Memory management</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#user-level-primitives">User-level primitives</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pointers">Pointers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#representation">Representation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#non-default-representations">Non-default representations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id2">Memory management</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#manual-memory-management">Manual memory management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compiler-memory-management">Compiler memory management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#copy-management">Copy management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#resource-management">Resource management</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Assembly.html">Assembly</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="zzreferences.html">References</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Stroscot</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Memory management</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Memory.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="memory-management">
<h1>Memory management<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h1>
<p>Programming in Stroscot by default sees a mathematical view of data: all data is fixed once created, and there is infinite storage space. And with the availability of cloud storage this model is pretty much accurate: global storage capacity is measured in zettabytes, and there is always a backup / history mechanism in place.</p>
<p>But the path from cloud to CPU is long, so there is a lot of caching in between:</p>
<p>Physical registers (0.3 ns): managed by the CPU
Logical registers (0.3 ns): assembly
Memory Ordering Buffers (MOB), L1/L2/L3 Cache (0.5-7 ns): Managed by the CPU
Main Memory (0.1us-4us): assembly
SSD (16us-62us): file APIs
LAN (0.5-500ms): network stack
HDD (3 ms): file APIs
WAN (150ms): network stack</p>
<p>for more advanced programming there is the need to avoid the use of slow storage mechanisms as much as possible by addressing the fast storage mechanisms directly.</p>
<p>The point of the memory system is to assign a storage location for every value, insert moves / frees where necessary, and overall minimize the amount of resources consumed.</p>
<div class="section" id="user-level-primitives">
<h2>User-level primitives<a class="headerlink" href="#user-level-primitives" title="Permalink to this headline">¶</a></h2>
<div class="section" id="pointers">
<h3>Pointers<a class="headerlink" href="#pointers" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>memory cell</dt><dd><p>An integer <code class="docutils literal notranslate"><span class="pre">i</span></code> with <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">MAX</span></code>. Since ternary computers <a class="reference external" href="https://www.extremetech.com/computing/295424-back-off-binary-samsung-backed-researchers-debut-ternary-semiconductor">might</a> eventually become popular, you should not assume that <code class="docutils literal notranslate"><span class="pre">MAX</span></code> is a power of 2, but for all practical purposes this will be some fixed number of logical bits (0/1).</p>
</dd>
</dl>
<p>Pointers are indices into a shared global sparse array of memory cells. It is in fact possible to implement the typical <a class="reference external" href="https://developer.android.com/reference/android/util/SparseArray">sparse array operations</a>. There are functions to directly allocate memory at an address, <a class="reference external" href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a> with MAP_FIXED_NOREPLACE on Linux and <a class="reference external" href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> on Windows. Reading and writing are done directly in assembly. The list of currently mapped pages can be had from <code class="docutils literal notranslate"><span class="pre">/proc/self/maps</span></code> and <a class="reference external" href="https://reverseengineering.stackexchange.com/questions/8297/proc-self-maps-equivalent-on-windows/8299">VirtualQueryEx</a>, although this has to be filtered to remove pages reserved by the kernel and internal pages allocated by the runtime, and looks slow - it’s easier to wrap the allocation functions and maintain a separate list of user-level allocations. Clearing mappings, hashing memory, and indexing by mapped pages all work when restricted to the list of user pages.</p>
<p>In practice direct allocation is never used and instead there are <code class="docutils literal notranslate"><span class="pre">mmap</span> <span class="pre">NULL</span></code> and <code class="docutils literal notranslate"><span class="pre">malloc</span></code> which allocate memory with system-chosen location. This means that the program behavior must be observationally equivalent no matter what addresses the system picks. The limitations on the system’s choice are that the allocation must be suitably aligned and disjoint from all unrevoked allocations. (The system can also return an out of memory error, but this doesn’t have to result in equivalent behavior so it can be ignored.)</p>
<p>We also want to support interfacing with other languages, so we need a pair <code class="docutils literal notranslate"><span class="pre">record_foreign</span></code> / <code class="docutils literal notranslate"><span class="pre">erase_foreign</span></code> that functions similarly to direct allocation but doesn’t actually call into the OS.</p>
<p>Eliminating pointer reads amounts to tracking down the matching pointer write, which can be accomplished by tracing control flow. Eliminating pointer writes requires proving that the address is never read before deallocation, which requires a global analysis of pointer reads. The analysis is complex as it has to deal with symbolic intervals but should be possible. We also want <code class="docutils literal notranslate"><span class="pre">volatile_read</span></code> / <code class="docutils literal notranslate"><span class="pre">visible_write</span></code> to prevent optimizing these away, e.g. for multithreaded situations with shared memory. Or maybe these should be the default and pointer operations should never be optimized.</p>
<p>Eliminating pointers entirely is not possible as they have to be used for system calls and interfacing with C. But we can minimize the lifetime of pointers in the standard library to the duration of the call, and use values / references everywhere else.</p>
<p>Pointers introduce a class of memory errors: use-after-free, double free, and memory leaks. But at this low level of operation it seems reasonable to expect programmers to worry about such errors.</p>
</div>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<p>A reference is essentially a pointer but allocated using a specific Stroscot function and with deallocation managed by Stroscot.</p>
<p>There is no need for a read-only reference, because Stroscot supports cyclic data so it is simply the value directly.</p>
<p>A mutable array is simply a reference containing a pure array.</p>
<p>Since we work with datatypes first and their representations only incidentally, we do not have to handle buffer overflows; pointer arithmetic is implicit in the pack/unpack functions and due to our correctness properties, unpacking fields of the datatype must read within the allocated buffer.</p>
</div>
</div>
<div class="section" id="representation">
<h2>Representation<a class="headerlink" href="#representation" title="Permalink to this headline">¶</a></h2>
<p>Layout is usually defined by its size, alignment, padding/stride, and field offsets, but this only specifies the representation of simple flat records. With enumerations, there is the question of how to encode constants. It gets even more complicated with ADTs, like JS’s <a class="reference external" href="https://wingolog.org/archives/2011/05/18/value-representation-in-javascript-implementations">value type</a>, and the choices often impact performance significantly. Finally there is the use of pointers. For example, we can encode a list in a number of ways:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;b&quot;</span><span class="p">]</span>
<span class="o">#</span> <span class="n">flat</span> <span class="n">list</span><span class="p">,</span> <span class="n">stored</span> <span class="n">like</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;b&quot;</span><span class="p">]</span> <span class="n">or</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="o">#</span> <span class="n">intrusive</span> <span class="n">list</span><span class="p">,</span> <span class="n">stored</span> <span class="n">like</span> <span class="n">x</span><span class="ow">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">y</span><span class="p">],</span> <span class="n">y</span><span class="ow">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">]</span>
<span class="o">#</span> <span class="n">uniform</span> <span class="n">list</span><span class="p">,</span> <span class="n">stored</span> <span class="n">like</span> <span class="n">x</span><span class="ow">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">y</span><span class="p">],</span><span class="n">x1</span><span class="ow">=</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="n">y</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">y1</span><span class="p">,</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">],</span><span class="n">y1</span><span class="ow">=</span><span class="s">&quot;b&quot;</span>
</pre></div>
</div>
<p>So in Stroscot there is no fixed memory representation. Instead memory layout is defined by overloaded <code class="docutils literal notranslate"><span class="pre">pack</span></code>/<code class="docutils literal notranslate"><span class="pre">unpack</span></code> functions that write/read a memory buffer, similar to the <a class="reference external" href="https://github.com/mgsloan/store/blob/master/store-core/src/Data/Store/Core.hs">store library</a>. The pack/unpack functions will end up getting passed around a lot, but implicit parameters scale pretty well, so it shouldn’t be an issue. Unlike Narcissus <span id="id1">[<a class="reference internal" href="zzreferences.html#id18" title="Benjamin Delaware, Sorawit Suriyakarn, Clément Pit-Claudel, Qianchuan Ye, and Adam Chlipala. Narcissus: correct-by-construction derivation of decoders and encoders from binary formats. Proceedings of the ACM on Programming Languages, 3(ICFP):1–29, July 2019. URL: https://www.cs.purdue.edu/homes/bendy/Narcissus/narcissus.pdf (visited on 2020-07-26), doi:10.1145/3341686.">DSPitClaudel+19</a>]</span> we don’t have a state parameter, also because of implicit parameters.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">unpack</span> <span class="kt">:</span> <span class="kt">ReadBuffer</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">pack</span> <span class="kt">:</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">WriteBuffer</span>

<span class="nf">read</span> <span class="kt">:</span> <span class="kt">ReadBuffer</span> <span class="ow">-&gt;</span> <span class="kt">Vector</span> <span class="kt">Word8</span>
<span class="nf">write</span> <span class="kt">:</span> <span class="kt">WriteBuffer</span> <span class="ow">-&gt;</span> <span class="kt">Vector</span> <span class="kt">Word8</span> <span class="ow">-&gt;</span> <span class="kt">WriteBuffer</span>
<span class="nf">length</span> <span class="kt">:</span> <span class="kt">WriteBuffer</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>

<span class="nf">shift</span> <span class="kt">:</span> <span class="kt">ReadBuffer</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">offset</span> <span class="kt">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">ReadBuffer</span>
<span class="nf">shift</span> <span class="kt">:</span> <span class="kt">WriteBuffer</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">offset</span> <span class="kt">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">WriteBuffer</span>
</pre></div>
</div>
<p>Write buffers have a length, so to compute the size of the type, we can do <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">.</span> <span class="pre">pack</span></code>. Read buffers don’t have a length so to figure out the length of something in memory we do <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">.</span> <span class="pre">pack</span> <span class="pre">.</span> <span class="pre">unpack</span></code>. Some simple types:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pack</span> <span class="kt">:</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">WriteBuffer</span>
<span class="nf">pack</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">w</span> <span class="ow">=</span> <span class="n">emptyWriteBuffer</span>
  <span class="n">write</span> <span class="n">w</span> <span class="mi">0</span>
  <span class="n">write</span> <span class="n">w</span> <span class="p">(</span><span class="n">pack</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">pack</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">w</span> <span class="ow">=</span> <span class="n">emptyWriteBuffer</span>
  <span class="n">write</span> <span class="n">w</span> <span class="mi">1</span>
  <span class="n">write</span> <span class="n">w</span> <span class="p">(</span><span class="n">pack</span> <span class="n">b</span><span class="p">)</span>

<span class="nf">unpack</span> <span class="n">r</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="n">read</span> <span class="n">r</span> <span class="kr">of</span>
    <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="p">(</span><span class="n">unpack</span> <span class="p">(</span><span class="n">shift</span> <span class="n">r</span> <span class="mi">1</span><span class="p">))</span>
    <span class="mi">1</span> <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">unpack</span> <span class="p">(</span><span class="n">shift</span> <span class="n">r</span> <span class="mi">1</span><span class="p">))</span>

<span class="nf">pack</span> <span class="kt">:</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">WriteBuffer</span>
<span class="nf">pack</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">w</span> <span class="ow">=</span> <span class="n">emptyWriteBuffer</span>
  <span class="n">write</span> <span class="n">w</span> <span class="p">(</span><span class="n">pack</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">write</span> <span class="n">w</span> <span class="p">(</span><span class="n">pack</span> <span class="n">b</span><span class="p">)</span>

<span class="nf">unpack</span> <span class="n">r</span> <span class="ow">=</span>
  <span class="n">a</span> <span class="ow">=</span> <span class="n">unpack</span> <span class="n">r</span>
  <span class="n">l</span> <span class="ow">=</span> <span class="n">length</span> <span class="p">(</span><span class="n">pack</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">b</span> <span class="ow">=</span> <span class="n">unpack</span> <span class="p">(</span><span class="n">shift</span> <span class="n">r</span> <span class="n">l</span><span class="p">)</span>
  <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">unpack</span></code> can fail on invalid byte sequences, but <code class="docutils literal notranslate"><span class="pre">pack</span></code> must always return a byte sequence. Also <code class="docutils literal notranslate"><span class="pre">unpack</span></code> can be more lenient and decode sequences that <code class="docutils literal notranslate"><span class="pre">pack</span></code> doesn’t produce, e.g. nonzero padding bytes. So for correctness we only require <code class="docutils literal notranslate"><span class="pre">unpack</span> <span class="pre">.</span> <span class="pre">pack</span> <span class="pre">=</span> <span class="pre">id</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> and not the reverse. Using this constraint we can derive <code class="docutils literal notranslate"><span class="pre">unpack</span></code> from <code class="docutils literal notranslate"><span class="pre">pack</span></code>, or vice-versa, if the format isn’t too complicated.</p>
<p>One tricky part is that the naive way to specify types interferes with overloading, subtyping and implicit conversions. <code class="docutils literal notranslate"><span class="pre">pack</span> <span class="pre">(Int8</span> <span class="pre">1)</span></code> can give a byte as expected, but it can also implicitly convert to an <code class="docutils literal notranslate"><span class="pre">Int32</span></code> and give 4 bytes. Since we have dependent types this isn’t a real issue, just make sure the code generated after representation specialization passes the type explicitly: <code class="docutils literal notranslate"><span class="pre">pack</span> <span class="pre">Int32</span> <span class="pre">(Int8</span> <span class="pre">1)</span></code>.</p>
<p>A few things need to optimize away for reasonable performance.  <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">.</span> <span class="pre">pack</span></code> should optimize to something like <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">20</span></code> for most values, or at least something that doesn’t allocate, so that field accesses are independent and values can be allocated sanely. These functions might have to be hacked in, specializing to constant-sized values.</p>
<p>Since writing these serialization functions all the time would be tedious, we can make a format DSL that specifies the functions in a nicer way. Although one of these DSL’s will be the standard / default, it’ll be some kind of macro / constraint system, so defining new format DSLs for specific purposes shouldn’t be hard.</p>
<div class="section" id="non-default-representations">
<h3>Non-default representations<a class="headerlink" href="#non-default-representations" title="Permalink to this headline">¶</a></h3>
<p>The translation to use pack/unpack is pretty simple: a pack is inserted around every constructor, and an unpack is inserted into the scrutinee of every match statement and field assignment. So <code class="docutils literal notranslate"><span class="pre">Foo</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">..</span> <span class="pre">}</span></code> translates to <code class="docutils literal notranslate"><span class="pre">pack</span> <span class="pre">(Foo</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">unpack</span> <span class="pre">(..)</span> <span class="pre">}</span> <span class="pre">)</span></code>.</p>
<p>But this translation uses whatever pack/unpack are in scope; they can be overridden like any other implicit parameters. To prevent mismatches the result of pack actually contains the matching unpack function.</p>
</div>
</div>
<div class="section" id="id2">
<h2>Memory management<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Ownership a la Rust cannot even handle doubly-linked lists. Code frequently switches to the <code class="docutils literal notranslate"><span class="pre">Rc</span></code> type, which besides cycles has the semantics of GC. There is even a <a class="reference external" href="https://github.com/Others/shredder">library</a> for a <code class="docutils literal notranslate"><span class="pre">Gc</span></code> type that does intrusive scanning.</p>
<p>And the malloc/free model is also not correct;</p>
<p>Meanwhile, as far as tracing GC goes, moving and compaction have been optimized using clever algorithms, but there is not a lot of room for performance improvements at runtime. The interesting area of research is static analysis. To that end some work <span id="id3">[<a class="reference internal" href="zzreferences.html#id49" title="Raphaël L Proust. ASAP: As Static As Possible memory management. Technical Report UCAM-CL-TR-908, University of Cambridge Computer Laboratory, July 2017. URL: https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-908.pdf.">Pro17</a>]</span> <span id="id4">[<a class="reference internal" href="zzreferences.html#id15" title="Nathan Corbyn. Practical Static Memory Management. Bachelor's Thesis, King’s College, May 2020. URL: http://nathancorbyn.com/nc513.pdf.">Cor20</a>]</span> on “as static as possible” (ASAP) memory management is quite relevant.</p>
<p>To begin with we must model memory. In reality memory is simply a map from addresses to words. But this doesn’t prevent any memory errors. So instead we have memory mapping (opaque) addresses to memory blocks, which are byte arrays of fixed size mapping to a single type. The type’s fields then determine the data / unpacked fields (ignored for memory purposes) and the references. We can name the references by their dereferencing list, e.g. <code class="docutils literal notranslate"><span class="pre">.a.b.c</span></code>. A given type may contain arbitrarily many references. A zone is the set of memory blocks reachable from a given value by following all the references. Function <code class="docutils literal notranslate"><span class="pre">scan</span></code> (figure 4.9) marks or frees the blocks in a zone. This is used in function <code class="docutils literal notranslate"><span class="pre">clean</span></code> which frees blocks from the zones of the antimatter set that aren’t in the zones of the matter set, using <a class="reference external" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">tri-color marking</a>.</p>
<p>Roughly then, to implement memory management, we call <code class="docutils literal notranslate"><span class="pre">clean</span></code> during each state transition in the program, with the matter set containing all live blocks and the antimatter set containing all allocated blocks. The size of the state transitions is arbitrary, but smaller ones ensure freeing is timely, while larger ones (may) reduce scanning. So ASAP is essentially stop-the-world GC in design.</p>
<p>The main difference is that, while most GC’s use reachability to approximate liveness, ASAP uses a finer approximation. In particular, the main analysis, <code class="docutils literal notranslate"><span class="pre">Access(s,z)</span></code>, determines if any memory blocks of a zone <code class="docutils literal notranslate"><span class="pre">z</span></code> could be accessed during execution starting from state <code class="docutils literal notranslate"><span class="pre">s</span></code>. With this information we can define the matter and antimatter sets for a state transition <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">-&gt;</span> <span class="pre">t</span></code>:</p>
<ul class="simple">
<li><p>The matter set is all blocks that will be accessed, <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">{z</span> <span class="pre">|</span> <span class="pre">Access(t,z)</span> <span class="pre">=</span> <span class="pre">yes}</span></code></p></li>
<li><p>The antimatter set is all blocks that are accessed before but not accessed later, <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">{z</span> <span class="pre">|</span> <span class="pre">Access(s,z)</span> <span class="pre">=</span> <span class="pre">yes</span> <span class="pre">&amp;&amp;</span> <span class="pre">Access(t,z)</span> <span class="pre">=</span> <span class="pre">no}</span></code></p></li>
</ul>
<p>We can prune all zones in A that are subsets of zones in M.</p>
<p>Using an aliasing analysis, <code class="docutils literal notranslate"><span class="pre">Shape</span></code>, we can further refine the sets into multiple calls to <code class="docutils literal notranslate"><span class="pre">clean</span></code>. <code class="docutils literal notranslate"><span class="pre">Shape</span></code>, given two locations and a state, determines if the zones of those two locations overlap. We use it as follows:
* We partition the anti-matter zones into overlapping zone-sets <span class="math notranslate nohighlight">\(A_i\)</span>.
* For each component, we filter the matter set to overlapping zones: <code class="docutils literal notranslate"><span class="pre">M_i</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">z</span> <span class="pre">in</span> <span class="pre">M</span> <span class="pre">|</span> <span class="pre">Shape(z,</span> <span class="pre">A_i)</span> <span class="pre">=</span> <span class="pre">yes</span> <span class="pre">}</span></code></p>
<p>If the antimatter set is empty then no calls to <code class="docutils literal notranslate"><span class="pre">clean</span></code> are needed at all. Furthermore, calls to <code class="docutils literal notranslate"><span class="pre">clean</span></code> with an empty <span class="math notranslate nohighlight">\(M_i\)</span> are unconditional frees and are quite efficient, although there is some overhead to avoid double frees with cyclic/shared data structures. This overhead can be eliminated if the sharing is statically known. Sometimes aliasing can be disallowed through analyzing the program structure and otherwise there are features that disallow aliasing, e.g. in C the strict aliasing rule and the <code class="docutils literal notranslate"><span class="pre">restrict</span></code> keyword.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Proust’s presentation is a bit more complex and confusing.  It’s a thesis, so it probably didn’t get much proofreading. For <code class="docutils literal notranslate"><span class="pre">clean</span></code> he outlines a basic mark-and-sweep algorithm using a mark array, but this doesn’t handle cycles, so he introduces an algorithm in Figure 6.8 that’s kind of like tricolor marking but more complicated. He has a ‘maybe’ state for <code class="docutils literal notranslate"><span class="pre">Access</span></code> and <code class="docutils literal notranslate"><span class="pre">Shape</span></code> which is uniformly treated as yes. Furthermore he does not use the state-transition formalism so his definition of liveness is split for the constructs of his core language. And by definition the antimatter and matter sets cannot overlap, but he describes a specific pass to remove the matter from the antimatter.</p>
</div>
<div class="section" id="manual-memory-management">
<h3>Manual memory management<a class="headerlink" href="#manual-memory-management" title="Permalink to this headline">¶</a></h3>
<p>There are cases where garbage collection can be faster than memory management <span id="id5">[<a class="reference internal" href="zzreferences.html#id8" title="Andrew W. Appel. Garbage collection can be faster than stack allocation. Information Processing Letters, 25(4):275–279, June 1987. URL: https://www.cs.princeton.edu/~appel/papers/45.pdf (visited on 2020-07-24), doi:10.1016/0020-0190(87)90175-X.">App87</a>]</span>. In particular, scratch buffers, as exemplified by GNU C’s <a class="reference external" href="https://www.gnu.org/software/libc/manual/html_node/Obstacks.html">obstack</a>. These can be filled full of miscellaneous data to compute a result, then the result can be copied out to a different area of memory and the scratch buffer can be freed in one go. As Appel points out, even if freeing an individual object is a single machine instruction, such as a stack pop, freeing a lot of objects still has significant overhead compared to copying out the useful data.</p>
<p>To do this automatically, we would have to determine the number of regions and their size, which is possible but would most likely require a lot of heuristic decision-making. It is better to allow the programmer to allocate chunks of memory directly, and store/read values within the chunks. The chunks can then be freed by the automatic memory management when they are no longer needed. This requires some modifications to the algorithm to track regions but should be fine.</p>
</div>
<div class="section" id="compiler-memory-management">
<h3>Compiler memory management<a class="headerlink" href="#compiler-memory-management" title="Permalink to this headline">¶</a></h3>
<p>For the compiler itself, a trivial bump or arena allocator is sufficient for most purposes, as it is invoked on a single file and lasts a few seconds. With multiple files and large projects the issue is more complicated, as some amount of information must be shared between files. Optimization passes are also quite traversal-intensive and it may be more efficient to do in-place updates with a tracing GC rather than duplicating the whole AST and de-allocating the old one. Two other sources of high memory usage are macros and generics, particularly in combination with optimizations that increase code size such as inlining.</p>
<p>Overall I don’t see much of an opportunity, SSD and network speeds are sufficient to make virtual memory and compile farms usable, so the maximum memory is some large number of petabytes. The real issue is not total usage but locality, because compilers need to look up information about random methods, blocks, types etc. very often. But good caching/prefetching heuristics should not be too hard to develop. In practice the programs people compile are relatively small, and the bottleneck is the CPU because optimizations are similar to brute-force searching through the list of possible programs. Parallelization is still useful. Particularly when AMD has started selling 64-core desktop processors, it’s clear that optimizing for some level of that, maybe 16 or 32 cores, is worthwhile.</p>
</div>
<div class="section" id="copy-management">
<h3>Copy management<a class="headerlink" href="#copy-management" title="Permalink to this headline">¶</a></h3>
<p>As well as handling allocation/deallocation, it would also be good to provide copy/move operations. The copy has a copy-on-write semantics where the copy isn’t actually done unless/until the original is modified/deallocated. But the memory is managed under the new allocator.</p>
</div>
<div class="section" id="resource-management">
<h3>Resource management<a class="headerlink" href="#resource-management" title="Permalink to this headline">¶</a></h3>
<p>There are also non-memory resources like thread-handles, file-handles, locks, and sockets. These can be passed around and stored in data structures. The same usage analysis should work to close these resources.</p>
<p>It is important to free memory when it is no longer needed, because otherwise you will run out.</p>
<p>garbage collection partially solves the memory management problem. Garbage collection decreases performance and increases memory usage.</p>
<p>The problem in parallel programming is race conditions. The standard solution is mutexes and condition variables, and variants thereof.</p>
<p>Languages that support exceptions need to support destructors or they need to support a try/finally construct. Otherwise using exceptions is too difficult, because if you have some local state to clean up in a function, you have to catch and rethrow every exception.</p>
<p>The goal of exceptions in C++ is that code which does not throw an exception should be just as efficient as code which is compiled without any support for exceptions. Unfortunately, this is impossible. When any function can throw an exception, and when there are destructors which must be run if an exception is thrown, the compiler is limited in its ability to move instructions across function calls. Of course it is not generally possible to move instructions which change global or heap memory across a function call, but in the absence of exceptions it is generally possible to move instructions which do not change memory or which change only stack memory. This means that exceptions limit what the compiler is able to do, and it follows that compiling with exception support generates code which is less efficient than compiling without exception support.</p>
<p>Of course exceptions still have their uses, but lets consider programming without them (this is easy for me to imagine–I didn’t use exceptions in the gold linker). If you program without exceptions, how useful are destructors and/or try/finally? What comes to mind is functions with multiple return points, loops with multiple exits, and RAII coding.</p>
<p>C has neither destructors nor try/finally. Does it miss them? I would say yes. A common workaround I’ve seen is to change all return points and loop exit points to use a goto to a label which does cleanups.</p>
<p>The gcc compiler has an extension to C to support, in effect, destructors. You can use __attribute__ ((__cleanup__ (function))) with any local variable. When the variable goes out of scope, the function will be called, passing it the address of the variable. This is an effective extension, but it is not widely used.</p>
<p>The Go language does not have destructors. Instead, it has two more dynamic mechanisms. A defer statement may be used to run a function on function exit or when processing a panic. A finalizer may be used to run a function when the garbage collector finds that a block of memory has nothing pointing to it and can be released. Both approaches are dynamic, in that you have to executed the defer statement or call the runtime.SetFinalizer function. They are have no lexical scoping; a single defer statement in a loop can cause its argument to be called many times on function exit.</p>
<p>These ideas are significantly different from destructors, which are associated with a type, and are executed when an object of that type goes out of lexical scope or is explicitly deleted. Destructors are primarily used to release resources acquired by an object of the type. This is a less important concept in a garbage collected language like Go.</p>
<p>The absence of destructors means that Go does not support the RAII pattern, in which an object is used to acquire a mutex or some other resource for the scope of a lexical block. Implementing this in Go requires two statements: one to acquire the mutex, and a defer statement to release the mutex on function exit. Because deferred functions are run on function exit, the mapping is not exact; you can not use this technique to acquire a lock in a loop. In fact, acquiring a mutex in a loop and correctly releasing it when a panic occurs is rather difficult in Go; fortunately it is easy to handle correctly by moving the body of the loop to a separate function. In any case, Go discourages this type of programming. Mutexes are available in Go, but channels are the preferred mechanism for synchronization.</p>
<p>Are defer statements and finalizers sufficient replacement for destructors in a garbage collected language? They are for me. When I write C++ my destructors are almost entirely concerned with releasing memory. In fact, in the gold linker I often deliberately omitted destructors, because many of the data structures live for the life the program; in such a case, destructors serve only to slow down program exit. I would be interested to hear of a pattern of programming which relies on destructors for cases other than releasing memory or RAII.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Assembly.html" class="btn btn-neutral float-right" title="Assembly" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="Compiler.html" class="btn btn-neutral float-left" title="Compiler design" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019-2020 Mathnerd314.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>