

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Compiler design &mdash; Stroscot  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="_static/hexagon_favicon.png"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Build system" href="BuildSystem.html" />
    <link rel="prev" title="Memory management" href="Memory.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html">
          

          
            
            <img src="_static/hexagon_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="About.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="Overloading.html">Overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="Verification.html">Verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arguments.html">Argument passing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Delimited-Continuations.html">Delimited continuations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fexprs.html">Metaprogramming</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reduction.html">Reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reduction.html#random-old-junk">Random old junk</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reduction-Example.html">Reduction example</a></li>
<li class="toctree-l1"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="Memory.html">Memory management</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Compiler design</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pipeline">Pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="#flags">Flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="#error-messages">Error messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="#output">Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cross-compilation">Cross compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bootstrapping">Bootstrapping</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#make-ghc-multi-target">Make GHC multi-target</a></li>
<li class="toctree-l3"><a class="reference internal" href="#make-ghc-multi-package">Make GHC multi-package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#make-iserv-program-reinstallable">Make iserv program reinstallable</a></li>
<li class="toctree-l3"><a class="reference internal" href="#make-boot-libraries-and-ghc-reinstallable">Make boot libraries and GHC reinstallable</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fix-template-haskell-stage-hygiene">Fix Template Haskell stage hygiene</a></li>
<li class="toctree-l3"><a class="reference internal" href="#don-t-use-the-external-interpreter-for-template-haskell">Don’t use the external interpreter for Template Haskell</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cabal">Cabal</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cabal-configure-build-type">Cabal: <code class="docutils literal notranslate"><span class="pre">configure</span></code> build-type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#remove-platform-specific-cpp">Remove platform specific CPP</a></li>
<li class="toctree-l3"><a class="reference internal" href="#breach-3-external-interpreter">Breach #3: external interpreter</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="PackageManager.html">Package manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="Programs.html">Exemplary programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="zzreferences.html">References</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Stroscot</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Compiler design</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Compiler.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="compiler-design">
<h1>Compiler design<a class="headerlink" href="#compiler-design" title="Permalink to this headline">¶</a></h1>
<div class="section" id="pipeline">
<h2>Pipeline<a class="headerlink" href="#pipeline" title="Permalink to this headline">¶</a></h2>
<p>The start is a parser - this will be written later once partial evaluation is sufficient to specialize naive parsers efficiently. For now the code is input using ADTs and parentheses. The parser will also add token start/end and other debugging information.</p>
<p>Next is the fexpr interpreter loop. This starts with the ADT tree and produces evaluated code. Parts of the evaluator include turning name-strings into direct evaluation graph references and compiling pattern matching to tag scrutinization.</p>
<p>Currying is handled by a pass that creates partially-applied functions using the eval-apply model, similar to <a class="bibtex reference internal" href="zzreferences.html#downenmakingfastercurry2019" id="id1">[DSAPJ19]</a>. Initially all user code starts out using one-argument functions.</p>
<p>Currently there are no code targets implemented - the main interactive element is an interpreter. There are some papers on partial evaluation and supercompilation that will probably get used for a C backend or a JIT or something.</p>
</div>
<div class="section" id="flags">
<h2>Flags<a class="headerlink" href="#flags" title="Permalink to this headline">¶</a></h2>
<p>In general flags can take 4 levels: ignore, warn, error, and fix. Ignore ignores the issue as much as possible. Warn issues a warning but otherwise ignores the issue. Error stops the compiler from continuing. Fix automatically constructs a fix for the issue and modifies the source file(s) in-place.</p>
</div>
<div class="section" id="error-messages">
<h2>Error messages<a class="headerlink" href="#error-messages" title="Permalink to this headline">¶</a></h2>
<p>Since Stroscot uses model checking, most failures will end up producing a counterexample. The counterexample may not be minimal, but it is much easier to debug a concrete instance than to try to figure one out from contextual information.</p>
<p>For source locations we produce the start/end span of two (filename, line number, column number) tuples. Go uses an efficient memory-map-like model from these tuples to integers, to avoid passing around strings. We could just use pointers, but Go’s integers are ordered so comparing within files is faster. But it isn’t clear how to make this incremental.</p>
</div>
<div class="section" id="output">
<h2>Output<a class="headerlink" href="#output" title="Permalink to this headline">¶</a></h2>
<p>The simplest output is to write out a copy of the interpreter with a comment “This is generated code - see Interpreter.hs for source” at the top. But we want to specialize this.</p>
<p>versioning of time/date
identifier minimization/translation
unit test
random input testing
quasiquotation
typechecking</p>
</div>
<div class="section" id="cross-compilation">
<h2>Cross compilation<a class="headerlink" href="#cross-compilation" title="Permalink to this headline">¶</a></h2>
<p>In cross compilation we have not one system, but two systems. To use the newer <a class="reference external" href="https://clang.llvm.org/docs/CrossCompilation.html">Clang</a> terminology, there is the <strong>host</strong> system where the program is being built, and the <strong>target</strong> system where the program will run. When the host and target systems are the same, it’s a native build; otherwise it’s a cross build.</p>
<p>The older <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gccint/Configure-Terms.html">GNU terminology</a> uses a triple, build/host/target; but the “target” there is really a configuration option, namely the supported target of the compiler that will run on the host. Programs that aren’t compilers need only build/host specified, but remembering whether the build system builds the host or vice-versa is tricky. Overall the Clang terminology host/target/supported targets seems clearer than build/host/target.</p>
</div>
<div class="section" id="bootstrapping">
<h2>Bootstrapping<a class="headerlink" href="#bootstrapping" title="Permalink to this headline">¶</a></h2>
<p>Bootstrapping is a 2-stage process. We start with the source <code class="docutils literal notranslate"><span class="pre">s</span></code> and bootstrap compiler <code class="docutils literal notranslate"><span class="pre">cB</span></code>, an old compiler using the old ABI. Then we build:</p>
<ul class="simple">
<li><p>stage 1: New compiler on old ABI <code class="docutils literal notranslate"><span class="pre">c1=compile(s,cB)</span></code></p></li>
<li><p>stage 2: New compiler on new ABI <code class="docutils literal notranslate"><span class="pre">c2=compile(s,c1)</span></code></p></li>
</ul>
<p>We can test stage 2 (the “compiler bootstrap test”) by building a new compiler <code class="docutils literal notranslate"><span class="pre">c3=compile(s,c2)</span></code>. If the build is deterministic, <code class="docutils literal notranslate"><span class="pre">c3</span></code> should be bit-identical to <code class="docutils literal notranslate"><span class="pre">c2</span></code>. We can also run the test suite to compare outputs of <code class="docutils literal notranslate"><span class="pre">c1</span></code> and <code class="docutils literal notranslate"><span class="pre">c2</span></code>. But we cannot compare performance of <code class="docutils literal notranslate"><span class="pre">c1</span></code> and <code class="docutils literal notranslate"><span class="pre">c2</span></code>, because they use different ABIs, and also <code class="docutils literal notranslate"><span class="pre">cB</span></code> may be buggy so <code class="docutils literal notranslate"><span class="pre">c1</span></code> and <code class="docutils literal notranslate"><span class="pre">c2</span></code> may not behave exactly the same. We can also use diverse double-compiling <a class="bibtex reference internal" href="zzreferences.html#wheelerfullycounteringtrusting2010" id="id2">[Whe10]</a>, compiling with multiple bootstrap compilers <code class="docutils literal notranslate"><span class="pre">cB</span></code>, to increase our confidence in the correctness of the stage 2 compiler.</p>
<p>For cross-compiling, we build stage 1 for the host and stage 2 for the target.</p>
<p>Actually this is more complex. The compiler is really two components, an interpreter and a specializer; in a full system there are many components:
* source-level libraries (macros) <code class="docutils literal notranslate"><span class="pre">m</span></code>
* bytecode libraries (plugins) <code class="docutils literal notranslate"><span class="pre">b</span></code>
* compiled libraries / run-time components (e.g. libc, GC) <code class="docutils literal notranslate"><span class="pre">r</span></code>
* the interpreter <code class="docutils literal notranslate"><span class="pre">i</span></code>
* specializer <code class="docutils literal notranslate"><span class="pre">s</span></code></p>
<p>A primitive <code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">:</span> <span class="pre">program</span> <span class="pre">-&gt;</span> <span class="pre">data</span> <span class="pre">-&gt;</span> <span class="pre">data</span></code>, that can run programs written in any language, given input data, and produce an output result. We use an oracle notion of result where erroring / not halting is itself a result. Two programs are equal if <code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">p</span> <span class="pre">d</span> <span class="pre">==</span> <span class="pre">run</span> <span class="pre">q</span> <span class="pre">d</span></code> for all <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p>
<p>An interpreter <code class="docutils literal notranslate"><span class="pre">int</span></code> has <code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">int</span> <span class="pre">(p,d)</span> <span class="pre">=</span> <span class="pre">run</span> <span class="pre">p</span> <span class="pre">d</span></code>.
A compiler <code class="docutils literal notranslate"><span class="pre">comp</span></code> has <code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">(run</span> <span class="pre">comp</span> <span class="pre">p)</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">run</span> <span class="pre">p</span> <span class="pre">d</span></code>.
A compiler generator <code class="docutils literal notranslate"><span class="pre">cog</span></code> has <code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">(run</span> <span class="pre">(run</span> <span class="pre">cog</span> <span class="pre">p)</span> <span class="pre">x)</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">run</span> <span class="pre">p</span> <span class="pre">(x,y)</span></code>.
A specializer <code class="docutils literal notranslate"><span class="pre">s</span></code> has <code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">(run</span> <span class="pre">s</span> <span class="pre">(p,x))</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">run</span> <span class="pre">p</span> <span class="pre">(x,y)</span></code>.</p>
<p>The Futamura projections:</p>
<p>let out = run p (x,y)
let res = run s (p,x) – residual program
run res y == out – by specializer property
let gen = run s (s,p) – generating extension
run gen x == res – by specializer property
let cog = run s (s,s) – compiler generator
run cog p == gen – by specializer property</p>
<p><code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">s</span> <span class="pre">(s,int)</span></code> produces a compiler. Similarly passing the interpreter to a compiler generator <code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">cog</span> <span class="pre">int</span></code> produces a compiler.</p>
<p>Given a specializer, we can produce a compiler generator <code class="docutils literal notranslate"><span class="pre">cog</span> <span class="pre">=</span> <span class="pre">run</span> <span class="pre">s</span> <span class="pre">(s,s)</span></code>. This compiler generator is self-generating, in that <code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">cog</span> <span class="pre">s</span> <span class="pre">==</span> <span class="pre">cog</span></code>. The reverse is true as well: if we have a compiler generator <code class="docutils literal notranslate"><span class="pre">cog</span></code> that self-generates with some program <code class="docutils literal notranslate"><span class="pre">s</span></code> (<code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">cog</span> <span class="pre">s</span> <span class="pre">==</span> <span class="pre">cog</span></code>), then <code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">s</span> <span class="pre">(s,s)</span> <span class="pre">==</span> <span class="pre">cog</span></code> and <code class="docutils literal notranslate"><span class="pre">s</span></code> is a specializer.</p>
<p>For any 3 specializers <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">j</span></code>, <code class="docutils literal notranslate"><span class="pre">k</span></code>, not necessarily distinct, <code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">i</span> <span class="pre">(j,k)</span></code> is a compiler generator. We can also produce this compiler generator from any compiler generator <code class="docutils literal notranslate"><span class="pre">cog</span></code> by doing <code class="docutils literal notranslate"><span class="pre">run</span> <span class="pre">(run</span> <span class="pre">(run</span> <span class="pre">cog</span> <span class="pre">i)</span> <span class="pre">j)</span> <span class="pre">k</span></code>.</p>
<p>package flags for the RTS
those flags should be stored into ABI hashes in installed packages to avoid mismatching incompatible code objects.
feature flags, can depend on the OS / target (e.g. NodeJS or browser targets)</p>
<p>package system must handle host packages and target packages.
compiler plugins are in the host package set</p>
<p>(<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/issues/14335">GHC ticket</a>).</p>
<p>Plugins still won’t work for stage 1 compilers because of ABI mismatch: the
stage 0 compiler may produce code objects for the stage 1 compiler that are not
compatible with the code objects the stage 1 compiler produces.</p>
<p>Breaking change: currently GHC is able to compile its own plugins in confined
mode. In particular, it supports loading plugins from the “home package” (the
set of modules it is currently compiling). While GHC isn’t multi-target, it
won’t be able to build its own plugins. Cross-compilers such as GHCJS or
Asterius relies on two GHCs: one for the real target and one which targets the
compiler host. We probably should make GHC multi-target and
multi-package before we could get this change integrated upstream.</p>
<div class="section" id="make-ghc-multi-target">
<h3>Make GHC multi-target<a class="headerlink" href="#make-ghc-multi-target" title="Permalink to this headline">¶</a></h3>
<p>GHC should be able to produce code objects for several targets:</p>
<ul class="simple">
<li><p>(not available in stage 1 because of ABI mismatch) its own host platform and
compiler way (for plugins): <code class="docutils literal notranslate"><span class="pre">-target</span> <span class="pre">self</span></code></p></li>
<li><p>its own host platform: <code class="docutils literal notranslate"><span class="pre">-target</span> <span class="pre">host</span></code>. It targets the same platform as
<code class="docutils literal notranslate"><span class="pre">-target</span> <span class="pre">self</span></code> by without the constraint of being linkable with GHC. Other
options could be applied (<code class="docutils literal notranslate"><span class="pre">-debug</span></code>,  <code class="docutils literal notranslate"><span class="pre">-profiling</span></code>, etc.).</p></li>
<li><p>several other targets</p></li>
</ul>
<p>We need a way to configure two external toolchain information (gcc, llvm, as,
ld, ar, strip, etc.): one for GHC plugins and another for the current target.
A bunch of work has been done making GHC read these things from the <code class="docutils literal notranslate"><span class="pre">settings</span></code>
file rather than it be hard-coded at build time.</p>
<p>There are still some target dependant hard-coded information in GHC about
<cite>Int64#/Word64#</cite> primops (cf <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/11953">#11953</a>, <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/17375">#17375</a>, <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/17377">#17377</a>), which &#64;Ericson2314 and &#64;hsyl20 are attempting
to fix in <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/merge_requests/3658">!3658</a>.</p>
<p>GHC needs to handle per-target package databases.</p>
<p>Making GHC multi-target does not make it able to produce code objects for
multiple targets in a single GHC session. In particular it can’t build plugins
(<code class="docutils literal notranslate"><span class="pre">-target</span> <span class="pre">self</span></code>) and actual code objects for the real target in the same session
yet. We need to make GHC multi-package to support this.</p>
<p>Related: <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/11470">#11470</a></p>
</div>
<div class="section" id="make-ghc-multi-package">
<h3>Make GHC multi-package<a class="headerlink" href="#make-ghc-multi-package" title="Permalink to this headline">¶</a></h3>
<p>Currently a GHC instance can only compile modules from a single package, then
called “home package”. Making GHC multi-package would mean that we would have
several active “home” packages at the same time.</p>
<p>Suppose we have a package containing a plugin module P and another module M
using the plugin. In confined mode we can just build and load P before building
M. But in a cross-compilation settings, we would need to build P with <cite>-target
self</cite> and then load it before building M for the actual target. I.e. we would
have the same package built for different targets. Hence we would have two
active packages.</p>
<p>Multi-package also permits interactive (re)compilation of modules from several
packages (cf <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/10827">#10827</a>).</p>
<p>&#64;fendor is working on this as part of GSOC 2020.
&#64;Ericson2314 is one of the mentors for this.</p>
<p>Related:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/pull/263">https://github.com/ghc-proposals/ghc-proposals/pull/263</a></p></li>
<li><p><a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/Multi-Session-GHC-API">https://gitlab.haskell.org/ghc/ghc/wikis/Multi-Session-GHC-API</a></p></li>
</ul>
</div>
<div class="section" id="make-iserv-program-reinstallable">
<h3>Make iserv program reinstallable<a class="headerlink" href="#make-iserv-program-reinstallable" title="Permalink to this headline">¶</a></h3>
<p>Allow on-the-fly build of the iserv program. Depending on the selected target,
GHC should build an iserv program executing on the host (but not necessarily
with the same way as the compiler) that can execute target code.</p>
<p>GHC distributions wouldn’t have to provide several <code class="docutils literal notranslate"><span class="pre">iserv</span></code> programs for every
target. They could be downloaded from Hackage and built for the host (now that
GHC would be multi-target).</p>
<p>Related issue: <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/12218">https://gitlab.haskell.org/ghc/ghc/issues/12218</a></p>
</div>
<div class="section" id="make-boot-libraries-and-ghc-reinstallable">
<h3>Make boot libraries and GHC reinstallable<a class="headerlink" href="#make-boot-libraries-and-ghc-reinstallable" title="Permalink to this headline">¶</a></h3>
<p>The long term goal it to make GHC behave like any other Haskell program, and the
boot libraries like any other Haskell libraries.</p>
<p>GHC should be able to rebuild its boot libraries with different flags. Similarly
to iserv programs, GHC distributions shouldn’t have to provide boot libraries
for every target (in addition to the boot libraries used by the compiler).</p>
<p>Similarly we also want GHC itself and the RTS to be reinstallable using standard
Haskell tools. It means that GHC shouldn’t need Hadrian to be built but should
behave like standard Cabal packages.</p>
<p>There are several subtasks to perform before we can achieve this goal:</p>
<ol class="arabic">
<li><p>Rather than having global build, host, and target platforms (and ways, see
the next section), Hadrian should give each stage its own host
platform. As GHC would be multi-target, we can infer the effective target of
the <code class="docutils literal notranslate"><span class="pre">stage</span> <span class="pre">n</span></code> compiler by looking at the required host for the <code class="docutils literal notranslate"><span class="pre">stage</span>
<span class="pre">(n+1)</span></code> compiler.</p>
<p>Instead of having a list of stages, we could have a tree:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span>       <span class="c1">-- (old stage 0) the bootstrap compiler version X</span>
<span class="o">|-</span> <span class="mi">0</span>    <span class="c1">-- (old stage 1) compiler version X+1, same host as bootstrap,</span>
<span class="o">|</span>  <span class="o">|</span>       <span class="n">don&#39;t</span> <span class="n">have</span> <span class="p">`</span><span class="o">-</span><span class="n">target</span> <span class="n">self</span><span class="p">`</span> <span class="n">support</span> <span class="n">because</span> <span class="kr">of</span> <span class="kt">ABI</span> <span class="n">mismatch</span>
<span class="o">|</span>  <span class="o">|-</span> <span class="mi">0</span> <span class="c1">-- (old stage 2) compiler version X+1 that supports `-target self`</span>
<span class="o">|</span>  <span class="o">|-</span> <span class="mi">1</span> <span class="c1">-- same but with other build options (e.g. profiling enabled)</span>
<span class="o">|</span>  <span class="o">|-</span> <span class="mi">2</span> <span class="c1">-- same but with other build options (e.g. debugging enabled)</span>
<span class="o">|</span>
<span class="o">|-</span> <span class="mi">1</span>    <span class="c1">-- compiler version X+1, without `-target self` support,</span>
<span class="o">|</span>  <span class="o">|</span>       <span class="n">with</span> <span class="n">other</span> <span class="n">build</span> <span class="n">options</span>
<span class="o">....</span>
</pre></div>
</div>
</li>
<li><p>GHC’s configure script should be split up per-package (cf <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/17191">#17191</a>).
Currently, a single top-level <code class="docutils literal notranslate"><span class="pre">configure.ac</span></code> file is used for several
packages and the compiler itself.</p>
<p>Rather than use a dummy <code class="docutils literal notranslate"><span class="pre">--target</span></code> when building the compiler itself
(because it is now multi-target), and then real ones when building the
libraries, we should just remove <cite>–target</cite> from the overall one.</p>
</li>
<li><p>Configure scripts should be avoided altogether. If we want to build GHC on
non Unix-like hosts (like Windows without using MSYS2), we shouldn’t use
configure scripts.</p></li>
<li><p>Don’t generate source files with an external tool that GHC/Cabal isn’t aware
of. Currently Hadrian generates several files:</p>
<ul class="simple">
<li><p>Parser/Lexer (via Happy/Alex): cf <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/17750">#17750</a></p></li>
<li><p>primops (via genprimopcode)</p></li>
</ul>
<p>Related: <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/merge_requests/490">!490</a></p>
</li>
<li><p>Build GHC in Nix.</p>
<p>Writing a build system is very hard especially because we don’t want to
mix up wrong files: e.g. wrong external files picked (<code class="docutils literal notranslate"><span class="pre">.h</span></code> header files),
artefacts produced from previous builds, etc.</p>
<p>There have been several tickets involving these kind of issues with GHC’s
build system (e.g. <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/17756">Hadrian picking the wrong gmp header</a>).</p>
<p><cite>Nix &lt;https://nixos.org/nix/&gt;</cite> is a purely functional build system that
provides sandboxed builds and correct-by-construction caching. It would be
great to be able to build GHC using <a class="reference external" href="https://input-output-hk.github.io/haskell.nix/">haskell.nix</a> to benefit from it.</p>
</li>
<li><p>Ancillary tools outside of the confined mode</p>
<p>There’s lots of low hanging fruit. &#64;angerman Fixed some silly make rules for <code class="docutils literal notranslate"><span class="pre">hsc2hs</span></code> and <code class="docutils literal notranslate"><span class="pre">unlit</span></code> in the past.
Haddock is confused between its rigid GHC API version bound and its conventional laxed constraints on the GHC version used to build it.</p>
<p>Related: <a class="reference external" href="https://github.com/haskell/haddock/pull/1129/files">Haddock #1129</a> fixing stage 1 build.</p>
</li>
</ol>
</div>
<div class="section" id="fix-template-haskell-stage-hygiene">
<h3>Fix Template Haskell stage hygiene<a class="headerlink" href="#fix-template-haskell-stage-hygiene" title="Permalink to this headline">¶</a></h3>
<p>Currently Template Haskell mixes up stages because it assumes that the confined
mode is used.</p>
<p>We should be able to specify/detect if an <code class="docutils literal notranslate"><span class="pre">import</span></code> is for a top-level TH splice
or not.</p>
<p>We should remove <code class="docutils literal notranslate"><span class="pre">Lift</span></code> instances for target dependent types (e.g. <code class="docutils literal notranslate"><span class="pre">Word</span></code>,
<code class="docutils literal notranslate"><span class="pre">Int</span></code>, linux only types, etc.).</p>
<ul class="simple">
<li><p>see <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/pull/243">this proposal</a></p></li>
</ul>
</div>
<div class="section" id="don-t-use-the-external-interpreter-for-template-haskell">
<h3>Don’t use the external interpreter for Template Haskell<a class="headerlink" href="#don-t-use-the-external-interpreter-for-template-haskell" title="Permalink to this headline">¶</a></h3>
<p>Template Haskell code shouldn’t be executed by the external interpreter because
its code should be executed on the compiler host, not on the compiler target.</p>
<p>It is especially true if the external interpreter use a simulator (e.g. Android,
iOS, etc.) to run the code: TH code can perform unrestricted IO (readFile) and
may expect to find some “source” data files. It is already an issue in confined
mode (e.g. what is the current working directory of an executed TH splice? <a class="reference external" href="https://github.com/haskus/packages/blob/fe2d5ce59e190ec54ae0f42a30c3eeed46997d45/haskus-utils-compat/src/lib/Haskus/Utils/Embed/ByteString.hs#L53">it
depends</a>)
but it is only worse with the external interpreter.</p>
<p>A sane way would be to assume execution of TH codes on the compiler host. We
should specify the interaction of TH splices with the filesystem. We should
perhaps add a Cabal field similar to <a class="reference external" href="https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-data-files">data-files</a>
(or reuse <cite>extra-source-files</cite>) to indicate which files are accessible via TH
code using a new method of the <code class="docutils literal notranslate"><span class="pre">Quasi</span></code> monad (e.g. <code class="docutils literal notranslate"><span class="pre">qLookupDataFile</span> <span class="pre">::</span>
<span class="pre">FilePath</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">ByteString</span></code>). Actually this could be done right now to avoid
CWD related issues.</p>
<p>TH code should have dynamic access (i.e. not via CPP) to the target platform
properties (word size, endianness, etc.).</p>
<p>We should provide a way for TH code to query some stuff about the target code
via the target code (external) interpreter: e.g. <code class="docutils literal notranslate"><span class="pre">sizeOf</span> <span class="pre">(undefined</span> <span class="pre">::</span>
<span class="pre">MyTargetSpecificData)</span></code>. It could also be used to resolve quoted identifiers
that only exists in target code (e.g. evaluate <code class="docutils literal notranslate"><span class="pre">'MyTargetSpecificData</span> <span class="pre">::</span>
<span class="pre">Name</span></code>).</p>
<p>Executing code on the compiler host in every cases should enhance speed as TH
code is often used to perform syntactic transformations (e.g. <code class="docutils literal notranslate"><span class="pre">makeLenses</span></code>)
which don’t require target code evaluation.</p>
<p>Now how would we execute TH code:</p>
<ol class="arabic">
<li><p>Use the internal interpreter just like plugins.</p>
<p>It requires a compiler with <code class="docutils literal notranslate"><span class="pre">-target</span> <span class="pre">self</span></code> support. Hence TH wouldn’t be
supported in the stage 1 compiler and still couldn’t be used in GHC source
itself.</p>
</li>
<li><p>Use another interpreter for host code.</p>
<p>We could compile TH code with <code class="docutils literal notranslate"><span class="pre">-target</span> <span class="pre">self</span></code> but not all the way to producing
code objects because we may not be able to load them (e.g. in a stage 1
compiler). Instead we stop at a previous stage and interpret the intermediate
representation:</p>
<ul class="simple">
<li><p>Core interpreter: compile to down to Core and evaluate it (cf <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/issues/162">proposal</a>)</p></li>
<li><p>STG interpreter: same but for STG (e.g. <a class="reference external" href="http://hackage.haskell.org/package/ministg">ministg</a>)</p></li>
<li><p>ByteCode interpreter: same but for ByteCode. It is similar to the current
internal interpreter but we would need to refactor it to virtualize the
interactions between the compiler and the interpreter (currently the
internal interpreter treats the rest of the compiler as yet another native
code library, just one that happens to be statically linked with the
interpreter itself).</p></li>
</ul>
</li>
</ol>
</div>
<div class="section" id="cabal">
<h3>Cabal<a class="headerlink" href="#cabal" title="Permalink to this headline">¶</a></h3>
<p>Cabal should understand cross compilation and bootstrapping.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">Setup.hs</span></code></p>
<p>Cabal packages are built by a <code class="docutils literal notranslate"><span class="pre">Setup.hs</span></code> program running on the compiler
host. Most of them use the same “Simple” one but some others use custom
<code class="docutils literal notranslate"><span class="pre">Setup.hs</span></code>, with dependencies specified in <code class="docutils literal notranslate"><span class="pre">.cabal</span></code> files.</p>
<p>Once GHC becomes multi-target, Stack and cabal-install could use <code class="docutils literal notranslate"><span class="pre">-target</span>
<span class="pre">self</span></code> (for stage &gt;= 2 compilers) or <code class="docutils literal notranslate"><span class="pre">-target</span> <span class="pre">host</span></code> (for any stage
compiler, including stage 1) to produce the actual program for the compiler
host. It would ensure that <code class="docutils literal notranslate"><span class="pre">Setup</span></code> programs can always be built and run on
the host.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-target</span> <span class="pre">self</span></code>: when it is available (stage &gt;= 2) it allows the use of
the same boot libraries as the compiler itself</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-target</span> <span class="pre">host</span></code>: should always be available. However with stage 1
compilers we can’t reuse self packages (boot libraries of the compilers and
the compiler package itself) because of ABI mismatch. There are two
solutions:</p>
<ul>
<li><p>a second set of boot libraries needs to be built for the host just as if
we were building a stage 2 compiler (hence it may require reinstallable
boot libraries)</p></li>
<li><p>Cabal should be aware of the bootstrapping relationships between
toolchains (next item).</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Cabal should be aware of the available toolchains</p>
<p>Currently cross-compilers such as GHCJS and Asterius use two GHC compilers:
one for the target and another for the host (used to build the former GHC,
the compiler plugins and <code class="docutils literal notranslate"><span class="pre">Setup.hs</span></code> programs). It would be good to make
Cabal aware of the different toolchains (including GHC compilers) at its
disposal and their bootstrapping relation.</p>
<ul class="simple">
<li><p>While GHC and Clang are multi-target, other tools like GCC are not so Cabal
would already need a notion of per-stage tools. It’s not that much harder
to also make that available for GHC itself.</p></li>
<li><p>When using a stage 1 compiler that doesn’t provide <code class="docutils literal notranslate"><span class="pre">-target</span> <span class="pre">self</span></code>, one
has the option to instead use the previous stage’s compiler to build
plugins, which will make the ABI match.</p></li>
</ul>
<p>Related: <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/11378">#11378</a></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Setup.hs</span></code> should be a regular Cabal executable component built like any
other.  Cabal now is well established in its notion of distinct components
per-package that interact just through their dependencies. What makes
<code class="docutils literal notranslate"><span class="pre">Setup.hs</span></code> component different is:</p>
<ul class="simple">
<li><p>the fact that other components of the package have a “this is my
Setup.hs”-type dependency on it</p></li>
<li><p>the fact that it is built to be executed on the compiler host, not on the
actual target.</p></li>
</ul>
</li>
<li><p>Cabal needs to know the target and the dependencies of each component it
builds, including <code class="docutils literal notranslate"><span class="pre">Setup.hs</span></code> components as per the previous item.</p>
<p>cabal-install’s solver already does have some understanding of disjoint
dependency graphs (via <a class="reference external" href="https://www.well-typed.com/blog/2015/03/qualified-goals/">qualified goals</a>). E.g. when
trying to build package <code class="docutils literal notranslate"><span class="pre">foo</span></code> which depends on <code class="docutils literal notranslate"><span class="pre">base</span></code>, it tries to find a
<code class="docutils literal notranslate"><span class="pre">base</span></code> package for <code class="docutils literal notranslate"><span class="pre">base</span></code> and another for <code class="docutils literal notranslate"><span class="pre">foo.setup.base</span></code> (they may
not be the same).  We would have to extend this mechanism to consider target
and stage information (as discussed in the context of Hadrian above).</p>
<p>This would be a <em>huge</em> step towards the goal of GHC not needing bespoke logic
in its build system.</p>
</li>
</ol>
</div>
<div class="section" id="cabal-configure-build-type">
<h3>Cabal: <code class="docutils literal notranslate"><span class="pre">configure</span></code> build-type<a class="headerlink" href="#cabal-configure-build-type" title="Permalink to this headline">¶</a></h3>
<p>Some Cabal packages use <code class="docutils literal notranslate"><span class="pre">build-type:</span> <span class="pre">configure</span></code> (see the <a class="reference external" href="https://www.haskell.org/cabal/users-guide/developing-packages.html#system-dependent-parameters">user manual</a>).
During the configuration phase, the package description is amended by a
<code class="docutils literal notranslate"><span class="pre">configure</span></code> script producing a <code class="docutils literal notranslate"><span class="pre">buildinfo</span></code> file.</p>
<p>This only works on Unix-like systems and without additional parameters it
assumes that the target is the compiler host.</p>
<p>Portable packages (in particular boot libraries) shouldn’t use this. They might
call <code class="docutils literal notranslate"><span class="pre">configure</span></code> in custom <code class="docutils literal notranslate"><span class="pre">Setup.hs</span></code> on Unix-like platforms though, passing it
flags to specify the actual target if necessary.</p>
<p>But for sake of unix-only packages it wouldn’t be hard to teach Cabal to use
<cite>–build</cite>, <cite>–host</cite>, and other Autotools conventions. Autotools, after all, may
be nasty and crude, but does actually have not-so-bad support for cross
compilation thanks to GNU trying to sneak onto all manner of proprietary Unices
in the 1990s.</p>
</div>
<div class="section" id="remove-platform-specific-cpp">
<h3>Remove platform specific CPP<a class="headerlink" href="#remove-platform-specific-cpp" title="Permalink to this headline">¶</a></h3>
<p>GHC should expose a virtual package (like <code class="docutils literal notranslate"><span class="pre">ghc-prim</span></code>) with target information
(e.g. word size, endianness) as values/types instead of using CPP to include
<code class="docutils literal notranslate"><span class="pre">MachDeps.h</span></code>.</p>
<p>Expressions using these values would be simplified in Core.</p>
<p>We could use Template Haskell instead of CPP in some cases. E.g.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>

<span class="o">#</span><span class="n">ifdef</span> <span class="kt">GHC_VERSION</span> <span class="o">&lt;=</span> <span class="mi">806</span>
<span class="nf">foo</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">#</span><span class="kr">else</span>
<span class="nf">foo</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span>
<span class="o">#</span><span class="n">endif</span>

<span class="c1">-- becomes</span>

<span class="o">$</span><span class="p">(</span><span class="kr">if</span> <span class="n">ghc_version</span> <span class="o">&lt;=</span> <span class="mi">806</span>
   <span class="kr">then</span> <span class="p">[</span><span class="n">d</span><span class="o">|</span> <span class="n">foo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
            <span class="n">foo</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
        <span class="o">|</span><span class="p">]</span>
   <span class="kr">else</span> <span class="p">[</span><span class="n">d</span><span class="o">|</span> <span class="n">foo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
            <span class="n">foo</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span>
        <span class="o">|</span><span class="p">]</span>
<span class="p">)</span>

<span class="c1">-- or</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="n">x</span> <span class="ow">=</span> <span class="o">$</span><span class="p">(</span><span class="kr">if</span> <span class="n">ghc_version</span> <span class="o">&lt;=</span> <span class="mi">806</span>
            <span class="kr">then</span> <span class="p">[</span><span class="n">e</span><span class="o">|</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span> <span class="o">|</span><span class="p">]</span>
            <span class="kr">else</span> <span class="p">[</span><span class="n">e</span><span class="o">|</span> <span class="n">x</span><span class="o">+</span><span class="n">z</span> <span class="o">|</span><span class="p">]</span>
         <span class="p">)</span>
</pre></div>
</div>
<p>The advantage of the latter is that both quotes must parse as valid Haskell
code. However renaming and type-checking are performed lazily, which is what we
want because some names may not be available (e.g. <code class="docutils literal notranslate"><span class="pre">y</span></code> or <code class="docutils literal notranslate"><span class="pre">z</span></code>) depending on
the condition (e.g. here <code class="docutils literal notranslate"><span class="pre">ghc_version</span> <span class="pre">&lt;=</span> <span class="pre">806</span></code>).</p>
<p>Related:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=YupkE1vsZ4o">https://www.youtube.com/watch?v=YupkE1vsZ4o</a></p></li>
</ul>
<p>when running byte code we must dynamically link the packages, and only in stage 2 and later do we have packages that GHC was built against
As the compiler quite often depends on features of libraries it depends on that are not guaranteed to be new enough in the bootstrap compilers package database, the first step is to augment the bootstrap compilers package database with those required packages to build the Stage 1 compiler. To do this, we compile this set of bootstrap packages with the bootstrap compiler.
stage 1 compiler
stage 1 package database
build stage 2 compiler with the stage 1 compiler using the stage 1 package database
ship with the stage 2 compiler). As such, the compiler is built with the identical libraries that it ships with. When running / interpreting byte code, we need to dynamically link packages and this way we can guarantee that the packages we link are identical to the ones the compiler was built with. This it is also the reason why we don’t have GHCi or Template Haskell support in the stage 1 compiler.</p>
<p>If we disable GHC features that require code execution (plugins and the internal
interpreter, hence Template Haskell too), we get a GHC that can produce code for
a different target. The price to pay is that this compiler doesn’t support the
full language.</p>
<p>GHC itself is written with this language subset (it doesn’t use compiler plugins
nor Template Haskell).</p>
<ul class="simple">
<li><p>use the multi-threaded runtime system or not</p></li>
<li><p>support profiling or not</p></li>
<li><p>use additional debug assertions or not</p></li>
<li><p>use different heap object representation (e.g. <code class="docutils literal notranslate"><span class="pre">tables_next_to_code</span></code>)</p></li>
<li><p>support dynamic linking or not</p></li>
</ul>
<p>These options are called “compiler ways”. Some of them can be combined (e.g.
threaded + debugging).</p>
<p>Depending on the selected way, the compiler produces and links appropriate
objects together. These objects are identified by a suffix: e.g. <code class="docutils literal notranslate"><span class="pre">*.p_o</span></code> for an
object built with profiling enabled; <code class="docutils literal notranslate"><span class="pre">*.thr_debug_p.a</span></code> for an archive built with
multi-threading, debugging, and profiling enabled. See the gory details on the
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/compiler-ways">wiki</a>.</p>
<p>Installed packages usually don’t provide objects for all the possible ways as it
would make compilation times and disk space explode for features rarely used.</p>
<p>If the selected way is not the same as the one used to build GHC and its boot
libraries, it breaks the confined mode assumptions: the produced objects can’t
be dynamically linked with GHC.</p>
<p>GHC can build objects both for itself (i.e. using the way it has been built
with) and for the selected target way. By doing this, it can simulate the
confined mode by loading objects on the host that are different from the objects
produced for the target, with the hope that the two ways have no observable
difference. Quoting the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/remote-GHCi">wiki</a>: “The way this is done
currently is inherently unsafe, because we use the profiled .hi files with the
unprofiled object files, and hope that the two are in sync.”</p>
<p>Another solution is to use an external interpreter.</p>
</div>
<div class="section" id="breach-3-external-interpreter">
<h3>Breach #3: external interpreter<a class="headerlink" href="#breach-3-external-interpreter" title="Permalink to this headline">¶</a></h3>
<p>The idea behind the external interpreter is to delegate the execution of the
target code to another process (called <code class="docutils literal notranslate"><span class="pre">iserv</span></code>). This process can then delegate
to another one hosted on another platform or in a VM (e.g. NodeJS) if necessary.</p>
<p>GHC performs two-way communication with <code class="docutils literal notranslate"><span class="pre">iserv</span></code> process to send ByteCode to
evaluate, to ask for package to be linked, etc. During code execution, the
<code class="docutils literal notranslate"><span class="pre">iserv</span></code> process may query the host GHC (e.g. when Template Haskell code is run,
it may query information about some <code class="docutils literal notranslate"><span class="pre">Names</span></code> and these information live in the
host GHC).</p>
<p>GHC spawns a different <code class="docutils literal notranslate"><span class="pre">iserv</span></code> process depending on the selected target way:
<code class="docutils literal notranslate"><span class="pre">ghc-iserv-prof</span></code>, <code class="docutils literal notranslate"><span class="pre">ghc-iserv-dyn</span></code>, etc. This allows the <code class="docutils literal notranslate"><span class="pre">iserv</span></code> process to load
target code objects which have not been built with the same way as GHC.</p>
<p>A different external interpreter can be specified with the <code class="docutils literal notranslate"><span class="pre">-pgmi</span></code> command-line
option.</p>
<ol class="arabic simple">
<li><p>Using the external interpreter in GHCi makes sense because it allows the
execution of the code produced for the target on the compiler host (or
remotely but it is internal to the <code class="docutils literal notranslate"><span class="pre">iserv</span></code> process and GHC isn’t aware of
it).</p></li>
<li><p>Using the external interpreter to execute Template Haskell code doesn’t
really make sense: TH code is similar to plugin code in that it has access to
some compiler internals (<code class="docutils literal notranslate"><span class="pre">Names</span></code>, etc.), it can modify the syntax tree and
it can perform IO (read files, etc.). Morally it should be built so that it
can be linked with the compiler and executed on the host.</p></li>
<li><p>Compiler plugins don’t work at all with the external interpreter (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/14335">#14335</a>). It is because they
directly depend on the <code class="docutils literal notranslate"><span class="pre">ghc</span></code> package and assume they are going to be linked
with it. Executing compiler plugins in the external interpreter would mean
that the communication protocol between <code class="docutils literal notranslate"><span class="pre">iserv</span></code> and GHC would need to be
extended to support everything a compiler plugin can do. As compiler plugins
can do virtually anything in the compiler, it would mean that most GHC
datatypes would need to be serializable, most functions explicitly exposed,
etc. Moreover we would have to deal with the discrepancy between host and
target datatypes (word size, etc.). It probably won’t happen.</p></li>
</ol>
<p>External interpreter links:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/external-interpreter">https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/external-interpreter</a></p></li>
<li><p><a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/remote-GHCi">https://gitlab.haskell.org/ghc/ghc/wikis/remote-GHCi</a></p></li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="BuildSystem.html" class="btn btn-neutral float-right" title="Build system" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="Memory.html" class="btn btn-neutral float-left" title="Memory management" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019-2020 Mathnerd314.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>