

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Types &mdash; Stroscot  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Memory management" href="Memory.html" />
    <link rel="prev" title="Overloading" href="Overloading.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Stroscot
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arguments.html">Argument passing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Delimited-Continuations.html">Delimited continuations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="Overloading.html">Overloading</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#roles">Roles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-synthesis">Type synthesis</a></li>
<li class="toctree-l2"><a class="reference internal" href="#condition-checking">Condition checking</a></li>
<li class="toctree-l2"><a class="reference internal" href="#terminology">Terminology</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-declaration-syntax">Type declaration syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="#concrete-types">Concrete types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Memory.html">Memory management</a></li>
<li class="toctree-l1"><a class="reference internal" href="FAQ.html">FAQ</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Stroscot</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Types</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Types.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="types">
<h1>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h1>
<p>Types are hard. Academics have spent decades in search of the perfect
type system, often not even paying attention to the work of others. As far as doing something type-related I think the only solution is to hack until it works. I’ve read a bunch of type papers and they all end up leaving it up to you to make it work. If they do present an algorithm it’s very simple and then all the rest of the paper is mostly about proving the algorithm correct and complete rather than on the implementation.</p>
<p>The academic approach to types can be summed up in this quote (from <a class="reference external" href="https://www.irif.fr/~gc/papers/covcon-again.pdf">here</a>):</p>
<blockquote>
<div><p>You should fit programming languages to types and not the other way round, insofar as a type theory should be developed pretty much independently of the language (but, of course, not of the problem) it is to be applied to. It is a language design problem to ensure that whenever we have a function of that type, then the code executed for each combination of the types of the arguments is not only unambiguously defined, but also easily predictable by the programmer. In order to solve type-related problems, you must first conceive the types and only after you can think of how to design a language that best fits these types.</p>
</div></blockquote>
<p>The alternative is model checking, which is the opposite approach: take an existing program and try to prove properties about it with some kind of model. Although types can encapsulate properties, for the most part they don’t have a lot of expressive power. Defining <code class="docutils literal notranslate"><span class="pre">newtype</span> <span class="pre">Even</span> <span class="pre">=</span> <span class="pre">Integer</span></code> does not give an error on <code class="docutils literal notranslate"><span class="pre">Even</span> <span class="pre">1</span></code>, while <code class="docutils literal notranslate"><span class="pre">assert(e</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0)</span></code> will throw an error regardless, and the model checker proves that error won’t happen. The only issue is that properties can become verbose and the model checker is a black box that cannot be helped along, as opposed to the expressive tactic notations found in proof assistants.</p>
<div class="section" id="roles">
<h2>Roles<a class="headerlink" href="#roles" title="Permalink to this headline">¶</a></h2>
<p>There’s really two kinds of types (three if you include erased phantom types, but those are just dead code). First, there’s representation types, which describe how the data type is represented in memory, how to pass it to a function, how many pointers you have to dereference to access it, and lifetime information for the garbage collector or memory deallocator. You have pointers, bits strings, structs, and not much else. Dependent types come in handy, for field lengths/types that depend on the value of other fields. But subtyping and polymorphism get erased as the compiler defaults variables to their generic pointer implementation or specializes the function to a more specific/efficient representation.</p>
<p>The other kind of types are nominal types, which are what you often see when people talk about static typing. So these types prevent you from using them in place of their underlying representation unless you’ve added the name to the type using a type constructor or cast. Usually they express some restriction about the data, for example with SQL statements you might have types for escaped expressions and unescaped expressions. All you’re saying is that there aren’t any unescaped commands in this data, but because programming languages don’t memoize functions it’s more efficient to say <code class="docutils literal notranslate"><span class="pre">typeof</span> <span class="pre">stmt</span> <span class="pre">==</span> <span class="pre">EscapedStmt</span></code> than it is to say <code class="docutils literal notranslate"><span class="pre">isEverythingEscaped</span> <span class="pre">stmt</span> <span class="pre">==</span> <span class="pre">True</span></code>. And often the type is correct by construction, because all the methods you’re using only construct values of the type, so it provides a handy way to assert an invariant without having to prove it like you would with a dependently typed environment.</p>
</div>
<div class="section" id="type-synthesis">
<h2>Type synthesis<a class="headerlink" href="#type-synthesis" title="Permalink to this headline">¶</a></h2>
<p>If types are hard, type synthesis is harder. There’s the <a class="reference external" href="https://github.com/stedolan/fyp">sub</a><a class="reference external" href="https://github.com/stedolan/mlsub">typing</a> stuff which actually has some pretty powerful type synthesis, better than Hindley-Milner. But <a class="reference external" href="https://github.com/UlfNorell/insane/">dependent</a>
<a class="reference external" href="https://github.com/gelisam/circular-sig">circular</a> dependent types will presumably ruin all the fun and require type signatures. However, <a class="reference external" href="https://www.cl.cam.ac.uk/~nk480/bidir-survey.pdf">bidirectional type checking</a> should be able to minimize the amount of signatures required.</p>
</div>
<div class="section" id="condition-checking">
<h2>Condition checking<a class="headerlink" href="#condition-checking" title="Permalink to this headline">¶</a></h2>
<p>There’s some interesting <a class="reference external" href="http://mmjb.github.io/T2/">work</a> I found on termination checking by Microsoft, called <a class="reference external" href="https://web.archive.org/web/20131005142732/http://research.microsoft.com:80/en-us/um/cambridge/projects/terminator/papers.htm">TERMINATOR</a>. There’s an interesting representation of terms as sets, which ends up mapping out all the paths through the program, and then identifying termination is fairly easy. But since you can check all these conditions it’s a very powerful analysis that can also check buffer overflows and array bounds and <a class="reference external" href="https://arxiv.org/abs/1907.10096">resource use</a> and things of that nature. I’m not sure how to integrate it into a type system but we’ll figure it out.</p>
</div>
<div class="section" id="terminology">
<h2>Terminology<a class="headerlink" href="#terminology" title="Permalink to this headline">¶</a></h2>
<p>At this point you might be getting confused about terminology. I certainly am. So here we are:</p>
<dl class="simple">
<dt>memory cell</dt><dd><p>A circuit that can store some fixed number of logical bits, 0 or 1. Since ternary computers might eventually become popular, a cell is probably best modeled as a register containing an integer <code class="docutils literal notranslate"><span class="pre">i</span></code> with <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">MAX</span></code> with no restriction that <code class="docutils literal notranslate"><span class="pre">MAX</span></code> is a power of 2.</p>
</dd>
<dt>value</dt><dd><p>A group of memory cells, paired with some interpretation as a data type</p>
</dd>
<dt>data type</dt><dd><p>A representational type, that can generally be narrowed down to a pair of functions doing pickle/unpickle on the value’s bits</p>
</dd>
<dt>reference</dt><dd><p>A value providing a way to access another value, usually a memory address. It’s distinct from an API because at any given time there’s only one unique value that can be accessed using the reference.</p>
</dd>
<dt>variable</dt><dd><p>A name/symbol/identifier representing a function argument or mathematical object</p>
</dd>
<dt>l-value</dt><dd><p>A variable representing a memory cell. The difference is some people don’t consider <code class="docutils literal notranslate"><span class="pre">arr[i]</span></code> to be a variable, while they’ll all agree it’s an l-value.</p>
</dd>
<dt>r-value</dt><dd><p>A value without a reference, basically an anonymous temporary value. Except in C++11 you can still bind its memory address, to get an x-value. Segfaults galore. ¯\_(ツ)_/¯</p>
</dd>
<dt>subtyping</dt><dd><p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">B</span></code> if every element of <code class="docutils literal notranslate"><span class="pre">A</span></code> is also in <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
</dd>
<dt>inheritance</dt><dd><p>Record subtyping, where for example <code class="docutils literal notranslate"><span class="pre">{a,b}</span></code> is considered a subtype of <code class="docutils literal notranslate"><span class="pre">{a}</span></code>.</p>
</dd>
</dl>
</div>
<div class="section" id="type-declaration-syntax">
<h2>Type declaration syntax<a class="headerlink" href="#type-declaration-syntax" title="Permalink to this headline">¶</a></h2>
<p>There are a few options for type declarations. Jai’s syntax for types is pretty simple, it’s just:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span><span class="p">:</span> <span class="nb">type</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</pre></div>
</div>
<p>Whereas in C and Rust the syntax is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">name</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</pre></div>
</div>
<p>The third choice is to put the type on the right with the expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span> <span class="o">=</span> <span class="nb">type</span> <span class="n">value</span><span class="p">;</span>
<span class="n">name</span> <span class="o">=</span> <span class="n">value</span> <span class="p">:</span> <span class="nb">type</span><span class="p">;</span> <span class="c1"># (:) is an operator x : y = y x</span>
</pre></div>
</div>
<p>This third option seems like the most logical place. For example, if I’m declaring a new mutable variable, I don’t want to say that the name is mutable. The name is just what I use to refer to the variable; it’s a handle so I can write my program without resorting to hexadecimal addresses.</p>
<p>What we want is to declare that the mutability as part of the value; it’s a mutable value. So putting it in the expression tells the compiler that you can’t store this like you would store a normal constant value; you have to create a data structure on the stack or the heap or whatever to access this variable.</p>
<p>By comparison, the other syntaxes don’t make sense. If I had <code class="docutils literal notranslate"><span class="pre">mut</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">1</span></code>, I’m not going to talk about “mut a” for the rest of the program, I’m going to talk about <code class="docutils literal notranslate"><span class="pre">a</span></code>. And what happens if I write <code class="docutils literal notranslate"><span class="pre">mut</span> <span class="pre">=</span> <span class="pre">1</span></code>? Terrible things. Similarly <code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">mut</span> <span class="pre">=</span> <span class="pre">1</span></code> makes no sense. Whereas <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">mut</span></code> actually makes some sense if I decide that 3 characters is too long and want to abbreviate <code class="docutils literal notranslate"><span class="pre">mut</span></code> to <code class="docutils literal notranslate"><span class="pre">a</span></code>, or if I’m doing higher-order functional programming that creates references. Similarly <code class="docutils literal notranslate"><span class="pre">mut</span> <span class="pre">1</span></code> is quite sensible, as an anonymous reference cell.</p>
<p>So getting back to our syntax, <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">type</span> <span class="pre">value</span></code>. It should be clear that we have two types of assignments. The first, with the type included, creates/allocates the stuff we need to access it, and then <code class="docutils literal notranslate"><span class="pre">name</span></code> is bound to a memory address.</p>
<p>When we assign again, it will look like <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">:=</span> <span class="pre">value</span></code>, without a type. This has a completely different semantics: we take the thing on the left, the l-value, and we access the memory that it refers to, and we change the memory. Since the semantics is so different it uses a different syntax.</p>
<p>There is no kind of syntax or semantics for changing or redefining identifiers (besides fexprs/macros which we’ll get to later); you can shadow, with warning, but once an identifier is declared in a scope, that’s what that identifier refers to for the duration of the scope.</p>
</div>
<div class="section" id="concrete-types">
<h2>Concrete types<a class="headerlink" href="#concrete-types" title="Permalink to this headline">¶</a></h2>
<p>Primitive types include bitstring patterns <code class="docutils literal notranslate"><span class="pre">bits</span></code> and pointers <code class="docutils literal notranslate"><span class="pre">ptr</span></code>. Can’t go wrong
there.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bits</span> <span class="mh">0xDEADBEEF</span>
<span class="n">ptr</span> <span class="mh">0xDEADBEEF</span>
</pre></div>
</div>
<p>The default arithmetic type is a <code class="docutils literal notranslate"><span class="pre">number</span></code> type.
This is arbitrary-precision magic which can store just about anything.
You can use <code class="docutils literal notranslate"><span class="pre">integer</span></code> for a strict integer, <code class="docutils literal notranslate"><span class="pre">decimal</span></code> for banking, and
<code class="docutils literal notranslate"><span class="pre">float</span></code> for any IEEE 754 thing. For <code class="docutils literal notranslate"><span class="pre">integer</span></code> the <code class="docutils literal notranslate"><span class="pre">size</span></code> argument restricts the size and <code class="docutils literal notranslate"><span class="pre">sign</span></code> restricts the sign. Those aren’t the full constructors, it’ll probably have a range too.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>number 100!
integer 123
decimal 123.45
float 1e20
i8 = integer { size = 2^8 }
i8 4
# bits 0b00000100 or bits 0x04
i8 129
# Error: out of range, cannot convert
u8 = i8 { sign = unsigned }
u8 129
# bits 0b10000001 or bits 0x81
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Memory.html" class="btn btn-neutral float-right" title="Memory management" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Overloading.html" class="btn btn-neutral float-left" title="Overloading" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019-2020 Mathnerd314

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>