import Control.Monad.Codensity (Codensity)

-- trifecta
data State = State { currentPosition :: Delta, chunk {- of input currently under analysis -} :: [Byte] }
-- attoparsec
type State = ([Byte],Pos,More)
type Pos = Int
data More = Complete | Incomplete -- Have we read all available input?
-- attoparsec Zepto
type State = [Byte]
-- parsec
data State = State { stateInput :: [Byte], statePos   :: !SourcePos, stateUser :: () }
data SourcePos  = SourcePos SourceName !Line !Column
-- megaparsec
data State = State
  { stateInput :: [Byte],
    stateOffset :: Int,
    stateParseErrors :: [ParseError]
  }

-- trifecta
type Parser = State -> It
data It = Pure BehaviorContinuation | It BehaviorContinuation ([Byte] -> It)
data BehaviorContinuation =
  -- the parser has consumed no input and has a result as well as a possible Err; the position and chunk are unchanged (see pure)
  EpsilonSuccess ParseTree Err
  -- the parser has consumed no input and is failing with the given Err; the position and chunk are unchanged (see empty)
  | EpsilonFailure Err
  -- the parser has consumed input and is yielding
  -- the result, set of expected strings that would have permitted this parse to continue, new residual state
  | CommittedSuccess ParseTree (Set String) State
  -- the parser has consumed input and is failing with a given ErrInfo (user-facing error message)
  | CommittedFailure ErrInfo

data Err = Err { _reason :: Maybe (Doc AnsiStyle), _footnotes :: [Doc AnsiStyle], _expected :: Set String, _finalDeltas :: [Delta] }
-- user-facing error message
data ErrInfo = ErrInfo { _errDoc :: Doc AnsiStyle, _errDeltas :: [Delta] }

data Delta = Delta { number_of_bytes :: Int64 }
{- and more structured location info:
number of characters before/after tab
number of bytes/characters since last newline
number of newlines seen since file start / last LINE directive
current file name / line directive
-}


-- attoparsec
type Parser = State -> IResult
data IResult
  = Fail { unconsumedInput :: [Byte], contexts :: [String], errorMessage :: String }
  | Partial ([Byte] -> IResult) -- Needs more input
  | Done { unconsumedInput :: [Byte], successful_result :: Cont }
data Cont =
  Failure State [String] String
  | Success State ParseTree

-- attoparsec Zepto
type ZeptoT = State -> (Fail String | OK ParseTree State)

-- parsec
type ParsecT = State -> Consumed Result

data Consumed a  = Consumed a | Empty !a
data Reply = Ok ParseTree State ParseError | Error ParseError
data ParseError = ParseError !SourcePos [Message]
data Message = SysUnExpect !String -- @ library generated unexpect
             | UnExpect    !String -- @ unexpected something
             | Expect      !String -- @ expecting something
             | Message     !String -- @ raw message

-- megaparsec
type ParsecT = State -> Reply
data Reply = Reply State Consumption Result
data Consumption = Consumed | Virgin
data Result = OK ParseTree (hints :: Set ErrorItem) | Error ParseError
data ErrorItem
  = -- | Non-empty stream of tokens
    Tokens (NonEmpty Byte)
  | -- | Label (cannot be empty)
    Label (NonEmptyString)
  | -- | End of input
    EndOfInput

data ParseError
  = -- | Trivial errors, generated by Megaparsec's machinery.
    TrivialError { errorOffset :: Int, unexpectedToken :: (Maybe ErrorItem), expectedTokens :: (Set ErrorItem) }
  | -- | Fancy, custom errors.
    FancyError { errorOffset :: Int, customErrors :: (Set ErrorFancy) }

data ErrorFancy e
  = ErrorFail String
  | ErrorIndentation Ordering Pos Pos
  {- | ... - extend as necessary -}
