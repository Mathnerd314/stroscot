<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Stroscot Playground</title>
  <script src="https://d3js.org/d3.v4.js"></script>
  <script src="https://dagrejs.github.io/project/dagre-d3/latest/dagre-d3.js"></script>
  <script src="https://dagrejs.github.io/project/graphlib-dot/latest/graphlib-dot.js"></script>
  <script src="interaction-nets.js"></script>
  <style>
    svg {
      border: 1px solid #999;
      overflow: hidden;
    }

    .node {
      white-space: nowrap;
    }

    .node rect,
    .node circle,
    .node ellipse {
      stroke: #333;
      fill: #fff;
      stroke-width: 1.5px;
    }

    .cluster rect {
      stroke: #333;
      fill: #000;
      fill-opacity: 0.1;
      stroke-width: 1.5px;
    }

    .edgePath path.path {
      stroke: #333;
      stroke-width: 1.5px;
      fill: none;
    }

    .demux {
      text-decoration: underline;
    }
  </style>
</head>

<body>
  <div>
    <input id="advance" type="button" value=">">
    <input id="ff" type="button" value=">|">
  </div>
  <pre id="output"></pre>
  <svg id="svg" width="1900" height="2000">
    <g id="graph" transform="translate(0,0)" />
  </svg>
  <script>
    L = (n, b) => { return { tag: "abs", name: n, body: b }; };
    S = (n) => { return { tag: "symbol", name: n }; };
    A = (f, a) => { return { tag: "app", func: f, arg: a }; };
    LET = (b, e) => { return { tag: "let", binds: b, expr: e }; };
    // t = LET([["id", L("x", S("x"))]],
    //   A(S("id"), L("y", L("z", A(S("z"), S("y"))))));
    // t = LET([
    //   ["z", L("g", L("x", S("x")))],
    //   ["s", L("n", L("f", L("x", A(S("f"), A(A(S("n"), S("f")), S("x"))))))]],
    //   A(S("s"), A(S("s"), S("z"))));
    // let y = L("f",
    //           A(L("y", A(S("y"), S("y"))),
    //             L("x", A(S("f"), A(S("x"), S("x"))))));


    // t = A(L("id", A(S("id"), L("y", L("z", A(S("z"), S("y")))))), L("x", S("x")));
    let net; {
      let x = S("x"), y = S("y");
      let id = L("x", S("x"));
      let l2 = L("x", L("y", A(x, A(x, y))));
      // let t = A(l2, l2);
      let t = {
        tag: "bigapp",
        func: {tag: "operator", cases: [{ constr: "blah", vars: ["g", "h"], rhs: A(A(id, "g"), "h")},
          { constr: "what", vars: ["g", "h"], rhs: A(A("g", l2), "h")}]},
        name: "blah",
        terms: [l2, l2]
      };
      net = compile(t);
    }

    function toSexpr(thing, needParens) {
      if (thing.tag == "symbol") {
        return toSexpr(thing.idx, needParens) + (thing.rule != "sole" ? `_${toSexpr(thing.rule_idx, needParens)}` : "");
      }
      if (thing.tag == "operator" && thing.cases.length == 1 && thing.cases[0][0] == "sole") {
        return `λ${toSexpr(thing.cases[0][2], needParens)}`;
      }
      if (thing.tag == "operator") {
        return `λ{` + thing.cases.map(c=> (
          toSexpr(c[0], false)
          + " " + toSexpr(c[1], false)
          + "." +toSexpr(c[2], false)
        )).join(",") + `}`;
      }
      if (thing.tag == "abs") return `λ${toSexpr(thing.body, needParens)}`;
      if (thing.tag == "bigapp") {
        let s = toSexpr(thing.func, true);
        for (let t of thing.terms) {
          s += toSexpr(t, true);
        }
        return needParens ? `(${s})` : s;
      }
      if (thing.tag == "app") {
        let s = `${toSexpr(thing.func, true)}${toSexpr(thing.arg, true)}`;
        return needParens ? `(${s})` : s;
      }
      return JSON.stringify(thing);
    }

    {
      // Set up zoom support
      let svg = d3.select("svg"),
        inner = d3.select("svg g"),
        zoom = d3.zoom().on("zoom", function () {
          let trf = d3.event.transform;
          let g = inner.node();
          g.transform.baseVal[0].setMatrix(
            g.parentNode.createSVGMatrix().translate(trf.x, trf.y).scale(trf.k, trf.k)
          );
        });
      svg.call(zoom);
    }
    var render = dagreD3.render();
    function showNet(x) {
      var g = graphlibDot.read(getdot(x));

      // Render the graph into svg g
      let graph = d3.select("#graph"), grph = graph.node();
      let tr = grph.transform.baseVal[0].matrix.scale(1);
      grph.transform.baseVal[0].setTranslate(0, 0);
      let ini = document.getElementById("initiator"), preMatrix = null;
      if (ini) { preMatrix = ini.offsetParent.getScreenCTM(); }
      graph.call(render, g);
      ini = document.getElementById("initiator");
      if (ini && preMatrix) {
        let postMatrix = ini.offsetParent.getScreenCTM();
        window.mats = [tr, preMatrix, postMatrix];
        tr = tr.multiply(postMatrix.inverse().multiply(preMatrix));
      }
      grph.transform.baseVal[0].setMatrix(tr);

      document.getElementById("output").textContent =
        toSexpr(readback(x, "out", Stack(0, []))) +
        `\nactive: ${activePairs.length} annihilations: ${stats.annihilate} commutes: ${stats.commute}`;
      if (!activePairs.length) {
        document.getElementById("advance").disabled = true;
        document.getElementById("ff").disabled = true;
      }
    }


    {
      // lo_redex([net, "out"]);
      showNet(net);
      document.getElementById("advance").onclick = () => {
        rewriteStep();
        // rewriteStepLo();
        showNet(net);
      }
    }
    document.getElementById("ff").onclick = () => {
      while (activePairs.length) {
        rewriteStep();
        getdot(net);
        readback(net, "out", Stack(0, []));
      }
      showNet(net);
    }
  </script>
</body>

</html>