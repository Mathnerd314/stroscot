[pattern] // optional
{pattern} // zero or more repetitions
(pattern) // grouping
pat_1 | pat_2 // choice
pat AND NOT pat // difference - elements generated by pat except those generated by pat'
'f' // literal character
[abc] A character set. Matches any one of the enclosed characters.

NL = Newline | CR | LF
FOZ = Format | Extend | ZWJ
MLQ = MidLetter | MidNumLetQ
AL = AHLetter
MNQ = MidNum | MidNumLetQ
special = (),;[]`{}

WB1  sot  ÷  Any
WB2  Any  ÷  eot
WB3  CR  ×  LF
WB3a  NL ÷
WB3b     ÷ NL
WB3c  ZWJ  ×  \p{Extended_Pictographic}
WB3d  WSegSpace  ×  WSegSpace
WB4a  Any × FOZ
WB4  X FOZ*  →  X
WB5  AL  ×  AL
WB6  AL  ×  MLQ AL
WB7  AL MLQ  ×  AL
WB7a  Hebrew_Letter  ×  Single_Quote
WB7b  Hebrew_Letter  ×  Double_Quote Hebrew_Letter
WB7c  Hebrew_Letter Double_Quote  ×  Hebrew_Letter
WB8  Numeric  ×  Numeric
WB9  AL  ×  Numeric
WB10  Numeric  ×  AL
WB11  Numeric MNQ  ×  Numeric
WB12  Numeric  ×  MNQ Numeric
WB13  Katakana  ×  Katakana
WB13a  (AL | Numeric | Katakana | ExtendNumLet)  ×  ExtendNumLet
WB13b  ExtendNumLet  ×  (AL | Numeric | Katakana)
WB15  sot (RI RI)* RI  ×  RI
WB16  [^RI] (RI RI)* RI  ×  RI
WB999  Any  ÷  Any

Haskell

LETTER = Unicode category Ll,Lt,Lu,Lo | '_'
SYMBOL = Unicode category Pc,Pd,Po,Sc,Sm,Sk,So
other_graphic = Unicode category Mc,Me,Nl,Ps,Pe,Pi,Pf
Numeric = Unicode category Nd,No
uniidchar = Lm, Mn

varid  LETTER  ×  (LETTER | DIGIT | SINGLE_QUOTE | uniidchar)
symbol  SYMBOL  ×  SYMBOL


whitechar -> newline | '\v' | space | tab (should include all Unicode whitespace)
program -> { lexeme | whitespace }
lexeme -> qvarid | qvarsym | literal | special | reservedop | reservedid
literal -> integer | float | char | string

whitespace -> whitestuff {whitestuff}
whitestuff -> whitechar | comment | ncomment


escaped-newline → escape-sequence inline-spaces opt line-break

comment -> dashes [ (any AND NOT symbol) {any} ] newline
dashes -> '--' {'-'}
opencom -> '{-'
closecom -> '-}'
ncomment -> opencom ANYseq {ncomment ANYseq} closecom
ANYseq -> {ANY AND NOT (opencom | closecom)}
symbol -> (/[!#$%&*+./<=>?@\'^|-~:]/ | any Unicode symbol or punctuation) AND NOT special | '_' | '"' | '\''

varsym -> ( symbol {symbol} ) AND NOT (reservedop | dashes)

reservedop -> '..' | ':' | '::' | '=' | '\' | '|' | '<-' | '->' | '@' | '~' | '=>'

modid -> {varid '.'} varid // (modules)
qvarid -> [ modid '.' ] varid
qvarsym -> [ modid '.' ] varsym

decimal -> {'0' | '1' | ... | '9' | any Unicode decimal digit}+
octal -> {'0' | '1' | ... | '7'}+
hexadecimal -> {any Unicode decimal digit | 'A' | ... | 'F' | 'a' | ... | 'f'}+

integer -> decimal | '0o' octal | '0O' octal | '0x' hexadecimal | '0X' hexadecimal
float -> decimal '.' decimal [exponent] | decimal exponent
exponent -> ('e' | 'E') ['+' | '-'] decimal

large -> Unicode category Lt | Unicode category Lu
graphic -> small | large | symbol | digit | special | '"' | '\''
ANY -> graphic | whitechar
any -> graphic | space | tab
char -> '\'' (graphic AND NOT '\'' | '\'} | space | (escape AND NOT '\&'})) '\''
string -> '"' { (graphic AND NOT '"' | '\' ) | space | escape | gap} '"'
escape -> '\' ( charesc | ascii | decimal | 'o' octal | 'x' hexadecimal )
charesc -> 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\' | '"' | '\'' | '&'
ascii -> '^'cntrl | 'NUL' | 'SOH' | 'STX' | 'ETX' | 'EOT' | 'ENQ' | 'ACK' | 'BEL' | 'BS' | 'HT' | 'LF' | 'VT' | 'FF' | 'CR' | 'SO' | 'SI' | 'DLE' | 'DC1' | 'DC2' | 'DC3' | 'DC4' | 'NAK' | 'SYN' | 'ETB' | 'CAN' | 'EM' | 'SUB' | 'ESC' | 'FS' | 'GS' | 'RS' | 'US' | 'SP' | 'DEL'
cntrl -> uppercase unicode char | '' | '[' | '\' | ']' | '^' | '_'
gap -> '\' whitechar {whitechar} '\'


module -> 'module' modid [exports] 'where' body | body
body -> '{' impdecls ';' topdecls '}' | '{' impdecls '}' | '{' topdecls '}'

impdecls -> impdecl_1 ';' ... ';' impdecl_n // (n>=1)

exports -> '(' export_1 ',' ... ',' export_n [ ',' ] ')' // (n>=0)

export -> qvar | qvarid ['(..)' | '(' cname_1 ',' ... ',' cname_n ')'] // (n>=0) | qvarid ['(..)' | '(' qvar_1 ',' ... ',' qvar_n ')'] // (n>=0) | 'module' modid

impdecl -> 'import' ['qualified'] modid ['as' modid] [impspec] | // (empty declaration)

impspec -> '(' import_1 ',' ... ',' import_n [ ',' ] ')' // (n>=0) | 'hiding' '(' import_1 ',' ... ',' import_n [ ',' ] ')' // (n>=0)

import -> var | varid [ '(..)' | '(' cname_1 ',' ... ',' cname_n ')'] // (n>=0) | varid ['(..)' | '(' var_1 ',' ... ',' var_n ')'] // (n>=0)
cname -> var | con

topdecls -> topdecl_1 ';' ... ';' topdecl_n // (n>=0)
topdecl -> 'type' simpletype '=' type | 'data' [context '=>'] simpletype ['=' constrs] [deriving] | 'newtype' [context '=>'] simpletype '=' newconstr [deriving] | 'class' [scontext '=>'] varid varid ['where' cdecls] | 'instance' [scontext '=>'] qvarid inst ['where' idecls] | 'default' '('type_1 ',' ... ',' type_n')' // (n>=0) | 'foreign' fdecl | decl

decls -> '{' decl_1 ';' ... ';' decl_n '}' // (n>=0)
decl -> gendecl | (funlhs | pat) rhs

cdecls -> '{' cdecl_1 ';' ... ';' cdecl_n '}' // (n>=0)
cdecl -> gendecl | (funlhs | var) rhs

idecls -> '{' idecl_1 ';' ... ';' idecl_n '}' // (n>=0)
idecl -> (funlhs | var) rhs | // (empty)

gendecl -> vars '::' [context '=>'] type // (type signature) | fixity [integer] ops // (fixity declaration) | // (empty declaration)

ops -> op_1 ',' ... ',' op_n // (n>=1)
vars -> var_1 ',' ...',' var_n // (n>=1)
fixity -> 'infixl' | 'infixr' | 'infix'

type -> btype ['->' type] // (function type)

btype -> [btype] atype // (type application)

atype -> gtycon | varid | '(' type_1 ',' ... ',' type_k ')' // (tuple type, k>=2) | '[' type ']' // (list type) | '(' type ')' // (parenthesized constructor)

gtycon -> qvarid | '()' // (unit type) | '[]' // (list constructor) | '(->)' // (function constructor) | '(,'{','}')' // (tupling constructors)

context -> class | '(' class_1 ',' ... ',' class_n ')' // (n>=0)
class -> qvarid varid | qvarid '(' varid atype_1 ... atype_n ')' // (n>=1)
scontext -> simpleclass | '(' simpleclass_1 ',' ... ',' simpleclass_n ')' // (n>=0)
simpleclass -> qvarid varid

simpletype -> varid tyvar_1 ... tyvar_k // (k>=0)
constrs -> constr_1 '|' ... '|' constr_n // (n>=1)
constr -> con ['!'] atype_1 ... ['!'] atype_k // (arity con = k, k>=0) | (btype | '!' atype) conop (btype | '!' atype) // (infix conop) | con '{' fielddecl_1 ',' ... ',' fielddecl_n '}' // (n>=0)
newconstr -> con atype | con '{' var '::' type '}'
fielddecl -> vars '::' (type | '!' atype)
deriving -> 'deriving' (dclass | '('dclass_1',' ... ',' dclass_n')')// (n>=0)
dclass -> qvarid

inst -> gtycon | '(' gtycon tyvar_1 ... tyvar_k ')' // (k>=0, tyvars distinct) | '(' tyvar_1 ',' ... ',' tyvar_k ')' // (k>=2, tyvars distinct) | '[' varid ']' | '(' tyvar_1 '->' tyvar_2 ')' // tyvar_1 and tyvar_2 distinct

fdecl -> 'import' callconv [safety] impent var '::' ftype // (define variable) | 'export' callconv expent var '::' ftype // (expose variable)
callconv -> 'ccall' | 'stdcall' | 'cplusplus' // (calling convention) | 'jvm' | 'dotnet' | system-specific calling conventions
impent -> [string] // ccall
expent -> [string] // ccall
safety -> 'unsafe' | 'safe'

ftype -> frtype | fatype \rightarrow ftype
frtype -> fatype | '()'
fatype -> qvarid atype_1 \ldots atype_k // (k \geq 0)

funlhs -> var apat { apat } | pat varop pat | '(' funlhs ')' apat { apat }

rhs -> '=' exp ['where' decls] | gdrhs ['where' decls]

gdrhs -> guards '=' exp [gdrhs]

guards -> '|' guard_1, ..., guard_n // (n>=1)
guard -> pat '<-' infixexp // (pattern guard) | 'let' decls // (local declaration) | infixexp // (boolean guard)

exp -> infixexp '::' [context '=>'] type // (expression type signature) | infixexp

infixexp -> lexp qop infixexp // (infix operator application) | '-' infixexp // (prefix negation) | lexp

lexp -> '\' apat_1 ... apat_n '->' exp // (lambda abstraction, n>=1) | 'let' decls 'in' exp // (let expression) | 'if' exp [';'] 'then' exp [';'] 'else' exp // (conditional) | 'case' exp 'of' '{' alts '}' // (case expression) | 'do' '{' stmts '}' // (do expression) | fexp
fexp -> [fexp] aexp // (function application)

aexp -> qvar // (variable) | gcon // (general constructor) | literal | '(' exp ')' // (parenthesized expression) | '(' exp_1 ',' ... ',' exp_k ')' // (tuple, k>=2) | '[' exp_1 ',' ... ',' exp_k ']' // (list, k>=1) | '[' exp_1 [',' exp_2] '..' [exp_3] ']' // (arithmetic sequence) | '[' exp '|' qual_1 ',' ... ',' qual_n ']' // (list comprehension, n>=1) | '(' infixexp qop ')' // (left section) | '(' (qop AND NOT '-') infixexp} ')' // (right section) | qcon '{' fbind_1 ',' ... ',' fbind_n '}' // (labeled construction, n>=0) | (aexp AND NOT qcon) '{' fbind_1 ',' ... ',' fbind_n '}' // (labeled update, n >= 1)

qual -> pat '<-' exp // (generator) | 'let' decls // (local declaration) | exp // (guard)

alts -> alt_1 ';' ... ';' alt_n // (n>=1)
alt -> pat '->' exp ['where' decls] | pat gdpat ['where' decls] | // (empty alternative)

gdpat -> guards '->' exp [ gdpat ]

stmts -> stmt_1 ... stmt_n exp [';'] // (n>=0)
stmt -> exp ';' | pat '<-' exp ';' | 'let' decls ';' | ';' // (empty statement)

fbind -> qvar '=' exp

pat -> lpat qconop pat // (infix constructor) | lpat

lpat -> apat | '-' (integer | float) // (negative literal) | gcon apat_1 ... apat_k // (arity gcon = k, k>=1)

apat -> var [@ apat] // (as pattern) | gcon // (arity gcon = 0) | qcon '{' fpat_1 ',' ... ',' fpat_k '}' // (labeled pattern, k>=0) | literal | '_' // (wildcard) | '(' pat ')' // (parenthesized pattern) | '(' pat_1 ',' ... ',' pat_k ')' // (tuple pattern, k>=2) | '[' pat_1 ',' ... ',' pat_k ']' // (list pattern, k>=1) | '~' apat // (irrefutable pattern)

fpat -> qvar '=' pat

gcon -> '()' | '[]' | '(,'{','}')' | qcon

var -> varid | '(' varsym ')' // (variable)
qvar -> qvarid | '(' qvarsym ')' // (qualified variable)
con -> varid | '(' varsym ')' // (constructor)
qcon -> qvarid | '(' gconsym ')' // (qualified constructor)
varop -> varsym | '`' varid '`' // (variable operator)
qvarop -> qvarsym | '`' qvarid '`' // (qualified variable operator)
conop -> varsym | '`' varid '`' // (constructor operator)
qconop -> gconsym | '`' qvarid '`' // (qualified constructor operator)
op -> varop | conop // (operator)
qop -> qvarop | qconop // (qualified operator)
gconsym -> ':' | qvarsym


decl -> '{-#' 'INLINE' qvars '#-}'
decl -> '{-#' 'NOINLINE' qvars '#-}'

decl -> '{-#' 'SPECIALIZE' spec_1 ',' ... ',' spec_k '#-}' // (k>=1)
spec -> vars :: type

modid -> {varid '.'} varid // (modules)

module -> 'module' modid [exports] 'where' body | body
body -> '{' impdecls ';' topdecls '}' | '{' impdecls '}' | '{' topdecls '}'

impdecls -> impdecl_1 ';' ... ';' impdecl_n // (n>=1)
topdecls -> topdecl_1 ';' ... ';' topdecl_n // (n>=1)

exports -> '(' export_1 ',' ... ',' export_n [ ',' ] ')' // (n>=0)

export -> qvar | qvarid ['(..)' | '(' cname_1 ',' ... ',' cname_n ')'] // (n>=0) | qvarid ['(..)' | '(' var_1 ',' ... ',' var_n ')'] // (n>=0) | 'module' modid

cname -> var | con

impdecl -> 'import' ['qualified'] modid ['as' modid] [impspec] | // (empty declaration)
impspec -> '(' import_1 ',' ... ',' import_n [ ',' ] ')' // (n>=0) | 'hiding' '(' import_1 ',' ... ',' import_n [ ',' ] ')' // (n>=0)

import -> var | varid [ '(..)' | '(' cname_1 ',' ... ',' cname_n ')'] // (n>=0) | varid ['(..)' | '(' var_1 ',' ... ',' var_n ')'] // (n>=0)

% var
% | varid
% | varid '(..)'
% | varid '(' con_1 ',' ... ',' con_n')' // (n>=1)
% | varid '(..)'
% | varid '(' var_1 ',' ... ',' var_n')' // (n>=0)

cname -> var | con


exp -> infixexp '::' [context '=>'] type // (expression type signature) | infixexp

infixexp -> lexp qop infixexp // (infix operator application) | '-' infixexp // (prefix negation) | lexp

lexp -> '\' apat_1 ... apat_n '->' exp // (lambda abstraction, n>=1) | 'let' decls 'in' exp // (let expression) | 'if' exp [';'] 'then' exp [';'] 'else' exp // (conditional) | 'case' exp 'of' '{' alts '}' // (case expression) | 'do' '{' stmts '}' // (do expression) | fexp
fexp -> [fexp] aexp // (function application)


aexp -> qvar // (variable) | gcon // (general constructor) | literal


gcon -> '()' | '[]' | '(,'{','}')' | qcon

var -> varid | '(' varsym ')' // (variable)
qvar -> qvarid | '(' qvarsym ')' // (qualified variable)
con -> varid | '(' varsym ')' // (constructor)
qcon -> qvarid | '(' gconsym ')' // (qualified constructor)
varop -> varsym | '`' varid '`' // (variable operator)
qvarop -> qvarsym | '`' qvarid '`' // (qualified variable operator)
conop -> varsym | '`' varid '`' // (constructor operator)
qconop -> gconsym | '`' qvarid '`' // (qualified constructor operator)
op -> varop | conop // (operator)
qop -> qvarop | qconop // (qualified operator)
gconsym -> ':' | qvarsym


fexp -> [fexp] aexp // (function application)
lexp -> '\' apat_1 ... apat_n '->' exp // (lambda abstraction, n>=1)


infixexp -> lexp qop infixexp | '-' infixexp // (prefix negation) | lexp
qop -> qvarop | qconop // (qualified operator)




lexp -> 'if' exp [';'] 'then' exp [';'] 'else' exp


infixexp -> exp_1 qop exp_2
aexp -> '[' exp_1 ',' ... ',' exp_k ']' // (k>=1) | gcon
gcon -> '[]' | qcon
qcon -> '(' gconsym ')'
qop -> qconop
qconop -> gconsym
gconsym -> ':'


aexp -> '(' exp_1 ',' ... ',' exp_k ')' // (k>=2) | qcon
qcon -> '(,'{','}')'


aexp -> gcon | '(' exp ')'
gcon -> '()'


aexp -> '[' exp_1 [',' exp_2] '..' [exp_3] ']'


aexp -> '[' exp '|' qual_1 ',' ... ',' qual_n ']' // (list comprehension, n>=1)
qual -> pat '<-' exp // (generator) | 'let' decls // (local declaration) | exp // (boolean guard)


lexp -> 'let' decls 'in' exp


lexp -> 'case' exp 'of' '{' alts '}'
alts -> alt_1 ';' ... ';' alt_n // (n>=1)
alt -> pat '->' exp ['where' decls] | pat gdpat ['where' decls] | // (empty alternative)

gdpat -> guards '->' exp [ gdpat ]
guards -> '|' guard_1, ..., guard_n // (n>=1)
guard -> pat '<-' infixexp // (pattern guard) | 'let' decls // (local declaration) | infixexp // (boolean guard)


lexp -> 'do' '{' stmts '}' // (do expression)
stmts -> stmt_1 ... stmt_n exp [';'] // (n>=0)
stmt -> exp ';' | pat '<-' exp ';' | 'let' decls ';' | ';' // (empty statement)


aexp -> qvar


aexp -> qcon '{' fbind_1 ',' ... ',' fbind_n '}' // (labeled construction, n>=0)
fbind -> qvar '=' exp

aexp -> (aexp AND NOT qcon) '{' fbind_1 ',' ... ',' fbind_n '}' // (labeled update, n>=1)
exp -> exp '::' [context '=>'] type

pat -> lpat qconop pat // (infix constructor) | lpat

lpat -> apat | '-' (integer | float) // (negative literal) | gcon apat_1 ... apat_k // (arity gcon = k, k>=1)

apat -> var ['@' apat] // (as pattern) | gcon // (arity gcon = 0) | qcon '{' fpat_1 ',' ... ',' fpat_k '}' // (labeled pattern, k>=0) | literal | '_' // (wildcard) | '(' pat ')' // (parenthesized pattern) | '(' pat_1 ',' ... ',' pat_k ')' // (tuple pattern, k>=2) | '[' pat_1 ',' ... ',' pat_k ']' // (list pattern, k>=1) | '~' apat // (irrefutable pattern)

fpat -> qvar '=' pat


module -> 'module' modid [exports] 'where' body | body
body -> '{' impdecls ';' topdecls '}' | '{' impdecls '}' | '{' topdecls '}'

topdecls -> topdecl_1 ';' ... ';' topdecl_n // (n>=1)
topdecl -> 'type' simpletype '=' type | 'data' [context '=>'] simpletype ['=' constrs] [deriving] | 'newtype' [context '=>'] simpletype '=' newconstr [deriving] | 'class' [scontext '=>'] varid varid ['where' cdecls] | 'instance' [scontext '=>'] qvarid inst ['where' idecls] | 'default' '('type_1 ',' ... ',' type_n')' // \qquad (n>=0) | 'foreign' fdecl | decl

decls -> '{' decl_1 ';' ... ';' decl_n '}' // (n>=0)
decl -> gendecl | (funlhs | pat) rhs

cdecls -> '{' cdecl_1 ';' ... ';' cdecl_n '}' // (n>=0)
cdecl -> gendecl | (funlhs | var) rhs

idecls -> '{' idecl_1 ';' ... ';' idecl_n '}' // (n>=0)
idecl -> (funlhs | var) rhs | // (empty)

gendecl -> vars '::' [context '=>'] type // (type signature) | fixity [integer] ops // (fixity declaration) | // (empty declaration)

ops -> op_1 ',' ... ',' op_n // (n>=1)
vars -> var_1 ',' ... ',' var_n // (n>=1)
fixity -> 'infixl' | 'infixr' | 'infix'


type -> btype ['->' type] // (function type)

btype -> [btype] atype // (type application)

atype -> gtycon | varid | '(' type_1 ',' ... ',' type_k ')' // (tuple type, k>=2) | '[' type ']' // (list type) | '(' type ')' // (parenthesised constructor)

gtycon -> qvarid | '()' // (unit type) | '[]' // (list constructor) | '(->)' // (function constructor) | '(,'{','}')' // (tupling constructors)


context -> class | '(' class_1 ',' ... ',' class_n ')' // (n>=0)
class -> qvarid varid | qvarid '(' varid atype_1 ... atype_n ')' // (n>=1)
qvarid -> [ modid '.' ] varid
varid -> varid
varid -> varid


topdecl -> 'data' [context '=>'] simpletype ['=' constrs] [deriving]

simpletype -> varid tyvar_1 ... tyvar_k // (k>=0)

constrs -> constr_1 '|' ... '|' constr_n // (n>=1)
constr -> con ['!'] atype_1 ... ['!'] atype_k // (arity con = k, k>=0) | (btype | '!' atype) conop (btype | '!' atype) // (infix conop) | con '{' fielddecl_1 ',' ... ',' fielddecl_n '}' // (n>=0)
fielddecl -> vars '::' (type | '!' atype)

deriving -> 'deriving' (dclass | '('dclass_1',' ... ',' dclass_n')')// (n>=0)
dclass -> qvarid


topdecl -> 'type' simpletype '=' type
simpletype -> varid tyvar_1 ... tyvar_k // (k>=0)


topdecl -> 'newtype' [context '=>'] simpletype '=' newconstr [deriving]
newconstr -> con atype | con '{' var '::' type '}'
simpletype -> varid tyvar_1 ... tyvar_k // (k>=0)


topdecl -> 'class' [scontext '=>'] varid varid ['where' cdecls]
scontext -> simpleclass | '(' simpleclass_1 ',' ... ',' simpleclass_n ')' // (n>=0)
simpleclass -> qvarid varid
cdecls -> '{' cdecl_1 ';' ... ';' cdecl_n '}' // (n>=0)
cdecl -> gendecl | (funlhs | var) rhs


topdecl -> 'instance' [scontext '=>'] qvarid inst ['where' idecls]
inst -> gtycon | '(' gtycon tyvar_1 ... tyvar_k ')' // (k>=0, tyvars distinct) | '(' tyvar_1 ',' ... ',' tyvar_k ')' // (k>=2, tyvars distinct) | '[' varid ']' | '(' tyvar_1 '->' tyvar_2 ')' // (tyvar_1 and tyvar_2 distinct)
idecls -> '{' idecl_1 ';' ... ';' idecl_n '}' // (n>=0)
idecl -> (funlhs | var) rhs | // (empty)

topdecl -> 'default' '('type_1 ',' ... ',' type_n')' // (n>=0)


gendecl -> vars '::' [context '=>'] type
vars -> var_1 ',' ...',' var_n // (n>=1)


gendecl -> fixity [integer] ops
fixity -> 'infixl' | 'infixr' | 'infix'
ops -> op_1 ',' ... ',' op_n // (n>=1)
op -> varop | conop


decl -> (funlhs | pat) rhs

funlhs -> var apat { apat } | pat varop pat | '(' funlhs ')' apat { apat }

rhs -> '=' exp ['where' decls] | gdrhs ['where' decls]

gdrhs -> guards '=' exp [gdrhs]

guards -> '|' guard_1, ..., guard_n // (n>=1)

guard -> pat '<-' infixexp // (pattern guard) | 'let' decls // (local declaration) | infixexp // (boolean guard)

