OS calls:

clock_gettime : clockid_t -> Op timespec
adjtimex : TimeX -> Modes -> Op (ClockState,timex)
ntp_gettimex : Op (ClockState, ntptimeval)

timespec = {seconds : time_t, nanoseconds : long}
clockid_t = {Realtime, Monotonic, ProcessCPUTime, ThreadCPUTime}
micronano = if STA_NANO then nanoseconds else microseconds
timeval = { seconds : time_t, tv_usec : micronano }
ClockState = {Synchronized,WillInsertLeapSecond,WillDeleteLeapSecond,LeapSecondInProgress,LeapSecondOccurred,Bad}
timex =
  { time_offset : long*micronano
  , freq_offset : long*2^-16 ppm
  , maxerror :  long*microseconds
  , esterror :  long*microseconds
  , status : ClockStatus
  , constant : long
  , precision : long*microseconds
  , tolerance : long*2^-16 ppm
  , time : timeval
  , tick : long*microseconds
  , ppsfreq : long*2^-16 PPM
  , jitter : long*micronano
  , shift : int*seconds
  , stabil : long*2^-16 PPM
  , jitcnt : long
  , calcnt : long
  , stbcnt : long
  , tai : int*seconds
  }
ntptimeval = { time : timeval, maxerror : long, esterror : long, tai_offset : long }

POSIX specifies the realtime clock to be UTC seconds, via a straightforward formula assuming 86400 seconds per day and doing leaps as 59-0-0.
Adjtimex can determine if a leap second is occuring or will occur in the near future.

QueryPerformanceCounter : Op counts
GetSystemTimePreciseAsFileTime : Op FILETIME
GetSystemTime : Op SYSTEMTIME -- second can be 60 during a leap second if you opt in via a special flag PROCESS_LEAP_SECOND_INFO_FLAG_ENABLE_SIXTY_SECOND



counts = LARGE_INTEGER # represent time in units of 1 second/(the frequency of the performance counter obtained from QueryPerformanceFrequency)
FILETIME = { dwHighDateTime : DWORD, dwLowDateTime : DWORD } -- a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).
SYSTEMTIME = {
  Year : WORD,
  Month : WORD,
  DayOfWeek : WORD,
  Day : WORD,
  Hour : WORD,
  Minute : WORD,
  Second : WORD,
  Milliseconds : WORD,
}

Library types:

Instant = Duration -- monotonic time
SystemTime = timespec|FILETIME

functions:
get the current UTC time (including leap second), and time-zone of the system, which together form the date and time
round an instant to a specified tick frequency
durations of standard lengths (seconds, days, etc.)

values:
DayOfWeek - enumeration Monday through Sunday
Month - enumeration January through December

timedelta = { days : int, seconds : range i32 0 SECONDS_PER_DAY, microseconds : range i32 0 1e6 }
Duration = { nanoseconds : i96 }
Instant = Duration -- since 1970-01-01T00:00:00Z
EpochSecond = i64
date, LocalDate, GregorianDate = -- e.g. 2007-12-03. Leap days are calculated using ISO-8601 proleptic Gregorian calendar
  {year : i32, month : i16, day : i16}
  {daysSinceEpoch : i64 }
  { year : int, dayNumber : range 0 366 }
  { year : int, weekNumber : range 0 53, d : DayOfWeek }
Possible anchors:
* epoch 1970-01-01
* founding of the Gregorian calendar
* November 24, 4714 BC, Julian day numbers
* November 17, 1858 , Modified Julian day
LocalDateTime = (LocalDate, LocalTime)
LocalTime = { n : i56*nanoseconds | 0 <= n < NANOS_PER_DAY }
MonthDay = { (month, day) : (Month,i32) | 1 <= day <= maxLength month }. Can be stored as day numbers 0-365 with February 29th included.
OffsetDateTime = (LocalDateTime, ZoneOffset)
OffsetTime = (LocalTime, ZoneOffset)
time = { hour : range 0 24, minute : range 0 60, second : range 0 60, microsecond : range 0 1e6, fold : {0,1}, tzinfo }
datetime = (date, time)
relativedelta =
  { years: int, months: int, days: int -- relative information
  , hours: int, minutes:int , seconds:int, microseconds:int
  , weekday: {weekday : DayOfWeek, n : int}, leapdays: int
  , year: , month: , day: , hour: , minute: , second: , microsecond: -- Absolute information; REPLACES the corresponding value
  }
rrule =
  { dtstart : datetime
  , freq : {YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY}
  . interval: int
  , (count : int | until : datetime)
  , wkst : DayOfWeek
  , rules : Map {bysetpos, bymonth, bymonthday, byyearday, byweekno, byweekday, byhour, byminute, bysecond, byeaster} [int]
  }
Period = { years : i32, months : i32, days : i32 } -- weeks are 7 days
Year = { y : i32 | YEAR.checkValidValue(y) }
YearMonth = { (y : i32, m : i32) | YEAR.checkValidValue(y) && MONTH_OF_YEAR.checkValidValue(month) }
ZonedDateTime = (LocalDateTime, ZoneOffset, ZoneId) -- ZoneOffset disambiguates DST
ZoneId = ZoneOffset | ZoneRegion
ZoneOffset = {totalOffset : i32*seconds | abs totalOffset <= 18*hours}
timezone = { name : String|none, offset : timedelta | abs timedelta < 24*hours }
ZoneRegion = { id : String | lookupZoneRules id != NotFound }
ChronoLocalDateTimeImpl = (ChronoLocalDate, LocalTime)
ChronoPeriodImpl = { chrono : Symbol, p : Period }
ChronoZonedDateTimeImpl = (ChronoLocalDateTimeImpl, ZoneOffset, ZoneId)
HijrahDate = {prolepticYear : i32, monthOfYear : i32, dayOfMonth : i32}
HijrahEra = enum {AH}
IsoEra = enum {BCE,CE}
JapaneseDate = { isoDate : LocalDate, era : JapaneseEra, yearOfEra : i32 }
  { era : JapaneseEra, yearOfEra : i32, month : i32, dayOfMonth : i32 }
  {prolepticYear : i32, monthOfYear : i32, dayOfMonth : i32}
  { era : JapaneseEra, yearOfEra : i32, dayOfYear : i32 }
  { isoDate : LocalDate }
    era = JapaneseEra.toJapaneseEra(jdate.getEra());
    yearOfEra = jdate.getYear();
JapaneseEra = {eraValue : JapaneseEra -> i32, -- index, from -2 to 3
  since : JapaneseEra -> LocalDate } -- the first day of the era
  }
{Meiji, Taisho, Showa, Heisei, Reiwa} subseteq JapaneseEra
MinguoDate = { isoDate : LocalDate }
MinguoEra = enum { Before_ROC, ROC }
ThaiBuddhistDate = { isoDate : LocalDate }
ThaiBuddhistEra = enum { Before_BE, BE }

DateTimeFormatterBuilder =
  { active : mut DateTimeFormatterBuilder
  , parent : DateTimeFormatterBuilder|null
  , printerParsers : ArrayList DateTimePrinterParser
  , optional : boolean
  , padNextWidth : mut i32
  , padNextChar : mut String
  , valueParserIndex : mut i32 }
DateTimeFormatter =
  { printerParser : CompositePrinterParser
  , locale : Locale
  , decimalStyle : DecimalStyle
  , resolverStyle : ResolverStyle
  , resolverFields : Set TemporalField
  , chrono : Chronology
  , Zone : ZoneId
  }
toFormatter : DateTimeFormatterBuilder -> DateTimeFormatter
DateTimePrinterParser =
  { format : DateTimePrintContext -> StringBuilder -> Boolean
  , parse : DateTimeParseContext -> CharSequence -> (position : i32) -> i32
  }
DateTimeParseContext =
  { formatter : { locale : Locale, decimalStyle : DecimalStyle }
  , caseSensitive : boolean
  , strict : boolean
  , parsed : ArrayList Parsed
  , chronoListeners : ArrayList (Consumer Chronology)
  }
DateTimePrintContext =
  { temporal : TemporalAccessor
  , formatter : { locale : Locale, decimalStyle : DecimalStyle, chrono : Chronology, zone : ZoneId }
  , optional : i32 }
DayPeriod = -- https://www.unicode.org/reports/tr35/tr35-dates.html#dayPeriods
  { from : i64 -- in minute-of-day
  , to : i64 -- in minute-of-day
  , index : DayPeriodIndex -- day period type index
  }
DayPeriodIndex = {am, pm, midnight, noon, morning1, morning2, afternoon1, afternoon2, evening1, evening2, night1, night2}
FormatStyle = enum { Full, Long, Medium, Short }
Parsed =
  { fieldValues : HashMap<TemporalField, Long>
  , zone : ZoneId|null
  , chrono : Chronology
  , leapSecond : boolean
  , dayPeriod : DayPeriod
  }
ParsedResolved =
  { resolverStyle : ResolverStyle
  , date : ChronoLocalDate
  , time : LocalTime
  , excessDays : Period
  }
ResolverStyle = enum {Strict, Smart, Lenient}
 -- strict: reject invalid values
 -- smart: day-of-month 32 is clipped to day 30 or 31
 -- lenient: month 15 is treated as being 3 months after month 12.
SignStyle = enum {Normal, Always, Never, Not_Negative, Exceeds_Pad}
 -- Normal: -1, 2
 -- Always: -1, +2
 -- Never: 1, 2
 -- Not_Negative: exception, 2
 -- Exceeds_Pad: Normal but output the sign if the value exceeds the pad width.
 -- In lenient parsing, any sign will be accepted unless the width is fixed,
 -- with the absence of a sign treated as a positive number.
TextStyle = enum {Full, Full_Standalone, Short, Short_Standalone, Narrow, Narrow_Standalone}
 -- standalone does not apply to English, but in other languages you have "MarchX" and "MarchY 2, 2003"

TemporalUnit = {Nano, Micro, Milli, Second, Minute, Hour, Half_Day, Day, Week, Month, Quarter, Year, Decade, Century, Millennium, Era, AllTime}
ChronoField =
  Of { baseUnit : TemporalUnit, rangeUnit : TemporalUnit | baseUnit < rangeUnit }
  | JulianDate | ModifiedJulianDate | RataDie | WeekBasedYear_Week | WeekBasedYear_Year
range : ChronoField -> ValueRange
duration : TemporalUnit -> (min : Duration, max : Duration) -- minutes can very due to leap seconds. there is also DST, irregular month lengths, etc. The range is conservative.

All of the TemporalUnit fields are 0-indexed.
Hour, Day, Week, Month are normally 1-indexed - use wrappers if you need this.
Week-based year - year starts on a Monday
without year, day 0 must be defined. JD, MJD, Rata die

ValueRange = { minSmallest : i64, maxSmallest : i64, minLargest : i64, maxLargest : i64
  | minSmallest <= minLargest <= maxLargest && minSmallest <= maxSmallest <= maxLargest }
 -- all values are within [minSmallest, maxLargest], but values outside of [minLargest, maxSmallest] may be invalid
 -- if minLargest > maxSmallest then all values must be checked

WeekFields = { firstDayOfWeek : DayOfWeek, minimalDaysInFirstWeek : i32}
  -- first day-of-week defines the ISO {@code DayOfWeek} that is day 1 of the week.
  -- minimal number of days in the first week defines how many days must be present
  -- in a month or year, starting from the first day-of-week, before the week is counted
  -- as the first week. A value of 1 will count the first day of the month or year as part
  -- of the first week, whereas a value of 7 will require the whole seven days to be in
  -- the new month or year.


TzdbZoneRulesProvider = { regionIds : [String], versionId : String, regionToRule : Map String ZoneRules }
ZoneOffsetTransition =
  { epochSecond : EpochSecond
  , offsetBefore : ZoneOffset
  , offsetAfter : ZoneOffset
  }
transition : ZoneOffsetTransition -> LocalDateTime
transition = LocalDateTime.ofEpochSecond(epochSecond, 0, offsetBefore)

TimeDefinition = enum { UTC, Wall, Standard } -- transition relative to offsets in X
ZoneOffsetTransitionRule =
  { month : Month, dayOfMonth : i8, dow : DayOfWeek, time : LocalTime, timeEndOfDay : boolean
  , timeDefinition : TimeDefinition, standardOffset : ZoneOffset
  , offsetBefore : ZoneOffset
  , offsetAfter : ZoneOffset
  }
ZoneRules =
  { standardTransitions : [EpochSecond]
  , standardOffsets : [ZoneOffset] | length standardOffsets = length standardTransitions + 1
  , savingsLocalTransitions : [LocalDateTime] | length savingsLocalTransitions = length wallOffsets * 2
  , wallOffsets : [ZoneOffset]
  , savingsInstantTransitions : [i64] | length savingsInstantTransitions = length wallOffsets
  , lastRules : [ZoneOffsetTransitionRule]
  }


NTPTimestamp = { seconds : u32, fraction: u32 } -- wrapping
NTPShort = { seconds : u16, fraction: u16 } -- wrapping

DTT+TAI+32.184 = TT


Arithmetic overflows in calendars should throw exceptions


The zoneinfo module provides a concrete time zone implementation to support the IANA time zone database as originally specified in PEP 615. By default, zoneinfo uses the system’s time zone data if available; if no system time zone data is available, the library will fall back to using the first-party tzdata package available on PyPI.

Time standards

We assume the observer has some knowledge of a proper time, tau (real number).
A timescale T is a one-to-one function of the proper time.

Timescales:
TT = (SI second)
TAI = (SI second)
TCG = (SI second)
TCB = (SI second)
TDB = (SI second)
UT1 = (angular HMS seconds)
ERA = (radians)
Apparent solar time = (angular HMS seconds)
Day fraction = (date : Date, fraction of day : range_real 0 1, day_start : date -> proper_time one-to-one)
UTC = (date : Date, time : TimeWithLeapSeconds)
UTC offsets UTC±[hh]:[mm]
  (date : Date, time : TimeWithLeapSeconds, offset : { hours : range_exclusive -24 24, minutes : range 0 60}) -- date/time is offset by offset
Civil time
  (date : Date, time : TimeWithLeapSeconds, zone : TimeZone, in_dst : {0,1}) -- date/time + in_dst is offset by zone offset w.r.t. date/time



Dates:
Gregorian calendar (year : int, month : range_inclusive 1 12, day : range_inclusive 1 31)
Julian Day number

Time = { hours : range 0 24, minutes : range 0 60, seconds : range_real 0 60 }
TimeWithLeapSeconds =
  Time { seconds : range_real 0 61 } -- for times after 1972
  { time : Time, in_leap_second : bool } -- for times after 1972
  { time : Time, tai_offset : real } -- real to accommodate fractional offsets before 1972
NTPDateTime = { seconds : i64, fraction: u64, tai_offset : int }
eraNumber (n : NTPDate)  = interpret_bits i32 seconds[bits 0:32]
eraOffset (n : NTPDate)  = interpret_bits u32 seconds[bits 32:64]



The UTC rounding means it is not strictly increasing: multiple UT1 instants 58-59-60 will map to the same number of seconds 59-59-0 or 59-0-0. To address this the instant can be marked as occuring during a positive leap second, 59-0!-0. A negative leap second goes 59 - 01 and does not introduce an aliasing problem.


UT1 and TAI are better for calculating long durations (days) as they are strictly increasing. But if you want UT1 or TAI you will have to calculate them, via converting from UTC or over the network. NTP errors can be between 2ms-100ms depending on connectivity. UTC is within 1s of UT1, and can be made better with a lookup table. TAI you just need a leap second table, and if the offset isn't important then just wait 1s until the time is definitely not a leap second.

For measuring short durations the system monotonic clock is best,


(because the clock can be reset), while clock_gettime(CLOCK_MONOTONIC,...) gives you a slowly changing error which cannot tell you the date but is more appropriate for measuring intervals in time.

UTC is UT1 rounded to an integer offset plus TAI so that Abs(UT1-UTC)<0.9. Obtained from NTP servers by OS's with a precision 2-100ms. Practically limited to an accuracy of 5ns-20ns by uncertainties and drift between atomic clocks, but defined accurate to measurement.
TAI is an average of atomic clocks. It can be calculated from UTC from the leap second table in the timezone database and observation of the NTP leap second flag.
Julian day number is a count of days elapsed since Greenwich mean noon on 1 January 4713 B.C., Julian proleptic calendar. The Julian Date is the Julian day number followed by the fraction of the day elapsed since the preceding noon. Modified Julian day (MJD) is defined as MJD = JD - 2400000.5. An MJD day thus begins at midnight, civil date. Julian dates can be expressed in UTC, UT1, TAI, etc. and so for precise applications the timescale should be specified, e.g. MJD 49135.3824 TAI.
Civil time is UTC plus an hour offset (summer or winter). Can be calculated using the timezone database.
Geocentric Coordinate Time (TCG) is a linear scaling of TT
Barycentric Coordinate Time (TCB) is a nonlinear transformation of TCG, dependent on observer location
Barycentric Dynamical Time (TDB) is a linear transformation of TCB
Sidereal time or Earth rotation angle (ERA) is a linear polynomial of Julian UT1 day number
Terrestrial Time (TT) is TAI offset by 32.184 and revised for accuracy. Can be linearly interpolated from TAI values to accuracy of 1ns using the TT(BIPM) tables in 44 kB text files and extrapolated via a formula in the file to accuracy of within 8 nanoseconds.
Mean solar time (UT1) is the rotation angle of the Earth as measured by various stars and radio sources corrected for location and smoothed. One mean solar revolution is 86400 UT1 seconds. Can be calculated as UTC+DUT1. DUT1 is available from https://datacenter.iers.org/eop.php to a precision of 0.05 ms daily, interpolated via an accurate IERS formula from https://hpiers.obspm.fr/iers/models/, and extrapolated to an estimated error of 25ms s at one year. The files are 3.3 MB CSV's.
Apparent solar time: solar days plus fraction of that solar day. Calculated as UT1+equation of time+local offset. The best formula for EOT on Wikipedia is accurate to 3 seconds.

