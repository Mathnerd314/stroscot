

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Reduction &mdash; Stroscot  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Types" href="Types.html" />
    <link rel="prev" title="Metaprogramming" href="Fexprs.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Stroscot
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Syntax.html">Syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="Overloading.html">Overloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="Verification.html">Verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arguments.html">Argument passing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Delimited-Continuations.html">Delimited continuations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fexprs.html">Metaprogramming</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Reduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#core">Core</a></li>
<li class="toctree-l2"><a class="reference internal" href="#syntax">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nets">Nets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cut-elimination">Cut elimination</a></li>
<li class="toctree-l2"><a class="reference internal" href="#optimal-reduction">Optimal reduction</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#random-old-junk">Random old junk</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#linear-logic">Linear logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recursion">Recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">Optimal reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementation">Implementation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#readback">Readback</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Types.html">Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="Memory.html">Memory management</a></li>
<li class="toctree-l1"><a class="reference internal" href="Compiler.html">Compiler design</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildSystem.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="zzreferences.html">References</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Stroscot</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Reduction</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/Mathnerd314/stroscot/edit/master/docs/Reduction.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="reduction">
<h1>Reduction<a class="headerlink" href="#reduction" title="Permalink to this headline">¶</a></h1>
<div class="section" id="core">
<h2>Core<a class="headerlink" href="#core" title="Permalink to this headline">¶</a></h2>
<p>Stroscot takes after Haskell in that all of the language is compiled to a smallish core language. Considerations:</p>
<ul class="simple">
<li><p>Based on <a class="bibtex reference internal" href="zzreferences.html#downensequentcalculuscompiler2016a" id="id1">[DMAPJ16]</a>, we use the full two-sided sequent calculus with cuts instead of an intuitionistic or one-sided calculus.</p></li>
<li><p>Based on optimal reduction, mostly <a class="bibtex reference internal" href="zzreferences.html#guerrinitheoreticalpracticalissues1996" id="id2">[Gue96]</a>, we use linear logic sequents, with operators for contraction (duplication) and weakening (erasing).</p></li>
<li><p>Based on <a class="bibtex reference internal" href="zzreferences.html#levyjumbolcalculus2006" id="id3">[Lev06]</a>, we aim for the largest allowable set of operators. In particular we generalize all of the different operators into two jumbo operators, sigma and pi. <span class="math notranslate nohighlight">\(\Sigma\)</span> contains LL’s synchronous/positive operators 0, 1, plus ⊕, and times ⊗. <span class="math notranslate nohighlight">\(\Pi\)</span> contains LL’s lollipop implication ⊸ and asynchronous/negative operators top ⊤, bottom ⊥, with &amp;, and par ⅋.</p></li>
</ul>
<p>We start with the generalized <span class="math notranslate nohighlight">\(\Pi\)</span> rule. This is similar to Levy’s rule except it allows multiple conclusions. We have indexed variables <span class="math notranslate nohighlight">\(A_{ij}\)</span> and <span class="math notranslate nohighlight">\(B_{ik}\)</span> where <span class="math notranslate nohighlight">\(0 \leq i &lt; N, 0 \leq j &lt; m_i, 0 \leq k &lt; n_i\)</span>. We call <span class="math notranslate nohighlight">\(N\)</span> the length of the jumbo type and the list <span class="math notranslate nohighlight">\((m_i,n_i)\)</span> the jumbo-arity.</p>
<div class="math notranslate nohighlight">
\[\newcommand{\rule}[3]{ \dfrac{\displaystyle ~~#1~~ }{\displaystyle ~~#2~~ } \  (#3)}
\begin{array}{cc}
\rule{\overrightarrow{ \Gamma, \overrightarrow{A_{i j}} \vdash \overrightarrow{B_{i k}}, \Delta }}
  {\Gamma \vdash \prod \limits_{i} \left(\overrightarrow{A_i} \multimap \overrightarrow{B_i}\right), \Delta }
  {\Pi_R}
&amp;
\rule{\overrightarrow{ \Gamma_j \vdash A_{i j}, \Delta_j } \quad \overrightarrow{ \Theta_k, B_{i k} \vdash \Lambda_k }}
  {\overrightarrow{\Gamma}, \vec \Theta, \prod \limits_{i} \left(\overrightarrow{A_i} \multimap \overrightarrow{B_i}\right) \vdash \overrightarrow{\Delta}, \vec\Lambda}
  {\Pi_{i} {}_{L}}
\end{array}\]</div>
<p>Next we have the generalized <span class="math notranslate nohighlight">\(\Sigma\)</span> rule. This allows premises as well. Following <a class="bibtex reference internal" href="zzreferences.html#wadlercallbyvaluedualcallbyname2003" id="id4">[Wad03]</a> <a class="bibtex reference internal" href="zzreferences.html#crolardformulaeastypesinterpretationsubtractive2004" id="id5">[Cro04]</a> the dual of implication is called “subtraction” or “difference” and is denoted <span class="math notranslate nohighlight">\(-\)</span>. For normal ADTs, the RHS of the difference is empty, i.e. it looks like <span class="math notranslate nohighlight">\(A - []\)</span>. Ideally the difference operator allows creating zippers, or maybe it is useless.</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cc}
\rule{\overrightarrow{ \Gamma_k, B_{i k} \vdash \Delta_k } \quad \overrightarrow{ \Theta_j \vdash A_{i j}, \Lambda_j } }
  {\overrightarrow{\Gamma}, \overrightarrow{\Theta} \vdash \sum \limits_{i} \left( \overrightarrow{A_i} - \overrightarrow{B_i} \right), \overrightarrow{\Delta}, \overrightarrow{\Lambda}}
  {\Sigma_{i} {}_{R}}
&amp;
\rule{\overrightarrow{ \Gamma, \overrightarrow{A_{i j}} \vdash \overrightarrow{B_{i k}}, \Delta } }
  {\Gamma, \sum \limits_{i} \left ( \overrightarrow{A_i} - \overrightarrow{B_i} \right ) \vdash \Delta }
  {\Sigma_L}
\end{array}\]</div>
<p>To allow/restrict contraction and weakening we have two S4 modalities, bang/!/”of course” and whim/whimper/?/”why not”. A call-by-value function type is <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-o</span> <span class="pre">?B</span></code> while call-by-name is <code class="docutils literal notranslate"><span class="pre">!A</span> <span class="pre">-o</span> <span class="pre">B</span></code>. To enforce the S4 rules we add a level index to every term, as in <a class="bibtex reference internal" href="zzreferences.html#martinifinestructureexponential1995" id="id6">[MM95]</a> and <a class="bibtex reference internal" href="zzreferences.html#guerrinitheoreticalpracticalissues1996" id="id7">[Gue96]</a>. The level of a context is the maximum of the levels of its terms (0 if empty). As a notational convention, the indices are omitted when they are all the same, i.e. in all the rules besides promotion and dereliction. Normally promotion has <span class="math notranslate nohighlight">\(j=i+1\)</span> instead of <span class="math notranslate nohighlight">\(j&gt;i\)</span>, shrug.</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cccc}
  \rule{\Gamma^i \vdash A^j, \Delta^i }{\Gamma^i \vdash !A^i, \Delta^i}{!}_{j &gt; i}
  &amp; \rule{\Gamma^i, A^i \vdash \Delta^i }{\Gamma^i, !A^j \vdash \Delta^i}{!d}_{i\leq j}
  &amp; \rule{\Gamma, !A, !A \vdash \Delta }{\Gamma, !A \vdash \Delta}{!c}
  &amp; \rule{\Gamma \vdash \Delta }{\Gamma, !A \vdash \Delta}{!w}
\end{array}\]</div>
<div class="math notranslate nohighlight">
\[\begin{array}{cccc}
  \rule{\Gamma^i, A^j \vdash \Delta^i }{\Gamma^i, ?A^i \vdash \Delta^i}{?}_{j &gt; i}
  &amp; \rule{\Gamma^i \vdash A^i, \Delta^i }{\Gamma^i \vdash ?A^j, \Delta^i}{?d}_{i\leq j}
  &amp; \rule{\Gamma \vdash ?A, ?A, \Delta }{\Gamma \vdash ?A, \Delta}{?c}
  &amp; \rule{\Gamma \vdash \Delta }{\Gamma \vdash ?A, \Delta}{?w}
\end{array}\]</div>
<p>To handle level mismatches we might also need lifting operators. The conditions are unclear.</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cc}
  \rule{\Gamma^i \vdash A^j, \Delta^i }{\Gamma^i \vdash A^i, \Delta^i}{\text{lift}_R}_{j &gt; i}
  &amp;
  \rule{\Gamma^i, A^j \vdash \Delta^i }{\Gamma^i, A^i \vdash \Delta^i}{\text{lift}_L}_{j &gt; i}
\end{array}\]</div>
<p>There are also quantifier rules, probably unnecessary but I’ll write them down for reference. For these <span class="math notranslate nohighlight">\(x\)</span> must have no free occurrence in <span class="math notranslate nohighlight">\(\Gamma\)</span> or <span class="math notranslate nohighlight">\(\Delta\)</span>, while <span class="math notranslate nohighlight">\(y\)</span> may occur. <span class="math notranslate nohighlight">\(A[t/x]\)</span> stands for the formula <span class="math notranslate nohighlight">\(A\)</span> where all free occurrences of the variable <span class="math notranslate nohighlight">\(x\)</span> have been replaced by the formula/term <span class="math notranslate nohighlight">\(t\)</span> (and bound variables have been renamed when necessary).</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cccc}
  \rule{\Gamma \vdash A, \Delta}{\Gamma \vdash \forall x. A, \Delta}{\forall_R}
  &amp;
  \rule{\Gamma, A[t/x] \vdash \Delta}{\Gamma, \forall x. A \vdash \Delta}{\forall_L}
  &amp;
  \rule{\Gamma \vdash A[t/x], \Delta}{\Gamma \vdash \exists x. A, \Delta}{\exists_R}
  &amp;
  \rule{\Gamma, A \vdash \Delta}{\Gamma, \exists x. A \vdash \Delta}{\exists_L}
\end{array}\]</div>
<p>Finally we have the structural rules. Exchange isn’t necessary because we assume multisets of formulas.</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cccc}
  \rule{}{A \vdash A}{\text{id}}
  &amp;
  \rule{\Gamma \vdash A, \Delta \quad \Theta, A \vdash \Lambda }{\Gamma, \Theta \vdash \Delta, \Lambda }{\text{cut}}
  &amp;
  \rule{\Gamma \vdash \Delta, A, B, \Theta}{\Gamma \vdash \Delta, B, A, \Theta}{\text{x}_R}
  &amp;
  \rule{\Gamma, A, B, \Delta \vdash \Theta}{\Gamma, B, A, \Delta \vdash \Theta}{\text{x}_L}
\end{array}\]</div>
<p>So in the end our propositions can be:</p>
<ul class="simple">
<li><p>A variable in the context</p></li>
<li><p>Pi / Sigma</p></li>
<li><p>A bang !A or whim ?A</p></li>
<li><p>A forall or exists type, where the proposition is in the context extended by the variable</p></li>
</ul>
</div>
<div class="section" id="syntax">
<h2>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h2>
<p>Since proofs are programs by the Curry-Howard correspondence, we can use the rules as a programming language. But we need a syntax for it, since writing sequents all the time is tedious. The simplest, most explicit syntax enumerates the free variables (context/signature) of each sequent, all propositions, and all subderivations, for example <code class="docutils literal notranslate"><span class="pre">Bang</span> <span class="pre">context</span> <span class="pre">Gamma</span> <span class="pre">Delta</span> <span class="pre">A</span> <span class="pre">subderivation</span></code>. But we can slim this down:</p>
<ul class="simple">
<li><p>The signature can be reconstructed by finding the free variables of the cedents (antecedent/succedent). We still need to add a type signature to each variable.</p></li>
<li><p>The level indices can be recovered by a constraint solving (in particular a topological sort)</p></li>
<li><p>The identified elements can be identified by variable names. Each variable occurs exactly twice. For identifying elements in the hypotheses we simple use the name, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code>. For the conclusion, almost all the formulas have a single identified element in the conclusion, so we can use <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">...</span></code> to identify it. For identity we assign names to both left and right, <code class="docutils literal notranslate"><span class="pre">xl/xr</span> <span class="pre">=</span> <span class="pre">...</span></code>.</p></li>
<li><p>Gamma, delta, theta, and lambda can be inferred in most cases by taking the subderivations and removing the identified elements. Since they are unchanged we do not need to rename the variables. For PiRight/SigmaLeft we do need to rename and combine gamma/delta from each case (similar to a phi-node).</p></li>
<li><p>Weakening and identity need a type argument <code class="docutils literal notranslate"><span class="pre">T</span></code> so we know the type of what’s being introduced. Similarly the absurdity cases of PiRight/SigmaLeft (0 and top) need type annotations on Gamma/Delta. (But these can often be omitted/inferred like any other type signatures)</p></li>
<li><p>For tags we use <code class="docutils literal notranslate"><span class="pre">^i</span></code>, because Levy’s notation <code class="docutils literal notranslate"><span class="pre">#i</span></code> is interpreted as a comment</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">/</span><span class="p">[</span><span class="n">Gamma_m</span><span class="p">]</span><span class="o">/</span><span class="p">[</span><span class="n">Delta_n</span><span class="p">]</span> <span class="o">=</span> <span class="n">PiRight</span>
  <span class="p">{</span><span class="o">^</span><span class="n">i</span><span class="p">,</span> <span class="p">[</span><span class="n">A_ij</span><span class="p">],[</span><span class="n">B_ik</span><span class="p">],[</span><span class="n">Gamma_mi</span><span class="p">],[</span><span class="n">Delta_ni</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">subderivation_i</span> <span class="p">}</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">PiLeft</span> <span class="o">^</span><span class="n">i</span> <span class="p">[(</span><span class="n">Ai_j</span><span class="p">,</span><span class="n">left_subderivation_j</span><span class="p">)]</span> <span class="p">[(</span><span class="n">Bi_k</span><span class="p">,</span><span class="n">right_subderivation_k</span><span class="p">)]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">SigmaRight</span> <span class="o">^</span><span class="n">i</span> <span class="p">[(</span><span class="n">Bi_k</span><span class="p">,</span><span class="n">left_subderivation_k</span><span class="p">)]</span> <span class="p">[(</span><span class="n">Ai_j</span><span class="p">,</span><span class="n">right_subderivation_k</span><span class="p">)]</span>
<span class="n">x</span><span class="o">/</span><span class="p">[</span><span class="n">Gamma_m</span><span class="p">]</span><span class="o">/</span><span class="p">[</span><span class="n">Delta_n</span><span class="p">]</span> <span class="o">=</span> <span class="n">SigmaLeft</span>
  <span class="p">{</span><span class="o">^</span><span class="n">i</span><span class="p">,</span> <span class="p">[</span><span class="n">A_ij</span><span class="p">],[</span><span class="n">B_ik</span><span class="p">],[</span><span class="n">Gamma_mi</span><span class="p">],[</span><span class="n">Delta_ni</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">subderivation_i</span> <span class="p">}</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Bang</span> <span class="n">A</span> <span class="n">subderivation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">BangD</span> <span class="n">A</span> <span class="n">subderivation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">BangC</span> <span class="n">A</span> <span class="n">A</span> <span class="n">subderivation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">BangW</span> <span class="n">subderivation</span> <span class="p">:</span> <span class="n">T</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Whim</span> <span class="n">A</span> <span class="n">subderivation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">WhimD</span> <span class="n">A</span> <span class="n">subderivation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">WhimC</span> <span class="n">A</span> <span class="n">A</span> <span class="n">subderivation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">WhimW</span> <span class="n">subderivation</span> <span class="p">:</span> <span class="n">T</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">LiftRight</span> <span class="n">A</span> <span class="n">subderivation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">LiftLeft</span> <span class="n">A</span> <span class="n">subderivation</span>
<span class="n">l</span><span class="o">/</span><span class="n">r</span> <span class="o">=</span> <span class="n">Identity</span> <span class="p">:</span> <span class="n">T</span>
<span class="n">Cut</span> <span class="n">Al</span> <span class="n">Ar</span> <span class="n">subderivation_left</span> <span class="n">subderivation_right</span>
</pre></div>
</div>
</div>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>So let’s look at a simple program, boolean “and”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ow">and</span> <span class="o">=</span> \<span class="n">x</span> <span class="o">-&gt;</span> <span class="n">case</span> <span class="n">x</span> <span class="n">of</span> <span class="p">{</span> <span class="kc">False</span> <span class="o">-&gt;</span> \<span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">False</span><span class="p">;</span> <span class="kc">True</span> <span class="o">-&gt;</span> \<span class="n">y</span> <span class="o">-&gt;</span> <span class="n">y</span> <span class="p">}</span>
<span class="ow">and</span> <span class="kc">False</span> <span class="kc">True</span> <span class="p">:</span> <span class="n">Bool</span>
</pre></div>
</div>
<p>We define the types <span class="math notranslate nohighlight">\(\text{B} = \Sigma [(F,[],[]),(T,[],[])]\)</span> and <span class="math notranslate nohighlight">\(a \to b = \Pi [(\text{func}, [a], [b])]\)</span>. <span class="math notranslate nohighlight">\(\to\)</span> is right associative as usual. Our program then has the following derivation tree, among others (we could add a bang to the first argument, use a multiple-argument function, expand out the identity, etc.).</p>
<img alt="_images/Stroscot_AND_Proof_Tree.svg" src="_images/Stroscot_AND_Proof_Tree.svg" /><p>Next is Core. We start with the rules, then assign variable names (alphabetically), then fill in the arguments, to obtain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># free variable pr : Bool</span>
<span class="n">Cut</span> <span class="n">a</span> <span class="n">n</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">Bang</span> <span class="n">b</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">SigmaRight</span> <span class="o">^</span><span class="kc">True</span> <span class="p">[]</span> <span class="p">[])</span>
  <span class="n">Cut</span> <span class="n">lr</span> <span class="n">m</span>
    <span class="n">Cut</span> <span class="n">c</span> <span class="n">k</span>
      <span class="n">c</span> <span class="o">=</span> <span class="n">SigmaRight</span> <span class="o">^</span><span class="kc">False</span> <span class="p">[]</span> <span class="p">[]</span>
      <span class="n">Cut</span> <span class="n">d</span> <span class="n">j</span>
        <span class="n">d</span><span class="o">/</span><span class="p">[]</span><span class="o">/</span><span class="p">[]</span> <span class="o">=</span> <span class="n">PiRight</span> <span class="p">{</span> <span class="o">^</span><span class="n">func</span><span class="p">,</span> <span class="p">[</span><span class="n">e</span><span class="p">],</span> <span class="p">[</span><span class="n">f</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[]</span> <span class="o">-&gt;</span>
          <span class="n">e</span><span class="o">/</span><span class="p">[]</span><span class="o">/</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">SigmaLeft</span> <span class="p">{</span>
            <span class="o">^</span><span class="kc">False</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[</span><span class="n">f1</span><span class="p">]</span> <span class="o">-&gt;</span>
              <span class="n">f1</span><span class="o">/</span><span class="p">[]</span><span class="o">/</span><span class="p">[]</span> <span class="o">=</span> <span class="n">PiRight</span> <span class="p">{</span> <span class="o">^</span><span class="n">func</span><span class="p">,</span> <span class="p">[</span><span class="n">g1</span><span class="p">],</span> <span class="p">[</span><span class="n">h1</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[]</span> <span class="o">-&gt;</span>
                <span class="n">g1</span> <span class="o">=</span> <span class="n">BangW</span> <span class="p">(</span><span class="n">h1</span> <span class="o">=</span> <span class="n">SigmaRight</span> <span class="o">^</span><span class="kc">False</span> <span class="p">[]</span> <span class="p">[])</span>
              <span class="p">}</span>
            <span class="o">^</span><span class="kc">True</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[</span><span class="n">f2</span><span class="p">]</span> <span class="o">-&gt;</span>
              <span class="n">f2</span><span class="o">/</span><span class="p">[]</span><span class="o">/</span><span class="p">[]</span> <span class="o">=</span> <span class="n">PiRight</span> <span class="p">{</span> <span class="o">^</span><span class="n">func</span><span class="p">,</span> <span class="p">[</span><span class="n">g2</span><span class="p">],</span> <span class="p">[</span><span class="n">h2r</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[]</span> <span class="o">-&gt;</span>
                <span class="n">g2</span> <span class="o">=</span> <span class="n">BangD</span> <span class="n">h2</span> <span class="p">(</span><span class="n">h2</span><span class="o">/</span><span class="n">h2r</span> <span class="o">=</span> <span class="n">Identity</span> <span class="n">Bool</span><span class="p">)</span>
              <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">PiLeft</span> <span class="o">^</span><span class="n">func</span> <span class="p">[(</span><span class="n">kr</span><span class="p">,</span> <span class="n">k</span><span class="o">/</span><span class="n">kr</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">)]</span> <span class="p">[(</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span><span class="o">/</span><span class="n">lr</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">)]</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">PiLeft</span> <span class="o">^</span><span class="n">func</span> <span class="p">[(</span><span class="n">nr</span><span class="p">,</span> <span class="n">n</span><span class="o">/</span><span class="n">nr</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">)]</span> <span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">/</span><span class="n">pr</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="section" id="nets">
<h2>Nets<a class="headerlink" href="#nets" title="Permalink to this headline">¶</a></h2>
<p>As a description the syntax is fine, but it suffers from what Girard calls “the bureaucracy of syntax”. For example the cuts <code class="docutils literal notranslate"><span class="pre">Cut</span> <span class="pre">a</span> <span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">Cut</span> <span class="pre">lr</span> <span class="pre">m</span></code> and the associated <code class="docutils literal notranslate"><span class="pre">a</span></code>/<code class="docutils literal notranslate"><span class="pre">m</span></code> can be swapped without changing the meaning. In fact, for computation, we do not need the syntactic subderivation inclusion relationship at all, only the variables. Furthermore, since each variable appears exactly twice, we can replace all the rule instances with nodes and variables with connecting edges. We thus obtain a graph, similar to a proof net / interaction net:</p>
<div class="graphviz"><img src="_images/graphviz-2b42685f1955f8ffe87a09f0e25f70237e7cb5b1.png" alt="digraph {
Root -&gt; c1 [style=invis]
c1 -&gt; c2 [style=invis]
c2 -&gt; c3 [style=invis]
c3 -&gt; c4 [style=invis]

Root -&gt; p /* pr */ [color=&quot;red&quot;]
c1 [label=&quot;Cut&quot;]
c1 -&gt; a [color=&quot;red&quot;]
c1 -&gt; n [color=&quot;blue&quot;]
a [label=&quot;!&quot;]
a -&gt; b [color=&quot;red&quot;]
b [label=&quot;True&quot;]
c2 [label=&quot;Cut&quot;]
c2 -&gt; l /* lr */ [color=&quot;red&quot;]
c2 -&gt; m [color=&quot;blue&quot;]
c3 [label=&quot;Cut&quot;]
c3 -&gt; c [color=&quot;red&quot;]
c3 -&gt; k [color=&quot;blue&quot;]
c [label=&quot;False&quot;]
c4 [label=&quot;Cut&quot;]
c4 -&gt; d [color=&quot;red&quot;]
c4 -&gt; j [color=&quot;blue&quot;]
d [label=&quot;PiR&quot;]
d -&gt; e [color=&quot;blue&quot;]
d -&gt; e /* f */ [color=&quot;red&quot;]
e [label=&quot;SigmaL&quot;]
e -&gt; f1 [color=&quot;red&quot;]
e -&gt; f2 [color=&quot;red&quot;]
f1 [label=&quot;PiR&quot;]
f1 -&gt; g1 [color=&quot;blue&quot;]
f1 -&gt; h1 [color=&quot;red&quot;]
g1 [label=&quot;!w&quot;]
h1 [label=&quot;False&quot;]
f2 [label=&quot;PiR&quot;]
f2 -&gt; g2 [color=&quot;blue&quot;]
f2 -&gt; h2 /* h2r */ [color=&quot;red&quot;]
g2 [label=&quot;!d&quot;]
g2 -&gt; h2 [color=&quot;blue&quot;]
h2 [label=&quot;Id&quot;]
j [label=&quot;PiL&quot;]
j -&gt; k /* kr */ [color=&quot;red&quot;]
j -&gt; l [color=&quot;blue&quot;]
k [label=&quot;Id&quot;]
l [label=&quot;Id&quot;]
m [label=&quot;PiL&quot;]
m -&gt; n /* nr */ [color=&quot;red&quot;]
m -&gt; p [color=&quot;blue&quot;]
n [label=&quot;Id&quot;]
p [label=&quot;Id&quot;]
}" class="graphviz" /></div>
<p>Technically, the edges connect ports of nodes. The directionality and left=blue/right=red coloring is enough to identity the ports for the graph above, but disambiguating n-ary graphs in a clear way seems hard.</p>
<p>If we reverse the directions of the blue edges, then the graph is almost a tree, except for the backedges that can show up in PiRight/SigmaLeft.</p>
</div>
<div class="section" id="cut-elimination">
<h2>Cut elimination<a class="headerlink" href="#cut-elimination" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>To eliminate cut with identity we remove both and link the unbound variables together</p></li>
<li><p>To eliminate matching left/right Pi/Sigma, we erase all of the non-matching cases, directly link the context variables inside the matching case with the outer variables, and connect the captured variables to the other side with cut nodes.</p></li>
<li><p>To eliminate !/!d or ?/?d, we remove them and insert a lift rule on one side to fix the levels, retaining the cut.</p></li>
<li><p>To eliminate !/!c or ?/?c, we duplicate the rule with ! and create two cuts with the variables under the contraction.</p></li>
<li><p>For !w/?w we delete the rule with ! and create no cuts.</p></li>
<li><p>To eliminate <span class="math notranslate nohighlight">\(\forall\)</span> or <span class="math notranslate nohighlight">\(\exists\)</span>, we extend the variable substitution to the other side.</p></li>
<li><p>The commuting cases are mostly handled by our graph formalism; cuts on the context are pushed down to where they apply. But for PiRight/SigmaLeft there can be a cut on the context variables. To push it down we need to duplicate the cut and its other side for each case.</p></li>
<li><p>To expand identities, start with PiRight/SigmaLeft, then use the opposite rule on the opposite side for each case, and terminate with identities. But actually we should prefer to contract identities, searching for expanded identities and replacing them with identities on larger types.</p></li>
</ul>
</div>
<div class="section" id="optimal-reduction">
<h2>Optimal reduction<a class="headerlink" href="#optimal-reduction" title="Permalink to this headline">¶</a></h2>
<p>Optimal reduction ensures the minimal amount of cut elimination (reduction) steps. It’s basically lazy evaluation, leftmost-outermost reduction order, but we have to be careful to avoid duplicating cuts. In particular, we want to avoid commuting under PiRight/SigmaLeft when there are two or more cases, and instead reduce the primary conclusions to identify the matching case. Also, for contraction, we want to avoid duplicating cuts, but also want to avoid doing unneeded reduction, so we create a duplicating node and incrementally push it down, doing reduction when needed instead of duplicating a cut.</p>
<p>For example, the term <code class="docutils literal notranslate"><span class="pre">F2</span> <span class="pre">G2</span> <span class="pre">=</span> <span class="pre">(\x.</span> <span class="pre">x</span> <span class="pre">(\w.</span> <span class="pre">w)</span> <span class="pre">x)</span> <span class="pre">(\y.</span> <span class="pre">(\x.</span> <span class="pre">x</span> <span class="pre">x)</span> <span class="pre">y</span> <span class="pre">z)</span></code> from page 18 of <a class="bibtex reference internal" href="zzreferences.html#aspertioptimalimplementationfunctional1999" id="id8">[AG99]</a>.</p>
<p>&lt;insert reduction here&gt;</p>
</div>
</div>
<div class="section" id="random-old-junk">
<h1>Random old junk<a class="headerlink" href="#random-old-junk" title="Permalink to this headline">¶</a></h1>
<div class="section" id="linear-logic">
<h2>Linear logic<a class="headerlink" href="#linear-logic" title="Permalink to this headline">¶</a></h2>
<p>Linear logic has boxes,  The difference is not observable if we do not use duplication; e.g. <code class="docutils literal notranslate"><span class="pre">(\x.print(x+1))</span> <span class="pre">(print(&quot;x&quot;);</span> <span class="pre">2)</span></code> can only print <code class="docutils literal notranslate"><span class="pre">x3</span></code>. But if we change <code class="docutils literal notranslate"><span class="pre">x+1</span></code> to <code class="docutils literal notranslate"><span class="pre">x+x</span></code> then CBV is <code class="docutils literal notranslate"><span class="pre">x4</span></code> while CBN is <code class="docutils literal notranslate"><span class="pre">xx4</span></code>.</p>
<p>So how do we specify the difference between the two, in linear logic?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="n">x</span> <span class="o">=</span>
  <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">dup</span> <span class="n">x</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="p">)</span>
<span class="n">s</span> <span class="p">(</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">);</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Boxes do have some performance cost, so how can they be avoided? There are cases where boxes are not necessary:</p>
<ol class="arabic simple">
<li><p>When the term is linear or affine and does not need to duplicate anything.</p></li>
<li><p>When the duplication is duplication of a graph without any cuts, such as a boolean, integer, list of integers, etc. Even when there are cuts, the value can be forced and then copied directly, using a fold. (per <a class="bibtex reference internal" href="zzreferences.html#filinskilinearcontinuations1992" id="id9">[Fil92]</a>) Q: Does this change the evaluation semantics to be stricter?</p></li>
<li><p>Inlining, when the duplication is carried out, resulting in two terms.</p></li>
<li><p>More complex cases enforced by a typing system, such as Elementary Affine Logic.</p></li>
</ol>
</div>
<div class="section" id="recursion">
<h2>Recursion<a class="headerlink" href="#recursion" title="Permalink to this headline">¶</a></h2>
<p>Sequent Core <a class="bibtex reference internal" href="zzreferences.html#downensequentcalculuscompiler2016a" id="id10">[DMAPJ16]</a> also introduces two more rules “multicut” and “rec” that are illogical but computationally useful:</p>
<div class="math notranslate nohighlight">
\[\begin{array}{cc}
  \rule
    {\Gamma, \Theta \vdash \Delta, \Lambda \quad \Gamma', \Lambda \vdash \Theta, \Delta' }
    {\Gamma, \Gamma' \vdash \Delta, \Delta' }{\text{multicut}}
  &amp;
  \rule
    { \overrightarrow{\Gamma, \vec \Lambda, \Theta_i \vdash \Lambda_i, \vec \Theta, \Delta }}
    {\Gamma, \overrightarrow{\Theta_i} \vdash \overrightarrow{\Lambda_i}, \Delta }{\text{rec}}
\end{array}\]</div>
<p>These probably aren’t needed, as let can be encoded as a record and recursion via a fixed-point combinator or a cycle in the graph. In particular <a class="bibtex reference internal" href="zzreferences.html#kiselyovmanyfacesfixedpoint2013" id="id11">[Kis13]</a> outline a polyvariadic combinator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>fix_poly fl = fix (\self -&gt; map ($ self) fl)
</pre></div>
</div>
<p>To implement <code class="docutils literal notranslate"><span class="pre">fix</span></code> we can use the variant of the Y combinator <span class="math notranslate nohighlight">\(\lambda f.(\lambda x.x x) (\lambda x.f (x x))\)</span>. To type it we need the cyclic/recursive type <span class="math notranslate nohighlight">\(Wr = \Pi[(^w, Wr, r)]\)</span> (in the sense of an infinite, regular tree). Though, once we have recursive types, we could allow recursive proof trees as well; then implementing recursion directly is probably not too hard. BOHM uses a fan/duplication node combined with a loop.</p>
</div>
<div class="section" id="id12">
<h2>Optimal reduction<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>In call-by-value reduction, work is duplicated quite frequently. And lazy or call-by-need reduction, although more efficient computation-wise than call-by-value, still duplicates work. An example is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>import System.IO.Unsafe
i = \w -&gt; (unsafePerformIO (print &quot;i&quot;)) `seq` w
z = 2 :: Integer
t = 3 :: Integer
f = \x -&gt; (x z) + (x t)
main = print (f (\y -&gt; i y) :: Integer)
</pre></div>
</div>
<p>This produces <code class="docutils literal notranslate"><span class="pre">5</span></code> in Haskell. However, without GHC’s optimizations, <code class="docutils literal notranslate"><span class="pre">&quot;i&quot;</span></code> is evaluated (printed) twice. With optimal reduction, all function applications with known arguments are evaluated exactly once. In particular, the only time a function is evaluated twice is when it is called with different arguments. In the example above it corresponds to a “hoisting” transformation that makes <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">(unsafePerformIO</span> <span class="pre">(print</span> <span class="pre">&quot;i&quot;))</span> <span class="pre">`seq`</span> <span class="pre">\w</span> <span class="pre">-&gt;</span> <span class="pre">w</span></code>, but more complex cases have higher-level sharing that no code transformation can mimic.</p>
<p>Although GHC will do this with <code class="docutils literal notranslate"><span class="pre">-O</span></code>, it does it messily; the interaction of <code class="docutils literal notranslate"><span class="pre">seq</span></code> and inlining is the source of <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/2273">numerous bugs</a>. In contrast, optimal reduction is based on a principled approach to sharing. The graph corresponds almost exactly to linear logic proof nets. Also, since the sharing is part of the reduction semantics rather than a compiler optimization, it is available in the interpreter (and in the runtime system too). There are no thunks, so there is no need for <code class="docutils literal notranslate"><span class="pre">seq</span></code>; instead there are boxes and duplicators.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>Reduction is fairly simple to implement without duplication, as it is just pairs of constructors and destructors annihilating and joining their wires, or, for <code class="docutils literal notranslate"><span class="pre">case</span></code>, joining some eraser nodes. But what about duplication?</p>
<p>Stroscot takes its general inspiration from the delimiter system found in Lambdascope. However, instead of having levels Stroscot keeps explicit track of “environments” or “scopes”. In particular a delimiter has an inside scope and an outside scope. Initially, all delimiters look like opening/closing delimiters where the outside scope is the default/root scope <code class="docutils literal notranslate"><span class="pre">0</span></code> and the inside scope is the scope of the multiplexer involved. When two delimiters meet, the touching outer scopes are compared for equality (they should always be equal) and one inner scope remains the inner scope while the other inner scope become the new delimiter’s outer scope.</p>
<p>To determine which scope becomes the outer scope, delimiters are also marked as “head”, “full”, or “empty” depending on whether they represent a reference to the result of a duplication, the target of a duplication, or a path that crosses the scope but doesn’t duplicate. Interactions are allowed only between head delimiters and other delimiter; the head delimiter’s scope stays on the inside.</p>
<p>For multiplexers the situation is a little more complicated. A multiplexer also has two scopes, an inner “label”/identity-like scope and an outer “ambient” scope. When a multiplexer crosses a delimiter, from outside to inside, its “ambient” scope is changed to the delimiter’s inside scope. Meanwhile the delimiter’s scope is split into a new set of scopes, and this is indexed by the label scope. In the Stroscot code these are referred to as “variant” scopes. In particular, multiplexers with the same label scope must split other scopes into the same set of variant scopes at each interaction. This is not too hard to keep track of, just give each scope a map <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">scope</span> <span class="pre">-&gt;</span> <span class="pre">variant</span> <span class="pre">scope</span> <span class="pre">set</span></code> that’s lazily created.</p>
<div class="section" id="readback">
<h3>Readback<a class="headerlink" href="#readback" title="Permalink to this headline">¶</a></h3>
<p>The real hard part is doing “readback”, i.e. proving that all of these transformations are either no-ops on the original lambda term or valid beta reductions. Since there is so much scope popping and pushing and varianting it is definitely a little complex. Also I decided to keep the levels from the original Lambdascope implementation for correctness verification purposes, so there is twice the work. But if you read Ian Mackie’s paper on efficient interaction nets implementation you will see that this “readback” algorithm also provides a way to directly execute the proof net / graph with call-by-value semantics at each reduction step. So it also has a close connection with how to compile the graph to machine code. Since our scopes are unique and the “stack” stores only one director index for a scope at a time, the scopes can correspond directly to machine registers or memory locations.</p>
<p>Scopes are nested, forming a simple tree hierarchy. When an opening head delimiter of scope A encounters a closing full or empty delimiter of scope B, then A is reparented under B. In particular the one closing delimiter of scope B vanishes, and duplicates of it are propagated to the outside of all other delimiters of A.</p>
<p>It should be possible to avoid this <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> operation by keeping a depth counter in the scope and each delimiter, with the total number of scopes that the delimiter enters/exit being the sum of the scope’s depth and the delimiter’s depth. Then the interaction would decrement the A scope delimiter’s local depth counter by 1, increment A’s scope-wide depth counter by 1, and vanish B’s delimiter as before. But this hasn’t been implemented yet.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Types.html" class="btn btn-neutral float-right" title="Types" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Fexprs.html" class="btn btn-neutral float-left" title="Metaprogramming" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019-2020 Mathnerd314

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>